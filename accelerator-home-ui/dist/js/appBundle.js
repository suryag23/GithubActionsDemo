/**
 * App version: 3.7 19/07/22
 * SDK version: 4.8.3
 * CLI version: 2.13.0
 * 
 * Generated: Tue, 07 Nov 2023 17:44:57 GMT
 */

var APP_accelerator_home_ui = (function () {
  'use strict';

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const settings$2 = {};
  const subscribers$2 = {};
  const initSettings$2 = (appSettings, platformSettings) => {
    settings$2['app'] = appSettings;
    settings$2['platform'] = platformSettings;
    settings$2['user'] = {};
  };
  const publish$2 = (key, value) => {
    subscribers$2[key] && subscribers$2[key].forEach(subscriber => subscriber(value));
  };
  const dotGrab$4 = function () {
    let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let key = arguments.length > 1 ? arguments[1] : undefined;
    if (obj === null) return undefined;
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' && obj !== null ? Object.keys(obj).length ? obj : undefined : obj;
  };
  var Settings$2 = {
    get(type, key) {
      let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      const val = dotGrab$4(settings$2[type], key);
      return val !== undefined ? val : fallback;
    },
    has(type, key) {
      return !!this.get(type, key);
    },
    set(key, value) {
      settings$2['user'][key] = value;
      publish$2(key, value);
    },
    subscribe(key, callback) {
      subscribers$2[key] = subscribers$2[key] || [];
      subscribers$2[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers$2[key] && subscribers$2[key].findIndex(cb => cb === callback);
        index > -1 && subscribers$2[key].splice(index, 1);
      } else {
        if (key in subscribers$2) {
          subscribers$2[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers$2)) {
        delete subscribers$2[key];
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const prepLog = (type, args) => {
    const colors = {
      Info: 'green',
      Debug: 'gray',
      Warn: 'orange',
      Error: 'red'
    };
    args = Array.from(args);
    return ['%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type), 'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px', args];
  };
  var Log = {
    info() {
      Settings$2.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments));
    },
    debug() {
      Settings$2.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments));
    },
    error() {
      Settings$2.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments));
    },
    warn() {
      Settings$2.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments));
    }
  };

  var executeAsPromise = (function (method) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let result;
    if (method && typeof method === 'function') {
      try {
        result = method.apply(context, args);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }

    // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
    if (result !== null && typeof result === 'object' && result.then && typeof result.then === 'function') {
      return result;
    }
    // otherwise make it into a promise
    else {
      return new Promise((resolve, reject) => {
        if (result instanceof Error) {
          reject(result);
        } else {
          resolve(result);
        }
      });
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let sendMetric = (type, event, params) => {
    Log.info('Sending metric', type, event, params);
  };
  const initMetrics = config => {
    sendMetric = config.sendMetric;
  };

  // available metric per category
  const metrics$1 = {
    app: ['launch', 'loaded', 'ready', 'close'],
    page: ['view', 'leave'],
    user: ['click', 'input'],
    media: ['abort', 'canplay', 'ended', 'pause', 'play',
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    'volumechange', 'waiting', 'seeking', 'seeked']
  };

  // error metric function (added to each category)
  const errorMetric = function (type, message, code, visible) {
    let params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    params = {
      params,
      ...{
        message,
        code,
        visible
      }
    };
    sendMetric(type, 'error', params);
  };
  const Metric = function (type, events) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return events.reduce((obj, event) => {
      obj[event] = function (name) {
        let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        params = {
          ...options,
          ...(name ? {
            name
          } : {}),
          ...params
        };
        sendMetric(type, event, params);
      };
      return obj;
    }, {
      error(message, code, params) {
        errorMetric(type, message, code, params);
      },
      event(name, params) {
        sendMetric(type, name, params);
      }
    });
  };
  const Metrics = types => {
    return Object.keys(types).reduce((obj, type) => {
      // media metric works a bit different!
      // it's a function that accepts a url and returns an object with the available metrics
      // url is automatically passed as a param in every metric
      type === 'media' ? obj[type] = url => Metric(type, types[type], {
        url
      }) : obj[type] = Metric(type, types[type]);
      return obj;
    }, {
      error: errorMetric,
      event: sendMetric
    });
  };
  var Metrics$1 = Metrics(metrics$1);

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var events$1 = {
    abort: 'Abort',
    canplay: 'CanPlay',
    canplaythrough: 'CanPlayThrough',
    durationchange: 'DurationChange',
    emptied: 'Emptied',
    encrypted: 'Encrypted',
    ended: 'Ended',
    error: 'Error',
    interruptbegin: 'InterruptBegin',
    interruptend: 'InterruptEnd',
    loadeddata: 'LoadedData',
    loadedmetadata: 'LoadedMetadata',
    loadstart: 'LoadStart',
    pause: 'Pause',
    play: 'Play',
    playing: 'Playing',
    progress: 'Progress',
    ratechange: 'Ratechange',
    seeked: 'Seeked',
    seeking: 'Seeking',
    stalled: 'Stalled',
    // suspend: 'Suspend', // this one is called a looooot for some videos
    timeupdate: 'TimeUpdate',
    volumechange: 'VolumeChange',
    waiting: 'Waiting'
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var autoSetupMixin = (function (sourceObject) {
    let setup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};
    let ready = false;
    const doSetup = () => {
      if (ready === false) {
        setup();
        ready = true;
      }
    };
    return Object.keys(sourceObject).reduce((obj, key) => {
      if (typeof sourceObject[key] === 'function') {
        obj[key] = function () {
          doSetup();
          return sourceObject[key].apply(sourceObject, arguments);
        };
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
        obj.__defineGetter__(key, function () {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject);
        });
      } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
        obj.__defineSetter__(key, function () {
          doSetup();
          return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(sourceObject, arguments);
        });
      } else {
        obj[key] = sourceObject[key];
      }
      return obj;
    }, {});
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let timeout$1 = null;
  var easeExecution = ((cb, delay) => {
    clearTimeout(timeout$1);
    timeout$1 = setTimeout(() => {
      cb();
    }, delay);
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let basePath;
  let proxyUrl;
  const initUtils = config => {
    basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'));
    if (config.proxyUrl) {
      proxyUrl = ensureUrlWithProtocol(config.proxyUrl);
    }
  };
  var Utils = {
    asset(relPath) {
      return basePath + relPath;
    },
    proxyUrl(url) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url;
    },
    makeQueryString() {
      return makeQueryString(...arguments);
    },
    // since imageworkers don't work without protocol
    ensureUrlWithProtocol() {
      return ensureUrlWithProtocol(...arguments);
    }
  };
  const ensureUrlWithProtocol = url => {
    if (/^\/\//.test(url)) {
      return window.location.protocol + url;
    }
    if (!/^(?:https?:)/i.test(url)) {
      return window.location.origin + url;
    }
    return url;
  };
  const makeFullStaticPath = function () {
    let pathname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';
    let path = arguments.length > 1 ? arguments[1] : undefined;
    // ensure path has traling slash
    path = path.charAt(path.length - 1) !== '/' ? path + '/' : path;

    // if path is URL, we assume it's already the full static path, so we just return it
    if (/^(?:https?:)?(?:\/\/)/.test(path)) {
      return path;
    }
    if (path.charAt(0) === '/') {
      return path;
    } else {
      // cleanup the pathname (i.e. remove possible index.html)
      pathname = cleanUpPathName(pathname);

      // remove possible leading dot from path
      path = path.charAt(0) === '.' ? path.substr(1) : path;
      // ensure path has leading slash
      path = path.charAt(0) !== '/' ? '/' + path : path;
      return pathname + path;
    }
  };
  const cleanUpPathName = pathname => {
    if (pathname.slice(-1) === '/') return pathname.slice(0, -1);
    const parts = pathname.split('/');
    if (parts[parts.length - 1].indexOf('.') > -1) parts.pop();
    return parts.join('/');
  };
  const makeQueryString = function (url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'url';
    // add operator as an option
    options.operator = 'metrological'; // Todo: make this configurable (via url?)
    // add type (= url or qr) as an option, with url as the value
    options[type] = url;
    return Object.keys(options).map(key => {
      return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key]);
    }).join('&');
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const initProfile = config => {
    config.getInfo;
    config.setInfo;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var t = window.lng;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const events = ['timeupdate', 'error', 'ended', 'loadeddata', 'canplay', 'play', 'playing', 'pause', 'loadstart', 'seeking', 'seeked', 'encrypted'];
  let mediaUrl$1 = url => url;
  const initMediaPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl$1 = config.mediaUrl;
    }
  };
  class Mediaplayer extends t.Component {
    _construct() {
      this._skipRenderToTexture = false;
      this._metrics = null;
      this._textureMode = Settings$2.get('platform', 'textureMode') || false;
      Log.info('Texture mode: ' + this._textureMode);
      console.warn(["The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'VideoPlayer'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer'].join('\n\n'));
    }
    static _template() {
      return {
        Video: {
          VideoWrap: {
            VideoTexture: {
              visible: false,
              pivot: 0.5,
              texture: {
                type: t.textures.StaticTexture,
                options: {}
              }
            }
          }
        }
      };
    }
    set skipRenderToTexture(v) {
      this._skipRenderToTexture = v;
    }
    get textureMode() {
      return this._textureMode;
    }
    get videoView() {
      return this.tag('Video');
    }
    _init() {
      //re-use videotag if already there
      const videoEls = document.getElementsByTagName('video');
      if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0];else {
        this.videoEl = document.createElement('video');
        this.videoEl.setAttribute('id', 'video-player');
        this.videoEl.style.position = 'absolute';
        this.videoEl.style.zIndex = '1';
        this.videoEl.style.display = 'none';
        this.videoEl.setAttribute('width', '100%');
        this.videoEl.setAttribute('height', '100%');
        this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible';
        document.body.appendChild(this.videoEl);
      }
      if (this.textureMode && !this._skipRenderToTexture) {
        this._createVideoTexture();
      }
      this.eventHandlers = [];
    }
    _registerListeners() {
      events.forEach(event => {
        const handler = e => {
          if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
            this._metrics[event]({
              currentTime: this.videoEl.currentTime
            });
          }
          this.fire(event, {
            videoElement: this.videoEl,
            event: e
          });
        };
        this.eventHandlers.push(handler);
        this.videoEl.addEventListener(event, handler);
      });
    }
    _deregisterListeners() {
      Log.info('Deregistering event listeners MediaPlayer');
      events.forEach((event, index) => {
        this.videoEl.removeEventListener(event, this.eventHandlers[index]);
      });
      this.eventHandlers = [];
    }
    _attach() {
      this._registerListeners();
    }
    _detach() {
      this._deregisterListeners();
      this.close();
    }
    _createVideoTexture() {
      const stage = this.stage;
      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = {
        source: glTexture,
        w: this.videoEl.width,
        h: this.videoEl.height
      };
    }
    _startUpdatingVideoTexture() {
      if (this.textureMode && !this._skipRenderToTexture) {
        const stage = this.stage;
        if (!this._updateVideoTexture) {
          this._updateVideoTexture = () => {
            if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
              const gl = stage.gl;
              const currentTime = new Date().getTime();

              // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
              // We'll fallback to fixed 30fps in this case.
              const frameCount = this.videoEl.webkitDecodedFrameCount;
              const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
              if (mustUpdate) {
                this._lastTime = currentTime;
                this._lastFrame = frameCount;
                try {
                  gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                  this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                  this.videoTextureView.visible = true;
                  this.videoTexture.options.w = this.videoEl.videoWidth;
                  this.videoTexture.options.h = this.videoEl.videoHeight;
                  const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h;
                  const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight;
                  if (expectedAspectRatio > realAspectRatio) {
                    this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio;
                    this.videoTextureView.scaleY = 1;
                  } else {
                    this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio;
                    this.videoTextureView.scaleX = 1;
                  }
                } catch (e) {
                  Log.error('texImage2d video', e);
                  this._stopUpdatingVideoTexture();
                  this.videoTextureView.visible = false;
                }
                this.videoTexture.source.forceRenderUpdate();
              }
            }
          };
        }
        if (!this._updatingVideoTexture) {
          stage.on('frameStart', this._updateVideoTexture);
          this._updatingVideoTexture = true;
        }
      }
    }
    _stopUpdatingVideoTexture() {
      if (this.textureMode) {
        const stage = this.stage;
        stage.removeListener('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = false;
        this.videoTextureView.visible = false;
        if (this.videoTexture.options.source) {
          const gl = stage.gl;
          gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
          gl.clearColor(0, 0, 0, 1);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
      }
    }
    updateSettings() {
      let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // The Component that 'consumes' the media player.
      this._consumer = settings.consumer;
      if (this._consumer && this._consumer.getMediaplayerSettings) {
        // Allow consumer to add settings.
        settings = Object.assign(settings, this._consumer.getMediaplayerSettings());
      }
      if (!t.Utils.equalValues(this._stream, settings.stream)) {
        if (settings.stream && settings.stream.keySystem) {
          navigator.requestMediaKeySystemAccess(settings.stream.keySystem.id, settings.stream.keySystem.config).then(keySystemAccess => {
            return keySystemAccess.createMediaKeys();
          }).then(createdMediaKeys => {
            return this.videoEl.setMediaKeys(createdMediaKeys);
          }).then(() => {
            if (settings.stream && settings.stream.src) this.open(settings.stream.src);
          }).catch(() => {
            console.error('Failed to set up MediaKeys');
          });
        } else if (settings.stream && settings.stream.src) {
          // This is here to be backwards compatible, will be removed
          // in future sdk release
          if (Settings$2.get('app', 'hls')) {
            if (!window.Hls) {
              window.Hls = class Hls {
                static isSupported() {
                  console.warn('hls-light not included');
                  return false;
                }
              };
            }
            if (window.Hls.isSupported()) {
              if (!this._hls) this._hls = new window.Hls({
                liveDurationInfinity: true
              });
              this._hls.loadSource(settings.stream.src);
              this._hls.attachMedia(this.videoEl);
              this.videoEl.style.display = 'block';
            }
          } else {
            this.open(settings.stream.src);
          }
        } else {
          this.close();
        }
        this._stream = settings.stream;
      }
      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPos);
    }
    _setHide(hide) {
      if (this.textureMode) {
        this.tag('Video').setSmooth('alpha', hide ? 0 : 1);
      } else {
        this.videoEl.style.visibility = hide ? 'hidden' : 'visible';
      }
    }
    open(url) {
      let settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        hide: false,
        videoPosition: null
      };
      // prep the media url to play depending on platform (mediaPlayerplugin)
      url = mediaUrl$1(url);
      this._metrics = Metrics$1.media(url);
      Log.info('Playing stream', url);
      if (this.application.noVideo) {
        Log.info('noVideo option set, so ignoring: ' + url);
        return;
      }
      // close the video when opening same url as current (effectively reloading)
      if (this.videoEl.getAttribute('src') === url) {
        this.close();
      }
      this.videoEl.setAttribute('src', url);

      // force hide, then force show (in next tick!)
      // (fixes comcast playback rollover issue)
      this.videoEl.style.visibility = 'hidden';
      this.videoEl.style.display = 'none';
      setTimeout(() => {
        this.videoEl.style.display = 'block';
        this.videoEl.style.visibility = 'visible';
      });
      this._setHide(settings.hide);
      this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080]);
    }
    close() {
      // We need to pause first in order to stop sound.
      this.videoEl.pause();
      this.videoEl.removeAttribute('src');

      // force load to reset everything without errors
      this.videoEl.load();
      this._clearSrc();
      this.videoEl.style.display = 'none';
    }
    playPause() {
      if (this.isPlaying()) {
        this.doPause();
      } else {
        this.doPlay();
      }
    }
    get muted() {
      return this.videoEl.muted;
    }
    set muted(v) {
      this.videoEl.muted = v;
    }
    get loop() {
      return this.videoEl.loop;
    }
    set loop(v) {
      this.videoEl.loop = v;
    }
    isPlaying() {
      return this._getState() === 'Playing';
    }
    doPlay() {
      this.videoEl.play();
    }
    doPause() {
      this.videoEl.pause();
    }
    reload() {
      var url = this.videoEl.getAttribute('src');
      this.close();
      this.videoEl.src = url;
    }
    getPosition() {
      return Promise.resolve(this.videoEl.currentTime);
    }
    setPosition(pos) {
      this.videoEl.currentTime = pos;
    }
    getDuration() {
      return Promise.resolve(this.videoEl.duration);
    }
    seek(time) {
      let absolute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (absolute) {
        this.videoEl.currentTime = time;
      } else {
        this.videoEl.currentTime += time;
      }
    }
    get videoTextureView() {
      return this.tag('Video').tag('VideoTexture');
    }
    get videoTexture() {
      return this.videoTextureView.texture;
    }
    _setVideoArea(videoPos) {
      if (t.Utils.equalValues(this._videoPos, videoPos)) {
        return;
      }
      this._videoPos = videoPos;
      if (this.textureMode) {
        this.videoTextureView.patch({
          smooth: {
            x: videoPos[0],
            y: videoPos[1],
            w: videoPos[2] - videoPos[0],
            h: videoPos[3] - videoPos[1]
          }
        });
      } else {
        const precision = this.stage.getRenderPrecision();
        this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px';
        this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px';
        this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px';
        this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px';
      }
    }
    _fireConsumer(event, args) {
      if (this._consumer) {
        this._consumer.fire(event, args);
      }
    }
    _equalInitData(buf1, buf2) {
      if (!buf1 || !buf2) return false;
      if (buf1.byteLength != buf2.byteLength) return false;
      const dv1 = new Int8Array(buf1);
      const dv2 = new Int8Array(buf2);
      for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false;
      return true;
    }
    error(args) {
      this._fireConsumer('$mediaplayerError', args);
      this._setState('');
      return '';
    }
    loadeddata(args) {
      this._fireConsumer('$mediaplayerLoadedData', args);
    }
    play(args) {
      this._fireConsumer('$mediaplayerPlay', args);
    }
    playing(args) {
      this._fireConsumer('$mediaplayerPlaying', args);
      this._setState('Playing');
    }
    canplay(args) {
      this.videoEl.play();
      this._fireConsumer('$mediaplayerStart', args);
    }
    loadstart(args) {
      this._fireConsumer('$mediaplayerLoad', args);
    }
    seeked() {
      this._fireConsumer('$mediaplayerSeeked', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    seeking() {
      this._fireConsumer('$mediaplayerSeeking', {
        currentTime: this.videoEl.currentTime,
        duration: this.videoEl.duration || 1
      });
    }
    durationchange(args) {
      this._fireConsumer('$mediaplayerDurationChange', args);
    }
    encrypted(args) {
      const video = args.videoElement;
      const event = args.event;
      // FIXME: Double encrypted events need to be properly filtered by Gstreamer
      if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
        this._previousInitData = event.initData;
        this._fireConsumer('$mediaplayerEncrypted', args);
      }
    }
    static _states() {
      return [class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture();
        }
        $exit() {
          this._stopUpdatingVideoTexture();
        }
        timeupdate() {
          this._fireConsumer('$mediaplayerProgress', {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1
          });
        }
        ended(args) {
          this._fireConsumer('$mediaplayerEnded', args);
          this._setState('');
        }
        pause(args) {
          this._fireConsumer('$mediaplayerPause', args);
          this._setState('Playing.Paused');
        }
        _clearSrc() {
          this._fireConsumer('$mediaplayerStop', {});
          this._setState('');
        }
        static _states() {
          return [class Paused extends this {}];
        }
      }];
    }
  }

  class localCookie {
    constructor(e) {
      return e = e || {}, this.forceCookies = e.forceCookies || !1, !0 === this._checkIfLocalStorageWorks() && !0 !== e.forceCookies ? {
        getItem: this._getItemLocalStorage,
        setItem: this._setItemLocalStorage,
        removeItem: this._removeItemLocalStorage,
        clear: this._clearLocalStorage,
        keys: this._getLocalStorageKeys
      } : {
        getItem: this._getItemCookie,
        setItem: this._setItemCookie,
        removeItem: this._removeItemCookie,
        clear: this._clearCookies,
        keys: this._getCookieKeys
      };
    }
    _checkIfLocalStorageWorks() {
      if ("undefined" == typeof localStorage) return !1;
      try {
        return localStorage.setItem("feature_test", "yes"), "yes" === localStorage.getItem("feature_test") && (localStorage.removeItem("feature_test"), !0);
      } catch (e) {
        return !1;
      }
    }
    _getItemLocalStorage(e) {
      return window.localStorage.getItem(e);
    }
    _setItemLocalStorage(e, t) {
      return window.localStorage.setItem(e, t);
    }
    _removeItemLocalStorage(e) {
      return window.localStorage.removeItem(e);
    }
    _clearLocalStorage() {
      return window.localStorage.clear();
    }
    _getLocalStorageKeys() {
      return Object.keys(window.localStorage);
    }
    _getItemCookie(e) {
      var t = document.cookie.match(RegExp("(?:^|;\\s*)" + function (e) {
        return e.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1");
      }(e) + "=([^;]*)"));
      return t && "" === t[1] && (t[1] = null), t ? t[1] : null;
    }
    _setItemCookie(e, t) {
      var o = new Date(),
        r = new Date(o.getTime() + 15768e7);
      document.cookie = "".concat(e, "=").concat(t, "; expires=").concat(r.toUTCString(), ";");
    }
    _removeItemCookie(e) {
      document.cookie = "".concat(e, "=;Max-Age=-99999999;");
    }
    _clearCookies() {
      document.cookie.split(";").forEach(e => {
        document.cookie = e.replace(/^ +/, "").replace(/=.*/, "=;expires=Max-Age=-99999999");
      });
    }
    _getCookieKeys() {
      return document.cookie.split(";").map(e => e.split("=")[0]);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let namespace;
  let lc;
  const initStorage = () => {
    namespace = Settings$2.get('platform', 'id');
    // todo: pass options (for example to force the use of cookies)
    lc = new localCookie();
  };
  const namespacedKey = key => namespace ? [namespace, key].join('.') : key;
  var Storage$1 = {
    get(key) {
      try {
        return JSON.parse(lc.getItem(namespacedKey(key)));
      } catch (e) {
        return null;
      }
    },
    set(key, value) {
      try {
        lc.setItem(namespacedKey(key), JSON.stringify(value));
        return true;
      } catch (e) {
        return false;
      }
    },
    remove(key) {
      lc.removeItem(namespacedKey(key));
    },
    clear() {
      if (namespace) {
        lc.keys().forEach(key => {
          // remove the item if in the namespace
          key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null;
        });
      } else {
        lc.clear();
      }
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g;
  const isWildcard = /^[!*$]$/;
  const hasLookupId = /\/:\w+?@@([0-9]+?)@@/;
  const isNamedGroup = /^\/:/;

  /**
   * Test if a route is part regular expressed
   * and replace it for a simple character
   * @param route
   * @returns {*}
   */
  const stripRegex = function (route) {
    let char = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'R';
    // if route is part regular expressed we replace
    // the regular expression for a character to
    // simplify floor calculation and backtracking
    if (hasRegex.test(route)) {
      route = route.replace(hasRegex, char);
    }
    return route;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Create a local request register
   * @param flags
   * @returns {Map<any, any>}
   */
  const createRegister = flags => {
    const reg = new Map()
    // store user defined and router
    // defined flags in register
    ;
    [...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
      reg.set(key, flags[key]);
    });
    return reg;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Request {
    constructor() {
      let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      let navArgs = arguments.length > 1 ? arguments[1] : undefined;
      let storeCaller = arguments.length > 2 ? arguments[2] : undefined;
      /**
       * Hash we navigate to
       * @type {string}
       * @private
       */
      this._hash = hash;

      /**
       * Do we store previous hash in history
       * @type {boolean}
       * @private
       */
      this._storeCaller = storeCaller;

      /**
       * Request and navigate data
       * @type {Map}
       * @private
       */
      this._register = new Map();

      /**
       * Flag if the instance is created due to
       * this request
       * @type {boolean}
       * @private
       */
      this._isCreated = false;

      /**
       * Flag if the instance is shared between
       * previous and current request
       * @type {boolean}
       * @private
       */
      this._isSharedInstance = false;

      /**
       * Flag if the request has been cancelled
       * @type {boolean}
       * @private
       */
      this._cancelled = false;

      /**
       * if instance is shared between requests we copy state object
       * from instance before the new request overrides state
       * @type {null}
       * @private
       */
      this._copiedHistoryState = null;

      // if there are arguments attached to navigate()
      // we store them in new request
      if (isObject(navArgs)) {
        this._register = createRegister(navArgs);
      } else if (isBoolean(navArgs)) {
        // if second navigate() argument is explicitly
        // set to false we prevent the calling page
        // from ending up in history
        this._storeCaller = navArgs;
      }
      // @todo: remove because we can simply check
      // ._storeCaller property
      this._register.set(symbols.store, this._storeCaller);
    }
    cancel() {
      Log.debug('[router]:', "cancelled ".concat(this._hash));
      this._cancelled = true;
    }
    get url() {
      return this._hash;
    }
    get register() {
      return this._register;
    }
    get hash() {
      return this._hash;
    }
    set hash(args) {
      this._hash = args;
    }
    get route() {
      return this._route;
    }
    set route(args) {
      this._route = args;
    }
    get provider() {
      return this._provider;
    }
    set provider(args) {
      this._provider = args;
    }
    get providerType() {
      return this._providerType;
    }
    set providerType(args) {
      this._providerType = args;
    }
    set page(args) {
      this._page = args;
    }
    get page() {
      return this._page;
    }
    set isCreated(args) {
      this._isCreated = args;
    }
    get isCreated() {
      return this._isCreated;
    }
    get isSharedInstance() {
      return this._isSharedInstance;
    }
    set isSharedInstance(args) {
      this._isSharedInstance = args;
    }
    get isCancelled() {
      return this._cancelled;
    }
    set copiedHistoryState(v) {
      this._copiedHistoryState = v;
    }
    get copiedHistoryState() {
      return this._copiedHistoryState;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Route {
    constructor() {
      let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // keep backwards compatible
      let type = ['on', 'before', 'after'].reduce((acc, type) => {
        return isFunction(config[type]) ? type : acc;
      }, undefined);
      this._cfg = config;
      if (type) {
        this._provider = {
          type,
          request: config[type]
        };
      }
    }
    get path() {
      return this._cfg.path;
    }
    get component() {
      return this._cfg.component;
    }
    get options() {
      return this._cfg.options;
    }
    get widgets() {
      return this._cfg.widgets;
    }
    get cache() {
      return this._cfg.cache;
    }
    get hook() {
      return this._cfg.hook;
    }
    get beforeNavigate() {
      return this._cfg.beforeNavigate;
    }
    get provider() {
      return this._provider;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple route length calculation
   * @param route {string}
   * @returns {number} - floor
   */
  const getFloor = route => {
    return stripRegex(route).split('/').length;
  };

  /**
   * return all stored routes that live on the same floor
   * @param floor
   * @returns {Array}
   */
  const getRoutesByFloor = floor => {
    const matches = [];
    // simple filter of level candidates
    for (let [route] of routes$1.entries()) {
      if (getFloor(route) === floor) {
        matches.push(route);
      }
    }
    return matches;
  };

  /**
   * return a matching route by provided hash
   * hash: home/browse/12 will match:
   * route: home/browse/:categoryId
   * @param hash {string}
   * @returns {boolean|{}} - route
   */
  const getRouteByHash = hash => {
    // @todo: clean up on handleHash
    hash = hash.replace(/^#/, '');
    const getUrlParts = /(\/?:?[^/]+)/g;
    // grab possible candidates from stored routes
    const candidates = getRoutesByFloor(getFloor(hash));
    // break hash down in chunks
    const hashParts = hash.match(getUrlParts) || [];

    // to simplify the route matching and prevent look around
    // in our getUrlParts regex we get the regex part from
    // route candidate and store them so that we can reference
    // them when we perform the actual regex against hash
    let regexStore = [];
    let matches = candidates.filter(route => {
      let isMatching = true;
      // replace regex in route with lookup id => @@{storeId}@@
      if (hasRegex.test(route)) {
        const regMatches = route.match(hasRegex);
        if (regMatches && regMatches.length) {
          route = regMatches.reduce((fullRoute, regex) => {
            const lookupId = regexStore.length;
            fullRoute = fullRoute.replace(regex, "@@".concat(lookupId, "@@"));
            regexStore.push(regex.substring(1, regex.length - 1));
            return fullRoute;
          }, route);
        }
      }
      const routeParts = route.match(getUrlParts) || [];
      for (let i = 0, j = routeParts.length; i < j; i++) {
        const routePart = routeParts[i];
        const hashPart = hashParts[i];

        // Since we support catch-all and regex driven name groups
        // we first test for regex lookup id and see if the regex
        // matches the value from the hash
        if (hasLookupId.test(routePart)) {
          const routeMatches = hasLookupId.exec(routePart);
          const storeId = routeMatches[1];
          const routeRegex = regexStore[storeId];

          // split regex and modifiers so we can use both
          // to create a new RegExp
          // eslint-disable-next-line
          const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex);
          if (regMatches && regMatches.length) {
            const expression = regMatches[1];
            const modifiers = regMatches[2];
            const regex = new RegExp("^/".concat(expression, "$"), modifiers);
            if (!regex.test(hashPart)) {
              isMatching = false;
            }
          }
        } else if (isNamedGroup.test(routePart)) {
          // we kindly skip namedGroups because this is dynamic
          // we only need to the static and regex drive parts
          continue;
        } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
          isMatching = false;
        }
      }
      return isMatching;
    });
    if (matches.length) {
      if (matches.indexOf(hash) !== -1) {
        const match = matches[matches.indexOf(hash)];
        return routes$1.get(match);
      } else {
        // we give prio to static routes over dynamic
        matches = matches.sort(a => {
          return isNamedGroup.test(a) ? -1 : 1;
        });
        // would be strange if this fails
        // but still we test
        if (routeExists(matches[0])) {
          return routes$1.get(matches[0]);
        }
      }
    }
    return false;
  };
  const getValuesFromHash = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let path = arguments.length > 1 ? arguments[1] : undefined;
    // replace the regex definition from the route because
    // we already did the matching part
    path = stripRegex(path, '');
    const getUrlParts = /(\/?:?[\w%\s:.-]+)/g;
    const hashParts = hash.match(getUrlParts) || [];
    const routeParts = path.match(getUrlParts) || [];
    const getNamedGroup = /^\/:([\w-]+)\/?/;
    return routeParts.reduce((storage, value, index) => {
      const match = getNamedGroup.exec(value);
      if (match && match.length) {
        storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')));
      }
      return storage;
    }, new Map());
  };
  const getOption = (stack, prop) => {
    // eslint-disable-next-line
    if (stack && stack.hasOwnProperty(prop)) {
      return stack[prop];
    }
    // we explicitly return undefined since we're testing
    // for explicit test values
  };

  /**
   * create and return new Route instance
   * @param config
   */
  const createRoute = config => {
    // we need to provide a bit of additional logic
    // for the bootComponent
    if (config.path === '$') {
      let options = {
        preventStorage: true
      };
      if (isObject(config.options)) {
        options = {
          ...config.options,
          ...options
        };
      }
      config.options = options;
      // if configured add reference to bootRequest
      // as router after provider
      if (bootRequest) {
        config.after = bootRequest;
      }
    }
    return new Route(config);
  };

  /**
   * Create a new Router request object
   * @param url
   * @param args
   * @param store
   * @returns {*}
   */
  const createRequest = (url, args, store) => {
    return new Request(url, args, store);
  };
  const getHashByName = obj => {
    if (!obj.to && !obj.name) {
      return false;
    }
    const route = getRouteByName(obj.to || obj.name);
    const hasDynamicGroup = /\/:([\w-]+)\/?/;
    let hash = route;

    // if route contains dynamic group
    // we replace them with the provided params
    if (hasDynamicGroup.test(route)) {
      if (obj.params) {
        const keys = Object.keys(obj.params);
        hash = keys.reduce((acc, key) => {
          return acc.replace(":".concat(key), obj.params[key]);
        }, route);
      }
      if (obj.query) {
        return "".concat(hash).concat(objectToQueryString(obj.query));
      }
    }
    return hash;
  };
  const getRouteByName = name => {
    for (let [path, route] of routes$1.entries()) {
      if (route.name === name) {
        return path;
      }
    }
    return false;
  };
  const keepActivePageAlive = (route, request) => {
    if (isString(route)) {
      const routes = getRoutes();
      if (routes.has(route)) {
        route = routes.get(route);
      } else {
        return false;
      }
    }
    const register = request.register;
    const routeOptions = route.options;
    if (register.has('keepAlive')) {
      return register.get('keepAlive');
    } else if (routeOptions && routeOptions.keepAlive) {
      return routeOptions.keepAlive;
    }
    return false;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var emit$4 = (function (page) {
    let events = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!isArray(events)) {
      events = [events];
    }
    events.forEach(e => {
      const event = "_on".concat(ucfirst(e));
      if (isFunction(page[event])) {
        page[event](params);
      }
    });
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let activeWidget = null;
  const getReferences = () => {
    if (!widgetsHost) {
      return;
    }
    return widgetsHost.get().reduce((storage, widget) => {
      const key = widget.ref.toLowerCase();
      storage[key] = widget;
      return storage;
    }, {});
  };

  /**
   * update the visibility of the available widgets
   * for the current page / route
   * @param page
   */
  const updateWidgets = (widgets, page) => {
    // force lowercase lookup
    const configured = (widgets || []).map(ref => ref.toLowerCase());
    widgetsHost.forEach(widget => {
      widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1;
      if (widget.visible) {
        emit$4(widget, ['activated'], page);
      }
    });
    if (app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
      app._setState('');
    }
  };
  const getWidgetByName = name => {
    name = ucfirst(name);
    return widgetsHost.getByRef(name) || false;
  };

  /**
   * delegate app focus to a on-screen widget
   * @param name - {string}
   */
  const focusWidget = name => {
    const widget = getWidgetByName(name);
    if (widget) {
      setActiveWidget(widget);

      // if app is already in 'Widgets' state we can assume that
      // focus has been delegated from one widget to another so
      // we need to set the new widget reference and trigger a
      // new focus calculation of Lightning's focuspath
      if (app.state === 'Widgets') {
        app.reload(activeWidget);
      } else {
        app._setState('Widgets', [activeWidget]);
      }
    }
  };
  const restoreFocus = () => {
    activeWidget = null;
    app._setState('');
  };
  const getActiveWidget = () => {
    return activeWidget;
  };
  const setActiveWidget = instance => {
    activeWidget = instance;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const createComponent = (stage, type) => {
    return stage.c({
      type,
      visible: false,
      widgets: getReferences()
    });
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Simple flat array that holds the visited hashes + state Object
   * so the router can navigate back to them
   * @type {Array}
   */
  let history = [];
  const updateHistory = request => {
    const hash = getActiveHash();
    if (!hash) {
      return;
    }

    // navigate storage flag
    const register = request.register;
    const forceNavigateStore = register.get(symbols.store);

    // test preventStorage on route configuration
    const activeRoute = getRouteByHash(hash);
    const preventStorage = getOption(activeRoute.options, 'preventStorage');

    // we give prio to navigate storage flag
    let store = isBoolean(forceNavigateStore) ? forceNavigateStore : !preventStorage;
    if (store) {
      const toStore = hash.replace(/^\//, '');
      const location = locationInHistory(toStore);
      const stateObject = getStateObject(getActivePage(), request);
      const routerConfig = getRouterConfig();

      // store hash if it's not a part of history or flag for
      // storage of same hash is true
      if (location === -1 || routerConfig.get('storeSameHash')) {
        history.push({
          hash: toStore,
          state: stateObject
        });
      } else {
        // if we visit the same route we want to sync history
        const prev = history.splice(location, 1)[0];
        history.push({
          hash: prev.hash,
          state: stateObject
        });
      }
    }
  };
  const locationInHistory = hash => {
    for (let i = 0; i < history.length; i++) {
      if (history[i].hash === hash) {
        return i;
      }
    }
    return -1;
  };
  const getHistoryState = hash => {
    let state = null;
    if (history.length) {
      // if no hash is provided we get the last
      // pushed history record
      if (!hash) {
        const record = history[history.length - 1];
        // could be null
        state = record.state;
      } else {
        if (locationInHistory(hash) !== -1) {
          const record = history[locationInHistory(hash)];
          state = record.state;
        }
      }
    }
    return state;
  };
  const replaceHistoryState = function () {
    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let hash = arguments.length > 1 ? arguments[1] : undefined;
    if (!history.length) {
      return;
    }
    const location = hash ? locationInHistory(hash) : history.length - 1;
    if (location !== -1 && isObject(state)) {
      history[location].state = state;
    }
  };
  const getStateObject = (page, request) => {
    // if the new request shared instance with the
    // previous request we used the copied state object
    if (request.isSharedInstance) {
      if (request.copiedHistoryState) {
        return request.copiedHistoryState;
      }
    } else if (page && isFunction(page.historyState)) {
      return page.historyState();
    }
    return null;
  };
  const getHistory = () => {
    return history.slice(0);
  };
  const setHistory = function () {
    let arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (isArray(arr)) {
      history = arr;
    }
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
  }

  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  var cjs = deepmerge_1;

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let warned = false;
  const deprecated = function () {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (force === true || warned === false) {
      console.warn(["The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.", "Please consider using the new 'Language'-plugin instead.", 'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language'].join('\n\n'));
    }
    warned = true;
  };
  class Locale {
    constructor() {
      this.__enabled = false;
    }

    /**
     * Loads translation object from external json file.
     *
     * @param {String} path Path to resource.
     * @return {Promise}
     */
    async load(path) {
      if (!this.__enabled) {
        return;
      }
      await fetch(path).then(resp => resp.json()).then(resp => {
        this.loadFromObject(resp);
      });
    }

    /**
     * Sets language used by module.
     *
     * @param {String} lang
     */
    setLanguage(lang) {
      deprecated();
      this.__enabled = true;
      this.language = lang;
    }

    /**
     * Returns reference to translation object for current language.
     *
     * @return {Object}
     */
    get tr() {
      deprecated(true);
      return this.__trObj[this.language];
    }

    /**
     * Loads translation object from existing object (binds existing object).
     *
     * @param {Object} trObj
     */
    loadFromObject(trObj) {
      deprecated();
      const fallbackLanguage = 'en';
      if (Object.keys(trObj).indexOf(this.language) === -1) {
        Log.warn('No translations found for: ' + this.language);
        if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
          Log.warn('Using fallback language: ' + fallbackLanguage);
          this.language = fallbackLanguage;
        } else {
          const error = 'No translations found for fallback language: ' + fallbackLanguage;
          Log.error(error);
          throw Error(error);
        }
      }
      this.__trObj = trObj;
      for (const lang of Object.values(this.__trObj)) {
        for (const str of Object.keys(lang)) {
          lang[str] = new LocalizedString(lang[str]);
        }
      }
    }
  }

  /**
   * Extended string class used for localization.
   */
  class LocalizedString extends String {
    /**
     * Returns formatted LocalizedString.
     * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
     *
     * E.g.:
     * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
     * A and B and A
     *
     * @param  {...any} args List of arguments for placeholders.
     */
    format() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const sub = args.reduce((string, arg, index) => string.split("{".concat(index, "}")).join(arg), this);
      return new LocalizedString(sub);
    }
  }
  var Locale$1 = new Locale();

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class VersionLabel extends t.Component {
    static _template() {
      return {
        rect: true,
        color: 0xbb0078ac,
        h: 40,
        w: 100,
        x: w => w - 50,
        y: h => h - 50,
        mount: 1,
        Text: {
          w: w => w,
          h: h => h,
          y: 5,
          x: 20,
          text: {
            fontSize: 22,
            lineHeight: 26
          }
        }
      };
    }
    _firstActive() {
      this.tag('Text').text = "APP - v".concat(this.version, "\nSDK - v").concat(this.sdkVersion);
      this.tag('Text').loadTexture();
      this.w = this.tag('Text').renderWidth + 40;
      this.h = this.tag('Text').renderHeight + 5;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class FpsIndicator extends t.Component {
    static _template() {
      return {
        rect: true,
        color: 0xffffffff,
        texture: t.Tools.getRoundRect(80, 80, 40),
        h: 80,
        w: 80,
        x: 100,
        y: 100,
        mount: 1,
        Background: {
          x: 3,
          y: 3,
          texture: t.Tools.getRoundRect(72, 72, 36),
          color: 0xff008000
        },
        Counter: {
          w: w => w,
          h: h => h,
          y: 10,
          text: {
            fontSize: 32,
            textAlign: 'center'
          }
        },
        Text: {
          w: w => w,
          h: h => h,
          y: 48,
          text: {
            fontSize: 15,
            textAlign: 'center',
            text: 'FPS'
          }
        }
      };
    }
    _setup() {
      this.config = {
        ...{
          log: false,
          interval: 500,
          threshold: 1
        },
        ...Settings$2.get('platform', 'showFps')
      };
      this.fps = 0;
      this.lastFps = this.fps - this.config.threshold;
      const fpsCalculator = () => {
        this.fps = ~~(1 / this.stage.dt);
      };
      this.stage.on('frameStart', fpsCalculator);
      this.stage.off('framestart', fpsCalculator);
      this.interval = setInterval(this.showFps.bind(this), this.config.interval);
    }
    _firstActive() {
      this.showFps();
    }
    _detach() {
      clearInterval(this.interval);
    }
    showFps() {
      if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return;
      this.lastFps = this.fps;
      // green
      let bgColor = 0xff008000;
      // orange
      if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500;
      // red
      else if (this.fps <= 20) bgColor = 0xffff0000;
      this.tag('Background').setSmooth('color', bgColor);
      this.tag('Counter').text = "".concat(this.fps);
      this.config.log && Log.info('FPS', this.fps);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let meta = {};
  let translations = {};
  let language$2 = null;
  let dictionary = null;
  const initLanguage = function (file) {
    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return new Promise((resolve, reject) => {
      fetch(file).then(response => response.json()).then(json => {
        setTranslations(json);
        // set language (directly or in a promise)
        typeof language === 'object' && 'then' in language && typeof language.then === 'function' ? language.then(lang => setLanguage(lang).then(resolve).catch(reject)).catch(e => {
          Log.error(e);
          reject(e);
        }) : setLanguage(language).then(resolve).catch(reject);
      }).catch(() => {
        const error = 'Language file ' + file + ' not found';
        Log.error(error);
        reject(error);
      });
    });
  };
  const setTranslations = obj => {
    if ('meta' in obj) {
      meta = {
        ...obj.meta
      };
      delete obj.meta;
    }
    translations = obj;
  };
  const getLanguage = () => {
    return language$2;
  };
  const setLanguage = lng => {
    language$2 = null;
    dictionary = null;
    return new Promise((resolve, reject) => {
      if (lng in translations) {
        language$2 = lng;
      } else {
        if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
          language$2 = meta.map[lng];
        } else if ('default' in meta && meta.default in translations) {
          const error = 'Translations for Language ' + language$2 + ' not found. Using default language ' + meta.default;
          Log.warn(error);
          language$2 = meta.default;
        } else {
          const error = 'Translations for Language ' + language$2 + ' not found.';
          Log.error(error);
          reject(error);
        }
      }
      if (language$2) {
        Log.info('Setting language to', language$2);
        const translationsObj = translations[language$2];
        if (typeof translationsObj === 'object') {
          dictionary = translationsObj;
          resolve();
        } else if (typeof translationsObj === 'string') {
          const url = Utils.asset(translationsObj);
          fetch(url).then(response => response.json()).then(json => {
            // save the translations for this language (to prevent loading twice)
            translations[language$2] = json;
            dictionary = json;
            resolve();
          }).catch(e => {
            const error = 'Error while fetching ' + url;
            Log.error(error, e);
            reject(error);
          });
        }
      }
    });
  };
  var Language$1 = {
    translate(key) {
      let replacements = [...arguments].slice(1);

      // no replacements so just translated string
      if (replacements.length === 0) {
        return dictionary && dictionary[key] || key;
      } else {
        if (replacements.length === 1 && typeof replacements[0] === 'object') {
          replacements = replacements.pop();
        }
        return Object.keys(
        // maps array input to an object {0: 'item1', 1: 'item2'}
        Array.isArray(replacements) ? Object.assign({}, replacements) : replacements).reduce((text, replacementKey) => {
          return text.replace(new RegExp('{\\s?' + replacementKey + '\\s?}', 'g'), replacements[replacementKey]);
        }, dictionary && dictionary[key] || key);
      }
    },
    translations(obj) {
      setTranslations(obj);
    },
    set(language) {
      return setLanguage(language);
    },
    get() {
      return getLanguage();
    },
    available() {
      const languageKeys = Object.keys(translations);
      return languageKeys.map(key => ({
        code: key,
        name: meta.names && meta.names[key] || key
      }));
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const registry = {
    eventListeners: [],
    timeouts: [],
    intervals: [],
    targets: []
  };
  var Registry = {
    // Timeouts
    setTimeout(cb, timeout) {
      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }
      const timeoutId = setTimeout(() => {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        cb.apply(null, params);
      }, timeout, params);
      Log.info('Set Timeout', 'ID: ' + timeoutId);
      registry.timeouts.push(timeoutId);
      return timeoutId;
    },
    clearTimeout(timeoutId) {
      if (registry.timeouts.indexOf(timeoutId) > -1) {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId);
        Log.info('Clear Timeout', 'ID: ' + timeoutId);
        clearTimeout(timeoutId);
      } else {
        Log.error('Clear Timeout', 'ID ' + timeoutId + ' not found');
      }
    },
    clearTimeouts() {
      registry.timeouts.forEach(timeoutId => {
        this.clearTimeout(timeoutId);
      });
    },
    // Intervals
    setInterval(cb, interval) {
      for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        params[_key2 - 2] = arguments[_key2];
      }
      const intervalId = setInterval(() => {
        registry.intervals.filter(id => id !== intervalId);
        cb.apply(null, params);
      }, interval, params);
      Log.info('Set Interval', 'ID: ' + intervalId);
      registry.intervals.push(intervalId);
      return intervalId;
    },
    clearInterval(intervalId) {
      if (registry.intervals.indexOf(intervalId) > -1) {
        registry.intervals = registry.intervals.filter(id => id !== intervalId);
        Log.info('Clear Interval', 'ID: ' + intervalId);
        clearInterval(intervalId);
      } else {
        Log.error('Clear Interval', 'ID ' + intervalId + ' not found');
      }
    },
    clearIntervals() {
      registry.intervals.forEach(intervalId => {
        this.clearInterval(intervalId);
      });
    },
    // Event listeners
    addEventListener(target, event, handler) {
      target.addEventListener(event, handler);
      const targetIndex = registry.targets.indexOf(target) > -1 ? registry.targets.indexOf(target) : registry.targets.push(target) - 1;
      registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {};
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || [];
      registry.eventListeners[targetIndex][event].push(handler);
      Log.info('Add eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
    },
    removeEventListener(target, event, handler) {
      const targetIndex = registry.targets.indexOf(target);
      if (targetIndex > -1 && registry.eventListeners[targetIndex] && registry.eventListeners[targetIndex][event] && registry.eventListeners[targetIndex][event].indexOf(handler) > -1) {
        registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event].filter(fn => fn !== handler);
        Log.info('Remove eventListener', 'Target:', target, 'Event: ' + event, 'Handler:', handler.toString());
        target.removeEventListener(event, handler);
      } else {
        Log.error('Remove eventListener', 'Not found', 'Target', target, 'Event: ' + event, 'Handler', handler.toString());
      }
    },
    // if `event` is omitted, removes all registered event listeners for target
    // if `target` is also omitted, removes all registered event listeners
    removeEventListeners(target, event) {
      if (target && event) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          registry.eventListeners[targetIndex][event].forEach(handler => {
            this.removeEventListener(target, event, handler);
          });
        }
      } else if (target) {
        const targetIndex = registry.targets.indexOf(target);
        if (targetIndex > -1) {
          Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
            this.removeEventListeners(target, _event);
          });
        }
      } else {
        Object.keys(registry.eventListeners).forEach(targetIndex => {
          this.removeEventListeners(registry.targets[targetIndex]);
        });
      }
    },
    // Clear everything (to be called upon app close for proper cleanup)
    clear() {
      this.clearTimeouts();
      this.clearIntervals();
      this.removeEventListeners();
      registry.eventListeners = [];
      registry.timeouts = [];
      registry.intervals = [];
      registry.targets = [];
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const isObject$1 = v => {
    return typeof v === 'object' && v !== null;
  };
  const isString$1 = v => {
    return typeof v === 'string';
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let colors = {
    white: '#ffffff',
    black: '#000000',
    red: '#ff0000',
    green: '#00ff00',
    blue: '#0000ff',
    yellow: '#feff00',
    cyan: '#00feff',
    magenta: '#ff00ff'
  };
  const normalizedColors = {
    //store for normalized colors
  };
  const addColors = (colorsToAdd, value) => {
    if (isObject$1(colorsToAdd)) {
      // clean up normalizedColors if they exist in the to be added colors
      Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color));
      colors = Object.assign({}, colors, colorsToAdd);
    } else if (isString$1(colorsToAdd) && value) {
      cleanUpNormalizedColors(colorsToAdd);
      colors[colorsToAdd] = value;
    }
  };
  const cleanUpNormalizedColors = color => {
    for (let c in normalizedColors) {
      if (c.indexOf(color) > -1) {
        delete normalizedColors[c];
      }
    }
  };
  const initColors = file => {
    return new Promise((resolve, reject) => {
      if (typeof file === 'object') {
        addColors(file);
        return resolve();
      }
      fetch(file).then(response => response.json()).then(json => {
        addColors(json);
        return resolve();
      }).catch(() => {
        const error = 'Colors file ' + file + ' not found';
        Log.error(error);
        return reject(error);
      });
    });
  };

  var name$1 = "@lightningjs/sdk";
  var version$1 = "4.8.3";
  var license = "Apache-2.0";
  var scripts = {
  	postinstall: "node ./scripts/postinstall.js",
  	lint: "eslint '**/*.js'",
  	release: "npm publish --access public"
  };
  var husky = {
  	hooks: {
  		"pre-commit": "lint-staged"
  	}
  };
  var dependencies = {
  	"@babel/polyfill": "^7.11.5",
  	"@lightningjs/core": "*",
  	"@michieljs/execute-as-promise": "^1.0.0",
  	deepmerge: "^4.2.2",
  	localCookie: "github:WebPlatformForEmbedded/localCookie",
  	shelljs: "^0.8.5",
  	"url-polyfill": "^1.1.10",
  	"whatwg-fetch": "^3.0.0"
  };
  var devDependencies = {
  	"@babel/core": "^7.11.6",
  	"@babel/plugin-transform-parameters": "^7.10.5 ",
  	"@babel/plugin-transform-spread": "^7.11.0",
  	"@babel/preset-env": "^7.11.5",
  	"babel-eslint": "^10.1.0",
  	eslint: "^7.10.0",
  	"eslint-config-prettier": "^6.12.0",
  	"eslint-plugin-prettier": "^3.1.4",
  	husky: "^4.3.0",
  	"lint-staged": "^10.4.0",
  	prettier: "^1.19.1",
  	rollup: "^1.32.1",
  	"rollup-plugin-babel": "^4.4.0"
  };
  var repository = {
  	type: "git",
  	url: "git@github.com:rdkcentral/Lightning-SDK.git"
  };
  var bugs = {
  	url: "https://github.com/rdkcentral/Lightning-SDK/issues"
  };
  var packageInfo = {
  	name: name$1,
  	version: version$1,
  	license: license,
  	scripts: scripts,
  	"lint-staged": {
  	"*.js": [
  		"eslint --fix"
  	],
  	"src/startApp.js": [
  		"rollup -c ./rollup.config.js"
  	]
  },
  	husky: husky,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	repository: repository,
  	bugs: bugs
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let AppInstance;
  const defaultOptions$1 = {
    stage: {
      w: 1920,
      h: 1080,
      clearColor: 0x00000000,
      canvas2d: false
    },
    debug: false,
    defaultFontFace: 'RobotoRegular',
    keys: {
      8: 'Back',
      13: 'Enter',
      27: 'Menu',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      174: 'ChannelDown',
      175: 'ChannelUp',
      178: 'Stop',
      250: 'PlayPause',
      191: 'Search',
      // Use "/" for keyboard
      409: 'Search'
    }
  };
  const customFontFaces = [];
  const fontLoader = (fonts, store) => new Promise((resolve, reject) => {
    fonts.map(_ref => {
      let {
        family,
        url,
        urls,
        descriptors
      } = _ref;
      return () => {
        const src = urls ? urls.map(url => {
          return 'url(' + url + ')';
        }) : 'url(' + url + ')';
        const fontFace = new FontFace(family, src, descriptors || {});
        store.push(fontFace);
        Log.info('Loading font', family);
        document.fonts.add(fontFace);
        return fontFace.load();
      };
    }).reduce((promise, method) => {
      return promise.then(() => method());
    }, Promise.resolve(null)).then(resolve).catch(reject);
  });
  function Application (App, appData, platformSettings) {
    const {
      width,
      height
    } = platformSettings;
    if (width && height) {
      defaultOptions$1.stage['w'] = width;
      defaultOptions$1.stage['h'] = height;
      defaultOptions$1.stage['precision'] = width / 1920;
    }

    // support for 720p browser
    if (!width && !height && window.innerHeight === 720) {
      defaultOptions$1.stage['w'] = 1280;
      defaultOptions$1.stage['h'] = 720;
      defaultOptions$1.stage['precision'] = 1280 / 1920;
    }
    return class Application extends t.Application {
      constructor(options) {
        const config = cjs(defaultOptions$1, options);
        // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
        if (options.stage.canvas) {
          config.stage.canvas = options.stage.canvas;
        }
        super(config);
        this.config = config;
      }
      static _template() {
        return {
          w: 1920,
          h: 1080
        };
      }
      _setup() {
        Promise.all([this.loadFonts(App.config && App.config.fonts || App.getFonts && App.getFonts() || []),
        // to be deprecated
        Locale$1.load(App.config && App.config.locale || App.getLocale && App.getLocale()), App.language && this.loadLanguage(App.language()), App.colors && this.loadColors(App.colors())]).then(() => {
          Metrics$1.app.loaded();
          AppInstance = this.stage.c({
            ref: 'App',
            type: App,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps
          });
          this.childList.a(AppInstance);
          this._refocus();
          Log.info('App version', this.config.version);
          Log.info('SDK version', packageInfo.version);
          if (platformSettings.showVersion) {
            this.childList.a({
              ref: 'VersionLabel',
              type: VersionLabel,
              version: this.config.version,
              sdkVersion: packageInfo.version,
              zIndex: 1
            });
          }
          if (platformSettings.showFps) {
            this.childList.a({
              ref: 'FpsCounter',
              type: FpsIndicator,
              zIndex: 1
            });
          }
          super._setup();
        }).catch(console.error);
      }
      _handleBack() {
        this.closeApp();
      }
      _handleExit() {
        this.closeApp();
      }
      closeApp() {
        Log.info('Signaling App Close');
        if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
          platformSettings.onClose(...arguments);
        } else {
          this.close();
        }
      }
      close() {
        Log.info('Closing App');
        Settings$2.clearSubscribers();
        Registry.clear();
        this.childList.remove(this.tag('App'));
        this.cleanupFonts();
        // force texture garbage collect
        this.stage.gc();
        this.destroy();
      }
      loadFonts(fonts) {
        return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function' ? platformSettings.fontLoader(fonts, customFontFaces) : fontLoader(fonts, customFontFaces);
      }
      cleanupFonts() {
        if ('delete' in document.fonts) {
          customFontFaces.forEach(fontFace => {
            Log.info('Removing font', fontFace.family);
            document.fonts.delete(fontFace);
          });
        } else {
          Log.info('No support for removing manually-added fonts');
        }
      }
      loadLanguage(config) {
        let file = Utils.asset('translations.json');
        let language = config;
        if (typeof language === 'object') {
          language = config.language || null;
          file = config.file || file;
        }
        return initLanguage(file, language);
      }
      loadColors(config) {
        let file = Utils.asset('colors.json');
        if (config && (typeof config === 'string' || typeof config === 'object')) {
          file = config;
        }
        return initColors(file);
      }
      set focus(v) {
        this._focussed = v;
        this._refocus();
      }
      _getFocused() {
        return this._focussed || this.tag('App');
      }
    };
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @type {Lightning.Application}
   */
  let application;

  /**
   * Actual instance of the app
   * @type {Lightning.Component}
   */
  let app;

  /**
   * Component that hosts all routed pages
   * @type {Lightning.Component}
   */
  let pagesHost;

  /**
   * @type {Lightning.Stage}
   */
  let stage;

  /**
   * Platform driven Router configuration
   * @type {Map<string>}
   */
  let routerConfig;

  /**
   * Component that hosts all attached widgets
   * @type {Lightning.Component}
   */
  let widgetsHost;

  /**
   * Hash we point the browser to when we boot the app
   * and there is no deep-link provided
   * @type {string|Function}
   */
  let rootHash;

  /**
   * Boot request will fire before app start
   * can be used to execute some global logic
   * and can be configured
   */
  let bootRequest;

  /**
   * Flag if we need to update the browser location hash.
   * Router can work without.
   * @type {boolean}
   */
  let updateHash = true;

  /**
   * Will be called before a route starts, can be overridden
   * via routes config
   * @param from - route we came from
   * @param to - route we navigate to
   * @returns {Promise<*>}
   */
  // eslint-disable-next-line
  let beforeEachRoute = async (from, to) => {
    return true;
  };

  /**
   *  * Will be called after a navigate successfully resolved,
   * can be overridden via routes config
   */
  let afterEachRoute = () => {};

  /**
   * All configured routes
   * @type {Map<string, object>}
   */
  let routes$1 = new Map();

  /**
   * Store all page components per route
   * @type {Map<string, object>}
   */
  let components = new Map();

  /**
   * Flag if router has been initialised
   * @type {boolean}
   */
  let initialised = false;

  /**
   * Current page being rendered on screen
   * @type {null}
   */
  let activePage = null;
  let activeHash;
  let activeRoute;

  /**
   *  During the process of a navigation request a new
   *  request can start, to prevent unwanted behaviour
   *  the navigate()-method stores the last accepted hash
   *  so we can invalidate any prior requests
   */
  let lastAcceptedHash;

  /**
   * With on()-data providing behaviour the Router forced the App
   * in a Loading state. When the data-provider resolves we want to
   * change the state back to where we came from
   */
  let previousState;
  const mixin = app => {
    // by default the Router Baseclass provides the component
    // reference in which we store our pages
    if (app.pages) {
      pagesHost = app.pages.childList;
    }
    // if the app is using widgets we grab refs
    // and hide all the widgets
    if (app.widgets && app.widgets.children) {
      widgetsHost = app.widgets.childList;
      // hide all widgets on boot
      widgetsHost.forEach(w => w.visible = false);
    }
    app._handleBack = e => {
      step(-1);
      e.preventDefault();
    };
  };
  const bootRouter = (config, instance) => {
    let {
      appInstance,
      routes
    } = config;

    // if instance is provided and it's and Lightning Component instance
    if (instance && isPage(instance)) {
      app = instance;
    }
    if (!app) {
      app = appInstance || AppInstance;
    }
    application = app.application;
    pagesHost = application.childList;
    stage = app.stage;
    routerConfig = getConfigMap();
    mixin(app);
    if (isArray(routes)) {
      setup(config);
    } else if (isFunction(routes)) {
      console.warn('[Router]: Calling Router.route() directly is deprecated.');
      console.warn('Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    }
  };
  const setup = config => {
    if (!initialised) {
      init$2(config);
    }
    config.routes.forEach(r => {
      const path = cleanHash(r.path);
      if (!routeExists(path)) {
        const route = createRoute(r);
        routes$1.set(path, route);
        // if route has a configured component property
        // we store it in a different map to simplify
        // the creating and destroying per route
        if (route.component) {
          let type = route.component;
          if (isComponentConstructor(type)) {
            if (!routerConfig.get('lazyCreate')) {
              type = createComponent(stage, type);
              pagesHost.a(type);
            }
          }
          components.set(path, type);
        }
      } else {
        console.error("".concat(path, " already exists in routes configuration"));
      }
    });
  };
  const init$2 = config => {
    rootHash = config.root;
    if (isFunction(config.boot)) {
      bootRequest = config.boot;
    }
    if (isBoolean(config.updateHash)) {
      updateHash = config.updateHash;
    }
    if (isFunction(config.beforeEachRoute)) {
      beforeEachRoute = config.beforeEachRoute;
    }
    if (isFunction(config.afterEachRoute)) {
      afterEachRoute = config.afterEachRoute;
    }
    if (config.bootComponent) {
      console.warn('[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes');
      console.warn('[Router]: setting { bootComponent } property will be deprecated in a future release');
      if (isPage(config.bootComponent)) {
        config.routes.push({
          path: '$',
          component: config.bootComponent,
          // we try to assign the bootRequest as after data-provider
          // so it will behave as any other component
          after: bootRequest || null,
          options: {
            preventStorage: true
          }
        });
      } else {
        console.error("[Router]: ".concat(config.bootComponent, " is not a valid boot component"));
      }
    }
    initialised = true;
  };
  const storeComponent = (route, type) => {
    if (components.has(route)) {
      components.set(route, type);
    }
  };
  const getComponent = route => {
    if (components.has(route)) {
      return components.get(route);
    }
    return null;
  };
  /**
   * Test if router needs to update browser location hash
   * @returns {boolean}
   */
  const mustUpdateLocationHash = () => {
    if (!routerConfig || !routerConfig.size) {
      return false;
    }
    // we need support to either turn change hash off
    // per platform or per app
    const updateConfig = routerConfig.get('updateHash');
    return !(isBoolean(updateConfig) && !updateConfig || isBoolean(updateHash) && !updateHash);
  };

  /**
   * Will be called when a new navigate() request has completed
   * and has not been expired due to it's async nature
   * @param request
   */
  const onRequestResolved = request => {
    const hash = request.hash;
    const route = request.route;
    const register = request.register;
    const page = request.page;

    // clean up history if modifier is set
    if (getOption(route.options, 'clearHistory')) {
      setHistory([]);
    } else if (hash && !isWildcard.test(route.path)) {
      updateHistory(request);
    }

    // we only update the stackLocation if a route
    // is not expired before it resolves
    storeComponent(route.path, page);
    if (request.isSharedInstance || !request.isCreated) {
      emit$4(page, 'changed');
    } else if (request.isCreated) {
      emit$4(page, 'mounted');
    }

    // only update widgets if we have a host
    if (widgetsHost) {
      updateWidgets(route.widgets, page);
    }

    // we want to clean up if there is an
    // active page that is not being shared
    // between current and previous route
    if (getActivePage() && !request.isSharedInstance) {
      cleanUp(activePage, request);
    }

    // provide history object to active page
    if (register.get(symbols.historyState) && isFunction(page.historyState)) {
      page.historyState(register.get(symbols.historyState));
    }
    setActivePage(page);
    activeHash = request.hash;
    activeRoute = route.path;

    // cleanup all cancelled requests
    for (let request of navigateQueue.values()) {
      if (request.isCancelled && request.hash) {
        navigateQueue.delete(request.hash);
      }
    }
    afterEachRoute(request);
    Log.info('[route]:', route.path);
    Log.info('[hash]:', hash);
  };
  const cleanUp = (page, request) => {
    const route = activeRoute;
    const register = request.register;
    const lazyDestroy = routerConfig.get('lazyDestroy');
    const destroyOnBack = routerConfig.get('destroyOnHistoryBack');
    const keepAlive = register.get('keepAlive');
    const isFromHistory = register.get(symbols.backtrack);
    let doCleanup = false;

    // if this request is executed due to a step back in history
    // and we have configured to destroy active page when we go back
    // in history or lazyDestory is enabled
    if (isFromHistory && (destroyOnBack || lazyDestroy)) {
      doCleanup = true;
    }

    // clean up if lazyDestroy is enabled and the keepAlive flag
    // in navigation register is false
    if (lazyDestroy && !keepAlive) {
      doCleanup = true;
    }

    // if the current and new request share the same route blueprint
    if (activeRoute === request.route.path) {
      doCleanup = true;
    }
    if (doCleanup) {
      // grab original class constructor if
      // statemachine routed else store constructor
      storeComponent(route, page._routedType || page.constructor);

      // actual remove of page from memory
      pagesHost.remove(page);

      // force texture gc() if configured
      // so we can cleanup textures in the same tick
      if (routerConfig.get('gcOnUnload')) {
        stage.gc();
      }
    } else {
      // If we're not removing the page we need to
      // reset it's properties
      page.patch({
        x: 0,
        y: 0,
        scale: 1,
        alpha: 1,
        visible: false
      });
    }
  };
  const getActiveHash = () => {
    return activeHash;
  };
  const setActivePage = page => {
    activePage = page;
  };
  const getActivePage = () => {
    return activePage;
  };
  const getActiveRoute = () => {
    return activeRoute;
  };
  const getLastHash = () => {
    return lastAcceptedHash;
  };
  const setLastHash = hash => {
    lastAcceptedHash = hash;
  };
  const getPreviousState = () => {
    return previousState;
  };
  const routeExists = key => {
    return routes$1.has(key);
  };
  const getRootHash = () => {
    return rootHash;
  };
  const getBootRequest = () => {
    return bootRequest;
  };
  const getRouterConfig = () => {
    return routerConfig;
  };
  const getRoutes = () => {
    return routes$1;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const isFunction = v => {
    return typeof v === 'function';
  };
  const isObject = v => {
    return typeof v === 'object' && v !== null;
  };
  const isBoolean = v => {
    return typeof v === 'boolean';
  };
  const isPage = v => {
    if (v instanceof t.Element || isComponentConstructor(v)) {
      return true;
    }
    return false;
  };
  const isComponentConstructor = type => {
    return type.prototype && 'isComponent' in type.prototype;
  };
  const isArray = v => {
    return Array.isArray(v);
  };
  const ucfirst = v => {
    return "".concat(v.charAt(0).toUpperCase()).concat(v.slice(1));
  };
  const isString = v => {
    return typeof v === 'string';
  };
  const isPromise = method => {
    let result;
    if (isFunction(method)) {
      try {
        result = method.apply(null);
      } catch (e) {
        result = e;
      }
    } else {
      result = method;
    }
    return isObject(result) && isFunction(result.then);
  };
  const cleanHash = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return hash.replace(/^#/, '').replace(/\/+$/, '');
  };
  const getConfigMap = () => {
    const routerSettings = Settings$2.get('platform', 'router');
    const isObj = isObject(routerSettings);
    return ['backtrack', 'gcOnUnload', 'destroyOnHistoryBack', 'lazyCreate', 'lazyDestroy', 'reuseInstance', 'autoRestoreRemote', 'numberNavigation', 'updateHash', 'storeSameHash'].reduce((config, key) => {
      config.set(key, isObj ? routerSettings[key] : Settings$2.get('platform', key));
      return config;
    }, new Map());
  };
  const getQueryStringParams = function () {
    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getActiveHash();
    const resumeHash = getResumeHash();
    if ((hash === '$' || !hash) && resumeHash) {
      if (isString(resumeHash)) {
        hash = resumeHash;
      }
    }
    let parse = '';
    const getQuery = /([?&].*)/;
    const matches = getQuery.exec(hash);
    const params = {};
    if (document.location && document.location.search) {
      parse = document.location.search;
    }
    if (matches && matches.length) {
      let hashParams = matches[1];
      if (parse) {
        // if location.search is not empty we
        // remove the leading ? to create a
        // valid string
        hashParams = hashParams.replace(/^\?/, '');
        // we parse hash params last so they we can always
        // override search params with hash params
        parse = "".concat(parse, "&").concat(hashParams);
      } else {
        parse = hashParams;
      }
    }
    if (parse) {
      const urlParams = new URLSearchParams(parse);
      for (const [key, value] of urlParams.entries()) {
        params[key] = value;
      }
      return params;
    } else {
      return false;
    }
  };
  const objectToQueryString = obj => {
    if (!isObject(obj)) {
      return '';
    }
    return '?' + Object.keys(obj).map(key => {
      return "".concat(key, "=").concat(obj[key]);
    }).join('&');
  };
  const symbols = {
    route: Symbol('route'),
    hash: Symbol('hash'),
    store: Symbol('store'),
    fromHistory: Symbol('fromHistory'),
    expires: Symbol('expires'),
    resume: Symbol('resume'),
    backtrack: Symbol('backtrack'),
    historyState: Symbol('historyState'),
    queryParams: Symbol('queryParams')
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const dataHooks = {
    on: request => {
      app.state || '';
      app._setState('Loading');
      return execProvider(request);
    },
    before: request => {
      return execProvider(request);
    },
    after: request => {
      try {
        execProvider(request, true);
      } catch (e) {
        // for now we fail silently
      }
      return Promise.resolve();
    }
  };
  const execProvider = (request, emitProvided) => {
    const route = request.route;
    const provider = route.provider;
    const expires = route.cache ? route.cache * 1000 : 0;
    const params = addPersistData(request);
    return provider.request(request.page, {
      ...params
    }).then(() => {
      request.page[symbols.expires] = Date.now() + expires;
      if (emitProvided) {
        emit$4(request.page, 'dataProvided');
      }
    }).catch(e => {
      request.page[symbols.expires] = Date.now();
      throw e;
    });
  };
  const addPersistData = _ref => {
    let {
      page,
      route,
      hash,
      register = new Map()
    } = _ref;
    const urlValues = getValuesFromHash(hash, route.path);
    const queryParams = getQueryStringParams(hash);
    const pageData = new Map([...urlValues, ...register]);
    const params = {};

    // make dynamic url data available to the page
    // as instance properties
    for (let [name, value] of pageData) {
      params[name] = value;
    }
    if (queryParams) {
      params[symbols.queryParams] = queryParams;
    }

    // check navigation register for persistent data
    if (register.size) {
      const obj = {};
      for (let [k, v] of register) {
        obj[k] = v;
      }
      page.persist = obj;
    }

    // make url data and persist data available
    // via params property
    page.params = params;
    emit$4(page, ['urlParams'], params);
    return params;
  };

  /**
   * Test if page passed cache-time
   * @param page
   * @returns {boolean}
   */
  const isPageExpired = page => {
    if (!page[symbols.expires]) {
      return false;
    }
    const expires = page[symbols.expires];
    const now = Date.now();
    return now >= expires;
  };
  const hasProvider = path => {
    if (routeExists(path)) {
      const record = routes$1.get(path);
      return !!record.provider;
    }
    return false;
  };
  const getProvider = route => {
    // @todo: fix, route already is passed in
    if (routeExists(route.path)) {
      const {
        provider
      } = routes$1.get(route.path);
      return {
        type: provider.type,
        provider: provider.request
      };
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  const fade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, {
            duration: 0.5,
            delay: 0.1
          }]
        }
      });
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        if (o) {
          o.visible = false;
        }
        resolve();
      });
    });
  };
  const crossFade = (i, o) => {
    return new Promise(resolve => {
      i.patch({
        alpha: 0,
        visible: true,
        smooth: {
          alpha: [1, {
            duration: 0.5,
            delay: 0.1
          }]
        }
      });
      if (o) {
        o.patch({
          smooth: {
            alpha: [0, {
              duration: 0.5,
              delay: 0.3
            }]
          }
        });
      }
      // resolve on y finish
      i.transition('alpha').on('finish', () => {
        resolve();
      });
    });
  };
  const moveOnAxes = (axis, direction, i, o) => {
    const bounds = axis === 'x' ? 1920 : 1080;
    return new Promise(resolve => {
      i.patch({
        ["".concat(axis)]: direction ? bounds * -1 : bounds,
        visible: true,
        smooth: {
          ["".concat(axis)]: [0, {
            duration: 0.4,
            delay: 0.2
          }]
        }
      });
      // out is optional
      if (o) {
        o.patch({
          ["".concat(axis)]: 0,
          smooth: {
            ["".concat(axis)]: [direction ? bounds : bounds * -1, {
              duration: 0.4,
              delay: 0.2
            }]
          }
        });
      }
      // resolve on y finish
      i.transition(axis).on('finish', () => {
        resolve();
      });
    });
  };
  const up = (i, o) => {
    return moveOnAxes('y', 0, i, o);
  };
  const down = (i, o) => {
    return moveOnAxes('y', 1, i, o);
  };
  const left = (i, o) => {
    return moveOnAxes('x', 0, i, o);
  };
  const right = (i, o) => {
    return moveOnAxes('x', 1, i, o);
  };
  var Transitions = {
    fade,
    crossFade,
    up,
    down,
    left,
    right
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * execute transition between new / old page and
   * toggle the defined widgets
   * @todo: platform override default transition
   * @param pageIn
   * @param pageOut
   */
  const executeTransition = function (pageIn) {
    let pageOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const transition = pageIn.pageTransition || pageIn.easing;
    const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition);
    const transitionsDisabled = getRouterConfig().get('disableTransitions');
    if (pageIn.easing) {
      console.warn('easing() method is deprecated and will be removed. Use pageTransition()');
    }

    // default behaviour is a visibility toggle
    if (!hasCustomTransitions || transitionsDisabled) {
      pageIn.visible = true;
      if (pageOut) {
        pageOut.visible = false;
      }
      return Promise.resolve();
    }
    if (transition) {
      let type;
      try {
        type = transition.call(pageIn, pageIn, pageOut);
      } catch (e) {
        type = 'crossFade';
      }
      if (isPromise(type)) {
        return type;
      }
      if (isString(type)) {
        const fn = Transitions[type];
        if (fn) {
          return fn(pageIn, pageOut);
        }
      }

      // keep backwards compatible for now
      if (pageIn.smoothIn) {
        // provide a smooth function that resolves itself
        // on transition finish
        const smooth = function (p, v) {
          let args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          return new Promise(resolve => {
            pageIn.visible = true;
            pageIn.setSmooth(p, v, args);
            pageIn.transition(p).on('finish', () => {
              resolve();
            });
          });
        };
        return pageIn.smoothIn({
          pageIn,
          smooth
        });
      }
    }
    return Transitions.crossFade(pageIn, pageOut);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * The actual loading of the component
   * */
  const load = async request => {
    let expired = false;
    try {
      request = await loader$4(request);
      if (request && !request.isCancelled) {
        // in case of on() providing we need to reset
        // app state;
        if (app.state === 'Loading') {
          if (getPreviousState() === 'Widgets') ; else {
            app._setState('');
          }
        }
        // Do page transition if instance
        // is not shared between the routes
        if (!request.isSharedInstance && !request.isCancelled) {
          await executeTransition(request.page, getActivePage());
        }
      } else {
        expired = true;
      }
      // on expired we only cleanup
      if (expired || request.isCancelled) {
        Log.debug('[router]:', "Rejected ".concat(request.hash, " because route to ").concat(getLastHash(), " started"));
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
      } else {
        onRequestResolved(request);
        // resolve promise
        return request.page;
      }
    } catch (request) {
      if (!request.route) {
        console.error(request);
      } else if (!expired) {
        // @todo: revisit
        const {
          route
        } = request;
        // clean up history if modifier is set
        if (getOption(route.options, 'clearHistory')) {
          setHistory([]);
        } else if (!isWildcard.test(route.path)) {
          updateHistory(request);
        }
        if (request.isCreated && !request.isSharedInstance) {
          // remove from render-tree
          pagesHost.remove(request.page);
        }
        handleError(request);
      }
    }
  };
  const loader$4 = async request => {
    const route = request.route;
    const hash = request.hash;
    const register = request.register;

    // todo: grab from Route instance
    let type = getComponent(route.path);
    let isConstruct = isComponentConstructor(type);
    let provide = false;

    // if it's an instance bt we're not coming back from
    // history we test if we can re-use this instance
    if (!isConstruct && !register.get(symbols.backtrack)) {
      if (!mustReuse(route)) {
        type = type.constructor;
        isConstruct = true;
      }
    }

    // If page is Lightning Component instance
    if (!isConstruct) {
      request.page = type;
      // if we have have a data route for current page
      if (hasProvider(route.path)) {
        if (isPageExpired(type) || type[symbols.hash] !== hash) {
          provide = true;
        }
      }
      let currentRoute = getActivePage() && getActivePage()[symbols.route];
      // if the new route is equal to the current route it means that both
      // route share the Component instance and stack location / since this case
      // is conflicting with the way before() and after() loading works we flag it,
      // and check platform settings in we want to re-use instance
      if (route.path === currentRoute) {
        request.isSharedInstance = true;
        // since we're re-using the instance we must attach
        // historyState to the request to prevent it from
        // being overridden.
        if (isFunction(request.page.historyState)) {
          request.copiedHistoryState = request.page.historyState();
        }
      }
    } else {
      request.page = createComponent(stage, type);
      pagesHost.a(request.page);
      // test if need to request data provider
      if (hasProvider(route.path)) {
        provide = true;
      }
      request.isCreated = true;
    }

    // we store hash and route as properties on the page instance
    // that way we can easily calculate new behaviour on page reload
    request.page[symbols.hash] = hash;
    request.page[symbols.route] = route.path;
    try {
      if (provide) {
        // extract attached data-provider for route
        // we're processing
        const {
          type: loadType,
          provider
        } = getProvider(route);

        // update running request
        request.provider = provider;
        request.providerType = loadType;
        await dataHooks[loadType](request);

        // we early exit if the current request is expired
        if (hash !== getLastHash()) {
          return false;
        } else {
          if (request.providerType !== 'after') {
            emit$4(request.page, 'dataProvided');
          }
          // resolve promise
          return request;
        }
      } else {
        addPersistData(request);
        return request;
      }
    } catch (e) {
      request.error = e;
      return Promise.reject(request);
    }
  };
  const handleError = request => {
    if (request && request.error) {
      console.error(request.error);
    } else if (request) {
      Log.error(request);
    }
    if (request.page && routeExists('!')) {
      navigate('!', {
        request
      }, false);
    }
  };
  const mustReuse = route => {
    const opt = getOption(route.options, 'reuseInstance');
    const config = routerConfig.get('reuseInstance');

    // route always has final decision
    if (isBoolean(opt)) {
      return opt;
    }
    return !(isBoolean(config) && config === false);
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class RoutedApp extends t.Component {
    static _template() {
      return {
        Pages: {
          forceZIndexContext: true
        },
        /**
         * This is a default Loading page that will be made visible
         * during data-provider on() you CAN override in child-class
         */
        Loading: {
          rect: true,
          w: 1920,
          h: 1080,
          color: 0xff000000,
          visible: false,
          zIndex: 99,
          Label: {
            mount: 0.5,
            x: 960,
            y: 540,
            text: {
              text: 'Loading..'
            }
          }
        }
      };
    }
    static _states() {
      return [class Loading extends this {
        $enter() {
          this.tag('Loading').visible = true;
        }
        $exit() {
          this.tag('Loading').visible = false;
        }
      }, class Widgets extends this {
        $enter(args, widget) {
          // store widget reference
          this._widget = widget;

          // since it's possible that this behaviour
          // is non-remote driven we force a recalculation
          // of the focuspath
          this._refocus();
        }
        _getFocused() {
          // we delegate focus to selected widget
          // so it can consume remotecontrol presses
          return this._widget;
        }

        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget;
          this._refocus();
        }
        _handleKey() {
          const restoreFocus = routerConfig.get('autoRestoreRemote');
          /**
           * The Router used to delegate focus back to the page instance on
           * every unhandled key. This is barely usefull in any situation
           * so for now we offer the option to explicity turn that behaviour off
           * so we don't don't introduce a breaking change.
           */
          if (!isBoolean(restoreFocus) || restoreFocus === true) {
            Router.focusPage();
          }
        }
      }];
    }

    /**
     * Return location where pages need to be stored
     */
    get pages() {
      return this.tag('Pages');
    }

    /**
     * Tell router where widgets are stored
     */
    get widgets() {
      return this.tag('Widgets');
    }

    /**
     * we MUST register _handleBack method so the Router
     * can override it
     * @private
     */
    _handleBack() {}

    /**
     * We MUST return Router.activePage() so the new Page
     * can listen to the remote-control.
     */
    _getFocused() {
      return Router.getActivePage();
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /*
  rouThor ==[x]
   */
  let navigateQueue = new Map();
  let forcedHash = '';
  let resumeHash = '';

  /**
   * Start routing the app
   * @param config - route config object
   * @param instance - instance of the app
   */
  const startRouter = (config, instance) => {
    bootRouter(config, instance);
    registerListener$1();
    start();
  };

  // start translating url
  const start = () => {
    let hash = (getHash() || '').replace(/^#/, '');
    const bootKey = '$';
    const params = getQueryStringParams(hash);
    const bootRequest = getBootRequest();
    const rootHash = getRootHash();
    const isDirectLoad = hash.indexOf(bootKey) !== -1;

    // prevent direct reload of wildcard routes
    // expect bootComponent
    if (isWildcard.test(hash) && hash !== bootKey) {
      hash = '';
    }

    // store resume point for manual resume
    resumeHash = isDirectLoad ? rootHash : hash || rootHash;
    const ready = () => {
      if (!hash && rootHash) {
        if (isString(rootHash)) {
          navigate(rootHash);
        } else if (isFunction(rootHash)) {
          rootHash().then(res => {
            if (isObject(res)) {
              navigate(res.path, res.params);
            } else {
              navigate(res);
            }
          });
        }
      } else {
        queue(hash);
        handleHashChange().then(() => {
          app._refocus();
        }).catch(e => {
          console.error(e);
        });
      }
    };
    if (routeExists(bootKey)) {
      if (hash && !isDirectLoad) {
        if (!getRouteByHash(hash)) {
          navigate('*', {
            failedHash: hash
          });
          return;
        }
      }
      navigate(bootKey, {
        resume: resumeHash,
        reload: bootKey === hash
      }, false);
    } else if (isFunction(bootRequest)) {
      bootRequest(params).then(() => {
        ready();
      }).catch(e => {
        handleBootError(e);
      });
    } else {
      ready();
    }
  };
  const handleBootError = e => {
    if (routeExists('!')) {
      navigate('!', {
        request: {
          error: e
        }
      });
    } else {
      console.error(e);
    }
  };

  /**
   * start a new request
   * @param url
   * @param args
   * @param store
   */
  const navigate = function (url) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let store = arguments.length > 2 ? arguments[2] : undefined;
    if (isObject(url)) {
      url = getHashByName(url);
      if (!url) {
        return;
      }
    }
    let hash = getHash();
    if (!mustUpdateLocationHash() && forcedHash) {
      hash = forcedHash;
    }
    if (hash.replace(/^#/, '') !== url) {
      // push request in the queue
      queue(url, args, store);
      setHash(url);
      if (!mustUpdateLocationHash()) {
        forcedHash = url;
        handleHashChange(url).then(() => {
          app._refocus();
        }).catch(e => {
          console.error(e);
        });
      }
    } else if (args.reload) {
      // push request in the queue
      queue(url, args, store);
      handleHashChange(url).then(() => {
        app._refocus();
      }).catch(e => {
        console.error(e);
      });
    }
  };
  const queue = function (hash) {
    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let store = arguments.length > 2 ? arguments[2] : undefined;
    hash = cleanHash(hash);
    if (!navigateQueue.has(hash)) {
      for (let request of navigateQueue.values()) {
        request.cancel();
      }
      const request = createRequest(hash, args, store);
      navigateQueue.set(decodeURIComponent(hash), request);
      return request;
    }
    return false;
  };

  /**
   * Handle change of hash
   * @param override
   * @returns {Promise<void>}
   */
  const handleHashChange = async override => {
    const hash = cleanHash(override || getHash());
    const queueId = decodeURIComponent(hash);
    let request = navigateQueue.get(queueId);

    // handle hash updated manually
    if (!request && !navigateQueue.size) {
      request = queue(hash);
    }
    const route = getRouteByHash(hash);
    if (!route) {
      if (routeExists('*')) {
        navigate('*', {
          failedHash: hash
        });
      } else {
        console.error("Unable to navigate to: ".concat(hash));
      }
      return;
    }

    // update current processed request
    request.hash = hash;
    request.route = route;
    let result = await beforeEachRoute(getActiveHash(), request);

    // test if a local hook is configured for the route
    if (result && route.beforeNavigate) {
      result = await route.beforeNavigate(getActiveHash(), request);
    }
    if (isBoolean(result)) {
      // only if resolve value is explicitly true
      // we continue the current route request
      if (result) {
        return resolveHashChange(request);
      }
    } else {
      // if navigation guard didn't return true
      // we cancel the current request
      request.cancel();
      navigateQueue.delete(queueId);
      if (isString(result)) {
        navigate(result);
      } else if (isObject(result)) {
        let store = true;
        if (isBoolean(result.store)) {
          store = result.store;
        }
        navigate(result.path, result.params, store);
      }
    }
  };

  /**
   * Continue processing the hash change if not blocked
   * by global or local hook
   * @param request - {}
   */
  const resolveHashChange = request => {
    const hash = request.hash;
    const route = request.route;
    const queueId = decodeURIComponent(hash);
    // store last requested hash so we can
    // prevent a route that resolved later
    // from displaying itself
    setLastHash(hash);
    if (route.path) {
      const component = getComponent(route.path);
      // if a hook is provided for the current route
      if (isFunction(route.hook)) {
        const urlParams = getValuesFromHash(hash, route.path);
        const params = {};
        for (const key of urlParams.keys()) {
          params[key] = urlParams.get(key);
        }
        route.hook(app, {
          ...params
        });
      }
      // if there is a component attached to the route
      if (component) {
        // force page to root state to prevent shared state issues
        const activePage = getActivePage();
        if (activePage) {
          const keepAlive = keepActivePageAlive(getActiveRoute(), request);
          if (activePage && route.path === getActiveRoute() && !keepAlive) {
            activePage._setState('');
          }
        }
        if (isPage(component)) {
          load(request).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        } else {
          // of the component is not a constructor
          // or a Component instance we can assume
          // that it's a dynamic import
          component().then(contents => {
            return contents.default;
          }).then(module => {
            storeComponent(route.path, module);
            return load(request);
          }).then(() => {
            app._refocus();
            navigateQueue.delete(queueId);
          });
        }
      } else {
        navigateQueue.delete(queueId);
      }
    }
  };

  /**
   * Directional step in history
   * @param level
   */
  const step = function () {
    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (!level || isNaN(level)) {
      return false;
    }
    const history = getHistory();
    // for now we only support negative numbers
    level = Math.abs(level);

    // we can't step back past the amount
    // of history entries
    if (level > history.length) {
      if (isFunction(app._handleAppClose)) {
        return app._handleAppClose();
      }
      return app.application.closeApp();
    } else if (history.length) {
      // for now we only support history back
      const route = history.splice(history.length - level, level)[0];
      // store changed history
      setHistory(history);
      return navigate(route.hash, {
        [symbols.backtrack]: true,
        [symbols.historyState]: route.state
      }, false);
    } else if (routerConfig.get('backtrack')) {
      const hashLastPart = /(\/:?[\w%\s-]+)$/;
      let hash = stripRegex(getHash());
      let floor = getFloor(hash);

      // test if we got deep-linked
      if (floor > 1) {
        while (floor--) {
          // strip of last part
          hash = hash.replace(hashLastPart, '');
          // if we have a configured route
          // we navigate to it
          if (getRouteByHash(hash)) {
            return navigate(hash, {
              [symbols.backtrack]: true
            }, false);
          }
        }
      }
    }
    return false;
  };

  /**
   * Resume Router's page loading process after
   * the BootComponent became visible;
   */
  const resume = () => {
    if (isString(resumeHash)) {
      navigate(resumeHash, false);
      resumeHash = '';
    } else if (isFunction(resumeHash)) {
      resumeHash().then(res => {
        resumeHash = '';
        if (isObject(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    } else {
      console.warn('[Router]: resume() called but no hash found');
    }
  };

  /**
   * Force reload active hash
   */
  const reload = () => {
    if (!isNavigating()) {
      const hash = getActiveHash();
      navigate(hash, {
        reload: true
      }, false);
    }
  };

  /**
   * Query if the Router is still processing a Request
   * @returns {boolean}
   */
  const isNavigating = () => {
    if (navigateQueue.size) {
      let isProcessing = false;
      for (let request of navigateQueue.values()) {
        if (!request.isCancelled) {
          isProcessing = true;
        }
      }
      return isProcessing;
    }
    return false;
  };
  const getResumeHash = () => {
    return resumeHash;
  };

  /**
   * By default we return the location hash
   * @returns {string}
   */
  let getHash = () => {
    return document.location.hash;
  };

  /**
   * Update location hash
   * @param url
   */
  let setHash = url => {
    document.location.hash = url;
  };

  /**
   * This can be called from the platform / bootstrapper to override
   * the default getting and setting of the hash
   * @param config
   */
  const initRouter = config => {
    if (config.getHash) {
      getHash = config.getHash;
    }
    if (config.setHash) {
      setHash = config.setHash;
    }
  };

  /**
   * On hash change we start processing
   */
  const registerListener$1 = () => {
    Registry.addEventListener(window, 'hashchange', async () => {
      if (mustUpdateLocationHash()) {
        try {
          await handleHashChange();
        } catch (e) {
          console.error(e);
        }
      }
    });
  };

  /**
   * Navigate to root hash
   */
  const root = () => {
    const rootHash = getRootHash();
    if (isString(rootHash)) {
      navigate(rootHash);
    } else if (isFunction(rootHash)) {
      rootHash().then(res => {
        if (isObject(res)) {
          navigate(res.path, res.params);
        } else {
          navigate(res);
        }
      });
    }
  };

  // export API
  var Router = {
    startRouter,
    navigate,
    resume,
    step,
    go: step,
    back: step.bind(null, -1),
    activePage: getActivePage,
    getActivePage() {
      // warning
      return getActivePage();
    },
    getActiveRoute,
    getActiveHash,
    focusWidget,
    getActiveWidget,
    restoreFocus,
    isNavigating,
    getHistory,
    setHistory,
    getHistoryState,
    replaceHistoryState,
    getQueryStringParams,
    reload,
    symbols,
    App: RoutedApp,
    // keep backwards compatible
    focusPage: restoreFocus,
    root: root,
    /**
     * Deprecated api methods
     */
    setupRoutes() {
      console.warn('Router: setupRoutes is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    on() {
      console.warn('Router.on() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    before() {
      console.warn('Router.before() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    },
    after() {
      console.warn('Router.after() is deprecated, consolidate your configuration');
      console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration');
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const defaultChannels = [{
    number: 1,
    name: 'Metro News 1',
    description: 'New York Cable News Channel',
    entitled: true,
    program: {
      title: 'The Morning Show',
      description: "New York's best morning show",
      startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(),
      // started 5 minutes ago
      duration: 60 * 30,
      // 30 minutes
      ageRating: 0
    }
  }, {
    number: 2,
    name: 'MTV',
    description: 'Music Television',
    entitled: true,
    program: {
      title: 'Beavis and Butthead',
      description: 'American adult animated sitcom created by Mike Judge',
      startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(),
      // started 20 minutes ago
      duration: 60 * 45,
      // 45 minutes
      ageRating: 18
    }
  }, {
    number: 3,
    name: 'NBC',
    description: 'NBC TV Network',
    entitled: false,
    program: {
      title: 'The Tonight Show Starring Jimmy Fallon',
      description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
      startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(),
      // started 10 minutes ago
      duration: 60 * 60,
      // 1 hour
      ageRating: 10
    }
  }];
  const channels = () => Settings$2.get('platform', 'tv', defaultChannels);
  const randomChannel = () => channels()[~~(channels.length * Math.random())];

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let currentChannel;
  const callbacks = {};
  const emit$3 = function (event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    callbacks[event] && callbacks[event].forEach(cb => {
      cb.apply(null, args);
    });
  };

  // local mock methods
  let methods = {
    getChannel() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        if (currentChannel) {
          const channel = {
            ...currentChannel
          };
          delete channel.program;
          resolve(channel);
        } else {
          reject('No channel found');
        }
      });
    },
    getProgram() {
      if (!currentChannel) currentChannel = randomChannel();
      return new Promise((resolve, reject) => {
        currentChannel.program ? resolve(currentChannel.program) : reject('No program found');
      });
    },
    setChannel(number) {
      return new Promise((resolve, reject) => {
        if (number) {
          const newChannel = channels().find(c => c.number === number);
          if (newChannel) {
            currentChannel = newChannel;
            const channel = {
              ...currentChannel
            };
            delete channel.program;
            emit$3('channelChange', channel);
            resolve(channel);
          } else {
            reject('Channel not found');
          }
        } else {
          reject('No channel number supplied');
        }
      });
    }
  };
  const initTV = config => {
    methods = {};
    if (config.getChannel && typeof config.getChannel === 'function') {
      methods.getChannel = config.getChannel;
    }
    if (config.getProgram && typeof config.getProgram === 'function') {
      methods.getProgram = config.getProgram;
    }
    if (config.setChannel && typeof config.setChannel === 'function') {
      methods.setChannel = config.setChannel;
    }
    if (config.emit && typeof config.emit === 'function') {
      config.emit(emit$3);
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const initPurchase = config => {
    if (config.billingUrl) config.billingUrl;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class PinInput extends t.Component {
    static _template() {
      return {
        w: 120,
        h: 150,
        rect: true,
        color: 0xff949393,
        alpha: 0.5,
        shader: {
          type: t.shaders.RoundedRectangle,
          radius: 10
        },
        Nr: {
          w: w => w,
          y: 24,
          text: {
            text: '',
            textColor: 0xff333333,
            fontSize: 80,
            textAlign: 'center',
            verticalAlign: 'middle'
          }
        }
      };
    }
    set index(v) {
      this.x = v * (120 + 24);
    }
    set nr(v) {
      this._timeout && clearTimeout(this._timeout);
      if (v) {
        this.setSmooth('alpha', 1);
      } else {
        this.setSmooth('alpha', 0.5);
      }
      this.tag('Nr').patch({
        text: {
          text: v && v.toString() || '',
          fontSize: v === '*' ? 120 : 80
        }
      });
      if (v && v !== '*') {
        this._timeout = setTimeout(() => {
          this._timeout = null;
          this.nr = '*';
        }, 750);
      }
    }
  }
  class PinDialog extends t.Component {
    static _template() {
      return {
        zIndex: 1,
        w: w => w,
        h: h => h,
        rect: true,
        color: 0xdd000000,
        alpha: 0.000001,
        Dialog: {
          w: 648,
          h: 320,
          y: h => (h - 320) / 2,
          x: w => (w - 648) / 2,
          rect: true,
          color: 0xdd333333,
          shader: {
            type: t.shaders.RoundedRectangle,
            radius: 10
          },
          Info: {
            y: 24,
            x: 48,
            text: {
              text: 'Please enter your PIN',
              fontSize: 32
            }
          },
          Msg: {
            y: 260,
            x: 48,
            text: {
              text: '',
              fontSize: 28,
              textColor: 0xffffffff
            }
          },
          Code: {
            x: 48,
            y: 96
          }
        }
      };
    }
    _init() {
      const children = [];
      for (let i = 0; i < 4; i++) {
        children.push({
          type: PinInput,
          index: i
        });
      }
      this.tag('Code').children = children;
    }
    get pin() {
      if (!this._pin) this._pin = '';
      return this._pin;
    }
    set pin(v) {
      if (v.length <= 4) {
        const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1);
        v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*');
        for (let i = 0; i < 4; i++) {
          this.tag('Code').children[i].nr = maskedPin[i] || '';
        }
        this._pin = v;
      }
    }
    get msg() {
      if (!this._msg) this._msg = '';
      return this._msg;
    }
    set msg(v) {
      this._timeout && clearTimeout(this._timeout);
      this._msg = v;
      if (this._msg) {
        this.tag('Msg').text = this._msg;
        this.tag('Info').setSmooth('alpha', 0.5);
        this.tag('Code').setSmooth('alpha', 0.5);
      } else {
        this.tag('Msg').text = '';
        this.tag('Info').setSmooth('alpha', 1);
        this.tag('Code').setSmooth('alpha', 1);
      }
      this._timeout = setTimeout(() => {
        this.msg = '';
      }, 2000);
    }
    _firstActive() {
      this.setSmooth('alpha', 1);
    }
    _handleKey(event) {
      if (this.msg) {
        this.msg = false;
      } else {
        const val = parseInt(event.key);
        if (val > -1) {
          this.pin += val;
        }
      }
    }
    _handleBack() {
      if (this.msg) {
        this.msg = false;
      } else {
        if (this.pin.length) {
          this.pin = this.pin.slice(0, this.pin.length - 1);
        } else {
          Pin.hide();
          this.resolve(false);
        }
      }
    }
    _handleEnter() {
      if (this.msg) {
        this.msg = false;
      } else {
        Pin.submit(this.pin).then(val => {
          this.msg = 'Unlocking ...';
          setTimeout(() => {
            Pin.hide();
          }, 1000);
          this.resolve(val);
        }).catch(e => {
          this.msg = e;
          this.reject(e);
        });
      }
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // only used during local development
  let unlocked = false;
  const contextItems = ['purchase', 'parental'];
  let submit = (pin, context) => {
    return new Promise((resolve, reject) => {
      if (pin.toString() === Settings$2.get('platform', 'pin', '0000').toString()) {
        unlocked = true;
        resolve(unlocked);
      } else {
        reject('Incorrect pin');
      }
    });
  };
  let check = context => {
    return new Promise(resolve => {
      resolve(unlocked);
    });
  };
  const initPin = config => {
    if (config.submit && typeof config.submit === 'function') {
      submit = config.submit;
    }
    if (config.check && typeof config.check === 'function') {
      check = config.check;
    }
  };
  let pinDialog = null;
  const contextCheck = context => {
    if (context === undefined) {
      Log.info('Please provide context explicitly');
      return contextItems[0];
    } else if (!contextItems.includes(context)) {
      Log.warn('Incorrect context provided');
      return false;
    }
    return context;
  };

  // Public API
  var Pin = {
    show() {
      return new Promise((resolve, reject) => {
        pinDialog = ApplicationInstance.stage.c({
          ref: 'PinDialog',
          type: PinDialog,
          resolve,
          reject
        });
        ApplicationInstance.childList.a(pinDialog);
        ApplicationInstance.focus = pinDialog;
      });
    },
    hide() {
      ApplicationInstance.focus = null;
      ApplicationInstance.children = ApplicationInstance.children.map(child => child !== pinDialog && child);
      pinDialog = null;
    },
    submit(pin, context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            submit(pin, context).then(resolve).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    },
    unlocked(context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            check(context).then(resolve).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    },
    locked(context) {
      return new Promise((resolve, reject) => {
        try {
          context = contextCheck(context);
          if (context) {
            check(context).then(unlocked => resolve(!!!unlocked)).catch(reject);
          } else {
            reject('Incorrect Context provided');
          }
        } catch (e) {
          reject(e);
        }
      });
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let ApplicationInstance;
  var Launch = ((App, appSettings, platformSettings, appData) => {
    initSettings$2(appSettings, platformSettings);
    initUtils(platformSettings);
    initStorage();
    // Initialize plugins
    if (platformSettings.plugins) {
      platformSettings.plugins.profile && initProfile(platformSettings.plugins.profile);
      platformSettings.plugins.metrics && initMetrics(platformSettings.plugins.metrics);
      platformSettings.plugins.mediaPlayer && initMediaPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.mediaPlayer && initVideoPlayer(platformSettings.plugins.mediaPlayer);
      platformSettings.plugins.ads && initAds(platformSettings.plugins.ads);
      platformSettings.plugins.router && initRouter(platformSettings.plugins.router);
      platformSettings.plugins.tv && initTV(platformSettings.plugins.tv);
      platformSettings.plugins.purchase && initPurchase(platformSettings.plugins.purchase);
      platformSettings.plugins.pin && initPin(platformSettings.plugins.pin);
    }
    const app = Application(App, appData, platformSettings);
    ApplicationInstance = new app(appSettings);
    return ApplicationInstance;
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class VideoTexture extends t.Component {
    static _template() {
      return {
        Video: {
          alpha: 1,
          visible: false,
          pivot: 0.5,
          texture: {
            type: t.textures.StaticTexture,
            options: {}
          }
        }
      };
    }
    set videoEl(v) {
      this._videoEl = v;
    }
    get videoEl() {
      return this._videoEl;
    }
    get videoView() {
      return this.tag('Video');
    }
    get videoTexture() {
      return this.videoView.texture;
    }
    get isVisible() {
      return this.videoView.alpha === 1 && this.videoView.visible === true;
    }
    _init() {
      this._createVideoTexture();
    }
    _createVideoTexture() {
      const stage = this.stage;
      const gl = stage.gl;
      const glTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, glTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.videoTexture.options = {
        source: glTexture,
        w: this.videoEl.width,
        h: this.videoEl.height
      };
      this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision();
      this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision();
    }
    start() {
      const stage = this.stage;
      this._lastTime = 0;
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl;
            const currentTime = new Date().getTime();
            const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality();

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
            const frameCount = getVideoPlaybackQuality ? getVideoPlaybackQuality.totalVideoFrames : this.videoEl.webkitDecodedFrameCount;
            const mustUpdate = frameCount ? this._lastFrame !== frameCount : this._lastTime < currentTime - 30;
            if (mustUpdate) {
              this._lastTime = currentTime;
              this._lastFrame = frameCount;
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl);
                this._lastFrame = this.videoEl.webkitDecodedFrameCount;
                this.videoView.visible = true;
                this.videoTexture.options.w = this.videoEl.width;
                this.videoTexture.options.h = this.videoEl.height;
                const expectedAspectRatio = this.videoView.w / this.videoView.h;
                const realAspectRatio = this.videoEl.width / this.videoEl.height;
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoView.scaleX = realAspectRatio / expectedAspectRatio;
                  this.videoView.scaleY = 1;
                } else {
                  this.videoView.scaleY = expectedAspectRatio / realAspectRatio;
                  this.videoView.scaleX = 1;
                }
              } catch (e) {
                Log.error('texImage2d video', e);
                this.stop();
              }
              this.videoTexture.source.forceRenderUpdate();
            }
          }
        };
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture);
        this._updatingVideoTexture = true;
      }
    }
    stop() {
      const stage = this.stage;
      stage.removeListener('frameStart', this._updateVideoTexture);
      this._updatingVideoTexture = false;
      this.videoView.visible = false;
      if (this.videoTexture.options.source) {
        const gl = stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
    }
    position(top, left) {
      this.videoView.patch({
        smooth: {
          x: left,
          y: top
        }
      });
    }
    size(width, height) {
      this.videoView.patch({
        smooth: {
          w: width,
          h: height
        }
      });
    }
    show() {
      this.videoView.setSmooth('alpha', 1);
    }
    hide() {
      this.videoView.setSmooth('alpha', 0);
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let mediaUrl = url => url;
  let videoEl;
  let videoTexture;
  let metrics;
  let consumer$1;
  let precision = 1;
  let textureMode = false;
  const initVideoPlayer = config => {
    if (config.mediaUrl) {
      mediaUrl = config.mediaUrl;
    }
  };

  // todo: add this in a 'Registry' plugin
  // to be able to always clean this up on app close
  let eventHandlers = {};
  const state$2 = {
    adsEnabled: false,
    playing: false,
    _playingAds: false,
    get playingAds() {
      return this._playingAds;
    },
    set playingAds(val) {
      if (this._playingAds !== val) {
        this._playingAds = val;
        fireOnConsumer$1(val === true ? 'AdStart' : 'AdEnd');
      }
    },
    skipTime: false,
    playAfterSeek: null
  };
  const hooks = {
    play() {
      state$2.playing = true;
    },
    pause() {
      state$2.playing = false;
    },
    seeked() {
      state$2.playAfterSeek === true && videoPlayerPlugin.play();
      state$2.playAfterSeek = null;
    },
    abort() {
      deregisterEventListeners();
    }
  };
  const withPrecision = val => Math.round(precision * val) + 'px';
  const fireOnConsumer$1 = (event, args) => {
    if (consumer$1) {
      consumer$1.fire('$videoPlayer' + event, args, videoEl.currentTime);
      consumer$1.fire('$videoPlayerEvent', event, args, videoEl.currentTime);
    }
  };
  const fireHook = (event, args) => {
    hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args);
  };
  let customLoader = null;
  let customUnloader = null;
  const loader$3 = (url, videoEl, config) => {
    return customLoader && typeof customLoader === 'function' ? customLoader(url, videoEl, config) : new Promise(resolve => {
      url = mediaUrl(url);
      videoEl.setAttribute('src', url);
      videoEl.load();
      resolve();
    });
  };
  const unloader = videoEl => {
    return customUnloader && typeof customUnloader === 'function' ? customUnloader(videoEl) : new Promise(resolve => {
      videoEl.removeAttribute('src');
      videoEl.load();
      resolve();
    });
  };
  const setupVideoTag = () => {
    const videoEls = document.getElementsByTagName('video');
    if (videoEls && videoEls.length) {
      return videoEls[0];
    } else {
      const videoEl = document.createElement('video');
      const platformSettingsWidth = Settings$2.get('platform', 'width') ? Settings$2.get('platform', 'width') : 1920;
      const platformSettingsHeight = Settings$2.get('platform', 'height') ? Settings$2.get('platform', 'height') : 1080;
      videoEl.setAttribute('id', 'video-player');
      videoEl.setAttribute('width', withPrecision(platformSettingsWidth));
      videoEl.setAttribute('height', withPrecision(platformSettingsHeight));
      videoEl.style.position = 'absolute';
      videoEl.style.zIndex = '1';
      videoEl.style.display = 'none';
      videoEl.style.visibility = 'hidden';
      videoEl.style.top = withPrecision(0);
      videoEl.style.left = withPrecision(0);
      videoEl.style.width = withPrecision(platformSettingsWidth);
      videoEl.style.height = withPrecision(platformSettingsHeight);
      document.body.appendChild(videoEl);
      return videoEl;
    }
  };
  const setUpVideoTexture = () => {
    if (!ApplicationInstance.tag('VideoTexture')) {
      const el = ApplicationInstance.stage.c({
        type: VideoTexture,
        ref: 'VideoTexture',
        zIndex: 0,
        videoEl
      });
      ApplicationInstance.childList.addAt(el, 0);
    }
    return ApplicationInstance.tag('VideoTexture');
  };
  const registerEventListeners = () => {
    Log.info('VideoPlayer', 'Registering event listeners');
    Object.keys(events$1).forEach(event => {
      const handler = e => {
        // Fire a metric for each event (if it exists on the metrics object)
        if (metrics && metrics[event] && typeof metrics[event] === 'function') {
          metrics[event]({
            currentTime: videoEl.currentTime
          });
        }
        // fire an internal hook
        fireHook(event, {
          videoElement: videoEl,
          event: e
        });

        // fire the event (with human friendly event name) to the consumer of the VideoPlayer
        fireOnConsumer$1(events$1[event], {
          videoElement: videoEl,
          event: e
        });
      };
      eventHandlers[event] = handler;
      videoEl.addEventListener(event, handler);
    });
  };
  const deregisterEventListeners = () => {
    Log.info('VideoPlayer', 'Deregistering event listeners');
    Object.keys(eventHandlers).forEach(event => {
      videoEl.removeEventListener(event, eventHandlers[event]);
    });
    eventHandlers = {};
  };
  const videoPlayerPlugin = {
    consumer(component) {
      consumer$1 = component;
    },
    loader(loaderFn) {
      customLoader = loaderFn;
    },
    unloader(unloaderFn) {
      customUnloader = unloaderFn;
    },
    position() {
      let top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      videoEl.style.left = withPrecision(left);
      videoEl.style.top = withPrecision(top);
      if (textureMode === true) {
        videoTexture.position(top, left);
      }
    },
    size() {
      let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1920;
      let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1080;
      videoEl.style.width = withPrecision(width);
      videoEl.style.height = withPrecision(height);
      videoEl.width = parseFloat(videoEl.style.width);
      videoEl.height = parseFloat(videoEl.style.height);
      if (textureMode === true) {
        videoTexture.size(width, height);
      }
    },
    area() {
      let top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1920;
      let bottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1080;
      let left = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.position(top, left);
      this.size(right - left, bottom - top);
    },
    open(url) {
      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.canInteract) return;
      metrics = Metrics$1.media(url);
      this.hide();
      deregisterEventListeners();
      if (this.src == url) {
        this.clear().then(this.open(url, config));
      } else {
        const adConfig = {
          enabled: state$2.adsEnabled,
          duration: 300
        };
        if (config.videoId) {
          adConfig.caid = config.videoId;
        }
        Ads.get(adConfig, consumer$1).then(ads => {
          state$2.playingAds = true;
          ads.prerolls().then(() => {
            state$2.playingAds = false;
            loader$3(url, videoEl, config).then(() => {
              registerEventListeners();
              this.show();
              this.play();
            }).catch(e => {
              fireOnConsumer$1('error', {
                videoElement: videoEl,
                event: e
              });
            });
          });
        });
      }
    },
    reload() {
      if (!this.canInteract) return;
      const url = videoEl.getAttribute('src');
      this.close();
      this.open(url);
    },
    close() {
      Ads.cancel();
      if (state$2.playingAds) {
        state$2.playingAds = false;
        Ads.stop();
        // call self in next tick
        setTimeout(() => {
          this.close();
        });
      }
      if (!this.canInteract) return;
      this.clear();
      this.hide();
      deregisterEventListeners();
    },
    clear() {
      if (!this.canInteract) return;
      // pause the video first to disable sound
      this.pause();
      if (textureMode === true) videoTexture.stop();
      return unloader(videoEl).then(() => {
        fireOnConsumer$1('Clear', {
          videoElement: videoEl
        });
      });
    },
    play() {
      if (!this.canInteract) return;
      if (textureMode === true) videoTexture.start();
      executeAsPromise(videoEl.play, null, videoEl).catch(e => {
        fireOnConsumer$1('error', {
          videoElement: videoEl,
          event: e
        });
      });
    },
    pause() {
      if (!this.canInteract) return;
      videoEl.pause();
    },
    playPause() {
      if (!this.canInteract) return;
      this.playing === true ? this.pause() : this.play();
    },
    mute() {
      let muted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (!this.canInteract) return;
      videoEl.muted = muted;
    },
    loop() {
      let looped = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      videoEl.loop = looped;
    },
    seek(time) {
      if (!this.canInteract) return;
      if (!this.src) return;
      // define whether should continue to play after seek is complete (in seeked hook)
      if (state$2.playAfterSeek === null) {
        state$2.playAfterSeek = !!state$2.playing;
      }
      // pause before actually seeking
      this.pause();
      // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
      videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1));
    },
    skip(seconds) {
      if (!this.canInteract) return;
      if (!this.src) return;
      state$2.skipTime = (state$2.skipTime || videoEl.currentTime) + seconds;
      easeExecution(() => {
        this.seek(state$2.skipTime);
        state$2.skipTime = false;
      }, 300);
    },
    show() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.show();
      } else {
        videoEl.style.display = 'block';
        videoEl.style.visibility = 'visible';
      }
    },
    hide() {
      if (!this.canInteract) return;
      if (textureMode === true) {
        videoTexture.hide();
      } else {
        videoEl.style.display = 'none';
        videoEl.style.visibility = 'hidden';
      }
    },
    enableAds() {
      let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      state$2.adsEnabled = enabled;
    },
    /* Public getters */
    get duration() {
      return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration);
    },
    get currentTime() {
      return videoEl && videoEl.currentTime;
    },
    get muted() {
      return videoEl && videoEl.muted;
    },
    get looped() {
      return videoEl && videoEl.loop;
    },
    get src() {
      return videoEl && videoEl.getAttribute('src');
    },
    get playing() {
      return state$2.playing;
    },
    get playingAds() {
      return state$2.playingAds;
    },
    get canInteract() {
      // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
      return state$2.playingAds === false;
    },
    get top() {
      return videoEl && parseFloat(videoEl.style.top);
    },
    get left() {
      return videoEl && parseFloat(videoEl.style.left);
    },
    get bottom() {
      return videoEl && parseFloat(videoEl.style.top - videoEl.style.height);
    },
    get right() {
      return videoEl && parseFloat(videoEl.style.left - videoEl.style.width);
    },
    get width() {
      return videoEl && parseFloat(videoEl.style.width);
    },
    get height() {
      return videoEl && parseFloat(videoEl.style.height);
    },
    get visible() {
      if (textureMode === true) {
        return videoTexture.isVisible;
      } else {
        return videoEl && videoEl.style.display === 'block';
      }
    },
    get adsEnabled() {
      return state$2.adsEnabled;
    },
    // prefixed with underscore to indicate 'semi-private'
    // because it's not recommended to interact directly with the video element
    get _videoEl() {
      return videoEl;
    },
    get _consumer() {
      return consumer$1;
    }
  };
  var VideoPlayer = autoSetupMixin(videoPlayerPlugin, () => {
    precision = ApplicationInstance && ApplicationInstance.stage && ApplicationInstance.stage.getRenderPrecision() || precision;
    videoEl = setupVideoTag();
    textureMode = Settings$2.get('platform', 'textureMode', false);
    if (textureMode === true) {
      videoEl.setAttribute('crossorigin', 'anonymous');
      videoTexture = setUpVideoTexture();
    }
  });

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  let consumer;
  let getAds = () => {
    // todo: enable some default ads during development, maybe from the settings.json
    return Promise.resolve({
      prerolls: [],
      midrolls: [],
      postrolls: []
    });
  };
  const initAds = config => {
    if (config.getAds) {
      getAds = config.getAds;
    }
  };
  const state$1 = {
    active: false
  };
  const playSlot = function () {
    let slot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return slot.reduce((promise, ad) => {
      return promise.then(() => {
        return playAd(ad);
      });
    }, Promise.resolve(null));
  };
  const playAd = ad => {
    return new Promise(resolve => {
      if (state$1.active === false) {
        Log.info('Ad', 'Skipping add due to inactive state');
        return resolve();
      }
      // is it safe to rely on videoplayer plugin already created the video tag?
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.style.display = 'block';
      videoEl.style.visibility = 'visible';
      videoEl.src = mediaUrl(ad.url);
      videoEl.load();
      let timeEvents = null;
      let timeout;
      const cleanup = () => {
        // remove all listeners
        Object.keys(handlers).forEach(handler => videoEl.removeEventListener(handler, handlers[handler]));
        resolve();
      };
      const handlers = {
        play() {
          Log.info('Ad', 'Play ad', ad.url);
          fireOnConsumer('Play', ad);
          sendBeacon(ad.callbacks, 'defaultImpression');
        },
        ended() {
          fireOnConsumer('Ended', ad);
          sendBeacon(ad.callbacks, 'complete');
          cleanup();
        },
        timeupdate() {
          if (!timeEvents && videoEl.duration) {
            // calculate when to fire the time based events (now that duration is known)
            timeEvents = {
              firstQuartile: videoEl.duration / 4,
              midPoint: videoEl.duration / 2,
              thirdQuartile: videoEl.duration / 4 * 3
            };
            Log.info('Ad', 'Calculated quartiles times', {
              timeEvents
            });
          }
          if (timeEvents && timeEvents.firstQuartile && videoEl.currentTime >= timeEvents.firstQuartile) {
            fireOnConsumer('FirstQuartile', ad);
            delete timeEvents.firstQuartile;
            sendBeacon(ad.callbacks, 'firstQuartile');
          }
          if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
            fireOnConsumer('MidPoint', ad);
            delete timeEvents.midPoint;
            sendBeacon(ad.callbacks, 'midPoint');
          }
          if (timeEvents && timeEvents.thirdQuartile && videoEl.currentTime >= timeEvents.thirdQuartile) {
            fireOnConsumer('ThirdQuartile', ad);
            delete timeEvents.thirdQuartile;
            sendBeacon(ad.callbacks, 'thirdQuartile');
          }
        },
        stalled() {
          fireOnConsumer('Stalled', ad);
          timeout = setTimeout(() => {
            cleanup();
          }, 5000); // make timeout configurable
        },

        canplay() {
          timeout && clearTimeout(timeout);
        },
        error() {
          fireOnConsumer('Error', ad);
          cleanup();
        },
        // this doesn't work reliably on sky box, moved logic to timeUpdate event
        // loadedmetadata() {
        //   // calculate when to fire the time based events (now that duration is known)
        //   timeEvents = {
        //     firstQuartile: videoEl.duration / 4,
        //     midPoint: videoEl.duration / 2,
        //     thirdQuartile: (videoEl.duration / 4) * 3,
        //   }
        // },
        abort() {
          cleanup();
        }
        // todo: pause, resume, mute, unmute beacons
      };
      // add all listeners
      Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]));
      videoEl.play();
    });
  };
  const sendBeacon = (callbacks, event) => {
    if (callbacks && callbacks[event]) {
      Log.info('Ad', 'Sending beacon', event, callbacks[event]);
      return callbacks[event].reduce((promise, url) => {
        return promise.then(() => fetch(url)
        // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
        // note: for fetch failed http responses don't throw an Error :)
        .then(response => {
          if (response.status === 200) {
            fireOnConsumer('Beacon' + event + 'Sent');
          } else {
            fireOnConsumer('Beacon' + event + 'Failed' + response.status);
          }
          Promise.resolve(null);
        }).catch(() => {
          Promise.resolve(null);
        }));
      }, Promise.resolve(null));
    } else {
      Log.info('Ad', 'No callback found for ' + event);
    }
  };
  const fireOnConsumer = (event, args) => {
    if (consumer) {
      consumer.fire('$ad' + event, args);
      consumer.fire('$adEvent', event, args);
    }
  };
  var Ads = {
    get(config, videoPlayerConsumer) {
      if (config.enabled === false) {
        return Promise.resolve({
          prerolls() {
            return Promise.resolve();
          }
        });
      }
      consumer = videoPlayerConsumer;
      return new Promise(resolve => {
        Log.info('Ad', 'Starting session');
        getAds(config).then(ads => {
          Log.info('Ad', 'API result', ads);
          resolve({
            prerolls() {
              if (ads.preroll) {
                state$1.active = true;
                fireOnConsumer('PrerollSlotImpression', ads);
                sendBeacon(ads.preroll.callbacks, 'slotImpression');
                return playSlot(ads.preroll.ads).then(() => {
                  fireOnConsumer('PrerollSlotEnd', ads);
                  sendBeacon(ads.preroll.callbacks, 'slotEnd');
                  state$1.active = false;
                });
              }
              return Promise.resolve();
            },
            midrolls() {
              return Promise.resolve();
            },
            postrolls() {
              return Promise.resolve();
            }
          });
        });
      });
    },
    cancel() {
      Log.info('Ad', 'Cancel Ad');
      state$1.active = false;
    },
    stop() {
      Log.info('Ad', 'Stop Ad');
      state$1.active = false;
      // fixme: duplication
      const videoEl = document.getElementsByTagName('video')[0];
      videoEl.pause();
      videoEl.removeAttribute('src');
    }
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2020 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ScaledImageTexture extends t.textures.ImageTexture {
    constructor(stage) {
      super(stage);
      this._scalingOptions = undefined;
    }
    set options(options) {
      this.resizeMode = this._scalingOptions = options;
    }
    _getLookupId() {
      return "".concat(this._src, "-").concat(this._scalingOptions.type, "-").concat(this._scalingOptions.w, "-").concat(this._scalingOptions.h);
    }
    getNonDefaults() {
      const obj = super.getNonDefaults();
      if (this._src) {
        obj.src = this._src;
      }
      return obj;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2023 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  let ws = null;
  if (typeof WebSocket !== 'undefined') {
    ws = WebSocket;
  }
  var ws_1 = ws;
  const requestsQueue = {};
  const listeners$2 = {};
  var requestQueueResolver = data => {
    if (typeof data === 'string') {
      let regex1 = /\\\\x([0-9A-Fa-f]{2})/g;
      let regex2 = /\\x([0-9A-Fa-f]{2})/g;
      data = data.normalize().replace(regex1, '');
      data = data.normalize().replace(regex2, '');
      data = JSON.parse(data);
    }
    if (data.id) {
      const request = requestsQueue[data.id];
      if (request) {
        if ('result' in data) request.resolve(data.result);else request.reject(data.error);
        delete requestsQueue[data.id];
      } else {
        console.log('no pending request found with id ' + data.id);
      }
    }
  };
  var notificationListener = data => {
    if (typeof data === 'string') {
      let regex1 = /\\\\x([0-9A-Fa-f]{2})/g;
      let regex2 = /\\x([0-9A-Fa-f]{2})/g;
      data = data.normalize().replace(regex1, '');
      data = data.normalize().replace(regex2, '');
      data = JSON.parse(data);
    }
    if (!data.id && data.method) {
      const callbacks = listeners$2[data.method];
      if (callbacks && Array.isArray(callbacks) && callbacks.length) {
        callbacks.forEach(callback => {
          callback(data.params);
        });
      }
    }
  };
  const protocol = 'ws://';
  const host = 'localhost';
  const endpoint = '/jsonrpc';
  const port = 80;
  var makeWebsocketAddress = options => {
    return [options && options.protocol || protocol, options && options.host || host, ':' + (options && options.port || port), options && options.endpoint || endpoint, options && options.token ? '?token=' + options.token : null].join('');
  };
  const sockets = {};
  var connect = options => {
    return new Promise((resolve, reject) => {
      const socketAddress = makeWebsocketAddress(options);
      let socket = sockets[socketAddress];
      if (socket && socket.readyState === 1) return resolve(socket);
      if (socket && socket.readyState === 0) {
        const waitForOpen = () => {
          socket.removeEventListener('open', waitForOpen);
          resolve(socket);
        };
        return socket.addEventListener('open', waitForOpen);
      }
      if (socket == null) {
        if (options.debug) {
          console.log('Opening socket to ' + socketAddress);
        }
        socket = new ws_1(socketAddress, options && options.subprotocols || 'notification');
        sockets[socketAddress] = socket;
        socket.addEventListener('message', message => {
          if (options.debug) {
            console.log(' ');
            console.log('API REPONSE:');
            console.log(JSON.stringify(message.data, null, 2));
            console.log(' ');
          }
          requestQueueResolver(message.data);
        });
        socket.addEventListener('message', message => {
          notificationListener(message.data);
        });
        socket.addEventListener('error', () => {
          notificationListener({
            method: 'client.ThunderJS.events.error'
          });
          sockets[socketAddress] = null;
        });
        const handleConnectClosure = event => {
          sockets[socketAddress] = null;
          reject(event);
        };
        socket.addEventListener('close', handleConnectClosure);
        socket.addEventListener('open', () => {
          notificationListener({
            method: 'client.ThunderJS.events.connect'
          });
          socket.removeEventListener('close', handleConnectClosure);
          socket.addEventListener('close', () => {
            notificationListener({
              method: 'client.ThunderJS.events.disconnect'
            });
            sockets[socketAddress] = null;
          });
          resolve(socket);
        });
      } else {
        sockets[socketAddress] = null;
        reject('Socket error');
      }
    });
  };
  var makeBody = (requestId, plugin, method, params, version) => {
    if (params) {
      delete params.version;
      if (params.versionAsParameter) {
        params.version = params.versionAsParameter;
        delete params.versionAsParameter;
      }
    }
    const body = {
      jsonrpc: '2.0',
      id: requestId,
      method: [plugin, version, method].join('.')
    };
    params !== undefined ? body.params = params : null;
    return body;
  };
  var getVersion = (versionsConfig, plugin, params) => {
    const defaultVersion = 1;
    let version;
    if (version = params && params.version) {
      return version;
    }
    return versionsConfig ? versionsConfig[plugin] || versionsConfig.default || defaultVersion : defaultVersion;
  };
  let id$1 = 0;
  var makeId = () => {
    id$1 = id$1 + 1;
    return id$1;
  };
  var execRequest = (options, body) => {
    return connect(options).then(connection => {
      connection.send(JSON.stringify(body));
    });
  };
  var API = options => {
    return {
      request(plugin, method, params) {
        return new Promise((resolve, reject) => {
          const requestId = makeId();
          const version = getVersion(options.versions, plugin, params);
          const body = makeBody(requestId, plugin, method, params, version);
          if (options.debug) {
            console.log(' ');
            console.log('API REQUEST:');
            console.log(JSON.stringify(body, null, 2));
            console.log(' ');
          }
          requestsQueue[requestId] = {
            body,
            resolve,
            reject
          };
          execRequest(options, body).catch(e => {
            reject(e);
          });
        });
      }
    };
  };
  var DeviceInfo = {
    freeRam(params) {
      return this.call('systeminfo', params).then(res => {
        return res.freeram;
      });
    },
    version(params) {
      return this.call('systeminfo', params).then(res => {
        return res.version;
      });
    }
  };
  var plugins = {
    DeviceInfo
  };
  function listener$2(plugin, event, callback, errorCallback) {
    const thunder = this;
    const index = register.call(this, plugin, event, callback, errorCallback);
    return {
      dispose() {
        const listener_id = makeListenerId(plugin, event);
        if (listeners$2[listener_id] === undefined) return;
        listeners$2[listener_id].splice(index, 1);
        if (listeners$2[listener_id].length === 0) {
          unregister.call(thunder, plugin, event, errorCallback);
        }
      }
    };
  }
  const makeListenerId = (plugin, event) => {
    return ['client', plugin, 'events', event].join('.');
  };
  const register = function (plugin, event, callback, errorCallback) {
    const listener_id = makeListenerId(plugin, event);
    if (!listeners$2[listener_id]) {
      listeners$2[listener_id] = [];
      if (plugin !== 'ThunderJS') {
        const method = 'register';
        const request_id = listener_id.split('.').slice(0, -1).join('.');
        const params = {
          event,
          id: request_id
        };
        this.api.request(plugin, method, params).catch(e => {
          if (typeof errorCallback === 'function') errorCallback(e.message);
        });
      }
    }
    listeners$2[listener_id].push(callback);
    return listeners$2[listener_id].length - 1;
  };
  const unregister = function (plugin, event, errorCallback) {
    const listener_id = makeListenerId(plugin, event);
    delete listeners$2[listener_id];
    if (plugin !== 'ThunderJS') {
      const method = 'unregister';
      const request_id = listener_id.split('.').slice(0, -1).join('.');
      const params = {
        event,
        id: request_id
      };
      this.api.request(plugin, method, params).catch(e => {
        if (typeof errorCallback === 'function') errorCallback(e.message);
      });
    }
  };
  var thunderJS$1 = options => {
    if (options.token === undefined && typeof window !== 'undefined' && window.thunder && typeof window.thunder.token === 'function') {
      options.token = window.thunder.token();
    }
    return wrapper({
      ...thunder$m(options),
      ...plugins
    });
  };
  const resolve$1 = (result, args) => {
    if (typeof result !== 'object' || typeof result === 'object' && (!result.then || typeof result.then !== 'function')) {
      result = new Promise((resolve, reject) => {
        result instanceof Error === false ? resolve(result) : reject(result);
      });
    }
    const cb = typeof args[args.length - 1] === 'function' ? args[args.length - 1] : null;
    if (cb) {
      result.then(res => cb(null, res)).catch(err => cb(err));
    } else {
      return result;
    }
  };
  const thunder$m = options => ({
    options,
    api: API(options),
    plugin: false,
    call() {
      const args = [...arguments];
      if (this.plugin) {
        if (args[0] !== this.plugin) {
          args.unshift(this.plugin);
        }
      }
      const plugin = args[0];
      const method = args[1];
      if (typeof this[plugin][method] == 'function') {
        return this[plugin][method](args[2]);
      }
      return this.api.request.apply(this, args);
    },
    registerPlugin(name, plugin) {
      this[name] = wrapper(Object.assign(Object.create(thunder$m), plugin, {
        plugin: name
      }));
    },
    subscribe() {},
    on() {
      const args = [...arguments];
      if (['connect', 'disconnect', 'error'].indexOf(args[0]) !== -1) {
        args.unshift('ThunderJS');
      } else {
        if (this.plugin) {
          if (args[0] !== this.plugin) {
            args.unshift(this.plugin);
          }
        }
      }
      return listener$2.apply(this, args);
    },
    once() {
      console.log('todo ...');
    }
  });
  const wrapper = obj => {
    return new Proxy(obj, {
      get(target, propKey) {
        const prop = target[propKey];
        if (propKey === 'api') {
          return target.api;
        }
        if (typeof prop !== 'undefined') {
          if (typeof prop === 'function') {
            if (['on', 'once', 'subscribe'].indexOf(propKey) > -1) {
              return function () {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return prop.apply(this, args);
              };
            }
            return function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return resolve$1(prop.apply(this, args), args);
            };
          }
          if (typeof prop === 'object') {
            return wrapper(Object.assign(Object.create(thunder$m(target.options)), prop, {
              plugin: propKey
            }));
          }
          return prop;
        } else {
          if (target.plugin === false) {
            return wrapper(Object.assign(Object.create(thunder$m(target.options)), {}, {
              plugin: propKey
            }));
          }
          return function () {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            args.unshift(propKey);
            return target.call.apply(this, args);
          };
        }
      }
    });
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**Color constants */

  const themeOptions = {
    partnerOne: {
      hex: 0xfff58233,
      logo: 'RDKLogo.png',
      background: '0xff000000'
    },
    partnerTwo: {
      hex: 0xff91c848,
      logo: 'RDKLogo.png',
      background: '0xff000000'
    }
  };
  const language$1 = {
    English: {
      id: 'en',
      fontSrc: 'Play/Play-Regular.ttf',
      font: 'Play'
    },
    Spanish: {
      id: 'sp',
      fontSrc: 'Play/Play-Regular.ttf',
      font: 'Play'
    }
  };
  const availableLanguages = ['English', 'Spanish'];
  const availableLanguageCodes = {
    "English": "en-US",
    "Spanish": "es-US"
  };
  var CONFIG = {
    theme: themeOptions['partnerOne'],
    language: localStorage.getItem('Language') != null && availableLanguages.includes(localStorage.getItem('Language')) ? language$1[localStorage.getItem('Language')] : language$1['English']
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Error$1 extends t.Component {
    static _template() {
      return {
        rect: true,
        w: 1920,
        h: 1080,
        color: 0xffb70606,
        InvalidText: {
          x: 960,
          y: 540,
          mount: 0.5,
          text: {
            text: 'Invalid Route',
            textColor: 0xff000000,
            fontFace: CONFIG.language.font,
            fontSize: 70,
            fontStyle: 'bold'
          },
          SubText: {
            y: 80,
            text: {
              text: 'Press OK to return home',
              textColor: 0xffffffff,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              fontStyle: 'bold',
              textAlign: 'center'
            }
          }
        }
      };
    }
    _handleEnter() {
      Router.navigate('menu');
    }
    _focus() {
      console.log('focus error page');
    }

    //   set error(obj) {
    //     const { page, error } = obj
    //     console.log(page, error)

    //     const errorMessage = `
    // error while loading page: ${page.constructor.name}
    // press enter to navigate to home
    // --
    // loaded via hash: ${page[Symbol.for('hash')]}
    // resulted in route: ${page[Symbol.for('route')]}
    // --
    // ${error.toString()}`

    //     this.tag('Label').text = errorMessage
    //   }

    pageTransition() {
      return 'up';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Network {
    constructor() {
      this._events = new Map();
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
      this.callsign = 'org.rdk.Network';
      this.INFO = console.info;
      this.LOG = console.log;
      this.ERR = console.error;
    }

    /**
     * Function to activate network plugin
     */
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this._thunder.on(this.callsign, 'onIPAddressStatusChanged', notification => {
            if (this._events.has('onIPAddressStatusChanged')) {
              this._events.get('onIPAddressStatusChanged')(notification);
            } else {
              this.LOG(this.callsign + "[onIPAddressStatusChanged]: " + notification);
            }
          });
          this._thunder.on(this.callsign, 'onDefaultInterfaceChanged', notification => {
            if (this._events.has('onDefaultInterfaceChanged')) {
              this._events.get('onDefaultInterfaceChanged')(notification);
            } else {
              this.LOG(this.callsign + "[onDefaultInterfaceChanged]: " + notification);
            }
          });
          this._thunder.on(this.callsign, 'onConnectionStatusChanged', notification => {
            if (this._events.has('onConnectionStatusChanged')) {
              this._events.get('onConnectionStatusChanged')(notification);
            } else {
              this.LOG(this.callsign + "[onConnectionStatusChanged]: " + notification);
            }
          });
          this._thunder.on(this.callsign, 'onInterfaceStatusChanged', notification => {
            if (this._events.has('onInterfaceStatusChanged')) {
              this._events.get('onInterfaceStatusChanged')(notification);
            } else {
              this.LOG(this.callsign + "[onInterfaceStatusChanged]: " + notification);
            }
          });
          this._thunder.on(this.callsign, 'onInternetStatusChange', notification => {
            if (this._events.has('onInternetStatusChange')) {
              this._events.get('onInternetStatusChange')(notification);
            } else {
              this.LOG(this.callsign + "[onInternetStatusChange]: " + notification);
            }
          });
          console.log('Activation success');
          resolve(true);
        });
      });
    }

    /**
     *Register events and event listeners.
     * @param {string} eventId
     * @param {function} callback
     *
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to return the IP of the default interface.
     */
    getStbIp() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getStbIp').then(result => {
          this.INFO(this.callsign + "[getStbIp] result: " + JSON.stringify(result));
          if (result.success) {
            resolve(result.ip);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getStbIp] error: " + err);
          reject(err);
        });
      });
    }
    /**
     * Function to return available interfaces.
     */
    getInterfaces() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getInterfaces').then(result => {
          this.INFO(this.callsign + "[getInterfaces] result: " + result);
          if (result.success) {
            resolve(result.interfaces);
          }
        }).catch(err => {
          this.ERR(this.callsign + "[getInterfaces] error: " + err);
          reject(err);
        });
      });
    }

    /**
     * Function to return default interfaces.
     */
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getDefaultInterface').then(result => {
          this.INFO(this.callsign + "[getDefaultInterface] result: " + result);
          if (result.success) {
            resolve(result.interface);
          }
        }).catch(err => {
          this.ERR(this.callsign + "[getDefaultInterface] error: " + err);
          reject(err);
        });
      });
    }
    setDefaultInterface() {
      let interfaceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ETHERNET";
      let persist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setDefaultInterface', {
          "interface": interfaceName,
          "persist": persist
        }).then(result => {
          this.INFO(this.callsign + "[setDefaultInterface] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setDefaultInterface] error: " + err);
          reject(err);
        });
      });
    }
    getSTBIPFamily() {
      let family = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "AF_INET";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getSTBIPFamily', {
          "family": family
        }).then(result => {
          this.INFO(this.callsign + "[getSTBIPFamily] result: " + result);
          if (result.success) {
            resolve(result);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getSTBIPFamily] error: " + err);
          reject(err);
        });
      });
    }

    /**
     * Function to return IP Settings.
     */

    getIPSettings(interfaceName) {
      let ipversion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IPv4";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getIPSettings', {
          "interface": interfaceName,
          "ipversion": ipversion
        }).then(result => {
          this.INFO(this.callsign + "[getIPSettings] result: " + result);
          if (result.success) {
            resolve(result);
          }
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getIPSettings] error: " + err);
          reject(err);
        });
      });
    }
    getNamedEndpoints() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getNamedEndpoints').then(result => {
          this.INFO(this.callsign + "[getNamedEndpoints] result: " + result);
          if (result.success) resolve(result.endpoints);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getNamedEndpoints] error: " + err);
          reject(err);
        });
      });
    }

    /**
     * Function to set IP Settings.
     */

    setIPSettings(IPSettings) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setIPSettings', IPSettings).then(result => {
          this.INFO(this.callsign + "[setIPSettings] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setIPSettings] error: " + err);
          reject(err);
        });
      });
    }
    isConnectedToInternet() {
      let useWeb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return new Promise((resolve, reject) => {
        if (useWeb) {
          let header = new Headers();
          header.append('pragma', 'no-cache');
          header.append('cache-control', 'no-cache');
          fetch("https://example.com/index.html", {
            method: 'GET',
            headers: header
          }).then(res => {
            this.INFO(this.callsign + "[isConnectedToInternet] result: " + res);
            if (res.status >= 200 && res.status <= 300) {
              console.log("Connected to internet");
              resolve(true);
            } else {
              console.log("No Internet Available");
              resolve(false);
            }
          }).catch(err => {
            this.ERR(this.callsign + "[isConnectedToInternet] error: Internet Check failed: No Internet Available." + err);
            resolve(false); //fail of fetch method needs to be considered as no internet
          });
        } else {
          this._thunder.call(this.callsign, 'isConnectedToInternet').then(result => {
            this.INFO(this.callsign + "[isConnectedToInternet] result: " + result);
            if (result.success) resolve(result.connectedToInternet);
            resolve(false);
          }).catch(err => {
            this.ERR(this.callsign + "[isConnectedToInternet] error: " + err);
            reject(err);
          });
        }
      });
    }
    getinternetconnectionstate() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getInternetConnectionState').then(result => {
          this.INFO(this.callsign + "[getinternetconnectionstate] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getinternetconnectionstate] error: " + err);
          reject(err);
        });
      });
    }
    getCaptivePortalURI() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getCaptivePortalURI').then(result => {
          this.INFO(this.callsign + "[getCaptivePortalURI] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getCaptivePortalURI] error: " + err);
          reject(err);
        });
      });
    }
    startConnectivityMonitoring() {
      let intervalInSec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'startConnectivityMonitoring', {
          "interval": intervalInSec
        }).then(result => {
          this.INFO(this.callsign + "[startConnectivityMonitoring] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[startConnectivityMonitoring] error: " + err);
          reject(err);
        });
      });
    }
    stopConnectivityMonitoring() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'stopConnectivityMonitoring').then(result => {
          this.INFO(this.callsign + "[stopConnectivityMonitoring] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[stopConnectivityMonitoring] error: " + err);
          reject(err);
        });
      });
    }
    isInterfaceEnabled() {
      let interfaceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "WIFI";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'isInterfaceEnabled', {
          "interface": interfaceName
        }).then(result => {
          this.INFO(this.callsign + "[isInterfaceEnabled] result: " + result);
          if (result.success) resolve(result.enabled);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[isInterfaceEnabled] error: " + err);
          reject(err);
        });
      });
    }
    ping() {
      let endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "8.8.8.8";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
      let guid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "2c6ff543-d929-4be4-a0d8-9abae2ca7471";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'ping', {
          "endpoint": endpoint,
          "packets": packets,
          "guid": guid
        }).then(result => {
          this.INFO(this.callsign + "[ping] result: " + result);
          if (result.success) resolve(result);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[ping] error: " + err);
          reject(err);
        });
      });
    }
    pingNamedEndpoint() {
      let endpointName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "CMTS";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;
      let guid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "2c6ff543-d929-4be4-a0d8-9abae2ca7471";
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'pingNamedEndpoint', {
          "endpointName": endpointName,
          "packets": packets,
          "guid": guid
        }).then(result => {
          this.INFO(this.callsign + "[pingNamedEndpoint] result: " + result);
          if (result.success) resolve(result);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[pingNamedEndpoint] error: " + err);
          reject(err);
        });
      });
    }
    setInterfaceEnabled(interfaceName) {
      let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      let persist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setInterfaceEnabled', {
          "interface": interfaceName,
          "enabled": enabled,
          "persist": persist
        }).then(result => {
          this.INFO(this.callsign + "[setInterfaceEnabled] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setInterfaceEnabled] error: " + err);
          reject(err);
        });
      });
    }
    getPublicIP() {
      let iface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ETHERNET";
      let ipv6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getPublicIP', {
          "iface": iface,
          "ipv6": ipv6
        }).then(result => {
          this.INFO(this.callsign + "[getPublicIP] result: " + result);
          if (result.success) resolve(result.public_ip);
          resolve(false);
        }).catch(err => {
          this.ERR(this.callsign + "[getPublicIP] error: " + err);
          reject(err);
        });
      });
    }
    setStunEndPoint() {
      let server = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "global.stun.twilio.com";
      let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3478;
      let sync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      let timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
      let cache_timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setStunEndPoint', {
          "server": server,
          "port": port,
          "sync": sync,
          "timeout": timeout,
          "cache_timeout": cache_timeout
        }).then(result => {
          this.INFO(this.callsign + "[setStunEndPoint] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[setStunEndPoint] error: " + err);
          reject(err);
        });
      });
    }
    configurePNI() {
      let disableConnectivityTest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'configurePNI', {
          "disableConnectivityTest": disableConnectivityTest
        }).then(result => {
          this.INFO(this.callsign + "[configurePNI] result: " + result);
          resolve(result.success);
        }).catch(err => {
          this.ERR(this.callsign + "[configurePNI] error: " + err);
          reject(err);
        });
      });
    }
    trace() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'trace', {
          "disableConnectivityTest": disableConnectivityTest
        }).then(result => {
          this.INFO(this.callsign + "[trace] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[trace] error: " + err);
          reject(err);
        });
      });
    }
    traceNamedEndpoint() {
      let endpointName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "CMTS";
      let packets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 15;
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'trace', {
          "endpointName": endpointName,
          "packets": packets
        }).then(result => {
          this.INFO(this.callsign + "[traceNamedEndpoint] result: " + result);
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR(this.callsign + "[traceNamedEndpoint] error: " + err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for HDMI thunder plugin apis.
   */
  class HDMIApi {
    constructor() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
      this._events = new Map();
      this.callsign = 'org.rdk.HdmiInput';

      // Updated as per https://github.com/rdkcentral/ThunderInterfaces/blob/master/interfaces/IPlayerInfo.h: PlaybackResolution
      this.resolution = {
        ResolutionUnknown: [1920, 1080],
        Resolution480: [640, 480],
        Resolution576: [768, 576],
        Resolution720: [1280, 720],
        Resolution1080: [1920, 1080],
        Resolution2160: [3840, 2160]
      };
    }
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          console.log('Activated HdmiInput plugin');
          this._thunder.on(this.callsign, 'onInputStatusChanged', notification => {
            if (this._events.has('onInputStatusChanged')) {
              this._events.get('onInputStatusChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onDevicesChanged', notification => {
            if (this._events.has('onDevicesChanged')) {
              this._events.get('onDevicesChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onSignalChanged', notification => {
            if (this._events.has('onSignalChanged')) {
              this._events.get('onSignalChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'videoStreamInfoUpdate', notification => {
            if (this._events.has('videoStreamInfoUpdate')) {
              this._events.get('videoStreamInfoUpdate')(notification);
            }
          });
          if (result === null) resolve(true);else resolve(false);
        }).catch(err => {
          console.log('Failed to activate HdmiInput plugin', JSON.stringify(err));
          reject(false);
        });
      });
    }
    getHDMIDevices() {
      return new Promise((resolve, reject) => {
        // resolve([{id: 0,locator: "hdmiin://localhost/deviceid/0",connected: true,},{id: 1,locator: "hdmiin://localhost/deviceid/1",connected: false,},{id: 2,locator: "hdmiin://localhost/deviceid/2",connected: true,}]) //#forTesting
        this._thunder.call(this.callsign, 'getHDMIInputDevices').then(result => {
          resolve(result.devices);
        }).catch(err => {
          // reject(err) // #forTesting //make the api reject, instead of resolving empty array
          console.log("getHDMIDevices Error: ", JSON.stringify(err), " resolving empty array");
          resolve([]);
        });
      });
    }
    checkStatus(plugin) {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller.1', 'status@' + plugin).then(res => {
          console.log(JSON.stringify(res));
          resolve(res);
        }).catch(err => {
          console.error(JSON.stringify(err));
          reject(err);
        });
      });
    }
    getDimensions() {
      return new Promise(resolve => {
        // resolve([1920, 1080])//#forTesting
        this._thunder.call('PlayerInfo', 'resolution').then(result => {
          // We need only the Width & Height for rectangle.
          let result1 = result.slice(0, result.indexOf(result.indexOf('I') !== -1 ? 'I' : 'P'));
          resolve(this.resolution[result1]);
        }).catch(err => {
          console.log('Failed to fetch dimensions', err);
          resolve([1920, 1080]);
        });
      });
    }
    setHDMIInput(portDetails) {
      return new Promise(async (resolve, reject) => {
        // resolve(true)//#forTesting
        if (portDetails.connected) {
          this._thunder.call(this.callsign, 'startHdmiInput', {
            portId: portDetails.id
          }).then(async result => {
            const dimension = await this.getDimensions();
            this._thunder.call(this.callsign, 'setVideoRectangle', {
              x: 0,
              y: 0,
              w: dimension[0],
              h: dimension[1]
            });
            resolve(result);
          }).catch(err => {
            reject(err);
          });
        } else {
          reject(false);
        }
      });
    }
    stopHDMIInput() {
      return new Promise((resolve, reject) => {
        // resolve(true)//#forTesting
        this._thunder.call(this.callsign, 'stopHdmiInput').then(result => {
          resolve(result);
        });
      });
    }

    /**
    *Register events and event listeners.
    * @param {string} eventId
    * @param {function} callback
    *
    */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
  }

  var App_launched_via_Netflix_Button = {
  	source_type: 3,
  	iid: "00000001"
  };
  var App_launched_at_suspended_mode_at_power_on = {
  	source_type: 22,
  	iid: "00000002"
  };
  var App_launched_via_DIAL_request = {
  	source_type: 12,
  	iid: "00000003"
  };
  var App_launched_from_EPG_Grid = {
  	source_type: 3,
  	iid: "00000004"
  };
  var App_launched_via_channel_number = {
  	source_type: 3,
  	iid: "00000005"
  };
  var App_launched_from_channel_info_bar = {
  	source_type: 3,
  	iid: "00000006"
  };
  var App_launched_via_channel_surf_option = {
  	source_type: 3,
  	iid: "00000007"
  };
  var App_launched_via_Netflix_Icon_On_The_Apps_Section = {
  	source_type: 3,
  	iid: "00000008"
  };
  var App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page = {
  	source_type: 3,
  	iid: "00000009"
  };
  var NetflixIIDs = {
  	App_launched_via_Netflix_Button: App_launched_via_Netflix_Button,
  	App_launched_at_suspended_mode_at_power_on: App_launched_at_suspended_mode_at_power_on,
  	App_launched_via_DIAL_request: App_launched_via_DIAL_request,
  	App_launched_from_EPG_Grid: App_launched_from_EPG_Grid,
  	App_launched_via_channel_number: App_launched_via_channel_number,
  	App_launched_from_channel_info_bar: App_launched_from_channel_info_bar,
  	App_launched_via_channel_surf_option: App_launched_via_channel_surf_option,
  	App_launched_via_Netflix_Icon_On_The_Apps_Section: App_launched_via_Netflix_Icon_On_The_Apps_Section,
  	App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page: App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  //Payloads, and other keys related to alexa and voiceControl plugin.

  //app/shortcuts identifier and callsign map
  const AlexaLauncherKeyMap = {
    "amzn1.alexa-ask-target.app.70045": {
      "name": "YouTube",
      "callsign": "YouTube",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.50623": {
      "name": "YouTubeTV",
      "callsign": "YouTubeTV",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.09817": {
      "name": "YouTubeKids",
      "callsign": "YouTubeKids",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.58952": {
      "name": "CNN go",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.CNN"
    },
    "amzn1.alexa-ask-target.app.72095": {
      "name": "Prime Video",
      "callsign": "Amazon",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.36377": {
      "name": "Netflix",
      "callsign": "Netflix",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.34908": {
      "name": "XUMO",
      "callsign": "HtmlApp",
      "url": "https://x1box-app.xumo.com/index.html"
    },
    "amzn1.alexa-ask-target.app.94721": {
      "name": "NBCU Peacock",
      "callsign": "Peacock",
      "url": ""
    },
    // TODO: refactor
    "amzn1.alexa-ask-target.app.73751": {
      "name": "Amazon Alexa",
      "callsign": "SmartScreen",
      "url": ""
    },
    // TODO: refactor
    "amzn1.alexa-ask-target.app.32470": {
      "name": "Amazon Music",
      "callsign": "SmartScreen",
      "url": ""
    },
    "amzn1.alexa-ask-target.app.96247": {
      "name": "The Weather Network",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WeatherNetwork"
    },
    "amzn1.alexa-ask-target.app.48144": {
      "name": "Euronews",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Euronews"
    },
    "amzn1.alexa-ask-target.app.54002": {
      "name": "AccuWeather - Weather for Life",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.AccuWeather"
    },
    "amzn1.alexa-ask-target.app.58518": {
      "name": "Al Jazeera",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aljazeera"
    },
    "amzn1.alexa-ask-target.app.41915": {
      "name": "Radioline",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Radioline"
    },
    "amzn1.alexa-ask-target.app.45441": {
      "name": "Wallstreet Journal",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WallStreetJournal"
    },
    "amzn1.alexa-ask-target.app.47328": {
      "name": "Radio by MyTuner",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.appgeneration.mytuner"
    },
    "amzn1.alexa-ask-target.app.79431": {
      "name": "Tastemade TV",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Tastemade"
    },
    "amzn1.alexa-ask-target.app.16283": {
      "name": "Bloomberg TV+",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.bloomberg.metrological.x1"
    },
    "amzn1.alexa-ask-target.app.79143": {
      "name": "Free Games by PlayWorks",
      "callsign": "LightningApp",
      "url": "https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.playworks.pwkids"
    },
    //shortcuts
    "amzn1.alexa-ask-target.shortcut.33122": {
      "name": "Home",
      "route": "menu"
    },
    "amzn1.alexa-ask-target.shortcut.28647": {
      "name": "Apps",
      "route": "apps"
    },
    "amzn1.alexa-ask-target.shortcut.82911": {
      "name": "Audio Output",
      "route": "settings/audio"
    },
    "amzn1.alexa-ask-target.shortcut.68228": {
      "name": "Guide",
      "route": "epg"
    },
    "amzn1.alexa-ask-target.shortcut.07395": {
      "name": "Settings",
      "route": "settings"
    },
    "amzn1.alexa-ask-target.shortcut.94081": {
      "name": "Bluetooth Settings",
      "route": "settings/bluetooth"
    },
    "amzn1.alexa-ask-target.app.30720": {
      "name": "Simple Player",
      "route": "player"
    },
    "amzn1.alexa-ask-target.shortcut.72631": {
      "name": "Language Settings",
      "route": "settings/other/language"
    },
    "amzn1.alexa-ask-target.shortcut.58566": {
      "name": "Network Settings",
      "route": "settings/network"
    },
    "amzn1.alexa-ask-target.shortcut.07345": {
      "name": "Power Settings",
      "route": "settings/other/energy"
    },
    "amzn1.alexa-ask-target.shortcut.12736": {
      "name": "Privacy Settings",
      "route": "settings/other/privacy"
    },
    "amzn1.alexa-ask-target.shortcut.69249": {
      "name": "Reset",
      "route": "settings/advanced/device/factoryReset"
    },
    "amzn1.alexa-ask-target.shortcut.78173": {
      "name": "Resolution Settings",
      "route": "settings/video/resolution"
    },
    "amzn1.alexa-ask-target.shortcut.94631": {
      "name": "Sleep timer",
      "route": "settings/other/timer"
    },
    "amzn1.alexa-ask-target.shortcut.32343": {
      "name": "Sound Settings",
      "route": "settings/audio"
    },
    "amzn1.alexa-ask-target.shortcut.10089": {
      "name": "System Information",
      "route": "settings/advanced/device/info"
    },
    "amzn1.alexa-ask-target.shortcut.01622": {
      "name": "Terms and Policy",
      "route": "settings/other/privacyPolicy"
    }
  };
  const errorPayload = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Alexa",
          "name": "ErrorResponse",
          "messageId": "Unique identifier, preferably a version 4 UUID",
          "correlationToken": "Opaque correlation token that matches the request",
          "payloadVersion": "3"
        },
        "endpoint": {
          "endpointId": "Endpoint ID"
        },
        "payload": {
          "type": "Error type",
          "message": "Error message"
        }
      }
    }
  };
  const VolumePayload = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Speaker",
          "name": "VolumeChanged",
          "messageId": "8912c9cc-a770-4fe9-8bf1-87e01a4a1f0b"
        },
        "payload": {
          "volume": 30,
          "muted": false
        }
      }
    }
  };
  const ApplicationStateReporter = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Alexa.ApplicationStateReporter",
          "name": "ForegroundApplication",
          "value": {
            "foregroundApplication": {
              "id": "amzn1.alexa-ask-target.app.70045",
              "version": "1",
              "type": "vsk",
              "metadata": {
                "categories": ["OTHER"],
                "isVisible": true,
                "isHome": true
              }
            }
          }
        }
      }
    }
  };

  /* state: PLAYING/PAUSED/STOPPED */
  const PlaybackStateReport = {
    "msgPayload": {
      "event": {
        "header": {
          "namespace": "Alexa.PlaybackStateReporter",
          "name": "playbackState",
          "value": {
            "state": "PLAYING"
          }
        }
      }
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class VoiceApi {
    constructor() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._events = new Map();
      this.thunder = thunderJS$1(config);
      this.INFO = function () {};
      this.LOG = function () {};
      this.ERR = console.error;
    }
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: activate.");
        this.thunder.Controller.activate({
          callsign: 'org.rdk.VoiceControl'
        }).then(result => {
          this.thunder.on('org.rdk.VoiceControl', 'onKeywordVerification', notification => {
            this.INFO('VoiceApi: onKeywordVerification ' + JSON.stringify(notification));
            if (this._events.has('onKeywordVerification')) {
              this._events.get('onKeywordVerification')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onServerMessage', notification => {
            this.INFO('VoiceApi: onServerMessage ' + JSON.stringify(notification));
            if (this._events.has('onServerMessage')) {
              this._events.get('onServerMessage')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onSessionBegin', notification => {
            this.INFO('VoiceApi: onSessionBegin ' + JSON.stringify(notification));
            if (this._events.has('onSessionBegin')) {
              this._events.get('onSessionBegin')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onSessionEnd', notification => {
            this.INFO('VoiceApi: onSessionEnd ' + JSON.stringify(notification));
            if (this._events.has('onSessionEnd')) {
              this._events.get('onSessionEnd')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onStreamBegin', notification => {
            this.INFO('VoiceApi: nStreamBegin ' + JSON.stringify(notification));
            if (this._events.has('onStreamBegin')) {
              this._events.get('onStreamBegin')(notification);
            }
          });
          this.thunder.on('org.rdk.VoiceControl', 'onStreamEnd', notification => {
            this.INFO('VoiceApi: onStreamEnd ' + JSON.stringify(notification));
            if (this._events.has('onStreamEnd')) {
              this._events.get('onStreamEnd')(notification);
            }
          });
          resolve(true);
        }).catch(err => {
          this.ERR('VoiceApi: Error Activation ', err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.thunder.Controller.deactivate({
          callsign: 'org.rdk.VoiceControl'
        }).then(res => {
          this.INFO("VoiceApi: deactivated org.rdk.VoiceControl");
          resolve(true);
        }).catch(err => {
          this.ERR('VoiceApi: Error deactivation ', err);
        });
      });
    }
    configureVoice(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: configure params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'configureVoice', params).then(result => {
          this.INFO("VoiceApi: configureVoice: " + JSON.stringify(params) + " result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: configureVoice error:", err);
          resolve(false);
        });
      });
    }
    sendVoiceMessage(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: sendVoiceMessage params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'sendVoiceMessage', params).then(result => {
          this.INFO("VoiceApi: sendVoiceMessage result:", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: sendVoiceMessage error:", err);
          resolve(false);
        });
      });
    }
    setVoiceInit(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: setVoiceInit params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'setVoiceInit', params).then(result => {
          this.INFO("VoiceApi: setVoiceInit result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: setVoiceInit error:", err);
          resolve(false);
        });
      });
    }
    voiceSessionByText(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: voiceSessionByText params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionByText', params).then(result => {
          this.INFO("VoiceApi: voiceSessionByText result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionByText error:", err);
          resolve(false);
        });
      });
    }
    voiceSessionTypes() {
      return new Promise((resolve, reject) => {
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionTypes', params).then(result => {
          this.INFO("VoiceApi: voiceSessionTypes result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionTypes error:", err);
          resolve(false);
        });
      });
    }
    voiceSessionRequest(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: voiceSessionRequest params", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionRequest', params).then(result => {
          this.INFO("VoiceApi: voiceSessionRequest result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionRequest error:", err);
          resolve(false);
        });
      });
    }
    voiceSessionTerminate(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: voiceSessionTerminate params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionTerminate', params).then(result => {
          this.INFO("VoiceApi: voiceSessionTerminate result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionTerminate error:", err);
          resolve(false);
        });
      });
    }
    voiceSessionAudioStreamStart(params) {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: voiceSessionAudioStreamStart params:", params);
        this.thunder.call('org.rdk.VoiceControl', 'voiceSessionAudioStreamStart', params).then(result => {
          this.INFO("VoiceApi: voiceSessionAudioStreamStart : " + JSON.stringify(params) + " result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceSessionAudioStreamStart error:", err);
          resolve(false);
        });
      });
    }
    voiceStatus() {
      return new Promise((resolve, reject) => {
        this.INFO("VoiceApi: voiceStatus");
        this.thunder.call('org.rdk.VoiceControl', 'voiceStatus').then(result => {
          this.INFO("VoiceApi: voiceStatus result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("VoiceApi: voiceStatus error:", err);
          resolve(false);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$j = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const thunder$l = thunderJS$1(config$j);
  let instance$2 = null;
  class AlexaApi extends VoiceApi {
    static get() {
      if (instance$2 == null) {
        instance$2 = new AlexaApi();
      }
      return instance$2;
    }

    /* Can be used to reduce enableSmartScreen() call */
    isSmartScreenActiavated() {
      let appApi = new AppApi();
      appApi.checkStatus('SmartScreen').then(result => {
        console.log("AlexaAPI: isSmartScreenActiavated result-", result);
        switch (result[0].state.toLowerCase()) {
          case "resumed":
          case "activated":
            break;
          default:
            return false;
        }
        return true;
      }).catch(err => {
        console.error("AlexaAPI: isSmartScreenActiavated error-", err);
        return false;
      });
    }
    enableSmartScreen() {
      thunder$l.Controller.activate({
        callsign: 'SmartScreen'
      }).then(res => {
        console.log("AlexaAPI: Activate SmartScreen result: " + res);
      }).catch(err => {
        console.error("AlexaAPI: Activate SmartScreen ERROR!: ", err);
      });
    }
    disableSmartScreen() {
      thunder$l.Controller.deactivate({
        callsign: 'SmartScreen'
      }).then(res => {
        console.log("AlexaAPI: Deactivate SmartScreen result: " + res);
      }).catch(err => {
        console.error("AlexaAPI: Deactivate SmartScreen ERROR!: ", err);
      });
    }
    displaySmartScreenOverlay() {
      let focused = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      let visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      let appApi = new AppApi();
      appApi.zorder("SmartScreen");
      appApi.setOpacity("SmartScreen", opacity);
      appApi.visible("SmartScreen", visible);
      if (focused) {
        appApi.setFocus("SmartScreen");
      }
    }
    reportApplicationState() {
      let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Menu";
      let isRoute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      /* retrieve 'app' matching from AlexaLauncherKeyMap. */
      for (let [key, value] of Object.entries(AlexaLauncherKeyMap)) {
        if (isRoute && value.hasOwnProperty("route") && value.route === app) {
          ApplicationStateReporter.msgPayload.event.header.value.foregroundApplication.id = key;
          if (app.toLowerCase() === "menu") ApplicationStateReporter.msgPayload.event.header.value.foregroundApplication.metadata.isHome = true;
          break;
        } else if (!isRoute && (value.callsign === app || value.url === app)) {
          ApplicationStateReporter.msgPayload.event.header.value.foregroundApplication.id = key;
          ApplicationStateReporter.msgPayload.event.header.value.foregroundApplication.metadata.isHome = false;
          break;
        }
      }
      /* Send the new app state object. */
      console.log("Sending app statereport to Alexa:", ApplicationStateReporter);
      this.sendVoiceMessage(ApplicationStateReporter);
    }
    reportVolumeState() {
      let volumeLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      let muteStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let messageId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      if (volumeLevel != undefined) VolumePayload.msgPayload.event.payload.volume = volumeLevel;
      if (muteStatus != undefined) VolumePayload.msgPayload.event.payload.muted = muteStatus;
      if (messageId != undefined) VolumePayload.msgPayload.event.header.messageId = messageId;
      console.log("Sending volume statereport to Alexa:", VolumePayload);
      this.sendVoiceMessage(VolumePayload);
    }
    updateDeviceLanguageInAlexa(updatedLanguage) {
      let updatedLan = [];
      updatedLan.push(updatedLanguage);
      let payload = {
        "msgPayload": {
          "DeviceSettings": "Set Device Settings",
          "values": {
            "locale": updatedLan
          }
        }
      };
      console.log("Sending language statereport to Alexa:", updatedLan);
      this.sendVoiceMessage(payload);
    }

    //reportDeviceTimeZone(updatedTimeZone) {
    updateDeviceTimeZoneInAlexa(updatedTimeZone) {
      console.log("updateDeviceTimeZoneInAlexa sending :" + updatedTimeZone);
      let payload = {
        "msgPayload": {
          "DeviceSettings": "Set Device Settings",
          "values": {
            "timezone": updatedTimeZone
          }
        }
      };
      this.sendVoiceMessage(payload);
    }
    reportErrorState(directive) {
      let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ENDPOINT_UNREACHABLE";
      let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "ENDPOINT_UNREACHABLE";
      errorPayload.msgPayload.event.payload.type = type;
      errorPayload.msgPayload.event.payload.message = message;
      errorPayload.msgPayload.event.header.correlationToken = directive.header.correlationToken;
      errorPayload.msgPayload.event.header.payloadVersion = directive.header.payloadVersion;
      errorPayload.msgPayload.event.endpoint.endpointId = directive.endpoint.endpointId;
      errorPayload.msgPayload.event.header.messageId = directive.header.messageId;
      console.log("AlexaAPI: reportErrorState payload:", errorPayload);
      this.sendVoiceMessage(errorPayload);
    }
    reportPlaybackState() {
      let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "STOPPED";
      PlaybackStateReport.msgPayload.event.header.value = state;
      console.log("AlexaAPI: reportPlaybackState payload:", PlaybackStateReport);
      this.sendVoiceMessage(PlaybackStateReport);
    }
    getAlexaDeviceSettings() {
      this.sendVoiceMessage({
        "msgPayload": {
          "DeviceSettings": "Get Device Settings"
        }
      });
    }

    /**
     * Function to send voice message.
     */
    resetAVSCredentials() {
      return new Promise(resolve => {
        Storage$1.set("AlexaVoiceAssitantState", "AlexaAuthPending");
        thunder$l.Controller.activate({
          callsign: 'SmartScreen'
        }).then(res => {
          console.log("AlexaAPI: resetAVSCredentials activating SmartScreen instance.");
        }).catch(err => {
          console.error("AlexaAPI: resetAVSCredentials activate SmartScreen ERROR!: ", err);
        });
        this.sendVoiceMessage({
          "msgPayload": {
            "event": "ResetAVS"
          }
        }).then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }

    /**
     * User can opt out Alexa; could be in Auth state or Some generic Alexa Error after Auth completed.
     * Return respective map so that logic can be drawn based on that.
     */
    checkAlexaAuthStatus() {
      if (Storage$1.get("AlexaVoiceAssitantState") === undefined || Storage$1.get("AlexaVoiceAssitantState") === null || Storage$1.get("AlexaVoiceAssitantState") === "AlexaAuthPending") return "AlexaAuthPending"; // Do not handle Alexa Related Errors; only Handle its Auth status.
      else return Storage$1.get("AlexaVoiceAssitantState"); // Return the stored value of AlexaVoiceAssitantState
    }

    setAlexaAuthStatus() {
      let newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Storage$1.set("AlexaVoiceAssitantState", newState);
      if (newState === "AlexaUserDenied") {
        this.configureVoice({
          "enable": false
        });
        /* Free up Smartscreen resources */
        thunder$l.Controller.deactivate({
          callsign: 'SmartScreen'
        }).then(res => {
          console.log("AlexaAPI: deactivated SmartScreen instance.");
        }).catch(err => {
          console.error("AlexaAPI: deactivate SmartScreen ERROR!: ", err);
        });
      } else {
        this.configureVoice({
          "enable": true
        });
      }
      console.warn("setAlexaAuthStatus with ", newState);
    }

    /**
     * To track playback state of Alexa Smartscreen App(AmazonMusic or anything else)
     */
    checkAlexaSmartscreenAudioPlaybackState() {
      if (Storage$1.get("AlexaSmartscreenAudioPlaybackState") === null || Storage$1.get("AlexaSmartscreenAudioPlaybackState") === "null") return "stopped"; // Assume default state.
      else return Storage$1.get("AlexaSmartscreenAudioPlaybackState");
    }
    setAlexaSmartscreenAudioPlaybackState() {
      let newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Storage$1.set("AlexaSmartscreenAudioPlaybackState", newState);
      console.log("setAlexaSmartscreenAudioPlaybackState with ", newState);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$i = {
    host: '127.0.0.1',
    port: 9998,
    default: 1,
    versions: {
      'org.rdk.System': 2
    }
  };
  const thunder$k = thunderJS$1(config$i);

  /**
   * Class that contains functions which commuicates with thunder API's
   */
  class AppApi {
    constructor() {
      this.activatedForeground = false;
      this._events = new Map();
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Bluetooth plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    fetchTimeZone() {
      return new Promise(resolve => {
        thunder$k.call('org.rdk.System', 'getTimeZones').then(result => {
          resolve(result.zoneinfo);
        }).catch(err => {
          console.error('AppAPI Cannot fetch time zone', err);
          resolve({});
        });
      });
    }
    isConnectedToInternet() {
      return new Promise((resolve, reject) => {
        let header = new Headers();
        header.append('pragma', 'no-cache');
        header.append('cache-control', 'no-cache');
        fetch("https://example.com/index.html", {
          method: 'GET',
          headers: header
        }).then(res => {
          if (res.status >= 200 && res.status <= 300) {
            console.log("AppAPI Connected to internet");
            resolve(true);
          } else {
            console.log("AppAPI No Internet Available");
            resolve(false);
          }
        }).catch(err => {
          console.error("AppAPI Internet Check failed: No Internet Available");
          resolve(false); //fail of fetch method needs to be considered as no internet
        });
      });
    }

    fetchApiKey() {
      return new Promise(resolve => {
        thunder$k.call('org.rdk.PersistentStore', 'getValue', {
          namespace: 'gracenote',
          key: 'apiKey'
        }).then(result => {
          resolve(result.value);
        }).catch(err => {
          console.error("AppAPI PersistentStore getValue gracenote apiKey failed.");
          resolve('');
        });
      });
    }

    /**
     * Function to launch Html app.
     * @param {String} url url of app.
     */
    getIP() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'org.rdk.System'
        }).then(() => {
          thunder$k.call('org.rdk.System', 'getDeviceInfo', {
            params: 'estb_ip'
          }).then(result => {
            resolve(result.success);
          }).catch(err => {
            console.error("AppAPI System getDeviceInfo estb_ip failed.");
            resolve(false);
          });
        }).catch(err => {
          console.error("AppAPI activate System failed.");
        });
      });
    }
    /**
    *  Function to get timeZone
    */
    getZone() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getTimeZoneDST').then(result => {
          resolve(result.timeZone);
        }).catch(err => {
          console.error('AppAPI System plugin getTimeZoneDST failed.');
          resolve(undefined);
        });
      });
    }
    setZone(zone) {
      console.log(zone);
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'setTimeZoneDST', {
          timeZone: zone
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error("AppAPI System plugin setTimeZoneDST failed.");
          resolve(false);
        });
      }).catch(err => {});
    }
    getPluginStatus(plugin) {
      return new Promise((resolve, reject) => {
        thunder$k.call('Controller', "status@".concat(plugin)).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI Controller plugin '" + plugin + "' status check failed.");
          reject(err);
        });
      });
    }

    /**
     * Function to get resolution of the display screen.
     */
    getResolution() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getCurrentResolution', {
          "videoDisplay": "HDMI0"
        }).then(result => {
          resolve(result.resolution);
        }).catch(err => {
          console.error("AppAPI DisplaySettings plugin getCurrentResolution failed.");
          resolve('NA');
        });
      });
    }
    activateDisplaySettings() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = "org.rdk.DisplaySettings";
        thunder$k.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {}).catch(err => {
          console.error("AppAPI activate DisplaySettings failed.");
        });
      });
    }
    getSupportedResolutions() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$k.call('org.rdk.DisplaySettings', 'getSupportedResolutions', {
            params: 'HDMI0'
          }).then(result => {
            resolve(result.supportedResolutions);
          }).catch(err => {
            console.error("AppAPI DisplaySettings getSupportedResolutions failed.");
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to set the display resolution.
     */
    setResolution(res) {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$k.call('org.rdk.DisplaySettings', 'setCurrentResolution', {
            videoDisplay: 'HDMI0',
            resolution: res,
            persist: true
          }).then(result => {
            resolve(result.success);
          }).catch(err => {
            console.error("AppAPI DisplaySettings setCurrentResolution failed.");
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get HDCP Status.
     */
    getHDCPStatus() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'org.rdk.HdcpProfile'
        }).then(() => {
          thunder$k.call('org.rdk.HdcpProfile', 'getHDCPStatus').then(result => {
            console.log("AppAPI HdcpProfile getHDCPStatus : " + JSON.stringify(result.HDCPStatus));
            resolve(result.HDCPStatus);
          }).catch(err => {
            console.error("AppAPI HdcpProfile getHDCPStatus failed.");
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate HdcpProfile ', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get TV HDR Support.
     */
    getTvHDRSupport() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$k.call('org.rdk.DisplaySettings', 'getTvHDRSupport').then(result => {
            console.log("AppAPI DisplaySettings getTvHDRSupport : " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get settop box HDR Support.
     */
    getSettopHDRSupport() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'org.rdk.DisplaySettings'
        }).then(() => {
          thunder$k.call('org.rdk.DisplaySettings', 'getSettopHDRSupport').then(result => {
            console.log("AppAPI DisplaySettings getSettopHDRSupport : " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error('AppAPI DisplaySettings getSettopHDRSupport failed ', JSON.stringify(err));
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get HDR Format in use.
     */
    getHDRSetting() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'DisplayInfo'
        }).then(() => {
          thunder$k.call('DisplayInfo', 'hdrsetting').then(result => {
            console.log("AppAPI DisplayInfo hdrsetting : " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error("AppAPI DisplayInfo hdrsetting failed : " + JSON.stringify(err));
            resolve(false);
          });
        }).catch(err => {
          console.log('AppAPI activate DisplayInfo Error', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to get DRMs.
     */
    getDRMS() {
      return new Promise((resolve, reject) => {
        thunder$k.Controller.activate({
          callsign: 'OCDM'
        }).then(() => {
          thunder$k.call('OCDM', 'drms').then(result => {
            console.log("AppAPI OCDM supported drms: " + JSON.stringify(result));
            resolve(result);
          }).catch(err => {
            console.error("AppAPI OCDM drms failed.");
            resolve(false);
          });
        }).catch(err => {
          console.error('AppAPI activate OCDM error:', JSON.stringify(err));
        });
      });
    }

    /**
     * Function to clear cache.
     */
    clearCache() {
      return new Promise((resolve, reject) => {
        thunder$k.call(Storage$1.get("selfClientName"), 'delete', {
          path: ".cache"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI ResidentApp delete cache failed.");
          resolve(err);
        });
      });
    }
    async getAvailableTypes() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RDKShell', 'getAvailableTypes', {}).then(result => {
          // Include NativeApp as well as its not being included from backend.
          if (!result.types.includes("NativeApp")) result.types.push("NativeApp");
          console.log("RDKShell.getAvailableTypes:", JSON.stringify(result));
          resolve(result.types);
        }).catch(err => {
          console.error("AppAPI ResidentApp delete cache failed.", err);
          resolve(false);
        });
      });
    }

    /**
     * Function to launch All types of apps. Accepts 2 params.
     * @param {String} callsign String required callsign of the particular app.
     * @param {Object} args Object optional depending on following properties.
     *  @property {string} url: optional for YouTube & netflix | required for Lightning and WebApps
     *  @property {string} launchLocation: optional | to pass Netflix IIDs or YouTube launch reason | launchLocation value is one among these values ["mainView", "dedicatedButton", "appsMenu", "epgScreen", "dial", "gracenote","alexa"]
     *  @property {boolean} preventInternetCheck: optional | true will prevent bydefault check for internet
     *  @property {boolean} preventCurrentExit: optional |  true will prevent bydefault launch of previous app
     */

    async launchApp(callsign, args) {
      Storage$1.set("appSwitchingInProgress", true);
      const saveAbleRoutes = ["menu", "epg", "apps"]; //routing back will happen to only these routes, otherwise it will default to #menu when exiting the app.
      const lastVisitedRoute = Router.getActiveHash();
      if (saveAbleRoutes.includes(lastVisitedRoute)) {
        Storage$1.set("lastVisitedRoute", lastVisitedRoute);
      } else {
        Storage$1.set("lastVisitedRoute", "menu");
      }
      Router.navigate("applauncher");
      console.log("AppAPI launchApp called with: ", callsign, args);
      if (callsign.startsWith("YouTube")) {
        Storage$1.set(callsign + "LaunchLocation", args.launchLocation);
      }
      let url,
        preventInternetCheck,
        preventCurrentExit,
        launchLocation,
        gracenoteUrl = null;
      if (args) {
        url = args.url;
        preventInternetCheck = args.preventInternetCheck;
        preventCurrentExit = args.preventCurrentExit;
        launchLocation = args.launchLocation;
      }
      const launchLocationKeyMapping = {
        //currently supported launch locations by the UI and mapping to corresponding reason/keys for IID
        "mainView": {
          "YouTube": "menu",
          "YouTubeTV": "menu",
          "YouTubeKids": "menu",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        },
        "dedicatedButton": {
          "YouTube": "remote",
          "YouTubeTV": "remote",
          "YouTubeKids": "remote",
          "Netflix": "App_launched_via_Netflix_Button"
        },
        "appsMenu": {
          "YouTube": "menu",
          "YouTubeTV": "menu",
          "YouTubeKids": "menu",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Section"
        },
        "epgScreen": {
          "YouTube": "guide",
          "YouTubeTV": "guide",
          "YouTubeKids": "guide",
          "Netflix": "App_launched_from_EPG_Grid"
        },
        "dial": {
          "YouTube": "dial",
          "YouTubeTV": "dial",
          "YouTubeKids": "dial",
          "Netflix": "App_launched_via_DIAL_request"
        },
        "gracenote": {
          "YouTube": "launcher",
          "YouTubeTV": "launcher",
          "YouTubeKids": "launcher",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        },
        "alexa": {
          "YouTube": "voice",
          "YouTubeTV": "voice",
          "YouTubeKids": "voice",
          "Netflix": "App_launched_via_Netflix_Icon_On_The_Apps_Row_On_The_Main_Home_Page"
        }
      };
      if (launchLocation && launchLocationKeyMapping[launchLocation]) {
        if (callsign === "Netflix" || callsign.startsWith("YouTube")) {
          /* Gracenote provides shortened url which shall only be deeplinked; do not use for activation. */
          if (launchLocation === "gracenote") {
            gracenoteUrl = url;
          }
          launchLocation = launchLocationKeyMapping[launchLocation][callsign];
        }
      }
      console.log("AppAPI launchApp with callsign: " + callsign + " | url: " + url + " | preventInternetCheck: " + preventInternetCheck + " | preventCurrentExit: " + preventCurrentExit + " | launchLocation: " + launchLocation);
      let IIDqueryString = "";
      if (callsign === "Netflix") {
        let netflixIids = await this.getNetflixIIDs();
        if (launchLocation) {
          IIDqueryString = "source_type=".concat(netflixIids[launchLocation].source_type, "&iid=").concat(netflixIids[launchLocation].iid);
          if (url) {
            IIDqueryString = "&" + IIDqueryString; //so that IIDqueryString can be appended with url later.
          }
        } else {
          console.warn("AppAPI launchLocation(IID) not specified while launching netflix");
        }
      }
      const availableCallsigns = await this.getAvailableTypes();
      if (!availableCallsigns.includes(callsign)) {
        Storage$1.set("appSwitchingInProgress", false);
        Router.navigate(Storage$1.get("lastVisitedRoute"));
        return Promise.reject("Can't launch App: " + callsign + " | Error: callsign not found!");
      }
      if (!preventInternetCheck) {
        let internet = await this.isConnectedToInternet();
        if (!internet) {
          Storage$1.set("appSwitchingInProgress", false);
          Router.navigate(Storage$1.get("lastVisitedRoute"));
          return Promise.reject("No Internet Available, can't launchApp.");
        }
      }
      const currentApp = Storage$1.get("applicationType"); //get it from stack if required. | current app ==="" means residentApp

      let pluginStatus, pluginState; // to check if the plugin is active, resumed, deactivated etc
      try {
        if (callsign != "NativeApp") {
          pluginStatus = await this.getPluginStatus(callsign);
          pluginState = pluginStatus[0].state;
        }
      } catch (err) {
        console.error(err);
        Storage$1.set("appSwitchingInProgress", false);
        Router.navigate(Storage$1.get("lastVisitedRoute"));
        return Promise.reject("AppAPI PluginError: " + callsign + ": App not supported on this device | Error: " + JSON.stringify(err));
      }
      console.log("AppAPI " + callsign + " : pluginStatus: " + JSON.stringify(pluginStatus) + " pluginState: ", JSON.stringify(pluginState));
      if (callsign === "Netflix") {
        if (pluginState === "deactivated" || pluginState === "deactivation") {
          //netflix cold launch scenario
          console.log("AppAPI Netflix : ColdLaunch");
          if (Router.getActivePage().showSplashImage) {
            Router.getActivePage().showSplashImage(callsign); //to make the splash image for netflix visible
          }

          if (url) {
            try {
              console.log("AppAPI Netflix ColdLaunch passing netflix url & IIDqueryString using configureApplication method:  ", url, IIDqueryString);
              await this.configureApplication("Netflix", url + IIDqueryString);
            } catch (err) {
              console.error("AppAPI Netflix configureApplication error: ", err);
            }
          } else {
            try {
              console.log("AppAPI Netflix ColdLaunch passing netflix IIDqueryString using configureApplication method:  ", IIDqueryString);
              await this.configureApplication("Netflix", IIDqueryString);
            } catch (err) {
              console.error("AppAPI Netflix configureApplication error: ", err);
            }
          }
        } else {
          //netflix hot launch scenario
          console.log("AppAPI Netflix : HotLaunch");
          if (url) {
            try {
              console.log("AppAPI Netflix HotLaunch passing netflix url & IIDqueryString using systemcommand method: ", url, IIDqueryString);
              await thunder$k.call("Netflix", "systemcommand", {
                command: url + IIDqueryString
              });
            } catch (err) {
              console.error("AppAPI Netflix systemcommand error: ", err);
            }
          } else {
            try {
              console.log("AppAPI Netflix HotLaunch passing netflix IIDqueryString using systemcommand method: ", IIDqueryString);
              await thunder$k.call("Netflix", "systemcommand", {
                command: IIDqueryString
              });
            } catch (err) {
              console.error("AppAPI Netflix systemcommand error: ", err);
            }
          }
        }
      }
      let params = {
        "callsign": callsign,
        "type": callsign,
        "configuration": {}
      };
      if (url && (callsign === "LightningApp" || callsign === "HtmlApp" || callsign === "NativeApp")) {
        //for lightning/htmlapp url is passed via rdkshell.launch method
        params.uri = url;
      } else if (callsign.startsWith("YouTube")) {
        let language = localStorage.getItem("Language");
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US"; //default to english US if language is not available.
        if (gracenoteUrl === null) {
          url = url ? url : Storage$1.get(callsign + "DefaultURL");
        } else {
          /* Gracenote provided url cannot be used for 'Configuring' plugin. Use only to deeplink. */
          url = Storage$1.get(callsign + "DefaultURL");
        }
        if (url) {
          if (!url.includes("?")) {
            url += "?";
          }
          if (!url.includes("inApp=")) {
            if (!url.endsWith("&")) {
              url += "&";
            }
            url += Storage$1.get("applicationType") === callsign ? "inApp=true" : "inApp=false";
          }
          if (!url.includes("launch=")) {
            if (!url.endsWith("&")) {
              url += "&";
            }
            url += "launch=" + launchLocation;
          }
          if (launchLocation === "voice" && !url.includes("vs=")) {
            if (!url.endsWith("&")) {
              url += "&";
            }
            url += "vs=2"; // YT Dev Doc specific to Alexa
          }

          console.log("AppAPI " + callsign + " is being launched using the url: " + url);
        }
        params.configuration = {
          //for gracenote cold launch url needs to be re formatted to youtube.com/tv/
          "language": language,
          "url": url,
          "launchtype": "launch=" + launchLocation
        };
        params.type = "Cobalt";
      } else if (callsign === "Amazon") {
        let language = localStorage.getItem("Language");
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US";
        params.configuration = {
          "deviceLanguage": language
        };
      } else if (callsign === "Netflix") {
        let language = localStorage.getItem("Language");
        language = availableLanguageCodes[language] ? availableLanguageCodes[language] : "en-US";
        params.configuration = {
          "language": language
        };
      }
      if (!preventCurrentExit && currentApp !== "" && currentApp !== callsign) {
        //currentApp==="" means currently on residentApp | make currentApp = "residentApp" in the cache and stack
        try {
          console.log("AppAPI calling exitApp with params: " + callsign + " and exitInBackground " + currentApp + " true.");
          await this.exitApp(currentApp, true);
        } catch (err) {
          console.error("AppAPI currentApp " + currentApp + " exit failed!: launching new app...");
        }
      }
      if (currentApp === "" && callsign !== "Netflix") {
        //currentApp==="" means currently on residentApp | make currentApp = "residentApp" in the cache and stack | for netflix keep the splash screen visible till it launches
        thunder$k.call('org.rdk.RDKShell', 'setVisibility', {
          "client": "ResidentApp",
          "visible": false
        });
      }
      if (callsign === "Netflix") {
        //special case for netflix to show splash screen
        params.behind = "ResidentApp"; //to make the app launch behind resident app | app will be moved to front after first frame event is triggered
      }

      if (JSON.stringify(params.configuration) === '{}') {
        delete params.configuration;
      }
      console.log("AppAPI RDKShell launch with params: ", params);
      return new Promise((resolve, reject) => {
        if (callsign === "NativeApp") {
          // Could be coming from PartnerApp.
          params.client = callsign;
          params.mimeType = "application/native";
          thunder$k.call("org.rdk.RDKShell", "launchApplication", params).then(res => {
            console.log("AppAPI ".concat(callsign, " : Launch results in ").concat(JSON.stringify(res)));
            if (res.success) {
              if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
                AlexaApi.get().reportApplicationState(callsign);
              }
              if (args.appIdentifier) {
                let order = Storage$1.get("appCarouselOrder");
                if (!order) {
                  Storage$1.set("appCarouselOrder", "");
                } else {
                  let storedApps = order.split(",");
                  let ix = storedApps.indexOf(args.appIdentifier);
                  if (ix != -1) {
                    storedApps.splice(ix, 1);
                  }
                  storedApps.unshift(args.appIdentifier);
                  Storage$1.set("appCarouselOrder", storedApps.toString());
                }
              }
              Storage$1.set("applicationType", callsign);
              Storage$1.set("appSwitchingInProgress", false);
              resolve(res);
            } else {
              console.error("AppAPI failed to launchApp(success false) : ", callsign, " ERROR: ", JSON.stringify(res));
              Storage$1.set("appSwitchingInProgress", false);
              Router.navigate(Storage$1.get("lastVisitedRoute"));
              reject(res);
            }
          }).catch(err => {
            console.error("AppAPI failed to launchApp: ", callsign, " ERROR: ", JSON.stringify(err), " | Launching residentApp back");
            thunder$k.call('org.rdk.RDKShell', 'kill', {
              "client": callsign
            });
            this.launchResidentApp(Storage$1.get("selfClientName"));
            Storage$1.set("appSwitchingInProgress", false);
            Router.navigate(Storage$1.get("lastVisitedRoute"));
            reject(err);
          });
        } else {
          thunder$k.call("org.rdk.RDKShell", "launch", params).then(res => {
            console.log("AppAPI ".concat(callsign, " : Launch results in ").concat(JSON.stringify(res)));
            if (res.success) {
              if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
                if (callsign === "HtmlApp" || callsign === "LightningApp") {
                  AlexaApi.get().reportApplicationState(url);
                } else {
                  AlexaApi.get().reportApplicationState(callsign);
                }
              }
              if (args.appIdentifier) {
                let order = Storage$1.get("appCarouselOrder");
                if (!order) {
                  Storage$1.set("appCarouselOrder", "");
                } else {
                  let storedApps = order.split(",");
                  let ix = storedApps.indexOf(args.appIdentifier);
                  if (ix != -1) {
                    storedApps.splice(ix, 1);
                  }
                  storedApps.unshift(args.appIdentifier);
                  Storage$1.set("appCarouselOrder", storedApps.toString());
                }
              }
              if (callsign !== "Netflix") {
                //if app is not netflix, move it to front(netflix will be moved to front from applauncherScreen.)
                thunder$k.call("org.rdk.RDKShell", "moveToFront", {
                  "client": callsign,
                  "callsign": callsign
                }).catch(err => {
                  console.error("AppAPI failed to moveToFront : ", callsign, " ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
                });
              }
              thunder$k.call("org.rdk.RDKShell", "setFocus", {
                "client": callsign,
                "callsign": callsign
              }).catch(err => {
                console.error("AppAPI failed to setFocus : ", callsign, " ERROR: ", JSON.stringify(err));
              });
              thunder$k.call("org.rdk.RDKShell", "setVisibility", {
                "client": callsign,
                "visible": true
              }).catch(err => {
                console.error("AppAPI failed to setVisibility : ", callsign, " ERROR: ", JSON.stringify(err));
              });
              if (callsign === "Netflix") {
                console.log("AppAPI Netflix launched: hiding residentApp");
                thunder$k.call('org.rdk.RDKShell', 'setVisibility', {
                  "client": "ResidentApp",
                  "visible": false
                }); //if netflix splash screen was launched resident app was kept visible Netflix until app launched.
              }

              if (callsign.startsWith("YouTube") && (res.launchType === "resume" || gracenoteUrl != null)) {
                // Page visibility requirement; 'launch' need to be 'deeplink'ed when app is 'resumed'.
                if (gracenoteUrl != null) {
                  url = gracenoteUrl;
                } else if (!url) {
                  url = params.configuration.url;
                }
                console.log("AppAPI Calling " + callsign + ".deeplink with url: " + url);
                thunder$k.call(callsign, 'deeplink', url);
              }
              Storage$1.set("appSwitchingInProgress", false);
              Storage$1.set("applicationType", callsign);
              resolve(res);
            } else {
              console.error("AppAPI failed to launchApp(success false) : ", callsign, " ERROR: ", JSON.stringify(res));
              Storage$1.set("appSwitchingInProgress", false);
              Router.navigate(Storage$1.get("lastVisitedRoute"));
              reject(res);
            }
          }).catch(err => {
            console.error("AppAPI failed to launchApp: ", callsign, " ERROR: ", JSON.stringify(err), " | Launching residentApp back");

            //destroying the app incase it's stuck in launching | if taking care of ResidentApp as callsign, make sure to prevent destroying it
            thunder$k.call('org.rdk.RDKShell', 'destroy', {
              "callsign": callsign
            });
            this.launchResidentApp(Storage$1.get("selfClientName"));
            Storage$1.set("appSwitchingInProgress", false);
            Router.navigate(Storage$1.get("lastVisitedRoute"));
            reject(err);
          });
        }
      });
    }

    /**
     * Function to launch Exit types of apps.
     * @param {String} callsign callsign of the particular app.
     * @param {boolean} exitInBackground to make the app not bring up residentApp on exit
     * @param {boolean} forceDestroy to force the app to do rdkshell.destroy instead of suspend
     */

    // exit method does not need to launch the previous app.
    async exitApp(callsign, exitInBackground, forceDestroy) {
      //test the new exit app method
      if (callsign === "") {
        //previousApp==="" means it's residentApp | change it to residentApp in cache and here
        return Promise.reject("AppAPI Can't exit from ResidentApp");
      }
      if (callsign === "HDMI") {
        console.log("AppAPI exit method called for hdmi");
        new HDMIApi().stopHDMIInput();
        Storage$1.set("_currentInputMode", {});
        if (!exitInBackground) {
          //means resident App needs to be launched
          this.launchResidentApp(Storage$1.get("selfClientName"));
        }
        return Promise.resolve(true);
        //check for hdmi scenario
      }

      if (callsign === "LightningApp" || callsign === "HtmlApp" || callsign === "Peacock") {
        forceDestroy = true; //html and lightning apps need not be suspended.
      }

      let pluginStatus, pluginState; // to check if the plugin is active, resumed, deactivated etc
      if (callsign != "NativeApp" && !callsign.includes('application/dac.native')) {
        try {
          pluginStatus = await this.getPluginStatus(callsign);
          if (pluginStatus !== undefined) {
            pluginState = pluginStatus[0].state;
            console.log("AppAPI pluginStatus: " + JSON.stringify(pluginStatus) + " pluginState: ", JSON.stringify(pluginState));
          } else {
            return Promise.reject("AppAPI PluginError: " + callsign + ": App not supported on this device");
          }
        } catch (err) {
          return Promise.reject("AppAPI PluginError: " + callsign + ": App not supported on this device | Error: " + JSON.stringify(err));
        }
      }
      if (!exitInBackground) {
        //means resident App needs to be launched
        this.launchResidentApp(Storage$1.get("selfClientName"));
      }

      //to hide the current app
      console.log("AppAPI setting visibility of " + callsign + " to false");
      await thunder$k.call("org.rdk.RDKShell", "setVisibility", {
        "client": callsign,
        "visible": false
      }).catch(err => {
        console.error("AppAPI failed to setVisibility : " + callsign + " ERROR: ", JSON.stringify(err));
      });
      if (forceDestroy) {
        if (pluginState != undefined) {
          // App is a Plugin
          console.log("AppAPI Force Destroying the app: ", callsign);
          await thunder$k.call('org.rdk.RDKShell', 'destroy', {
            "callsign": callsign
          });
          return Promise.resolve(true);
        } else if (callsign === "NativeApp" || callsign.includes('application/dac.native')) {
          await thunder$k.call('org.rdk.RDKShell', 'kill', {
            "client": callsign.includes('application/dac.native') ? callsign.substring(0, callsign.indexOf(';')) : callsign
          }).then(res => {
            console.log("AppAPI RDKShell kill: " + callsign + " RESPONSE: ", JSON.stringify(res));
            return Promise.resolve(true);
          }).catch(err => {
            console.error("AppAPI RDKShell kill: " + callsign + " ERROR: ", JSON.stringify(err));
            return Promise.resolve(false);
          });
        }
      } else {
        console.log("AppAPI Exiting from App: ", callsign, " depending on platform settings enableAppSuspended: ", Settings$2.get("platform", "enableAppSuspended"));
        //enableAppSuspended = true means apps will be suspended by default
        if (Settings$2.get("platform", "enableAppSuspended")) {
          if (pluginState != undefined) {
            // App is a Plugin
            await thunder$k.call('org.rdk.RDKShell', 'suspend', {
              "callsign": callsign
            }).catch(err => {
              console.error("AppAPI Error in suspending app: ", callsign, " | trying to destroy the app");
              thunder$k.call('org.rdk.RDKShell', 'destroy', {
                "callsign": callsign
              });
            });
            return Promise.resolve(true);
          } else if (callsign === "NativeApp" || callsign.includes('application/dac.native')) {
            // DAC Demo WorkAround; TODO: use suspendApplication instead of kill
            await thunder$k.call('org.rdk.RDKShell', 'kill', {
              "client": callsign.includes('application/dac.native') ? callsign.substring(0, callsign.indexOf(';')) : callsign
            }).catch(err => {
              console.error("AppAPI Error in kill app: ", callsign, " | trying to destroy the app");
              thunder$k.call('org.rdk.RDKShell', 'destroy', {
                "callsign": callsign
              });
            });
            return Promise.resolve(true);
          }
        } else {
          await thunder$k.call('org.rdk.RDKShell', 'destroy', {
            "callsign": callsign
          });
          return Promise.resolve(true);
        }
      }
    }

    /**
     * Function to launch ResidentApp explicitly(incase of special scenarios)
     * Prefer using launchApp and exitApp for ALL app launch and exit scenarios.
     */
    async launchResidentApp() {
      let client = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ResidentApp";
      let callsign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ResidentApp";
      console.log("AppAPI launchResidentApp got Called: setting visibility, focus and moving to front the client: " + client);
      await thunder$k.call("org.rdk.RDKShell", "moveToFront", {
        "client": client,
        "callsign": callsign
      }).catch(err => {
        console.error("AppAPI failed to moveToFront : ResidentApp ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
      });
      await thunder$k.call("org.rdk.RDKShell", "setFocus", {
        "client": client,
        "callsign": callsign
      }).catch(err => {
        console.error("AppAPI failed to setFocus : ResidentApp ERROR: ", JSON.stringify(err));
      });
      await thunder$k.call("org.rdk.RDKShell", "setVisibility", {
        "client": client,
        "visible": true
      }).catch(err => {
        console.error("AppAPI failed to setVisibility : ResidentApp ERROR: ", JSON.stringify(err));
      });
      Storage$1.set("applicationType", ""); //since it's residentApp aplication type is "" | change application type to ResidentApp
    }

    async getNetflixIIDs() {
      let defaultIIDs = NetflixIIDs;
      let data = new HomeApi().getPartnerAppsInfo();
      if (!data) {
        return defaultIIDs;
      }
      console.log("AppAPI homedata: ", data);
      try {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("netflix-iid-file-path")) {
          let url = data["netflix-iid-file-path"];
          console.log("AppAPI Netflix : requested to fetch iids from ", url);
          const fetchResponse = await fetch(url);
          const fetchData = await fetchResponse.json();
          return fetchData;
        } else {
          console.log("AppAPI Netflix IID file path not found in conf file, using deffault IIDs");
          return defaultIIDs;
        }
      } catch (err) {
        console.error("AppAPI Error in fetching iid data from specified path, returning defaultIIDs | Error:", err);
        return defaultIIDs;
      }
    }

    /*
     *Function to launch apps in hidden mode
     */
    launchPremiumAppInSuspendMode(childCallsign) {
      return new Promise((resolve, reject) => {
        thunder$k.call("org.rdk.RDKShell", "launch", {
          callsign: childCallsign,
          type: childCallsign,
          suspend: true,
          visible: false,
          focused: false
        }).then(res => {
          if (childCallsign == "Netflix") {
            console.log("AppAPI launchPremiumAppInSuspendMode : launch netflix results in :", res);
          } else {
            console.log("AppAPI launchPremiumAppInSuspendMode : launch amazon results in :", res);
          }
          resolve(true);
        }).catch(err => {
          if (childCallsign == "Netflix") {
            console.error("AppAPI Netflix : error while launching netflix :", err);
          } else {
            console.log("AppAPI Amazon : error while launching amazon :", err);
          }
          reject(false);
        });
      });
    }

    /**
     * Function to launch Netflix/Amazon Prime app.
     */
    launchPremiumApp(childCallsign) {
      return new Promise((resolve, reject) => {
        thunder$k.call("org.rdk.RDKShell", "launch", {
          callsign: childCallsign,
          type: childCallsign,
          visible: true,
          focused: true
        }).then(res => {
          if (childCallsign == "Netflix") {
            console.log("AppAPI launchPremiumApp : launch netflix results in :", res);
          } else {
            console.log("AppAPI launchPremiumApp : launch amazon results in :", res);
          }
          this.setVisibility(childCallsign, true);
          this.zorder(childCallsign);
          Storage$1.set("applicationType", childCallsign);
          console.log("AppAPI launchPremiumApp the current application Type : ", Storage$1.get("applicationType"));
          resolve(true);
        }).catch(err => {
          if (childCallsign == "Netflix") {
            console.error("AppAPI launchPremiumApp : error while launching netflix :", err);
          } else {
            console.error("AppAPI launchPremiumApp : error while launching amazon :", err);
          }
          reject(false);
        });
      });
    }

    /**
     * Function to launch Resident app.
     * @param {String} url url of app.
     */
    launchResident(url, client) {
      return new Promise((resolve, reject) => {
        const childCallsign = client;
        thunder$k.call('org.rdk.RDKShell', 'launch', {
          callsign: childCallsign,
          type: Storage$1.get("selfClientName"),
          uri: url
        }).then(res => {
          console.log("AppAPI launchResident returned: ", JSON.stringify(res));
          resolve(true);
        }).catch(err => {
          console.error('AppAPI launchResident error: ' + JSON.stringify(err));
          reject(false);
        });
      });
    }
    launchOverlay(url, client) {
      return new Promise(resolve => {
        const childCallsign = client;
        thunder$k.call('org.rdk.RDKShell', 'launch', {
          callsign: childCallsign,
          type: Storage$1.get("selfClientName"),
          uri: url
        }).then(res => {
          thunder$k.call('org.rdk.RDKShell', 'moveToFront', {
            client: childCallsign
          });
          console.log("AppAPI launchOverlay : launched overlay : ", JSON.stringify(res));
          resolve(res);
        }).catch(err => {
          console.error("AppAPI launchOverlay : error ", JSON.stringify(err));
          reject(err);
        });
      });
    }

    /**
     * Function to suspend Netflix/Amazon Prime app.
     */
    suspendPremiumApp(appName) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RDKShell', 'suspend', {
          callsign: appName
        }).then(res => {
          resolve(true);
        }).catch(err => {
          console.error("AppAPI suspendPremiumApp error: ", JSON.stringify(err));
          resolve(false);
        });
      });
    }

    /**
     * Function to deactivate html app.
     */
    deactivateWeb() {
      thunder$k.call('org.rdk.RDKShell', 'destroy', {
        callsign: 'HtmlApp'
      });
    }

    /**
     * Function to deactivate cobalt app.
     */
    deactivateCobalt() {
      let instanceName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Cobalt';
      thunder$k.call('org.rdk.RDKShell', 'destroy', {
        callsign: instanceName
      });
    }
    cobaltStateChangeEvent() {
      try {
        thunder$k.on('Controller', 'statechange', notification => {
          if (this._events.has('statechange')) {
            this._events.get('statechange')(notification);
          }
        });
      } catch (e) {
        console.error('AppAPI Failed to register statechange event' + e);
      }
    }

    /**
     * Function to deactivate lightning app.
     */
    deactivateLightning() {
      thunder$k.call('org.rdk.RDKShell', 'destroy', {
        callsign: 'Lightning'
      });
    }

    /**
     * Function to deactivate resident app.
     */
    deactivateResidentApp(client) {
      thunder$k.call('org.rdk.RDKShell', 'destroy', {
        callsign: client
      });
    }

    /**
     * Function to set visibility to client apps.
     * @param {client} client client app.
     * @param {visible} visible value of visibility.
     */
    setVisibility(client, visible) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RDKShell', 'setVisibility', {
          client: client,
          visible: visible
        });
        if (visible) {
          thunder$k.call('org.rdk.RDKShell', 'setFocus', {
            client: client
          }).then(res => {
            resolve(true);
          }).catch(err => {
            console.error('AppAPI Set focus error', JSON.stringify(err));
            reject(false);
          });
        }
      });
    }
    visible(client, visible) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RDKShell', 'setVisibility', {
          client: client,
          visible: visible
        });
      });
    }
    enabledisableinactivityReporting(bool) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RDKShell', 'enableInactivityReporting', {
          "enable": bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI error in getting sound mode:", JSON.stringify(err, 3, null));
          reject(err);
        });
      });
    }
    setInactivityInterval(duration) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RDKShell', 'setInactivityInterval', {
          "interval": duration
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI RDKShell setInactivityInterval error.");
          reject(false);
        });
      });
    }
    zorder(cli) {
      thunder$k.call('org.rdk.RDKShell', 'moveToFront', {
        client: cli,
        callsign: cli
      });
    }
    setFocus(cli) {
      thunder$k.call('org.rdk.RDKShell', 'setFocus', {
        client: cli
      });
    }
    moveToBack(cli) {
      thunder$k.call('org.rdk.RDKShell', 'moveToBack', {
        client: cli
      });
    }
    setOpacity(cli, opacity) {
      thunder$k.call('org.rdk.RDKShell', 'setOpacity', {
        client: cli,
        opacity: opacity
      });
    }

    /**
    * Function to set the configuration of premium apps.
    * @param {appName} Name of the application
    * @param {config_data} config_data configuration data
    */
    configureApplication(appName, config_data) {
      let plugin = 'Controller';
      let method = 'configuration@' + appName;
      return new Promise((resolve, reject) => {
        thunder$k.call(plugin, method).then(res => {
          res.querystring = config_data;
          thunder$k.call(plugin, method, res).then(resp => {
            console.log("AppAPI ".concat(appName, " : updating configuration with object ").concat(res, " results in ").concat(resp));
            resolve(true);
          }).catch(err => {
            reject(err); //resolve(true)
          });
        }).catch(err => {
          reject(err);
        });
      });
    }
    setPowerState(value) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'setPowerState', {
          "powerState": value,
          "standbyReason": "ResidentApp User Requested"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System setPowerState failed: ", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getPowerState() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getPowerState').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getPowerState failed: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    getWakeupReason() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getWakeupReason').then(result => {
          resolve(result);
        }).catch(err => {
          console.log("org.rdk.System: getWakeupReason: Error in getting wake up reason: ", err);
          reject(err);
        });
      });
    }
    enableDisplaySettings() {
      return new Promise((resolve, reject) => {
        thunder$k.call('Controller', 'activate', {
          callsign: 'org.rdk.DisplaySettings'
        }).then(result => {
          console.log('AppAPI activate DisplaySettings success.');
          resolve(result);
        }).catch(err => {
          console.error('AppAPI activate DisplaySettings error: ', JSON.stringify(err));
          reject(err);
        });
      });
    }
    getSoundMode() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getSoundMode', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getSoundMode error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    setSoundMode(mode) {
      mode = mode.startsWith("AUTO") ? "AUTO" : mode;
      console.log("mode", mode);
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'setSoundMode', {
          "audioPort": "HDMI0",
          "soundMode": mode,
          "persist": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setSoundMode error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getSupportedAudioModes() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getSupportedAudioModes', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getSupportedAudioModes error:", JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }

    //Enable or disable the specified audio port based on the input audio port ID.
    setEnableAudioPort(port) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'setEnableAudioPort', {
          "audioPort": port,
          "enable": true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setEnableAudioPort error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getDRCMode() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getDRCMode', {
          "audioPort": "HDMI0"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getDRCMode error:", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    setDRCMode(DRCNum) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'setDRCMode', {
          "DRCMode": DRCNum
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setDRCMode error:", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getZoomSetting() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getZoomSetting').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getZoomSetting error:", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    setZoomSetting(zoom) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'setZoomSetting', {
          "zoomSetting": zoom
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings setZoomSetting error:", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getEnableAudioPort(audioPort) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getEnableAudioPort', {
          "audioPort": audioPort
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getEnableAudioPort error:", JSON.stringify(err));
          resolve(false);
        });
      });
    }
    getSupportedAudioPorts() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getSupportedAudioPorts').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI DisplaySettings getSupportedAudioPorts error:", JSON.stringify(err));
          resolve(false);
        });
      });
    }

    //________________________________________________________________________________________________________________________

    //OTHER SETTINGS PAGE API

    //1. UI VOICE

    //Start a speech
    ttsSpeak() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.TextToSpeech', 'speak', {
          "text": "speech_1"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech speak error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Resume a speech
    ttsResume() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.TextToSpeech', 'resume', {
          "speechid": 1
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech resume error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Pause a speech
    ttsPause() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.TextToSpeech', 'pause', {
          "speechid": 1
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech pause error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 2. TTS Options
    ttsGetListVoices() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.TextToSpeech', 'listvoices', {
          "language": "en-US"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI TextToSpeech listvoices error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 3. Sync Location
    syncLocation() {
      return new Promise((resolve, reject) => {
        thunder$k.call('LocationSync', 'sync').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI LocationSync sync error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getLocation() {
      return new Promise((resolve, reject) => {
        thunder$k.call('LocationSync', 'location').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI LocationSync location error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    // 4. Check for Firmware Update

    //Get Firmware Update Info
    getFirmwareUpdateInfo() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getFirmwareUpdateInfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getFirmwareUpdateInfo error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // Get Firmware Update State
    getFirmwareUpdateState() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getFirmwareUpdateState').then(result => {
          resolve(result);
        }).catch(err => {
          console.error(" AppAPI System getFirmwareUpdateState error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // Get Firmware download info
    getDownloadFirmwareInfo() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getDownloadedFirmwareInfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getDownloadedFirmwareInfo error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getModelName() {
      return new Promise((resolve, reject) => {
        thunder$k.call('DeviceInfo', 'modelname').then(result => {
          resolve(result.model);
        }).catch(err => {
          console.error("AppAPI DeviceInfo modelname failed:", err);
          resolve("RDK-VA");
        });
      });
    }
    getSerialNumber() {
      return new Promise((resolve, reject) => {
        thunder$k.call('DeviceInfo', 'serialnumber').then(result => {
          resolve(result.serialnumber);
        }).catch(err => {
          console.error("AppAPI DeviceInfo serialnumber error:", JSON.stringify(err, 3, null));
          resolve('0123456789');
        });
      });
    }

    //Get system versions
    getSystemVersions() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getSystemVersions').then(result => {
          console.log(JSON.stringify(result, 3, null));
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System getSystemVersions error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Update firmware
    updateFirmware() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'updateFirmware').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI System updateFirmware error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //Get download percentage
    getFirmwareDownloadPercent() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getFirmwareDownloadPercent').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getFirmwareDownloadPercent error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // device Identification
    getDeviceIdentification() {
      return new Promise((resolve, reject) => {
        thunder$k.call('DeviceIdentification', 'deviceidentification').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getDeviceIdentification error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 5. Device Info
    systeminfo() {
      return new Promise((resolve, reject) => {
        thunder$k.call('DeviceInfo', 'systeminfo').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI systeminfo error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    deviceType() {
      return new Promise((resolve, reject) => {
        thunder$k.call('DeviceInfo', 'devicetype').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI devicetype error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // 6. Reboot
    reboot() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'reboot', {
          "rebootReason": "FIRMWARE_FAILURE"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI reboot error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getNetflixESN() {
      return new Promise(resolve => {
        thunder$k.call('Netflix', 'esn').then(res => {
          resolve(res);
        });
      });
    }

    // get prefered standby mode
    getPreferredStandbyMode() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getPreferredStandbyMode').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getPreferredStandbyMode error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    setPreferredStandbyMode(standbyMode) {
      console.log("setPreferredStandbyMode called : " + standbyMode);
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'setPreferredStandbyMode', {
          "standbyMode": standbyMode
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI setPreferredStandbyMode error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    getNetworkStandbyMode() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getNetworkStandbyMode').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getNetworkStandbyMode error:", JSON.stringify(err, 3, null));
          reject(err);
        });
      });
    }
    getRFCConfig(rfcParamsList) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'getRFCConfig', rfcParamsList).then(result => {
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          console.error("AppAPI getRFCConfig error:", JSON.stringify(err, 3, null));
          reject(err);
        });
      });
    }
    setNetworkStandbyMode() {
      let nwStandby = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'setNetworkStandbyMode', {
          nwStandby: nwStandby
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error("AppAPI setNetworkStandbyMode error:", JSON.stringify(err, 3, null));
          reject(err);
        });
      });
    }
    setWakeupSrcConfiguration(params) {
      console.log("AppAPI: setWakeupSrcConfiguration params:", JSON.stringify(params));
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.System', 'setWakeupSrcConfiguration', params).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error("AppAPI setWakeupSrcConfiguration error:", JSON.stringify(err, 3, null));
          reject(err);
        });
      });
    }
    registerChangeLocation() {
      thunder$k.call('Controller', 'activate', {
        callsign: "LocationSync"
      }).then(result => {
        thunder$k.on("LocationSync", "locationchange", notification => {
          console.log("AppAPI locationchange notification :", notification);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    async sendAppState(value) {
      const state = await thunder$k.call('org.rdk.RDKShell', 'getState', {}).then(result => result.state);
      this.state = state;
      let params = {
        applicationName: value,
        state: 'stopped'
      };
      for (let i = 0; i < state.length; i++) {
        if (state[i].callsign == value) {
          if (state[i].state == 'resumed') {
            params.state = 'running';
          } else if (state[i].state == 'suspended') {
            params.state = 'suspended';
          } else {
            params.state = 'stopped';
          }
        }
      }
      await thunder$k.call('org.rdk.Xcast', 'onApplicationStateChanged', params).then(result => result.success);
    }
    //NETWORK INFO APIS

    //1. Get IP Setting
    getIPSetting(defaultInterface) {
      let ipversion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IPv4";
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Network', 'getIPSettings', {
          "interface": defaultInterface,
          "ipversion": ipversion
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getIPSetting error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //2. Get default interface
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Network', 'getDefaultInterface').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getDefaultInterface error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //3. Is interface enabled
    isInterfaceEnabled() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Network', 'isInterfaceEnabled', {
          "interface": "WIFI"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI isInterfaceEnabled error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //4. Get interfaces
    getInterfaces() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Network', 'getInterfaces').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getInterfaces error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    //5. getConnectedSSID
    getConnectedSSID() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Wifi', 'getConnectedSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getConnectedSSID error:", JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }

    // Volume Apis
    getConnectedAudioPorts() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getConnectedAudioPorts', {}).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI getConnectedAudioPorts error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    getVolumeLevel(port) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getVolumeLevel', {
          audioPort: port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI getVolumeLevel error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    getMuted(port) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getMuted', {
          audioPort: port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI getMuted error:', JSON.stringify(err, 3, null));
          reject(false);
        });
      });
    }
    setVolumeLevel(port, volume) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'setVolumeLevel', {
          audioPort: port,
          volumeLevel: volume
        }).then(result => {
          console.log("AppAPI setVolumeLevel :", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.error('AppAPI setVolumeLevel error:', JSON.stringify(err));
          resolve(false);
        });
      });
    }
    audio_mute(audio_source, value) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'setMuted', {
          audioPort: audio_source,
          muted: value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('AppAPI audio_mute setMuted error:', JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    //created only to get the required params
    getPluginStatusParams(plugin) {
      return new Promise((resolve, reject) => {
        thunder$k.call('Controller', "status@".concat(plugin)).then(result => {
          console.log("pluginstatus", result);
          let pluginParams = [result[0].callsign, result[0].state];
          resolve(pluginParams);
        }).catch(err => {
          console.error("AppAPI getPluginStatusParams error: ", err);
          reject(err);
        });
      });
    }
    //activate autopairing for stack
    activateAutoPairing() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.RemoteControl', 'startPairing', {
          "netType": '1',
          "timeout": '30'
        }).then(result => {
          console.log("AppAPI activateAutoPairing: ", result);
          resolve(result);
        }).catch(err => {
          console.error('AppAPI activateAutoPairing error:', JSON.stringify(err, 3, null));
          resolve(false);
        });
      });
    }
    resetBassEnhancer(port) {
      console.log("portname", port);
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'resetBassEnhancer', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetBassEnhancer error: ", err);
          resolve(false);
        });
      });
    }
    resetDialogEnhancement(port) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'resetDialogEnhancement', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetDialogEnhancement error:", err);
          resolve(false);
        });
      });
    }
    //resetSurroundVirtualizer
    resetSurroundVirtualizer(port) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'resetSurroundVirtualizer', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetSoundVitualizer error:", err);
          resolve(false);
        });
      });
    }
    //resetVolumeLeveller
    resetVolumeLeveller(port) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'resetVolumeLeveller', {
          "audioPort": port
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetvolumeLevel error:", err);
          resolve(false);
        });
      });
    }
    flushcache() {
      return new Promise(resolve => {
        thunder$k.call('org.rdk.PersistentStore', 'flushCache').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI flushCache error:", err);
          resolve(false);
        });
      });
    }
    //resetInactivityTime
    resetInactivityTime() {
      return new Promise(resolve => {
        thunder$k.call('org.rdk.RDKShell', 'resetInactivityTime').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetInactivityTime error:", err);
          resolve(false);
        });
      });
    }

    //clearLastDeepSleepReason
    clearLastDeepSleepReason() {
      return new Promise(resolve => {
        thunder$k.call('org.rdk.System', 'clearLastDeepSleepReason').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI clearLastDeepSleepReason error:", err);
          resolve(false);
        });
      });
    }
    getSupportedAudioPorts() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DisplaySettings', 'getSupportedAudioPorts').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getSupportedAudioPorts error:", err);
          resolve(false);
        });
      });
    }
    monitorStatus(callsign) {
      return new Promise((resolve, reject) => {
        thunder$k.call('Monitor', 'resetstats', {
          "callsign": callsign
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI monitorStatus error:", err);
          resolve(false);
        });
      });
    }

    // warehouse api's
    internalReset() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Warehouse', 'internalReset', {
          "passPhrase": "FOR TEST PURPOSES ONLY"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI interalReset error:", err);
          resolve(false);
        });
      });
    }
    isClean() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Warehouse', 'isClean').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI isClean error:", err);
          resolve(false);
        });
      });
    }
    lightReset() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Warehouse', 'lightReset').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI lightReset error:", err);
          resolve(false);
        });
      });
    }
    resetDevice() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.Warehouse', 'resetDevice', {
          "suppressReboot": false,
          "resetType": "USERFACTORY"
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI resetDevice error:", err);
          resolve(false);
        });
      });
    }

    //{ path: ".cache" }
    deletecache(systemcCallsign, path) {
      return new Promise((resolve, reject) => {
        thunder$k.call(systemcCallsign, 'delete', {
          path: path
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI deletecache error:", err);
          resolve(false);
        });
      });
    }

    // activate controller plugin
    activateController(callsign) {
      return new Promise((resolve, reject) => {
        thunder$k.call('Controller', 'activate', {
          callsign: callsign
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI activateController error:", err);
          resolve(false);
        });
      });
    }
    checkStatus(plugin) {
      return new Promise((resolve, reject) => {
        thunder$k.call('Controller', 'status@' + plugin).then(res => {
          //console.log("AppAPI checkStatus ", JSON.stringify(res))
          resolve(res);
        }).catch(err => {
          console.error("AppAPI checkStatus error:", err);
          resolve(false);
        });
      });
    }
    configStatus() {
      //controller.1.configuration
      return new Promise((resolve, reject) => {
        thunder$k.call('Controller', 'status').then(res => {
          //console.log("AppAPI configStatus ",JSON.stringify(res))
          resolve(res);
        }).catch(err => {
          console.error("AppAPI configStatus error:", err);
          resolve(false);
        });
      });
    }
    getAvCodeStatus() {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.DeviceDiagnostics', 'getAVDecoderStatus').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("AppAPI getAvCodeStatus error:", err);
          resolve(false);
        });
      });
    }
    SaveTimerValue(value1) {
      console.log("persistenceSt", value1);
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.PersistentStore', 'setValue', {
          namespace: "ScreenSaverTime",
          key: "timerValue",
          value: value1
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('AppAPI SaveTimerValue ScreenSaverTime failed:', err);
          reject();
        });
      });
    }
    getTimerValue() {
      return new Promise(resolve => {
        thunder$k.call('org.rdk.PersistentStore', 'getValue', {
          namespace: 'ScreenSaverTime',
          key: 'timerValue'
        }).then(result => {
          resolve(result.value);
        }).catch(err => {
          resolve('');
        });
      });
    }
    setUILanguage(updatedLanguage) {
      return new Promise((resolve, reject) => {
        thunder$k.call('org.rdk.UserPreferences', 'setUILanguage', {
          "ui_language": updatedLanguage
        }).then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }
    deeplinkToApp() {
      let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      let payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      let launchLocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "voice";
      let namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
      if (app === undefined || app === "" || payload == undefined) {
        console.error("AppApi: deeplinkToApp '" + app + "' not possible with payload '" + payload + "'.");
        resolve(false);
      } else if (app.startsWith("YouTube")) {
        let url = Storage$1.get(app + "DefaultURL").toString();
        url = url.substring(0, url.indexOf('?'));
        if (!url.endsWith("?")) url += "?";
        url += Storage$1.get("applicationType") === app ? "inApp=true" : "inApp=false";
        // For the timebeing Alexa alone. Revisit when we have other voice sysyems.
        url += "&launch=voice" + "&vs=" + (launchLocation === "alexa" ? 2 : 0);
        if (namespace === "ExternalMediaPlayer") {
          // Received sample : {"payload":{"playbackContextToken":"{deeplinkMethodType=PLAY, searchString='cat videos'}"}}
          url += "&va=" + (payload.playbackContextToken.includes("deeplinkMethodType=PLAY") ? "play" : "search");
          if (payload.playbackContextToken.includes("deeplinkMethodType")) {
            let searchString = payload.playbackContextToken.replace(/[{}]/g, '').split(',');
            for (let i = 0; i < searchString.length; i++) {
              if (searchString[i].includes("searchString")) {
                let data = searchString[i].split('=').slice(1)[0].replace(/\'/g, '');
                url += "&vaa=" + encodeURI(data.trim());
                break;
              }
            }
          }
        } else if (namespace === "Alexa.SeekController") {
          let time = payload.deltaPositionMilliseconds / 1000;
          let minutes = Math.abs(parseInt(time / 60));
          let seconds = Math.abs(parseInt(time % 60));
          url += "&va=" + (time < 0 ? "mediaRewind" : "mediaFastForward") + "&vaa=" + minutes + "m" + seconds + "s";
        } else if (namespace === "Alexa.PlaybackController") {
          let playbackOperations = new Set(["Play", "Pause", "FastForward", "Rewind", "Shuffle", "Repeat"]);
          if (playbackOperations.has(payload)) {
            url += "&va=media" + payload;
          } else if (payload === "Next" || payload === "Previous") {
            url += "&va=media" + payload + "Video";
          }
        }
        console.info("AppApi: deeplinkToApp " + app + " url - " + url);
        thunder$k.call(app, 'deeplink', url);
      } else if (app === "Amazon") {
        // TODO: no deeplink format support.
        console.error("AppApi: deeplinkToApp '" + app + "' not supported.");
        resolve(false);
      } else if (app === "Netflix") {
        // TODO: no deeplink format support.
        console.error("AppApi: deeplinkToApp '" + app + "' not supported.");
        resolve(false);
      } else {
        console.error("AppApi: deeplinkToApp '" + app + "' not supported.");
        resolve(false);
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var appListInfo = [{
    displayName: 'USB',
    applicationType: '',
    uri: 'USB',
    url: '/images/usb/USB_Featured_Item.jpg',
    appIdentifier: 'n:0'
  }, {
    displayName: 'Netflix',
    applicationType: 'Netflix',
    uri: '',
    url: '/images/apps/App_Netflix_454x255.png',
    appIdentifier: 'n:1'
  }, {
    displayName: 'Amazon Prime video',
    applicationType: 'Amazon',
    uri: '',
    url: '/images/apps/App_Amazon_Prime_454x255.png',
    appIdentifier: 'n:2'
  }, {
    displayName: 'YouTube',
    applicationType: 'YouTube',
    uri: 'https://www.youtube.com/tv',
    url: '/images/apps/App_YouTube_454x255.png',
    appIdentifier: 'n:3'
  }, {
    displayName: 'YouTubeTV',
    applicationType: 'YouTubeTV',
    uri: 'https://www.youtube.com/tv/upg',
    url: '/images/apps/App_YouTubeTV_454x255.png',
    appIdentifier: 'n:4'
  }, {
    displayName: 'YouTubeKids',
    applicationType: 'YouTubeKids',
    uri: 'https://www.youtube.com/tv_kids',
    url: '/images/apps/App_YouTubeKids_454x255.png',
    appIdentifier: 'n:5'
  }, {
    displayName: 'Peacock',
    applicationType: 'Peacock',
    uri: '',
    url: '/images/apps/App_Peacock_454x255.png',
    appIdentifier: 'n:6'
  }, {
    displayName: 'Xumo',
    applicationType: 'HtmlApp',
    uri: 'https://x1box-app.xumo.com/index.html',
    url: '/images/apps/App_Xumo_454x255.png',
    appIdentifier: 'n:7'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for tv shows listings.
   */
  var tvShowsInfo = [{
    displayName: 'Fantasy-Island',
    url: '/images/tvShows/fantasy-island.jpg'
  }, {
    displayName: 'Onward',
    url: '/images/tvShows/onward.jpg'
  }, {
    displayName: 'Let it Snow',
    url: '/images/tvShows/let-it-snow.jpg'
  }, {
    displayName: 'FOG DASH',
    url: '/images/tvShows/do-little.jpg'
  }, {
    displayName: 'FOG HLS',
    url: '/images/tvShows/summerland.jpg'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for settings listings.
   */
  var settingsInfo = [{
    displayName: 'Bluetooth',
    url: '/images/settings/bluetooth.jpg'
  }, {
    displayName: 'Wi-Fi',
    url: '/images/settings/wifi.jpg'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for listings in side panel.
   */
  var sidePanelInfo = [{
    title: 'Apps',
    url: '/images/sidePanel/menu.png'
  }, {
    title: 'Metro Apps',
    url: '/images/sidePanel/metro.png'
  }, {
    title: 'TV Shows',
    url: '/images/sidePanel/video.png'
  }, {
    title: 'Settings',
    url: '/images/sidePanel/settings.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var rightArrowInfo = [{
    url: '/images/right-small.png'
  }, {
    url: '/images/right-small.png'
  }, {
    url: '/images/right-small.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var leftArrowInfo = [{
    url: '/images/left-small.png'
  }, {
    url: '/images/left-small.png'
  }, {
    url: '/images/left-small.png'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for UI selection.
   */
  var uiInfo = [{
    title: 'DEFAULT',
    url: '/images/splash/DefaultUI.png',
    uri: ''
  }, {
    title: 'LIVE',
    url: '/images/splash/LiveTv.png',
    uri: 'http://35.155.171.121:8088/index.html'
  }, {
    title: 'TATA',
    url: '/images/splash/TataElxsi.png',
    uri: 'http://35.155.171.121:8088/index.html'
  }, {
    title: 'NEW',
    url: '/images/splash/NewUi.png',
    uri: 'https://px-apps.sys.comcast.net/lightning_apps/diagnostics/dist/index.html'
  }, {
    title: 'COMINGSOON',
    url: '/images/splash/ComingSoon.png',
    uri: 'https://px-apps.sys.comcast.net/lightning_apps/diagnostics/dist/index.html'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for metro app listings.
   */
  var metroAppsInfo = [{
    displayName: 'CNN',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.CNN',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.CNN.png',
    appIdentifier: 'm:0'
  }, {
    displayName: 'WeatherNetwork',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WeatherNetwork',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.WeatherNetwork.png',
    appIdentifier: 'm:1'
  }, {
    displayName: 'EuroNews',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Euronews',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.Euronews.png',
    appIdentifier: 'm:2'
  }, {
    displayName: 'AccuWeather',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.AccuWeather',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.AccuWeather.png',
    appIdentifier: 'm:3'
  }, {
    displayName: 'Aljazeera',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aljazeera',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.Aljazeera.png',
    appIdentifier: 'm:4'
  }, {
    displayName: 'GuessThatCity',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.GuessThatCity',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.GuessThatCity.png',
    appIdentifier: 'm:5'
  }, {
    displayName: 'Radioline',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Radioline',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.Radioline.png',
    appIdentifier: 'm:6'
  }, {
    displayName: 'WallStreetJournal',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WallStreetJournal',
    url: 'https://cdn-ipv6.metrological.com/lightning/apps/com.metrological.ui.FutureUI/2.0.15-ea2bf91/static/images/applications/com.metrological.app.WallStreetJournal.png',
    appIdentifier: 'm:7'
  }, {
    displayName: 'FRacer',
    applicationType: 'LightningApp',
    uri: 'https://lightningjs.io/fracer/#main',
    url: '/images/metroApps/fracer-steerling.png',
    appIdentifier: 'm:8'
  }, {
    displayName: 'Aquarium',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aquarium',
    url: '/images/metroApps/Aquarium.png',
    appIdentifier: 'm:9'
  }, {
    displayName: 'Fireplace',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Fireplace',
    url: '/images/metroApps/Fireplace.png',
    appIdentifier: 'm:10'
  }, {
    displayName: 'Deutsche Welle',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.DW',
    url: '/images/metroApps/DWelle.png',
    appIdentifier: 'm:11'
  }, {
    displayName: 'MyTuner Radio',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.appgeneration.mytuner',
    url: '/images/metroApps/Radio.png',
    appIdentifier: 'm:12'
  }, {
    displayName: 'Sudoku',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sudoku',
    url: '/images/metroApps/Sudoku.png',
    appIdentifier: 'm:13'
  }, {
    displayName: 'Tastemade',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Tastemade',
    url: '/images/metroApps/Tastemade.png',
    appIdentifier: 'm:14'
  }, {
    displayName: 'Bloomberg',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.bloomberg.metrological.x1',
    url: '/images/metroApps/Bloomberg.png',
    appIdentifier: 'm:15'
  }, {
    displayName: 'Playworks',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.playworks.pwkids',
    url: '/images/metroApps/Playworks.png',
    appIdentifier: 'm:16'
  }, {
    displayName: 'Sunrise',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sunrise',
    url: '/images/metroApps/Sunrise.png',
    appIdentifier: 'm:17'
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for metro app listings.
   */
  var metroAppsInfoOffline = [{
    displayName: 'CNN',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.CNN',
    url: '/images/metroApps/Test-01.jpg',
    appIdentifier: 'm:0'
  }, {
    displayName: 'WeatherNetwork',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WeatherNetwork',
    url: '/images/metroApps/Test-03.jpg',
    appIdentifier: 'm:1'
  }, {
    displayName: 'EuroNews',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Euronews',
    url: '/images/metroApps/Test-04.jpg',
    appIdentifier: 'm:2'
  }, {
    displayName: 'AccuWeather',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.AccuWeather',
    url: '/images/metroApps/Test-05.jpg',
    appIdentifier: 'm:3'
  }, {
    displayName: 'Aljazeera',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aljazeera',
    url: '/images/metroApps/Test-07.jpg',
    appIdentifier: 'm:4'
  }, {
    displayName: 'GuessThatCity',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.GuessThatCity',
    url: '/images/metroApps/Test-08.jpg',
    appIdentifier: 'm:5'
  }, {
    displayName: 'Radioline',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Radioline',
    url: '/images/metroApps/Test-09.jpg',
    appIdentifier: 'm:6'
  }, {
    displayName: 'WallStreetJournal',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.WallStreetJournal',
    url: '/images/metroApps/Test-10.jpg',
    appIdentifier: 'm:7'
  }, {
    displayName: 'FRacer',
    applicationType: 'LightningApp',
    uri: 'https://lightningjs.io/fracer/#main',
    url: '/images/metroApps/fracer-steerling.png',
    appIdentifier: 'm:8'
  }, {
    displayName: 'Aquarium',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Aquarium',
    url: '/images/metroApps/Aquarium.png',
    appIdentifier: 'm:9'
  }, {
    displayName: 'Fireplace',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Fireplace',
    url: '/images/metroApps/Fireplace.png',
    appIdentifier: 'm:10'
  }, {
    displayName: 'Deutsche Welle',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.DW',
    url: '/images/metroApps/DWelle.png',
    appIdentifier: 'm:11'
  }, {
    displayName: 'MyTuner Radio',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.appgeneration.mytuner',
    url: '/images/metroApps/Radio.png',
    appIdentifier: 'm:12'
  }, {
    displayName: 'Sudoku',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sudoku',
    url: '/images/metroApps/Sudoku.png',
    appIdentifier: 'm:13'
  }, {
    displayName: 'Tastemade',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Tastemade',
    url: '/images/metroApps/Tastemade.png',
    appIdentifier: 'm:14'
  }, {
    displayName: 'Bloomberg',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.bloomberg.metrological.x1',
    url: '/images/metroApps/Bloomberg.png',
    appIdentifier: 'm:15'
  }, {
    displayName: 'Playworks',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.playworks.pwkids',
    url: '/images/metroApps/Playworks.png',
    appIdentifier: 'm:16'
  }, {
    displayName: 'Sunrise',
    applicationType: 'LightningApp',
    uri: 'https://widgets.metrological.com/lightning/rdk/d431ce8577be56e82630650bf701c57d#app:com.metrological.app.Sunrise',
    url: '/images/metroApps/Sunrise.png',
    appIdentifier: 'm:17'
  }];

  /**
   * If not stated otherwise in this file or this component"s LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  var showCaseApps = [{
    displayName: 'Strike Benchmark',
    applicationType: 'LightningApp',
    uri: 'https://strike.lightningjs.io/es6/#home',
    url: '/images/lightningApps/strike_app.png',
    appIdentifier: 's:0'
  }, {
    displayName: 'TMBD App',
    applicationType: 'LightningApp',
    uri: 'https://lightningjs.io/tmdb/#splash',
    url: '/images/lightningApps/tmbd.png',
    appIdentifier: 's:1'
  }, {
    displayName: 'FCA',
    applicationType: 'FireboltApp',
    appId: "comcast.test.firecert",
    intent: {
      "action": "home",
      "context": {
        "source": "device"
      }
    },
    url: '/images/lightningApps/fb_cert.png',
    appIdentifier: 's:2'
  }];

  var lib = {};

  var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {
    __assign = Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  var defaultOptions = {
    aloneValueName: '_@attribute'
  };
  /**
   * Main function. Clears the given xml and then starts the recursion
   * @param xmlStr
   * @param options the options
   */
  function xml2json(xmlStr, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var opt = __assign(__assign({}, defaultOptions), options);
    xmlStr = cleanXML(xmlStr, opt.aloneValueName);
    return xml2jsonRecurse(xmlStr, opt);
  }
  var _default = lib.default = xml2json;
  /**
   * Recursive function that creates a JSON object with a given XML string.
   *
   * @param xmlStr
   * @param options the options
   */
  function xml2jsonRecurse(xmlStr, options) {
    var obj = {};
    var startTagMatch;
    while (startTagMatch = xmlStr.match(/<[^\/][^>]*>/)) {
      var openingTag = startTagMatch[0];
      var tagName = openingTag.substring(1, openingTag.length - 1);
      var indexClosingTag = xmlStr.indexOf(openingTag.replace('<', '</'));
      // account for case where additional information in the opening tag
      var closingTagMatch = void 0;
      if (indexClosingTag == -1 && (closingTagMatch = openingTag.match(/[^<][\S+$]*/))) {
        tagName = closingTagMatch[0];
        indexClosingTag = xmlStr.indexOf('</' + tagName);
        if (indexClosingTag == -1) {
          indexClosingTag = xmlStr.indexOf('<\\/' + tagName);
        }
      }
      var inner_substring = xmlStr.substring(openingTag.length, indexClosingTag);
      var tempVal = inner_substring.match(/<[^\/][^>]*>/) ? xml2json(inner_substring, options) : inner_substring;
      // account for array or obj
      if (obj[tagName] === undefined) {
        obj[tagName] = tempVal;
      } else if (Array.isArray(obj[tagName])) {
        obj[tagName].push(tempVal);
      } else {
        obj[tagName] = [obj[tagName], tempVal];
      }
      xmlStr = xmlStr.substring(openingTag.length * 2 + 1 + inner_substring.length);
    }
    return obj;
  }
  /**
   * Removes some characters that would break the recursive function.
   *
   * @param xmlStr
   * @param aloneValueName
   * @returns {string}
   */
  function cleanXML(xmlStr, aloneValueName) {
    xmlStr = xmlStr.replace(/<!--[\s\S]*?-->/g, ''); // remove commented lines
    xmlStr = xmlStr.replace(/[\n\t\r]/g, ''); // replace special characters
    xmlStr = xmlStr.replace(/>[ \t]+</g, '><'); // replace leading spaces and tabs betweet elements
    xmlStr = xmlStr.replace(/<\?[^>]*\?>/g, ''); // delete docType tags
    xmlStr = replaceSelfClosingTags(xmlStr); // replace self closing tags
    xmlStr = replaceAloneValues(xmlStr, aloneValueName); // replace the alone tags values
    xmlStr = replaceAttributes(xmlStr); // replace attributes
    return xmlStr;
  }
  /**
   * Replaces all the self closing tags with attributes with another tag containing its attribute as a property.
   * The function works if the tag contains multiple attributes.
   * Example : '<tagName attrName="attrValue" />' becomes
   *           '<tagName><attrName>attrValue</attrName></tagName>'
   * @param xmlStr
   * @returns {*}
   */
  function replaceSelfClosingTags(xmlStr) {
    var selfClosingTags = xmlStr.match(/<[^/][^>]*\/>/g);
    if (!selfClosingTags) {
      return xmlStr;
    }
    for (var i = 0; i < selfClosingTags.length; i++) {
      var oldTag = selfClosingTags[i];
      var match = oldTag.match(/[^<][\S+$]*/);
      if (match) {
        var tagName = match[0];
        var closingTag = "</" + tagName + ">";
        var newTag = extractAttributeValue(tagName, oldTag) + closingTag;
        xmlStr = xmlStr.replace(oldTag, newTag);
      }
    }
    return xmlStr;
  }
  /**
   *  Replaces all the tags with attributes and a value with a new tag.
   *
   *  Example : '<tagName attrName="attrValue">tagValue</tagName>' becomes
   *  '<tagName><attrName>attrValue</attrName><_@attribute>tagValue</_@attribute></tagName>'
   *
   * @param xmlStr
   * @param aloneValueName
   * @returns {string}
   */
  function replaceAloneValues(xmlStr, aloneValueName) {
    var tagsWithAttributesAndValue = xmlStr.match(/<[^\/][^>][^<]+\s+.[^<]+[=][^<]+>([^<]+)/g);
    if (!tagsWithAttributesAndValue) {
      return xmlStr;
    }
    for (var i = 0; i < tagsWithAttributesAndValue.length; i++) {
      var oldTag = tagsWithAttributesAndValue[i];
      var oldTagName = oldTag.substring(0, oldTag.indexOf(">") + 1);
      var oldTagValue = oldTag.substring(oldTag.indexOf(">") + 1);
      var newTag = oldTagName + "<" + aloneValueName + ">" + oldTagValue + "</" + aloneValueName + ">";
      xmlStr = xmlStr.replace(oldTag, newTag);
    }
    return xmlStr;
  }
  function extractAttributeValue(tagName, oldTag) {
    var newTag = "<" + tagName + ">";
    var attrs = oldTag.match(/(\S+)\s?=\s?((?:"[^"]+")|(?:'[^']+'))/g);
    if (!attrs) {
      return newTag;
    }
    for (var j = 0; j < attrs.length; j++) {
      var attr = attrs[j];
      var attrName = attr.substring(0, attr.indexOf('=')).trim();
      var quote = attr[attr.length - 1];
      var attrValue = attr.substring(attr.indexOf(quote) + 1, attr.lastIndexOf(quote));
      newTag += "<" + attrName + ">" + attrValue + "</" + attrName + ">";
    }
    return newTag;
  }
  /**
   * Replaces all the tags with attributes with another tag containing its attribute as a property.
   * The function works if the tag contains multiple attributes.
   *
   * Example : '<tagName attrName="attrValue"></tagName>' becomes '<tagName><attrName>attrValue</attrName></tagName>'
   *
   * @param xmlStr
   * @returns {*}
   */
  function replaceAttributes(xmlStr) {
    var tagsWithAttributes = xmlStr.match(/<[^\/><]\S+\s+[^<]+[=][^<]+>/g);
    if (!tagsWithAttributes) {
      return xmlStr;
    }
    for (var i = 0; i < tagsWithAttributes.length; i++) {
      var oldTag = tagsWithAttributes[i];
      var match = oldTag.match(/[^<]\S*/);
      if (match) {
        var tagName = match[0];
        var newTag = extractAttributeValue(tagName, oldTag);
        xmlStr = xmlStr.replace(oldTag, newTag);
      }
    }
    return xmlStr;
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let partnerApps = [];

  /**
   * Get the ip address.
   */
  let IpAddress1 = "";
  let IpAddress2 = "";
  let networkApi = new Network();
  networkApi.getStbIp().then(ip => {
    IpAddress1 = ip;
    Storage$1.set("ipAddress", IpAddress1);
  }).catch(() => {
    Storage$1.set("ipAddress", null);
  });
  let appApi$d = new AppApi();
  appApi$d.getIP().then(ip => {
    IpAddress2 = ip;
  });

  /**
   * Class that returns the data required for home screen.
   */
  class HomeApi {
    /**
     * Function to get details for app listing.
     */
    getAppListInfo() {
      let appsMetaData = appListInfo;
      return JSON.parse(JSON.stringify(appsMetaData));
    }

    /**
     * Function to get details for tv shows listings.
     */
    getTVShowsInfo() {
      return tvShowsInfo;
    }

    /**
     * Function to get details for settings listings.
     */
    getSettingsInfo() {
      return settingsInfo;
    }

    /**
     * Function to get details for lightning showcase apps.
     */
    getShowCaseApps() {
      return JSON.parse(JSON.stringify(showCaseApps));
    }

    /**
     * Function to get details for all apps.
     */
    getAllApps() {
      return [...this.getAppListInfo(), ...this.getMetroInfo(), ...this.getShowCaseApps()];
    }

    /**
     * Function to get details for side panel.
     */
    getSidePanelInfo() {
      return sidePanelInfo;
    }

    /**
     * Function to get details of different UI
     */
    getUIInfo() {
      return uiInfo;
    }

    /**
     * Function to details of metro apps
     */
    getMetroInfo() {
      let metroAppsMetaData;
      if (IpAddress1 || IpAddress2) {
        metroAppsMetaData = metroAppsInfo;
      } else {
        metroAppsMetaData = metroAppsInfoOffline;
      }
      return metroAppsMetaData;
    }
    getOfflineMetroApps() {
      return JSON.parse(JSON.stringify(metroAppsInfoOffline));
    }
    getOnlineMetroApps() {
      return JSON.parse(JSON.stringify(metroAppsInfo));
    }

    /**
     * Function to store partner app details.
     * @param {obj} data Partner app details.
     */
    setPartnerAppsInfo(data) {
      partnerApps = data;
    }

    /**
     *Function to return partner app details.
     */
    getPartnerAppsInfo() {
      return partnerApps;
    }
    /**
     * Function to details of right arrow
     */
    getRightArrowInfo() {
      return rightArrowInfo;
    }
    /**
     * Function to details of left arrow
     */
    getLeftArrowInfo() {
      return leftArrowInfo;
    }
    getMovieSubscriptions(id) {
      return new Promise((resolve, reject) => {
        appApi$d.fetchApiKey().then(res => {
          // console.log("Key is: ", res);
          // console.log("tmsID is :", id);
          try {
            fetch("http://feeds.tmsapi.com/v2/movies/" + id + ".xml?api_key=" + res).then(response => response.text()).then(res => {
              resolve(_default(res));
            });
          } catch (err) {
            console.log("API key not defined");
          }
        });
      });
    }
    getAPIKey() {
      return new Promise((resolve, reject) => {
        appApi$d.fetchApiKey().then(res => {
          let [day, month, year] = [new Date().getUTCDate(), new Date().getUTCMonth(), new Date().getUTCFullYear()];
          month += 1;
          day = day.toString();
          month = month.toString();
          //fetch date time from the thunder plugins and pass it to the url
          try {
            fetch("http://data.tmsapi.com/v1.1/movies/airings?lineupId=USA-TX42500-X&startDateTime=" + year + "-" + month + "-" + day + "T08%3A00Z&includeAdult=false&imageSize=Lg&imageAspectTV=16x9&imageText=true&api_key=" + res).then(response => response.json()).then(response => {
              const ids = response.map(id => id.program.rootId);
              const filtered = response.filter((_ref, index) => {
                let {
                  program
                } = _ref;
                return !ids.includes(program.rootId, index + 1);
              });
              resolve({
                key: res,
                data: filtered.slice(0, 20)
              });
            }).catch(err => {
              console.log("Incorrect API key or no data available");
              resolve({
                key: res,
                data: []
              });
            });
          } catch (err) {
            console.log("API key not defined");
            resolve({
              key: res,
              data: []
            });
          }
        });
      });
    }
    async checkChannelComapatability(items) {
      for (let i = 0; i < items.length; i++) {
        let callsign = null;
        if (items[i].dvburi === "OTT") {
          callsign = items[i].callsign;
          if (items[i].callsign === "YouTube" || items[i].callsign === "YouTubeTV" || items[i].callsign === "YouTubeKids") {
            callsign = "Cobalt";
          }
          await appApi$d.getPluginStatus(callsign).then(res => {}).catch(err => {
            console.log("Error:", err);
            items.splice(i, 1);
            i--;
          });
        }
      }
      return items;
    }
    async checkAppCompatability(items) {
      for (let i = 0; i < items.length; i++) {
        let callsign = items[i].applicationType;
        if (items[i].applicationType !== '') {
          if (items[i].applicationType === "FireboltApp" && Storage$1.get("selfClientName") === "FireboltMainApp-refui") {
            callsign = "HtmlApp";
          } else if (items[i].applicationType === "YouTube" || items[i].applicationType === "YouTubeTV" || items[i].applicationType === "YouTubeKids") {
            callsign = "Cobalt";
          }
          await appApi$d.getPluginStatus(callsign).then(res => {}).catch(err => {
            console.log("Error:", err);
            items.splice(i, 1);
            i--;
          });
        }
      }
      return items;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**Color constants */
  var COLORS = {
    textColor: 0xffffffff,
    titleColor: 0xffffffff,
    hightlightColor: 0xffc0c0c0,
    headingColor: 0xffffffff
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class SettingsItem extends t.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: false
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SettingsMainItem extends SettingsItem {
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {}
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$h = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  const thunder$j = thunderJS$1(config$h);
  let playerID = -1; //set to -1 to indicate nothing is currently playing

  let customServiceList = []; //list containing all channel details
  let customEventList = {}; //object with dvduri mapping to eventlist on that channel
  const getCustomServiceList = async () => {
    try {
      let response = await fetch("http://127.0.0.1:50050/lxresui/static/moreChannels/ChannelData.json");
      response = await response.json();
      customServiceList = response.serviceList;
      customEventList = response.eventList;
      console.log("customServiceList: ", customServiceList);
      console.log("customEventList: ", customEventList);
    } catch (err) {
      console.log("Failed to read Custom Channel Data: ", err);
    }
  };
  getCustomServiceList(); //call this method in activate

  //plugin is activated by default, no need to call explicitly
  class DTVApi {
    activate() {
      return new Promise((resolve, reject) => {
        thunder$j.Controller.activate({
          callsign: "DTV"
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log("DTV Error Activation", err);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        thunder$j.Controller.deactivate({
          callsign: "DTV"
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log("DTV Error Deactivation", err);
          reject(err);
        });
      });
    }
    //gets the number of available countries
    noOfCountries() {
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "numberOfCountries").then(result => {
          resolve(result);
        }).catch(err => {
          console.log("Error: noOfCountries: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    //returns the list of the available countries
    countryList() {
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "countryList").then(result => {
          resolve(result);
        }).catch(err => {
          console.log("Error: countryList: ", JSON.stringify(err));
          reject(err);
        });
      });
    }

    //returns the list of services(channels with name, uri and other details)
    serviceList() {
      let arr = [{
        shortname: "Amazon Prime",
        callsign: "Amazon",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "Netflix",
        callsign: "Netflix",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "YouTube",
        callsign: "YouTube",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "YouTubeTV",
        callsign: "YouTubeTV",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }, {
        shortname: "YouTubeKids",
        callsign: "YouTubeKids",
        url: "",
        dvburi: "OTT",
        lcn: 0
      }];
      if (customServiceList) {
        arr = arr.concat(JSON.parse(JSON.stringify(customServiceList)));
      }
      console.log("arr from serviceList: ", arr);
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "serviceList@dvbs").then(result => {
          arr = arr.concat(result);
          console.log("serviceListResult: ", JSON.stringify(arr));
          resolve(arr);
        }).catch(err => {
          console.log("Error: serviceList: ", JSON.stringify(err));
          resolve(arr);
        });
      });
    }
    getEvents(dvburi) {
      return customEventList[dvburi];
    }

    //returns the schedule for the given channel with provided dvburi
    scheduleEvents(dvburi) {
      let method = 'scheduleEvents@' + dvburi;
      return new Promise((resolve, reject) => {
        if (dvburi.startsWith("C_")) {
          let data = customEventList[dvburi];
          if (data) {
            // resolve([]); //need to pass actual data here
            data = JSON.parse(JSON.stringify(data));
            for (let show of data) {
              show.starttime *= 1000;
              show.duration *= 1000;
            }
            resolve(data);
          } else {
            console.log("Error: getting schedule from custom channels");
            resolve([]);
          }
        } else {
          thunder$j.call("DTV", method).then(result => {
            console.log("scheduleEventsResult: ", JSON.stringify(result));
            for (let show of result) {
              show.starttime *= 1000;
              show.duration *= 1000;
            }
            resolve(result);
          }).catch(err => {
            console.log("Error: scheduleEvents: ", JSON.stringify(err));
            reject(err);
          });
        }
      });
    }

    //lists the satellites available
    satelliteList() {
      return new Promise((resolve, reject) => {
        // resolve([{name: "Satellite 1",longitude: 282,lnb: "Universal" },{name: "Satellite 2",longitude: 282,lnb: "Universal" }]) //#forTesting
        thunder$j.call("DTV", "satelliteList").then(result => {
          if (result.length === 0) {
            result = [{
              "name": "Astra 28.2E",
              "longitude": 282,
              "lnb": "Universal"
            }];
          }
          resolve(result);
        }).catch(err => {
          console.log("Error: satelliteList: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    //returns the available polarity options for dvb-s scan, returns a list of static values
    polarityList() {
      return new Promise((resolve, reject) => {
        resolve(["horizontal", "vertical", "left", "right"]);
      });
    }

    //returns the available symbolRate options for dvb-s scan, returns a list of static values
    symbolRateList() {
      return new Promise((resolve, reject) => {
        resolve(["22000", "23000", "27500", "29500"]); //values can be edited/entered custom from UI, no need to mention custom here
      });
    }
    //returns the available FEC options for dvb-s scan, returns a list of static values
    fecList() {
      return new Promise((resolve, reject) => {
        resolve(["fecauto", "fec1_2", "fec2_3", "fec3_4", "fec5_6", "fec7_8", "fec1_4", "fec1_3", "fec2_5", "fec8_9", "fec9_10", "fec3_5", "fec4_5"]);
      });
    }
    //returns the available modulation options for dvb-s scan, returns a list of static values
    modulationList() {
      return new Promise((resolve, reject) => {
        resolve(["auto", "qpsk", "8psk", "16qam"]);
      });
    }
    //returns the available searchtype(searchmode) options for dvb-s scan, returns a list of static values
    searchtypeList() {
      return new Promise((resolve, reject) => {
        resolve(["frequency", "network"]);
      });
    }
    //initiates a service search for the provided params
    startServiceSearch(params) {
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "startServiceSearch", params).then(result => {
          //console.log("serviceSearchResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("serviceSearchError: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    //returns the number of available services(channels)
    noOfServices() {
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "numberOfServices").then(result => {
          //console.log("numberOfServicesResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Error: numberOfServices: ", JSON.stringify(err));
          reject(err);
        });
      });
    }

    //returns the current and next event details for the given channel with provided dvburi
    nowNextEvents(dvburi) {
      let method = "nowNextEvents@" + dvburi;
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", method).then(result => {
          //console.log("nowNextEventsResult: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Error: nowNextEvents: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    startPlaying(params) {
      //params contains dvburi and lcn
      console.log("PARAMS: startPlaying: ", JSON.stringify(params));
      if (playerID !== -1) {
        this.stopPlaying();
        return Promise.reject("something is still playing Please retry");
      }
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "startPlaying", params).then(result => {
          console.log("RESULT: startPlaying: ", JSON.stringify(result));
          if (result === -1) {
            reject("Can't be played");
          } else {
            playerID = result; //to be used in stopPlaying method
            resolve(result);
          }
        }).catch(err => {
          console.log("ERROR: startPlaying: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    stopPlaying() {
      return new Promise((resolve, reject) => {
        thunder$j.call("DTV", "stopPlaying", playerID).then(result => {
          //playerID is retuned from startPlaying method
          console.log("RESULT: stopPlaying: ", JSON.stringify(result)); //result is always null
          playerID = -1; //to set that nothing is being played currently
          resolve(true);
        }).catch(err => {
          console.log("ERROR: stopPlaying: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    launchChannel(dvburi) {
      console.log("PARAMS: launchChannel: ", JSON.stringify(dvburi));
      if (playerID !== -1) {
        this.exitChannel();
        console.log("launchChannel: FAIL: something is still playing, trying to call exitChannel");
        return Promise.reject("Fail: something is still playing");
      }
      return new Promise((resolve, reject) => {
        let port = "8080"; //try to fetch it later
        let cmd = "open"; //add other methods also
        let url = "http://127.0.0.1:" + port + "/vldms/sessionmgr/" + cmd;
        let data = {
          "openRequest": {
            "type": "main",
            "locator": "dtv://" + dvburi,
            "playerParams": {
              "subContentType": "live",
              "window": "0,0,1920,1080",
              "videoBlank": false
            }
          }
        };
        let params = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        };
        console.log("launchChannel: url & params: ", JSON.stringify(url), JSON.stringify(params));
        fetch(url, params).then(response => response.json()).then(result => {
          console.log("launchChannel: SUCCESS: ", JSON.stringify(result));
          playerID = result.openStatus.sessionId;
          console.log("launchChannel: SESSIONID: ", playerID);
          resolve(result);
        }).catch(err => {
          console.log("launchChannel: FAILED: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    exitChannel() {
      return new Promise((resolve, reject) => {
        let port = "8080"; //try to fetch it later
        let cmd = "close"; //add other methods also
        let url = "http://127.0.0.1:" + port + "/vldms/sessionmgr/" + cmd;
        let data = {
          "closeRequest": {
            "sessionId": playerID
          }
        };
        let params = {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        };
        console.log("exitChannel: url & params: ", JSON.stringify(url), JSON.stringify(params));
        fetch(url, params).then(response => response.json()).then(result => {
          console.log("exitChannel: SUCCESS: ", JSON.stringify(result));
          playerID = -1;
          resolve(result);
        }).catch(err => {
          console.log("exitChannel: FAILED: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$g = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var thunder$i = thunderJS$1(config$g);

  /**
   * Class for settings screen.
   */
  class SettingsScreen extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SettingsScreenContents: {
          x: 200,
          y: 275,
          NetworkConfiguration: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Configuration'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Bluetooth: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Pair Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Video: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Video'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Audio: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OtherSettings: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Other Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NFRStatus: {
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Native Frame Rate'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          DTVSettings: {
            alpha: 0.3,
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Live TV'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          VoiceRemoteControl: {
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Voice Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('NetworkConfiguration');
    }
    _focus() {
      this._setState(this.state);
    }
    _firstActive() {
      if (Storage$1.get("NFRStatus")) {
        console.log("Netflix : NFRStatus is found to be enabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
      } else {
        console.log("Netflix : NFRStatus is found to be disabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
      }
      this.dtvApi = new DTVApi();
      this.dtvPlugin = false; //plugin availability
      if (Storage$1.get("deviceType") != "IpStb") {
        this.dtvApi.activate().then(res => {
          this.dtvPlugin = true;
          this.tag("DTVSettings").alpha = 1;
        });
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('menu');
      }
    }
    static _states() {
      return [class NetworkConfiguration extends this {
        $enter() {
          this.tag('NetworkConfiguration')._focus();
        }
        $exit() {
          this.tag('NetworkConfiguration')._unfocus();
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network');
          }
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkConfiguration');
        }
        _handleDown() {
          this._setState('Video');
        }
        _handleLeft() {}
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/bluetooth');
          }
        }
      }, class Video extends this {
        $enter() {
          this.tag('Video')._focus();
        }
        $exit() {
          this.tag('Video')._unfocus();
        }
        _handleUp() {
          this._setState('Bluetooth');
        }
        _handleDown() {
          this._setState('Audio');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/video');
          }
        }
      }, class Audio extends this {
        $enter() {
          this.tag('Audio')._focus();
        }
        $exit() {
          this.tag('Audio')._unfocus();
        }
        _handleUp() {
          this._setState('Video');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/audio');
          }
        }
        _handleDown() {
          this._setState('OtherSettings');
        }
      }, class OtherSettings extends this {
        $enter() {
          this.tag('OtherSettings')._focus();
        }
        $exit() {
          this.tag('OtherSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Audio');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other');
          }
        }
        _handleDown() {
          this._setState("NFRStatus");
        }
      }, class NFRStatus extends this {
        $enter() {
          this.tag('NFRStatus')._focus();
        }
        $exit() {
          this.tag('NFRStatus')._unfocus();
        }
        _handleUp() {
          this._setState('OtherSettings');
        }
        _handleDown() {
          this._setState('VoiceRemoteControl');
        }
        _handleEnter() {
          //handle Switch
          let self = this;
          if (Storage$1.get("NFRStatus")) {
            thunder$i.call("Netflix.1", "nfrstatus", {
              "params": "disable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
              Storage$1.set("NFRStatus", false);
              console.log("Netflix : nfr disable updation results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus");
              console.error(nerr);
            });
          } else {
            thunder$i.call("Netflix.1", "nfrstatus", {
              "params": "enable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
              Storage$1.set("NFRStatus", true);
              console.log("Netflix : nfr enable results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus ");
              console.error(nerr);
            });
          }
        }
      }, class DTVSettings extends this {
        $enter() {
          this.tag('DTVSettings')._focus();
        }
        $exit() {
          this.tag('DTVSettings')._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleEnter() {
          if (this.dtvPlugin) {
            Router.navigate('settings/livetv');
          }
        }
      }, class VoiceRemoteControl extends this {
        $enter() {
          this.tag('VoiceRemoteControl')._focus();
        }
        $exit() {
          this.tag('VoiceRemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleDown() {
          if (this.dtvPlugin) {
            this._setState('DTVSettings');
          }
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/bluetooth/RCVolumeInfoScreen');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class ListItem extends t.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + this.bar * 2,
        w: this.w,
        x: this.x,
        y: this.y - this.bar
      });
      if (!this.data.url) {
        console.log("data from app carousal: ", this.data);
      }
      if (this.data.url.startsWith('/images')) {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: Utils.asset(this.data.url),
          scale: this.unfocus
        });
      } else {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: this.data.url
        });
      }

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 10,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.displayName,
              fontSize: 35,
              maxLines: 1,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        smooth: {
          scale: [this.focus, {
            timingFunction: 'ease',
            duration: 0.7
          }],
          alpha: 1
        }
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        zIndex: 0
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0,
          scale: [this.unfocus, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var imageListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var musicListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var videoListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class which contains data for app listings.
   */
  var UsbInnerFolderListInfo = [];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$f = {
    host: '127.0.0.1',
    port: 9998,
    versions: {
      default: 2,
      Controller: 1,
      UsbAccess: 2
    }
  };
  let thunder$h = thunderJS$1(config$f);
  /**
   * Class that contains functions which commuicates with thunder API's
   */

  class UsbApi {
    /**
    *  Function to activate USB Access Plugin
    */

    activate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$h.Controller.activate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.log('UsbAccess Plugin Activation Failed: ' + err);
          reject(err);
        });
      });
    }

    /**
    *  Function to deactivate USB Access Plugin
    */

    deactivate() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$h.Controller.deactivate({
          callsign: systemcCallsign
        }).then(res => {
          resolve(res);
        }).catch(err => {
          console.log('UsbAccess Plugin Deactivation Failed: ' + err);
          reject(err);
        });
      });
    }

    /**
    *  Function to create link for USB content
    */
    clearLink() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$h.call(systemcCallsign, 'clearLink').then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }

    /**
    *  Function to create link for USB content
    */
    createLink() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = 'org.rdk.UsbAccess';
        thunder$h.call(systemcCallsign, 'createLink').then(result => {
          resolve(result);
        }).catch(err => {
          resolve(false);
        });
      });
    }

    /**
    *  Function to get getUsbList
    */
    getUsbFileList() {
      if (arguments.length === 0) {
        return new Promise((resolve, reject) => {
          const systemcCallsign = 'org.rdk.UsbAccess';
          thunder$h.call(systemcCallsign, 'getFileList').then(result => {
            resolve(result.contents);
          }).catch(err => {
            resolve(false);
          });
        });
      } else {
        return new Promise((resolve, reject) => {
          const systemcCallsign = 'org.rdk.UsbAccess';
          thunder$h.call(systemcCallsign, 'getFileList', {
            "path": arguments[0]
          }).then(result => {
            resolve(result.contents);
          }).catch(err => {
            resolve(false);
          });
        });
      }
    }
    retrieUsb() {
      this.usbLink = "";
      let self = this;
      return new Promise((resolve, reject) => {
        self.clearLink().then(result => {
          self.createLink().then(res => {
            if (res.success) {
              self.usbLink = res.baseURL;
              self.getUsbFileList().then(result1 => {
                self.getUsbContentList(result1);
                resolve(true);
              }).catch(err => {
                reject(err);
              });
            }
          }).catch(err => {
            reject(err);
          });
        }).catch(err => {
          reject(err);
        });
      });
    }
    destroy() {
      imageListInfo.length = 0;
      videoListInfo.length = 0;
      musicListInfo.length = 0;
      UsbInnerFolderListInfo.length = 0;
    }
    cd(dname) {
      return new Promise((resolve, reject) => {
        this.getUsbFileList(dname).then(result1 => {
          this.getUsbContentList(result1, dname);
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getMountedDevices() {
      return new Promise((resolve, reject) => {
        const systemcCallsign = "org.rdk.UsbAccess";
        thunder$h.call(systemcCallsign, 'getMounted').then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
          console.error("Error while getting the mounted device ".concat(JSON.stringify(err)));
        });
      });
    }
    getUsbContentList(result) {
      this.destroy();
      let cwd = this.usbLink;
      if (arguments[1]) {
        cwd = cwd + '/' + arguments[1];
      }
      // to add support for more formats, extension can be added same as below 
      let extensionForImage = ['.png', '.jpg', '.PNG', '.jpeg', '.JPEG', '.jpg', '.JPG'];
      let extensionForVideo = ['.mp4', '.MP4', '.mov', '.MOV', '.avi', '.AVI', '.m3u8', '.M3U8', '.mpeg2', '.MPEG2'];
      let extensionForAudio = ['.mp3', '.mpeg', '.MP3', '.MPEG'];
      this._discoveredC = result;
      //   console.log("Discovered result :: " + JSON.stringify(result));

      this._discoveredC.filter(device => {
        for (let i in extensionForImage) {
          if (device.name.indexOf(extensionForImage[i]) !== -1) {
            let obj1 = {
              displayName: device.name,
              uri: cwd + '/' + device.name,
              url: cwd + '/' + device.name
              // url: '/images/usb/picture-default-tile.jpg',
              // url: '/images/usb/USB_Photo_Placeholder.jpg',
              // uri: this.usbLink + '/' + device.name,
            };

            imageListInfo.push(obj1);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        for (let i in extensionForVideo) {
          if (device.name.indexOf(extensionForVideo[i]) !== -1) {
            let obj2 = {
              displayName: device.name,
              //  url: '/images/usb/video-default-tile.jpg',
              url: '/images/usb/USB_Video_Placeholder.jpg',
              uri: cwd + '/' + device.name
            };
            videoListInfo.push(obj2);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        for (let i in extensionForAudio) {
          if (device.name.indexOf(extensionForAudio[i]) !== -1) {
            let obj3 = {
              displayName: device.name,
              //  url: '/images/usb/music-default-tile.jpg',
              url: '/images/usb/USB_Audio_Placeholder.jpg',
              uri: cwd + '/' + device.name
            };
            musicListInfo.push(obj3);
            return device;
          }
        }
      });
      this._discoveredC.filter(device => {
        if (device.t === 'd') {
          if (!(device.name === '.' || device.name === "..")) {
            let obj4 = {
              displayName: device.name,
              url: "/images/usb/USB_Folder.jpg",
              uri: cwd + "/" + device.name
            };
            UsbInnerFolderListInfo.push(obj4);
            return device;
          }
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Xcast thunder plugin apis.
   */
  class XcastApi {
    constructor() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
      console.log('Xcast constructor');
      this._events = new Map();
    }

    /**
     * Function to activate the Xcast plugin
     */
    activate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Xcast';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          console.log('Xcast activation success ' + result);
          this._thunder.call('org.rdk.Xcast', 'setEnabled', {
            enabled: true
          }).then(result => {
            if (result.success) {
              console.log('Xcast enabled');
              this._thunder.on(this.callsign, 'onApplicationLaunchRequest', notification => {
                console.log('onApplicationLaunchRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationLaunchRequest')) {
                  this._events.get('onApplicationLaunchRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationHideRequest', notification => {
                console.log('onApplicationHideRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationHideRequest')) {
                  this._events.get('onApplicationHideRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationResumeRequest', notification => {
                console.log('onApplicationResumeRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationResumeRequest')) {
                  this._events.get('onApplicationResumeRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationStopRequest', notification => {
                console.log('onApplicationStopRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationStopRequest')) {
                  this._events.get('onApplicationStopRequest')(notification);
                }
              });
              this._thunder.on(this.callsign, 'onApplicationStateRequest', notification => {
                // console.log('onApplicationStateRequest ' + JSON.stringify(notification));
                if (this._events.has('onApplicationStateRequest')) {
                  this._events.get('onApplicationStateRequest')(notification);
                }
              });
              resolve(true);
            } else {
              console.log('Xcast enabled failed');
            }
          }).catch(err => {
            console.error('Enabling failure', err);
            reject('Xcast enabling failed', err);
          });
        }).catch(err => {
          console.error('Activation failure', err);
          reject('Xcast activation failed', err);
        });
      });
    }
    getEnabled() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'getEnabled').then(res => {
          resolve(res);
        }).catch(err => {
          console.log('Xdial error', err);
          reject(err);
        });
      });
    }
    getFriendlyName() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'getFriendlyName').then(res => {
          resolve(res);
        }).catch(err => {
          console.log('Xdial getFriendlyName error', err);
          reject(err);
        });
      });
    }
    setFriendlyName(name) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'setFriendlyName', {
          friendlyname: name
        }).then(result => {
          console.log("Xcast setFriendlyName: " + name + " result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.error(err);
          resolve(false);
        });
      }).then(val => {
        console.log("The resolved value is:", val);
      }).catch(error => {
        console.error("An error occurred:", error);
      });
    }
    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Xcast plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to deactivate the Xcast plugin.
     */
    deactivate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast', 'setEnabled', {
          enabled: false
        }).then(res => {
          resolve(res.success);
        }).catch(err => {
          console.log('Failed to close Xcast', err);
        });
      });
    }

    /**
     * Function to notify the state of the app.
     */
    onApplicationStateChanged(params) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Xcast.1', 'onApplicationStateChanged', params).then(result => {
          //console.log("XCastAPI onApplicationStateChanged Updating: "+ JSON.stringify(params) +" result: ",JSON.stringify(result))
          resolve(result);
        }).catch(err => {
          console.error(err);
          resolve(false);
        });
      });
    }
    static supportedApps() {
      let xcastApps = {
        AmazonInstantVideo: 'Amazon',
        YouTube: 'YouTube',
        NetflixApp: 'Netflix',
        YouTubeKids: "YouTubeKids",
        YouTubeTV: "YouTubeTV"
      };
      return xcastApps;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class GracenoteItem extends t.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      let imgUrl = this.data.program.preferredImage.uri.replace("w=1280&", "w=480&").replace("&h=720", "&h=270");
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + this.bar * 2,
        w: this.w,
        x: this.x,
        y: this.y - this.bar
      });
      this.tag('Image').patch({
        rtt: true,
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        src: Utils.proxyUrl('http://developer.tmsimg.com/' + imgUrl + '&api_key=' + this.key),
        scale: this.unfocus
      });

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 20,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.program.title,
              fontSize: 35,
              maxLines: 1,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        smooth: {
          scale: [this.focus, {
            timingFunction: 'ease',
            duration: 0.7
          }],
          alpha: 1
        }
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0,
          scale: [this.unfocus, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class CollectionWrapper extends t.Component {
    static _template() {
      return {
        Wrapper: {}
      };
    }
    _construct() {
      this._direction = CollectionWrapper.DIRECTION.row;
      this._scrollTransitionSettings = this.stage.transitions.createSettings({});
      this._spacing = 0;
      this._autoResize = false;
      this._requestingItems = false;
      this._requestThreshold = 1;
      this._requestsEnabled = false;
      this._gcThreshold = 5;
      this._gcIncrement = 0;
      this._forceLoad = false;
      this.clear();
    }
    _setup() {
      this._updateScrollTransition();
    }
    _updateScrollTransition() {
      const axis = this._direction === 1 ? 'y' : 'x';
      this.wrapper.transition(axis, this._scrollTransitionSettings);
      this._scrollTransition = this.wrapper.transition(axis);
    }
    _indexChanged(obj) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let {
        index: target,
        dataLength: max,
        mainIndex,
        previousMainIndex,
        lines
      } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        target = mainIndex;
        max = lines;
      }
      if (this._requestsEnabled && !this._requestingItems) {
        if (target + this._requestThreshold >= max) {
          this.requestItems(false, obj);
        }
      }
      this._refocus();
      this.scrollCollectionWrapper(obj, options);
      if (obj.previousIndex !== obj.index) {
        this.signal('onIndexChanged', obj);
      }
    }
    requestItems() {
      let reload = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      if (obj === undefined) {
        obj = {
          previousIndex: 0,
          index: this._index,
          mainIndex: this._mainIndex || 0,
          previousMainIndex: this._mainIndex || 0,
          crossIndex: this._crossIndex || 0,
          previousCrossIndex: this._crossIndex || 0,
          lines: this._lines && this._lines.length || 0,
          dataLength: this._items && this._items.length || 0
        };
      }
      this._requestingItems = true;
      this._request(obj).then(response => {
        this._requestingItems = false;
        if (reload) {
          this.clear();
        }
        const type = typeof response;
        if (Array.isArray(response) && response.length > 0 || type === 'object' || type === 'string' || type === 'number') {
          this.add(response);
          obj.dataLength = this._items && this._items.length || 0;
          this.signal('onRequestItemsAdded', obj);
        }
      });
    }
    _request(obj) {
      return new Promise(resolve => {
        this.signal('onRequestItems', obj).then(response => {
          if (response === undefined || response === false || Array.isArray(response) && response.length === 0) {
            this.enableRequests = false;
          }
          resolve(response);
        });
      });
    }
    _requestMore(index) {
      var _this = this;
      let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      let options = arguments.length > 2 ? arguments[2] : undefined;
      const obj = {
        previousIndex: this._index,
        index,
        mainIndex: this._mainIndex || 0,
        previousMainIndex: this._previous && this._previous.mainIndex || 0,
        crossIndex: this._crossIndex || 0,
        previousCrossIndex: this._previous && this._previous.crossIndex || 0,
        lines: this._lines && this._lines.length || 0,
        dataLength: data.length + (this._items && this._items.length || 0)
      };
      this._requestingItems = true;
      return new Promise(resolve => {
        this._request(obj).then(function () {
          let response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          if (response) {
            const newData = [...data, ...response];
            if (index > _this._items.length + newData.length) {
              _this._requestMore(index, newData).then(resolve);
            } else {
              _this.add(newData);
              obj.dataLength = _this._items && _this._items.length || 0;
              _this.signal('onRequestItemsAdded', obj);
              _this._requestingItems = false;
              _this.setIndex(index, options);
              resolve(true);
            }
          } else {
            _this._requestingItems = false;
            resolve(false);
          }
        });
      });
    }
    setIndex(index) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._requestsEnabled && index > this._items.length - 1) {
        if (!this._requestingItems) {
          this._requestMore(index, [], options);
        }
        return true;
      }
      if (this._items.length === 0) {
        this._index = 0;
        return false;
      }
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      this._index = targetIndex;
      this._indexChanged({
        previousIndex,
        index: targetIndex,
        dataLength: this._items.length
      }, options);
      return previousIndex !== targetIndex;
    }
    clear() {
      this._uids = [];
      this._items = [];
      this._index = 0;
      if (this._scrollTransition && this._scrollTransition.isRunning()) {
        this._scrollTransition.reset(0, 1);
      }
      if (this.wrapper) {
        const hadChildren = this.wrapper.children.length > 0;
        this.wrapper.patch({
          x: 0,
          y: 0,
          children: []
        });
        if (hadChildren) {
          this._collectGarbage(true);
        }
      }
    }
    add(item) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.addAt(item, this._items.length, options);
    }
    addAt(item) {
      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._items.length;
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (index >= 0 && index <= this._items.length) {
        if (!Array.isArray(item)) {
          item = [item];
        }
        const items = this._normalizeDataItems(item);
        this._items.splice(index, 0, ...items);
        this.plotItems(options);
        const targetIndex = index < this._index ? this._index + items.length : this._index;
        this.setIndex(targetIndex, options);
      } else {
        throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
      }
    }
    remove(target) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this.hasItems && target.assignedID) {
        const itemWrappers = this.itemWrappers;
        for (let i = 0; i < this._items.length; i++) {
          let item = this._items[i];
          if (itemWrappers[i] && itemWrappers[i].component.isAlive) {
            item = itemWrappers[i].component;
          }
          if (target.assignedID === item.assignedID) {
            if (i === this._items.length - 1 && item.hasFocus()) {
              this._index = this._index - 1;
            }
            return this.removeAt(i, 1, options);
          }
        }
      } else {
        throw new Error('remove: item not found');
      }
    }
    removeAt(index) {
      let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (index < 0 && index >= this._items.length) {
        throw new Error('removeAt: The index ' + index + ' is out of bounds ' + this._items.length);
      }
      const item = this._items[index];
      this._items.splice(index, amount);
      if (this._items.length > 0) {
        this.plotItems(options);
      }
      this.setIndex(this.index);
      return item;
    }
    reload(item) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.clear();
      this.add(item, options);
    }
    plotItems() {
    } //placeholder

    reposition() {
      let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 70;
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._repositionDebounce = setTimeout(() => {
        this.repositionItems();
      }, time);
    }
    repositionItems() {
      //placeHolder
      this.signal('onItemsRepositioned');
    }
    up() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(-1, 1, options);
    }
    down() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(1, 1, options);
    }
    left() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(-1, 0, options);
    }
    right() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._attemptNavigation(1, 0, options);
    }
    first() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(0, options);
    }
    last() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(this._items.length - 1, options);
    }
    next() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(this._index + 1, options);
    }
    previous() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.setIndex(this._index - 1, options);
    }
    _attemptNavigation(shift, direction) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (this.hasItems) {
        return this.navigate(shift, direction, options);
      }
      return false;
    }
    navigate(shift) {
      let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._direction;
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (direction !== this._direction) {
        return false;
      }
      return this.setIndex(this._index + shift, options);
    }
    scrollCollectionWrapper(obj) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        immediate = false
      } = options;
      let {
        previousIndex: previous,
        index: target,
        dataLength: max,
        mainIndex,
        previousMainIndex,
        lines
      } = obj;
      if (!isNaN(previousMainIndex) && !isNaN(mainIndex) && !isNaN(lines)) {
        previous = previousMainIndex;
        target = mainIndex;
        max = lines;
      }
      const {
        directionIsRow,
        main,
        mainDim,
        mainMarginFrom,
        mainMarginTo
      } = this._getPlotProperties(this._direction);
      const cw = this.currentItemWrapper;
      let bound = this[mainDim];
      if (bound === 0) {
        bound = directionIsRow ? 1920 : 1080;
      }
      const offset = Math.min(this.wrapper[main], this._scrollTransition && this._scrollTransition.targetValue || 0);
      const sizes = this._getItemSizes(cw);
      const marginFrom = sizes[mainMarginFrom] || sizes.margin || 0;
      const marginTo = sizes[mainMarginTo] || sizes.margin || 0;
      let scroll = this._scroll;
      if (!isNaN(scroll)) {
        if (scroll >= 0 && scroll <= 1) {
          scroll = bound * scroll - (cw[main] + cw[mainDim] * scroll);
        } else {
          scroll = scroll - cw[main];
        }
      } else if (typeof scroll === 'function') {
        scroll = scroll.apply(this, [cw, obj]);
      } else if (typeof scroll === 'object') {
        const {
          jump = false,
          after = false,
          backward = 0.0,
          forward = 1.0
        } = scroll;
        if (jump) {
          let mod = target % jump;
          if (mod === 0) {
            scroll = marginFrom - cw[main];
          }
          if (mod === jump - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = mod * actualSize + marginFrom - cw[main];
          }
        } else if (after) {
          scroll = 0;
          if (target >= after - 1) {
            const actualSize = marginFrom + cw[mainDim] + marginTo;
            scroll = (after - 1) * actualSize + marginFrom - cw[main];
          }
        } else {
          const backwardBound = bound * this._normalizePixelToPercentage(backward, bound);
          const forwardBound = bound * this._normalizePixelToPercentage(forward, bound);
          if (target < max - 1 && previous < target && offset + cw[main] + cw[mainDim] > forwardBound) {
            scroll = forwardBound - (cw[main] + cw[mainDim]);
          } else if (target > 0 && target < previous && offset + cw[main] < backwardBound) {
            scroll = backwardBound - cw[main];
          } else if (target === max - 1) {
            scroll = bound - (cw[main] + cw[mainDim]);
          } else if (target === 0) {
            scroll = marginFrom - cw[main];
          }
        }
      } else if (isNaN(scroll)) {
        if (previous < target && offset + cw[main] + cw[mainDim] > bound) {
          scroll = bound - (cw[main] + cw[mainDim]);
        } else if (target < previous && offset + cw[main] < 0) {
          scroll = marginFrom - cw[main];
        }
      }
      if (this.active && !isNaN(scroll) && this._scrollTransition) {
        if (immediate) {
          this._scrollTransition.reset(scroll, 1);
        } else {
          if (this._scrollTransition.isRunning()) {
            this._scrollTransition.reset(scroll, 0.05);
          } else {
            this._scrollTransition.start(scroll);
          }
        }
      } else if (!isNaN(scroll)) {
        this.wrapper[main] = scroll;
      }
    }
    $childInactive(_ref) {
      let {
        child
      } = _ref;
      if (typeof child === 'object') {
        const index = child.componentIndex;
        for (let key in this._items[index]) {
          if (child.component[key] !== undefined) {
            this._items[index][key] = child.component[key];
          }
        }
      }
      this._collectGarbage();
    }
    $getChildComponent(_ref2) {
      let {
        index
      } = _ref2;
      return this._items[index];
    }
    _resizeWrapper(crossSize) {
      let obj = crossSize;
      if (!isNaN(crossSize)) {
        const {
          main,
          mainDim,
          crossDim
        } = this._getPlotProperties(this._direction);
        const lastItem = this.wrapper.childList.last;
        obj = {
          [mainDim]: lastItem[main] + lastItem[mainDim],
          [crossDim]: crossSize
        };
      }
      this.wrapper.patch(obj);
      if (this._autoResize) {
        this.patch(obj);
      }
    }
    _generateUniqueID() {
      let id = '';
      while (this._uids[id] || id === '') {
        id = Math.random().toString(36).substring(2, 9);
      }
      this._uids[id] = true;
      return id;
    }
    _getPlotProperties(direction) {
      const directionIsRow = direction === 0;
      return {
        directionIsRow: directionIsRow ? true : false,
        mainDirection: directionIsRow ? 'rows' : 'columns',
        main: directionIsRow ? 'x' : 'y',
        mainDim: directionIsRow ? 'w' : 'h',
        mainMarginTo: directionIsRow ? 'marginRight' : 'marginBottom',
        mainMarginFrom: directionIsRow ? 'marginLeft' : 'marginTop',
        crossDirection: !directionIsRow ? 'columns' : 'rows',
        cross: directionIsRow ? 'y' : 'x',
        crossDim: directionIsRow ? 'h' : 'w',
        crossMarginTo: directionIsRow ? 'marginBottom' : 'marginRight',
        crossMarginFrom: directionIsRow ? 'marginTop' : 'marginLeft'
      };
    }
    _getItemSizes(item) {
      const itemType = item.type;
      if (item.component && item.component.__attached) {
        item = item.component;
      }
      return {
        w: item.w || itemType && itemType['width'],
        h: item.h || itemType && itemType['height'],
        margin: item.margin || itemType && itemType['margin'] || 0,
        marginLeft: item.marginLeft || itemType && itemType['marginLeft'],
        marginRight: item.marginRight || itemType && itemType['marginRight'],
        marginTop: item.marginTop || itemType && itemType['marginTop'],
        marginBottom: item.marginBottom || itemType && itemType['marginBottom']
      };
    }
    _collectGarbage(immediate) {
      this._gcIncrement++;
      if (immediate || this.active && this._gcThreshold !== 0 && this._gcIncrement >= this._gcThreshold) {
        this._gcIncrement = 0;
        this.stage.gc();
      }
    }
    _normalizeDataItems(array) {
      return array.map((item, index) => {
        return this._normalizeDataItem(item) || index;
      }).filter(item => {
        if (!isNaN(item)) {
          console.warn("Item at index: ".concat(item, ", is not a valid item. Removing it from dataset"));
          return false;
        }
        return true;
      });
    }
    _normalizeDataItem(item, index) {
      if (typeof item === 'string' || typeof item === 'number') {
        item = {
          label: item.toString()
        };
      }
      if (typeof item === 'object') {
        let id = this._generateUniqueID();
        return {
          assignedID: id,
          type: this.itemType,
          collectionWrapper: this,
          isAlive: false,
          ...item
        };
      }
      return index;
    }
    _normalizePixelToPercentage(value, max) {
      if (value && value > 1) {
        return value / max;
      }
      return value || 0;
    }
    _getFocused() {
      if (this.hasItems) {
        return this.currentItemWrapper;
      }
      return this;
    }
    _handleRight() {
      return this.right();
    }
    _handleLeft() {
      return this.left();
    }
    _handleUp() {
      return this.up();
    }
    _handleDown() {
      return this.down();
    }
    _inactive() {
      if (this._repositionDebounce) {
        clearTimeout(this._repositionDebounce);
      }
      this._collectGarbage(true);
    }
    static get itemType() {
      return undefined;
    }
    set forceLoad(bool) {
      this._forceLoad = bool;
    }
    get forceLoad() {
      return this._forceLoad;
    }
    get requestingItems() {
      return this._requestingItems;
    }
    set requestThreshold(num) {
      this._requestThreshold = num;
    }
    get requestThreshold() {
      return this._requestThreshold;
    }
    set enableRequests(bool) {
      this._requestsEnabled = bool;
    }
    get enableRequests() {
      return this._requestsEnabled;
    }
    set gcThreshold(num) {
      this._gcThreshold = num;
    }
    get gcThreshold() {
      return this._gcThreshold;
    }
    get wrapper() {
      return this.tag('Wrapper');
    }
    get hasItems() {
      return this.wrapper && this.wrapper.children && this.wrapper.children.length > 0;
    }
    get currentItemWrapper() {
      return this.wrapper.children[this._index];
    }
    get currentItem() {
      return this.currentItemWrapper && this.currentItemWrapper.component || undefined;
    }
    set direction(string) {
      this._direction = CollectionWrapper.DIRECTION[string] || CollectionWrapper.DIRECTION.row;
    }
    get direction() {
      return Object.keys(CollectionWrapper.DIRECTION)[this._direction];
    }
    set items(array) {
      this.clear();
      this.add(array);
    }
    get items() {
      const itemWrappers = this.itemWrappers;
      return this._items.map((item, index) => {
        if (itemWrappers[index] && itemWrappers[index].component.isAlive) {
          return itemWrappers[index].component;
        }
        return item;
      });
    }
    get length() {
      return this._items.length;
    }
    set index(index) {
      this.setIndex(index);
    }
    get itemWrappers() {
      return this.wrapper.children;
    }
    get index() {
      return this._index;
    }
    set scrollTransition(obj) {
      this._scrollTransitionSettings.patch(obj);
      if (this.active) {
        this._updateScrollTransition();
      }
    }
    get scrollTransition() {
      return this._scrollTransition;
    }
    set scroll(value) {
      this._scroll = value;
    }
    get scroll() {
      return this._scroll;
    }
    set autoResize(bool) {
      this._autoResize = bool;
    }
    get autoResize() {
      return this._autoResize;
    }
    set spacing(num) {
      this._spacing = num;
    }
    get spacing() {
      return this._spacing;
    }
  }
  CollectionWrapper.DIRECTION = {
    row: 0,
    column: 1
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Cursor extends t.Component {
    static _template() {
      return {
        alpha: 0
      };
    }
    _construct() {
      this._blink = true;
    }
    _init() {
      this._blinkAnimation = this.animation({
        duration: 1,
        repeat: -1,
        actions: [{
          p: 'alpha',
          v: {
            0: 0,
            0.5: 1,
            1: 0
          }
        }]
      });
    }
    show() {
      if (this._blink) {
        this._blinkAnimation.start();
      } else {
        this.alpha = 1;
      }
    }
    hide() {
      if (this._blink) {
        this._blinkAnimation.stop();
      } else {
        this.alpha = 0;
      }
    }
    set blink(bool) {
      this._blink = bool;
      if (this.active) {
        if (bool) {
          this.show();
        } else {
          this.hide();
        }
      }
    }
    get blink() {
      return this._blink;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ItemWrapper extends t.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    create() {
      if (this.children.length > 0) {
        return;
      }
      const component = this.fireAncestors('$getChildComponent', {
        index: this.componentIndex
      });
      component.isAlive = true;
      const {
        w,
        h,
        margin,
        marginTop,
        marginBottom,
        marginRight,
        marginLeft
      } = this;
      this.children = [{
        ...component,
        w,
        h,
        margin,
        marginTop,
        marginRight,
        marginLeft,
        marginBottom
      }];
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    get component() {
      return this.children[0] || this.fireAncestors('$getChildComponent', {
        index: this.componentIndex
      });
    }
    _setup() {
      if (this.forceLoad) {
        this.create();
      }
    }
    _active() {
      this.create();
    }
    _inactive() {
      if (!this.forceLoad) {
        this.children[0].isAlive = false;
        this.fireAncestors('$childInactive', {
          child: this
        });
        this.childList.clear();
      }
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class KeyWrapper extends t.Component {
    static _template() {
      return {
        clipbox: true
      };
    }
    _update() {
      let currentKey = this.children && this.children[0];
      if (currentKey && currentKey.action === this._key.data.action) {
        currentKey.patch({
          ...this._key
        });
      } else {
        this.children = [{
          type: this._key.keyType,
          ...this._key
        }];
      }
      if (this.hasFocus()) {
        this._refocus();
      }
    }
    set key(obj) {
      this._key = obj;
      if (this.active) {
        this._update();
      }
    }
    get key() {
      return this._key;
    }
    _active() {
      this._update();
    }
    _inactive() {
      this.childList.clear();
    }
    _getFocused() {
      return this.children && this.children[0] || this;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const limitWithinRange = (num, min, max) => {
    return Math.min(Math.max(num, min), max);
  };
  const defineProperties = (component, props) => {
    props.forEach(prop => {
      Object.defineProperty(component, prop, {
        set: function (value) {
          component["_".concat(prop)] = value;
        },
        get: function () {
          return component["_".concat(prop)];
        }
      });
    });
  };
  const findIndexOfObject = (array, search, targetProp) => {
    for (let i = 0; i < array.length; i++) {
      if (array[i][targetProp] === search) {
        return i;
      }
    }
    return -1;
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Grid extends CollectionWrapper {
    _construct() {
      this._crossSpacing = 5;
      this._mainSpacing = 5;
      this._rows = 0;
      this._columns = 0;
      super._construct();
    }
    clear() {
      super.clear();
      this._mainIndex = 0;
      this._crossIndex = 0;
      this._previous = undefined;
    }
    setIndex(index) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this._requestsEnabled && index > this._items.length - 1) {
        if (!this._requestingItems) {
          this._requestMore(index, [], options);
        }
        return true;
      }
      if (this._items.length === 0) {
        this._mainIndex = 0;
        this._crossIndex = 0;
        this._index = 0;
        return false;
      }
      const targetIndex = limitWithinRange(index, 0, this._items.length - 1);
      const previousIndex = this._index;
      const {
        mainIndex: previousMainIndex,
        crossIndex: previousCrossIndex
      } = this._findLocationOfIndex(previousIndex);
      const {
        mainIndex,
        crossIndex
      } = this._findLocationOfIndex(targetIndex);
      this._mainIndex = mainIndex;
      this._crossIndex = crossIndex;
      this._previous = {
        mainIndex,
        crossIndex,
        realIndex: previousIndex
      };
      this._index = targetIndex;
      this._indexChanged({
        previousIndex,
        index: targetIndex,
        mainIndex,
        previousMainIndex,
        crossIndex,
        previousCrossIndex,
        lines: this._lines.length,
        dataLength: this._items.length
      }, options);
      return previousIndex !== targetIndex;
    }
    _findLocationOfIndex(index) {
      for (let i = 0; i < this._lines.length; i++) {
        if (this._lines[i].includes(index)) {
          return {
            mainIndex: i,
            crossIndex: this._lines[i].indexOf(index)
          };
        }
      }
      return {
        mainIndex: -1,
        crossIndex: -1
      };
    }
    plotItems() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        immediate = false
      } = options;
      const items = this._items;
      const wrapper = this.wrapper;
      const {
        directionIsRow,
        mainDirection,
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim,
        crossMarginTo,
        crossMarginFrom
      } = this._getPlotProperties(this._direction);
      const crossSize = this[crossDim];
      let mainPos = 0,
        crossPos = 0,
        lineIndex = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      this._lines = [[]];
      //create empty line array
      let cl = [];
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
        if (index === 0) {
          mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
          const bil = this._getBiggestInLine(cl);
          mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
          crossPos = targetCrossFromMargin;
          this._lines.push([]);
          cl = [];
          lineIndex++;
        } else {
          crossPos += targetCrossFromMargin;
        }
        const ref = "IW-".concat(item.assignedID);
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext["p".concat(main)] + wrapper[main] + mainPos <= viewboundMain || renderContext["p".concat(cross)] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        const newItem = {
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad,
          ...sizes,
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: tmp,
          [cross]: tcp
        };
        crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
        this._lines[lineIndex].push(index);
        cl.push(newItem);
        return newItem;
      });
      wrapper.children = newChildren;
      animateItems.forEach(index => {
        const item = wrapper.children[index];
        if (immediate) {
          item.patch({
            x: item.assignedX,
            y: item.assignedY
          });
        } else {
          item.patch({
            smooth: {
              x: item.assignedX,
              y: item.assignedY
            }
          });
        }
      });
      const biggestInLastLine = this._getBiggestInLine(cl);
      this._resizeWrapper({
        [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
        [crossDim]: crossSize
      });
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const {
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim,
        crossMarginTo,
        crossMarginFrom
      } = this._getPlotProperties(this._direction);
      const crossSize = this[crossDim];
      let mainPos = 0,
        crossPos = 0,
        lineIndex = 0;

      //create empty line array
      let cl = [];
      this.lines = [[]];
      wrapper.children.forEach((item, index) => {
        const sizes = this._getItemSizes(item);
        const targetCrossFromMargin = sizes[crossMarginFrom] || sizes.margin || 0;
        if (index === 0) {
          mainPos += sizes[mainMarginFrom] || sizes.margin || 0;
        }
        if (cl.length > 0 && (this[mainDirection] > 0 && this[mainDirection] === cl.length || this[mainDirection] === 0 && crossPos + targetCrossFromMargin + sizes[crossDim] > crossSize)) {
          const bil = this._getBiggestInLine(cl);
          mainPos = bil[main] + bil[mainDim] + (bil[mainMarginTo] || bil.margin || this._mainSpacing);
          crossPos = targetCrossFromMargin;
          this._lines.push([]);
          cl = [];
          lineIndex++;
        } else {
          crossPos += targetCrossFromMargin;
        }
        item.patch({
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: mainPos,
          [cross]: crossPos
        });
        crossPos += sizes[crossDim] + (sizes[crossMarginTo] || sizes.margin || this._crossSpacing);
        this._lines[lineIndex].push(index);
        cl.push(item);
      });
      const biggestInLastLine = this._getBiggestInLine(cl);
      this._resizeWrapper({
        [mainDim]: biggestInLastLine[main] + biggestInLastLine[mainDim],
        [crossDim]: crossSize
      });
      super.repositionItems();
    }
    _getBiggestInLine(line) {
      const {
        mainDim
      } = this._getPlotProperties(this._direction);
      return line.reduce((biggestItem, newItem) => {
        if (newItem[mainDim] > biggestItem[mainDim]) {
          return newItem;
        }
        return biggestItem;
      });
    }
    navigate(shift, direction) {
      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const {
        directionIsRow,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      const overCross = directionIsRow && direction === CollectionWrapper.DIRECTION.column || !directionIsRow && direction === CollectionWrapper.DIRECTION.row;
      let targetMainIndex = this._mainIndex + !!!overCross * shift;
      let targetCrossIndex = this._crossIndex + !!overCross * shift;
      let targetIndex = this._index;
      if (overCross && targetCrossIndex > -1 && targetCrossIndex <= this._lines[targetMainIndex].length) {
        if (this._lines[targetMainIndex][targetCrossIndex] !== undefined) {
          targetIndex = this._lines[targetMainIndex][targetCrossIndex];
          this._previous = undefined;
        }
      } else if (!overCross && targetMainIndex < this._lines.length && targetMainIndex > -1) {
        const targetLine = this._lines[targetMainIndex];
        if (this._previous && this._previous.mainIndex === targetMainIndex) {
          targetIndex = this._previous.realIndex;
          targetCrossIndex = this._previous.crossIndex;
        } else if (targetLine) {
          const currentItem = this.currentItemWrapper;
          const m = targetLine.map(item => {
            const targetItem = this.wrapper.children[item];
            if (targetItem[cross] <= currentItem[cross] && currentItem[cross] <= targetItem[cross] + targetItem[crossDim]) {
              return targetItem[cross] + targetItem[crossDim] - currentItem[cross];
            }
            if (targetItem[cross] >= currentItem[cross] && targetItem[cross] <= currentItem[cross] + currentItem[crossDim]) {
              return currentItem[cross] + currentItem[crossDim] - targetItem[cross];
            }
            return -1;
          });
          let acc = -1;
          let t = -1;
          for (let i = 0; i < m.length; i++) {
            if (m[i] === -1 && acc > -1) {
              break;
            }
            if (m[i] > acc) {
              acc = m[i];
              t = i;
            }
          }
          if (t > -1) {
            targetCrossIndex = t;
            targetIndex = targetLine[t];
          }
        }
        this._previous = {
          mainIndex: this._mainIndex,
          crossIndex: this._crossIndex,
          realIndex: this._index
        };
      }
      if (this._index !== targetIndex) {
        this.setIndex(targetIndex, options);
        return true;
      }
      return false;
    }
    set rows(num) {
      this._rows = num;
      this.direction = 'row';
    }
    get rows() {
      return this._rows;
    }
    set columns(num) {
      this._columns = num;
      this.direction = 'column';
    }
    get columns() {
      return this._columns;
    }
    set crossSpacing(num) {
      this._crossSpacing = num;
    }
    get crossSpacing() {
      return this._crossSpacing;
    }
    set mainSpacing(num) {
      this._mainSpacing = num;
    }
    get mainSpacing() {
      return this._mainSpacing;
    }
    set spacing(num) {
      this._spacing = num;
      this._mainSpacing = num;
      this._crossSpacing = num;
    }
    get spacing() {
      return this._spacing;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class InputField extends t.Component {
    static _template() {
      return {
        PreLabel: {
          renderOffscreen: true
        },
        PostLabel: {
          renderOffscreen: true
        },
        Cursor: {
          type: Cursor,
          rect: true,
          w: 4,
          h: 54,
          x: 0,
          y: 0
        }
      };
    }
    _construct() {
      this._input = '';
      this._previousInput = '';
      this._description = '';
      this._cursorX = 0;
      this._cursorIndex = 0;
      this._passwordMask = '*';
      this._passwordMode = false;
      this._autoHideCursor = true;
      this._labelPositionStatic = true;
      this._maxLabelWidth = 0;
    }
    _init() {
      this.tag('PreLabel').on('txLoaded', () => {
        this._labelTxLoaded();
      });
      this.tag('PostLabel').on('txLoaded', () => {
        this._labelTxLoaded;
      });
    }
    onInputChanged(_ref) {
      let {
        input = ''
      } = _ref;
      let targetIndex = Math.max(input.length - this._input.length + this._cursorIndex, 0);
      this._input = input;
      this._update(targetIndex);
    }
    toggleCursor() {
      let bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this._cursorVisible;
      this._cursorVisible = bool;
      this.cursor[bool ? 'show' : 'hide']();
    }
    _labelTxLoaded() {
      const preLabel = this.tag('PreLabel');
      const cursor = this.tag('Cursor');
      const postLabel = this.tag('PostLabel');
      this.h = preLabel.renderHeight || postLabel.renderHeight;
      cursor.x = preLabel.renderWidth + this._cursorX;
      postLabel.x = cursor.x + cursor.w * (1 - cursor.mountX);
      this.setSmooth('x', this._labelOffset);
      if (!this.autoHideCursor) {
        this.toggleCursor(true);
      }
    }
    _update() {
      let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      const hasInput = this._input.length > 0;
      let pre = this._description + '';
      let post = '';
      if (hasInput) {
        pre = this._input.substring(0, index);
        post = this._input.substring(index, this._input.length);
        if (this._passwordMode) {
          pre = this._passwordMask.repeat(pre.length);
          post = this._passwordMask.repeat(post.length);
        }
        this.toggleCursor(true);
      } else if (this._autoHideCursor) {
        this.toggleCursor(false);
      }
      this.patch({
        PreLabel: {
          text: {
            text: pre
          }
        },
        PostLabel: {
          text: {
            text: post
          }
        }
      });
      if (this.h === 0) {
        this.tag('PreLabel').loadTexture();
        this.h = this.tag('PreLabel').renderHeight;
      }
      this._cursorIndex = index;
    }
    _handleRight() {
      this._update(Math.min(this._input.length, this._cursorIndex + 1));
    }
    _handleLeft() {
      this._update(Math.max(0, this._cursorIndex - 1));
    }
    _firstActive() {
      this._labelTxLoaded();
      this._update();
    }
    get input() {
      return this._input;
    }
    get hasInput() {
      return this._input.length > 0;
    }
    get cursorIndex() {
      return this._cursorIndex;
    }
    set inputText(obj) {
      this._inputText = obj;
      this.tag('PreLabel').patch({
        text: obj
      });
      this.tag('PostLabel').patch({
        text: obj
      });
    }
    get inputText() {
      return this._inputText;
    }
    set description(str) {
      this._description = str;
    }
    get description() {
      return this._description;
    }
    set cursor(obj) {
      if (obj.x) {
        this._cursorX = obj.x;
        delete obj.x;
      }
      this.tag('Cursor').patch(obj);
    }
    get cursor() {
      return this.tag('Cursor');
    }
    get cursorVisible() {
      return this._cursorVisible;
    }
    set autoHideCursor(bool) {
      this._autoHideCursor = bool;
    }
    get autoHideCursor() {
      return this._autoHideCursor;
    }
    set passwordMode(val) {
      this._passwordMode = val;
    }
    get passwordMode() {
      return this._passwordMode;
    }
    set passwordMask(str) {
      this._passwordMask = str;
    }
    get passwordmask() {
      return this._passwordMask;
    }

    // the width at which the text start scrolling
    set maxLabelWidth(val) {
      this._maxLabelWidth = val;
    }
    get maxLabelWidth() {
      return this._maxLabelWidth;
    }
    set labelPositionStatic(val) {
      this._labelPositionStatic = val;
    }
    get labelPositionStatic() {
      return this._labelPositionStatic;
    }
    get _labelOffset() {
      if (this._labelPositionStatic) return 0;
      let offset = this.maxLabelWidth - this.tag('Cursor').x;
      return offset < 0 ? offset : 0;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Key$1 extends t.Component {
    static _template() {
      return {
        Background: {
          w: w => w,
          h: h => h,
          rect: true
        },
        Label: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }
    _construct() {
      this._backgroundColors = {};
      this._labelColors = {};
    }
    set data(obj) {
      this._data = obj;
      this._update();
    }
    get data() {
      return this._data;
    }
    set labelText(obj) {
      this._labelText = obj;
      this.tag('Label').patch({
        text: obj
      });
    }
    get labelText() {
      return this._labelText;
    }
    set label(obj) {
      this.tag('Label').patch(obj);
    }
    get label() {
      return this.tag('Label');
    }
    set labelColors(obj) {
      this._labelColors = obj;
      this._update();
    }
    get labelColors() {
      return this._labelColors;
    }
    set backgroundColors(obj) {
      this._backgroundColors = obj;
      this._update();
    }
    get backgroundColors() {
      return this._backgroundColors;
    }
    set background(obj) {
      this.tag('Background').patch(obj);
    }
    get background() {
      return this.tag('Background');
    }
    _update() {
      if (!this.active) {
        return;
      }
      const {
        label = ''
      } = this._data;
      const hasFocus = this.hasFocus();
      let {
        focused,
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        focused: labelFocused,
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          color: hasFocus && focused ? focused : unfocused
        },
        Label: {
          text: {
            text: label
          },
          color: hasFocus && labelFocused ? labelFocused : labelUnfocused
        }
      });
    }
    _firstActive() {
      this._update();
    }
    _focus() {
      let {
        focused,
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        focused: labelFocused,
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          smooth: {
            color: focused || unfocused
          }
        },
        Label: {
          smooth: {
            color: labelFocused || labelUnfocused
          }
        }
      });
    }
    _unfocus() {
      let {
        unfocused = 0xff000000
      } = this._backgroundColors;
      let {
        unfocused: labelUnfocused = 0xffffffff
      } = this._labelColors;
      this.patch({
        Background: {
          smooth: {
            color: unfocused
          }
        },
        Label: {
          smooth: {
            color: labelUnfocused
          }
        }
      });
    }
    static get width() {
      return 80;
    }
    static get height() {
      return 80;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class Keyboard$2 extends t.Component {
    static _template() {
      return {
        Keys: {
          w: w => w
        }
      };
    }
    _construct() {
      this._input = '';
      this._inputField = undefined;
      this._maxCharacters = 56;
      this.navigationWrapAround = false;
      this._snapToRow = false;
      this.resetFocus();
    }
    resetFocus() {
      this._columnIndex = 0;
      this._rowIndex = 0;
      this._previousKey = null;
    }
    _setup() {
      this._keys = this.tag('Keys');
      this._update();
    }
    _update() {
      const {
        layouts,
        buttonTypes = {},
        styling = {}
      } = this._config;
      if (!this._layout || this._layout && layouts[this._layout] === undefined) {
        console.error("Configured layout \"".concat(this._layout, "\" does not exist. Picking first available: \"").concat(Object.keys(layouts)[0], "\""));
        this._layout = Object.keys(layouts)[0];
      }
      const {
        horizontalSpacing = 0,
        verticalSpacing = 0,
        align = 'left'
      } = styling;
      let rowPosition = 0;
      const isEvent = /^[A-Z][A-Za-z0-9]{1}/;
      const hasLabel = /\:/;
      if (buttonTypes.default === undefined) {
        buttonTypes.default = Key$1;
      }
      this._keys.children = layouts[this._layout].map((row, rowIndex) => {
        const {
          x = 0,
          margin = 0,
          marginRight,
          marginLeft,
          marginTop,
          marginBottom,
          spacing: rowHorizontalSpacing = horizontalSpacing || 0,
          align: rowAlign = align
        } = styling["Row".concat(rowIndex + 1)] || {};
        let keyPosition = 0;
        let rowHeight = 0;
        const rowKeys = row.map((key, keyIndex) => {
          const origin = key;
          let keyType = buttonTypes.default;
          let action = 'Input';
          let label = key;
          if (isEvent.test(key)) {
            if (hasLabel.test(key)) {
              key = key.split(':');
              label = key[1].toString();
              key = key[0];
            }
            if (buttonTypes[key]) {
              keyType = buttonTypes[key];
              action = key.action || key;
            }
          }
          let keySpacing = keyType && keyType.margin || 0;
          let w = 0;
          let h = 0;
          let marginLeft = 0;
          let marginRight = rowHorizontalSpacing;
          if (keyType.type) {
            keySpacing = keyType.type.margin || keySpacing;
            w = keyType.type.width || w;
            h = keyType.type.height || h;
            marginLeft = keyType.type.marginLeft || marginLeft;
            marginRight = keyType.type.marginRight || marginRight;
          }
          w = keyType.w || w;
          h = keyType.h || h;
          rowHeight = h > rowHeight ? h : rowHeight;
          const currentPosition = keyPosition + marginLeft;
          keyPosition += marginLeft + w + marginRight;
          return {
            ref: "Key-{".concat(keyIndex + 1, "}"),
            type: KeyWrapper,
            keyboard: this,
            x: currentPosition,
            w,
            h,
            key: {
              data: {
                origin,
                key,
                label,
                action
              },
              w,
              h,
              ...keyType
            }
          };
        });
        let rowOffset = x + (marginLeft || margin);
        let rowMount = 0;
        if (this.w && rowAlign === 'center') {
          rowOffset = this.w / 2;
          rowMount = 0.5;
        }
        if (this.w && rowAlign === 'right') {
          rowOffset = this.w - (marginRight || margin);
          rowMount = 1;
        }
        const currentPosition = rowPosition + (marginTop || margin);
        rowPosition = currentPosition + rowHeight + (marginBottom || margin || verticalSpacing);
        return {
          ref: "Row-".concat(rowIndex + 1),
          x: rowOffset,
          mountX: rowMount,
          w: keyPosition,
          y: currentPosition,
          children: rowKeys
        };
      });
      this._refocus();
    }
    _getFocused() {
      return this.currentKeyWrapper || this;
    }
    _handleRight() {
      return this.navigate('row', 1);
    }
    _handleLeft() {
      return this.navigate('row', -1);
    }
    _handleUp() {
      return this.navigate('column', -1);
    }
    _handleDown() {
      return this.navigate('column', 1);
    }
    _handleKey(_ref) {
      let {
        key,
        code = 'CustomKey'
      } = _ref;
      if (code === 'Backspace' && this._input.length === 0) {
        return false;
      }
      if (key === ' ') {
        key = 'Space';
      }
      const targetFound = this._findKey(key);
      if (targetFound) {
        this._handleEnter();
      }
      return targetFound;
    }
    _findKey(str) {
      const rows = this._config.layouts[this._layout];
      let i = 0,
        j = 0;
      for (; i < rows.length; i++) {
        for (j = 0; j < rows[i].length; j++) {
          let key = rows[i][j];
          if (str.length > 1 && key.indexOf(str) > -1 || key.toUpperCase() === str.toUpperCase()) {
            this._rowIndex = i;
            this._columnIndex = j;
            return true;
          }
        }
      }
      return false;
    }
    _handleEnter() {
      const {
        origin,
        action
      } = this.currentKey.data;
      const event = {
        index: this._input.length,
        key: origin
      };
      if (this._inputField && this._inputField.cursorIndex) {
        event.index = this._inputField.cursorIndex;
      }
      if (action !== 'Input') {
        const split = event.key.split(':');
        const call = "on".concat(split[0]);
        const eventFunction = this[call];
        event.key = split[1];
        if (eventFunction && eventFunction.apply && eventFunction.call) {
          eventFunction.call(this, event);
        }
        this.signal(call, {
          input: this._input,
          keyboard: this,
          ...event
        });
      } else {
        this.addAt(event.key, event.index);
      }
    }
    _changeInput(input) {
      if (input.length > this._maxCharacters) {
        return;
      }
      const eventData = {
        previousInput: this._input,
        input: this._input = input
      };
      if (this._inputField && this._inputField.onInputChanged) {
        this._inputField.onInputChanged(eventData);
      }
      this.signal('onInputChanged', eventData);
    }
    focus(str) {
      this._findKey(str);
    }
    add(str) {
      this._changeInput(this._input + str);
    }
    addAt(str, index) {
      if (index > this._input.length - 1) {
        this.add(str);
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index) + str + this._input.substring(index, this._input.length));
      }
    }
    remove() {
      this._changeInput(this._input.substring(0, this._input.length - 1));
    }
    removeAt(index) {
      if (index > this._input.length - 1) {
        this.remove();
      } else if (index > -1) {
        this._changeInput(this._input.substring(0, index - 1) + this._input.substring(index, this._input.length));
      }
    }
    clear() {
      this._changeInput('');
    }
    layout(key) {
      if (key === this._layout) {
        return;
      }
      this._layout = key;
      if (this.attached) {
        this.resetFocus();
        this._update();
      }
    }
    inputField(component) {
      if (component && component.isComponent) {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = component.input !== undefined ? component.input : '';
        this._inputField = component;
      } else {
        this._rowIndex = 0;
        this._columnIndex = 0;
        this._input = '';
        this._inputField = undefined;
      }
    }
    _findKeyInRow(currentKey, currentRow, targetRow) {
      const currentX = currentRow.x - currentRow.w * currentRow.mountX + currentKey.x;
      const m = targetRow.children.map(key => {
        const keyX = targetRow.x - targetRow.w * targetRow.mountX + key.x;
        if (keyX <= currentX && (this._snapToRow || currentX < keyX + key.w)) {
          return keyX + key.w - currentX;
        }
        if (keyX >= currentX && (this._snapToRow || keyX < currentX + currentKey.w)) {
          return currentX + currentKey.w - keyX;
        }
        return -1;
      });
      if (!this._snapToRow) {
        let acc = -1;
        let t = -1;
        for (let i = 0; i < m.length; i++) {
          if (m[i] === -1 && acc > -1) {
            break;
          }
          if (m[i] > acc) {
            acc = m[i];
            t = i;
          }
        }
        return t;
      }
      let t = m.indexOf(currentKey.w);
      if (t === -1 && m.length > 0) {
        let acc = this.w;
        for (let i = 0; i < m.length; i++) {
          if (m[i] >= 0) {
            const cutoff = currentX + currentKey.w - currentX - m[i];
            if (cutoff < acc) {
              acc = cutoff;
              t = i;
            }
          }
        }
        if (t === -1) {
          acc = this.w;
          for (let i = 0; i < m.length; i++) {
            if (Math.abs(m[i]) < acc) {
              acc = Math.abs(m[i]);
              t = i;
            }
          }
        }
      }
      return t;
    }
    navigate(direction, shift) {
      const targetIndex = (direction === 'row' ? this._columnIndex : this._rowIndex) + shift;
      const currentRow = this.rows[this._rowIndex];
      if (direction === 'row' && targetIndex > -1 && targetIndex < currentRow.children.length) {
        this._previous = null;
        return this._columnIndex = targetIndex;
      } else if (direction === 'row' && this.navigationWrapAround) {
        this._previous = null;
        let rowLen = currentRow.children.length;
        return this._columnIndex = (targetIndex % rowLen + rowLen) % rowLen;
      }
      if (direction === 'column' && targetIndex > -1 && targetIndex < this.rows.length) {
        const currentRowIndex = this._rowIndex;
        const currentColumnIndex = this._columnIndex;
        if (this._previous && this._previous.row === targetIndex) {
          const tmp = this._previous.column;
          this._previous.column = this._columnIndex;
          this._columnIndex = tmp;
          this._rowIndex = this._previous.row;
        } else {
          const targetRow = this.rows[targetIndex];
          const currentKey = this.currentKeyWrapper;
          const currentRow = this.rows[this._rowIndex];
          let t = this._findKeyInRow(currentKey, currentRow, targetRow);
          if (t > -1) {
            this._rowIndex = targetIndex;
            this._columnIndex = t;
          } // if no next row found and wraparound is on, loop back to first row
          else if (this.navigationWrapAround) {
            t = this._findKeyInRow(currentKey, currentRow, this.rows[0]);
            this._columnIndex = t > -1 ? t : Math.min(this.rows[0].children.length - 1, this._columnIndex);
            return this._rowIndex = 0;
          }
        }
        if (this._rowIndex !== currentRowIndex) {
          this._previous = {
            column: currentColumnIndex,
            row: currentRowIndex
          };
          return this._rowIndex = targetIndex;
        }
      } else if (direction === 'column' && this.navigationWrapAround) {
        this._previous = {
          column: this._columnIndex,
          row: this._rowIndex
        };
        let nrRows = this.rows.length;
        this._rowIndex = (targetIndex % nrRows + nrRows) % nrRows;
        this._columnIndex = Math.min(this.rows[this._rowIndex].children.length - 1, this._columnIndex);
      }
      return false;
    }
    onSpace(_ref2) {
      let {
        index
      } = _ref2;
      this.addAt(' ', index);
    }
    onBackspace(_ref3) {
      let {
        index
      } = _ref3;
      this.removeAt(index);
    }
    onClear() {
      this.clear();
    }
    onLayout(_ref4) {
      let {
        key
      } = _ref4;
      this.layout(key);
    }
    set config(obj) {
      this._config = obj;
      if (this.active) {
        this._update();
      }
    }
    get config() {
      return this._config;
    }
    set currentInputField(component) {
      this.inputField(component);
    }
    get currentInputField() {
      return this._inputField;
    }
    set currentLayout(str) {
      this.layout(str);
    }
    get currentLayout() {
      return this._layout;
    }
    set maxCharacters(num) {
      this._maxCharacters = num;
    }
    get maxCharacters() {
      return this._maxCharacters;
    }
    set snapToRow(bool) {
      this._snapToRow = bool;
    }
    get snapToRow() {
      return true;
    }
    get rows() {
      return this._keys && this._keys.children;
    }
    get currentKeyWrapper() {
      return this.rows && this.rows[this._rowIndex] && this.rows[this._rowIndex].children[this._columnIndex];
    }
    get currentKey() {
      return this.currentKeyWrapper && this.currentKeyWrapper.key;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class List extends CollectionWrapper {
    plotItems() {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const {
        immediate = false
      } = options;
      const items = this._items;
      const wrapper = this.wrapper;
      const {
        directionIsRow,
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      let crossPos = 0,
        crossSize = 0,
        position = 0;
      const animateItems = [];
      const viewboundMain = directionIsRow ? 1920 : 1080;
      const viewboundCross = directionIsRow ? 1080 : 1920;
      const renderContext = this.core.renderContext;
      const newChildren = items.map((item, index) => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const ref = "IW-".concat(item.assignedID);
        let mainPos = position;
        crossPos = item[cross] || crossPos;
        let tmp = mainPos;
        let tcp = crossPos;
        const existingItemWrapper = wrapper.tag(ref);
        if (existingItemWrapper && (existingItemWrapper.active && (crossPos !== existingItemWrapper[cross] || mainPos !== existingItemWrapper[main]) || !existingItemWrapper.active && (renderContext["p".concat(main)] + wrapper[main] + mainPos <= viewboundMain || renderContext["p".concat(cross)] + wrapper[cross] + crossPos <= viewboundCross))) {
          tmp = existingItemWrapper[main];
          tcp = existingItemWrapper[cross];
          animateItems.push(index);
        }
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this._spacing);
        return {
          ref,
          type: ItemWrapper,
          componentIndex: index,
          forceLoad: this._forceLoad,
          ...sizes,
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: crossPos,
          [main]: tmp,
          [cross]: tcp
        };
      });
      wrapper.children = newChildren;
      animateItems.forEach(index => {
        const item = wrapper.children[index];
        if (immediate) {
          item.patch({
            x: item.assignedX,
            y: item.assignedY
          });
        } else {
          item.patch({
            smooth: {
              x: item.assignedX,
              y: item.assignedY
            }
          });
        }
      });
      this._resizeWrapper(crossSize);
    }
    repositionItems() {
      const wrapper = this.wrapper;
      if (!wrapper && wrapper.children.length) {
        return true;
      }
      const {
        main,
        mainDim,
        mainMarginTo,
        mainMarginFrom,
        cross,
        crossDim
      } = this._getPlotProperties(this._direction);
      let crossPos = 0,
        crossSize = 0,
        position = 0;
      wrapper.children.forEach(item => {
        const sizes = this._getItemSizes(item);
        position += sizes[mainMarginFrom] || sizes.margin || 0;
        crossPos = item[cross] || crossPos;
        if (crossSize < sizes[crossDim]) {
          crossSize = sizes[crossDim];
        }
        const mainPos = position;
        position += sizes[mainDim] + (sizes[mainMarginTo] || sizes.margin || this.spacing);
        item.patch({
          ["assigned".concat(main.toUpperCase())]: mainPos,
          ["assigned".concat(cross.toUpperCase())]: 0,
          [main]: mainPos,
          [cross]: crossPos,
          ...sizes
        });
      });
      this._resizeWrapper(crossSize);
      super.repositionItems();
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ScrollingLabel extends t.Component {
    static _template() {
      return {
        LabelClipper: {
          w: w => w,
          rtt: true,
          shader: {
            type: t.shaders.FadeOut
          },
          LabelWrapper: {
            Label: {
              renderOffscreen: true
            },
            LabelCopy: {
              renderOffscreen: true
            }
          }
        }
      };
    }
    _construct() {
      this._autoStart = true;
      this._scrollAnimation = false;
      this._fade = 30;
      this._spacing = 30;
      this._label = {};
      this._align = 'left';
      this._animationSettings = {
        delay: 0.7,
        repeat: -1,
        stopMethod: 'immediate'
      };
    }
    _init() {
      const label = this.tag('Label');
      label.on('txLoaded', () => {
        this._update(label);
        this._updateAnimation(label);
        if (this._autoStart) {
          this.start();
        }
      });
    }
    _update() {
      let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
      const renderWidth = label.renderWidth;
      const noScroll = renderWidth <= this.renderWidth;
      let labelPos = 0;
      if (noScroll && this._align !== 'left') {
        labelPos = (this.renderWidth - renderWidth) * ScrollingLabel.ALIGN[this._align];
      }
      this.tag('LabelClipper').patch({
        h: label.renderHeight,
        shader: {
          right: noScroll ? 0 : this._fade
        },
        LabelWrapper: {
          x: 0,
          Label: {
            x: labelPos
          },
          LabelCopy: {
            x: renderWidth + this._spacing
          }
        }
      });
    }
    _updateAnimation() {
      let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tag('Label');
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
      }
      if (label.renderWidth > this.renderWidth) {
        if (!this._animationSettings.duration) {
          this._animationSettings.duration = label.renderWidth / 50;
        }
        this._scrollAnimation = this.animation({
          ...this._animationSettings,
          actions: [{
            t: 'LabelWrapper',
            p: 'x',
            v: {
              sm: 0,
              0: 0,
              1.0: -(label.renderWidth + this._spacing)
            }
          }, {
            t: 'LabelClipper',
            p: 'shader.left',
            v: {
              0: 0,
              0.2: this._fade,
              0.8: this._fade,
              1.0: 0
            }
          }]
        });
      }
    }
    start() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag('LabelCopy').patch({
          text: this._label
        });
        this._scrollAnimation.start();
      }
    }
    stop() {
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this.tag('LabelCopy').text = '';
      }
    }
    set label(obj) {
      if (typeof obj === 'string') {
        obj = {
          text: obj
        };
      }
      this._label = {
        ...this._label,
        ...obj
      };
      this.tag('Label').patch({
        text: obj
      });
    }
    get label() {
      return this.tag('Label');
    }
    set align(pos) {
      this._align = pos;
    }
    get align() {
      return this._align;
    }
    set autoStart(bool) {
      this._autoStart = bool;
    }
    get autoStart() {
      return this._autoStart;
    }
    set repeat(num) {
      this.animationSettings = {
        repeat: num
      };
    }
    get repeat() {
      return this._animationSettings.repeat;
    }
    set delay(num) {
      this.animationSettings = {
        delay: num
      };
    }
    get delay() {
      return this._animationSettings.delay;
    }
    set duration(num) {
      this.animationSettings = {
        duration: num
      };
    }
    get duration() {
      return this._animationSettings.duration;
    }
    set animationSettings(obj) {
      this._animationSettings = {
        ...this._animationSettings,
        ...obj
      };
      if (this._scrollAnimation) {
        this._updateAnimation();
      }
    }
    get animationSettings() {
      return this._animationSettings;
    }
  }
  ScrollingLabel.ALIGN = {
    left: 0,
    center: 0.5,
    right: 1
  };

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  const calcCarouselNavigation = (dir, current, min, max) => {
    let target = current + dir;
    if (target < min) {
      target = max;
    }
    if (target > max) {
      target = min;
    }
    return target;
  };
  class Stepper extends t.Component {
    static _template() {
      return {
        h: 80,
        w: 574,
        Focus: {
          alpha: 0,
          w: w => w,
          h: h => h,
          rect: true
        },
        Label: {
          x: 30,
          y: h => h * 0.5,
          mountY: 0.5,
          text: {
            text: '',
            fontSize: 22
          }
        },
        ValueWrapper: {
          x: w => w - 30,
          w: 200,
          h: h => h,
          mountX: 1,
          Value: {
            x: w => w * 0.5,
            y: h => h * 0.5,
            mountX: 0.5,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 22
            }
          }
        }
      };
    }
    _construct() {
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._padding = 30;
      this._max = 100;
      this._min = 0;
      this._value = 50;
      this._options = undefined;
      this._label = 'label';
      this._focusAnimation = null;
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding', 'max', 'min', 'focusAnimation']);
    }
    _update() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          x: this._padding,
          color: this._labelColor,
          text: {
            text: this._label
          }
        },
        ValueWrapper: {
          x: w => w - this._padding,
          Value: {
            color: this._labelColor,
            text: {
              text: this.optionValue || this.value
            }
          }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Focus',
          p: 'alpha',
          v: {
            0: 0,
            1: 1
          }
        }, {
          t: 'Label',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.Value',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this._update();
    }
    _navigate(dir) {
      this.value = calcCarouselNavigation(dir, this._value, this._min, this._max);
      const event = {
        value: this._value
      };
      if (this._options) {
        event.options = this._options;
      }
      this.fireAncestors('$onValueChanged', event);
      this.signal('onValueChanged', event);
    }
    _handleLeft() {
      this._navigate(-1);
    }
    _handleRight() {
      this._navigate(1);
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set label(str) {
      this._label = str;
      if (this.active) {
        this.tag('Label').text.text = str;
      }
    }
    get label() {
      return this._label;
    }
    set value(str) {
      this._value = str;
      if (this.active) {
        this.tag('Value').text.text = this.optionValue || this._value;
      }
    }
    get value() {
      return this._value;
    }
    get optionValue() {
      return this._options && this._options[this._value] && this._options[this._value].label || undefined;
    }
    set options(arr) {
      const refactor = arr.map(option => {
        if (typeof option === 'string') {
          return {
            label: option
          };
        }
        return option;
      });
      this._value = 0;
      this._options = refactor;
      this._max = refactor.length - 1;
      this._update();
    }
    get options() {
      return this._options;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ArrowStepper extends Stepper {
    static _template() {
      return {
        ...super._template(),
        ValueWrapper: {
          x: w => w - 30,
          w: 200,
          h: h => h,
          mountX: 1,
          ArrowLeft: {
            y: h => h * 0.5,
            mountY: 0.5
          },
          Value: {
            x: w => w * 0.5,
            y: h => h * 0.5,
            mountX: 0.5,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 22
            }
          },
          ArrowRight: {
            y: h => h * 0.5,
            x: w => w,
            mountY: 0.5,
            mountX: 1
          }
        }
      };
    }
    _update() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          x: this._padding,
          color: this._labelColor,
          text: {
            text: this._label
          }
        },
        ValueWrapper: {
          x: w => w - this._padding,
          ArrowLeft: {
            color: this._labelColor
          },
          Value: {
            color: this._labelColor,
            text: {
              text: this.optionValue || this.value
            }
          },
          ArrowRight: {
            color: this._labelColor
          }
        }
      });
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Focus',
          p: 'alpha',
          v: {
            0: 0,
            1: 1
          }
        }, {
          t: 'ValueWrapper.ArrowLeft',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.Value',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }, {
          t: 'ValueWrapper.ArrowRight',
          p: 'color',
          v: {
            0: this._labelColor,
            1: this._labelColorFocused
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      const arrowLeft = this.tag('ArrowLeft');
      const arrowRight = this.tag('ArrowRight');
      if (!(arrowLeft.src !== undefined && arrowLeft.text !== null)) {
        arrowLeft.text = {
          text: '\u25c0',
          fontSize: 18
        };
      }
      if (!(arrowRight.src !== undefined && arrowRight.text !== null)) {
        arrowRight.text = {
          text: '\u25b6',
          fontSize: 18
        };
      }
      this._update();
    }
  }

  class ColorShift extends t.Component {
    static _template() {
      return {
        w: 574,
        h: 240,
        List: {
          type: List,
          w: w => w,
          h: h => h,
          forceLoad: true,
          spacing: 0,
          direction: 'column'
        }
      };
    }
    _construct() {
      this._autoColorShift = true;
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._options = [{
        type: 'neutral',
        label: 'normal'
      }, {
        type: 'protanopia',
        label: 'Protanopia'
      }, {
        type: 'deuteranopia',
        label: 'Deuteranopia'
      }, {
        type: 'tritanopia',
        label: 'Tritanopia'
      }, {
        type: 'monochromacy',
        label: 'Achromatopsia'
      }];
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'options', 'autoColorShift']);
    }
    _getFocused() {
      return this.tag('List');
    }
    _shiftColors() {
      if (this._autoColorShift && this.application && this.application.colorshift) {
        this.application.colorshift(this._settings.correction, this._settings);
      }
    }
    $onValueChanged() {
      const listItems = this.tag('List').items;
      const correction = listItems[0];
      this._settings = {
        correction: correction.options[correction.value].type,
        brightness: listItems[1].value,
        contrast: listItems[2].value,
        gamma: listItems[3].value
      };
      if (this._currentCorrection && this._settings.correction !== this._currentCorrection) {
        const steppers = listItems.slice(1);
        steppers.forEach(stepper => {
          stepper.value = 50;
        });
      }
      this._currentCorrection = this._settings.correction;
      this._shiftColors();
      this.signal('onColorShift', this._settings);
    }
    _update() {
      const list = this.tag('List');
      const steppers = ['Brightness', 'Contrast', 'Gamma'];
      const options = this._options;
      const settings = this._settings;
      const colors = {
        focusColor: this._focusColor,
        labelColor: this._labelColor,
        labelColorFocused: this._labelColorFocused
      };
      this._shiftColors();
      const settingItems = steppers.map(stepper => {
        const lowerC = stepper.toLocaleLowerCase();
        return {
          type: this["".concat(lowerC, "Component")],
          label: stepper,
          value: settings[lowerC],
          w: this.finalW,
          h: 80,
          ...colors
        };
      });
      settingItems.unshift({
        type: this.correctionComponent,
        options,
        value: findIndexOfObject(options, settings.correction, 'type'),
        label: 'Color adjustment',
        w: this.finalW,
        h: 80,
        ...colors
      });
      list.clear();
      list.add(settingItems);
    }
    _firstActive() {
      if (!this._settings) {
        this._settings = {
          correction: 'neutral',
          brightness: 50,
          contrast: 50,
          gamma: 50
        };
      }
      this._update();
    }
    set settings(obj) {
      this._settings = obj;
      if (this.active) {
        const listItems = this.tag('List').items;
        listItems[0] = findIndexOfObject(this._options, obj.correction, 'type');
        listItems[1] = obj.brightness || 50;
        listItems[2] = obj.contrast || 50;
        listItems[3] = obj.gamma || 50;
      }
    }
    get settings() {
      return this._settings;
    }
    get correctionTag() {
      return this.tag('List').items[0];
    }
    get brightnessTag() {
      return this.tag('List').items[1];
    }
    get contrastTag() {
      return this.tag('List').items[2];
    }
    get gammaTag() {
      return this.tag('List').items[3];
    }
    get adjustmentTags() {
      return this.tag('List').items;
    }
    set stepperComponent(component) {
      this._stepperComponent = component;
    }
    get stepperComponent() {
      return this._stepperComponent || ArrowStepper;
    }
    set correctionComponent(component) {
      this._correctionComponent = component;
    }
    get correctionComponent() {
      return this._correctionComponent || this.stepperComponent;
    }
    set brightnessComponent(component) {
      this._brightnessComponent = component;
    }
    get brightnessComponent() {
      return this._brightnessComponent || this.stepperComponent;
    }
    set contrastComponent(component) {
      this._contrastComponent = component;
    }
    get contrastComponent() {
      return this._contrastComponent || this.stepperComponent;
    }
    set gammaComponent(component) {
      this._gammaComponent = component;
    }
    get gammaComponent() {
      return this._gammaComponent || this.stepperComponent;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class CarouselItem extends t.Component {
    static _template() {
      return {
        Focus: {
          alpha: 0,
          x: w => w * 0.5,
          y: h => h * 0.5,
          mount: 0.5,
          w: 120,
          h: 50,
          rect: true,
          shader: {
            type: t.shaders.RoundedRectangle,
            radius: 25
          }
        },
        Label: {
          x: w => w * 0.5,
          y: h => h * 0.5,
          mount: 0.5,
          renderOffscreen: true,
          text: {
            text: '',
            fontSize: 22
          }
        }
      };
    }
    _construct() {
      this._focusColor = 0xff009245;
      this._labelColor = 0xff9d9d9d;
      this._labelColorFocused = 0xffffffff;
      this._padding = 40;
      defineProperties(this, ['focusColor', 'labelColor', 'labelColorFocused', 'padding']);
    }
    set label(str) {
      this.tag('Label').text.text = str;
      this._label = str;
    }
    get label() {
      return this._label;
    }
    _init() {
      const label = this.tag('Label');
      label.on('txLoaded', () => {
        this.patch({
          w: label.renderWidth,
          Focus: {
            w: label.renderWidth + this._padding * 2
          }
        });
        if (this.collectionWrapper) {
          this.collectionWrapper.reposition();
        }
      });
    }
    _focus() {
      this.patch({
        Focus: {
          smooth: {
            alpha: 1
          }
        },
        Label: {
          smooth: {
            color: this._labelColorFocused
          }
        }
      });
    }
    _unfocus(target) {
      if (target.isCarouselItem === true) {
        this.patch({
          Focus: {
            smooth: {
              alpha: 0
            }
          },
          Label: {
            smooth: {
              color: this._labelColor
            }
          }
        });
      }
    }
    _firstActive() {
      this.patch({
        Focus: {
          color: this._focusColor
        },
        Label: {
          color: this._labelColor
        }
      });
      if (this.cparent.componentIndex === this.collectionWrapper.currentItemWrapper.componentIndex) {
        this._focus();
      }
    }
    get isCarouselItem() {
      return true;
    }
    static get width() {
      return 120;
    }
    static get height() {
      return 50;
    }
  }

  /*
   * If not stated otherwise in this file or this component's LICENSE file the
   * following copyright and licenses apply:
   *
   * Copyright 2021 Metrological
   *
   * Licensed under the Apache License, Version 2.0 (the License);
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class ProgressBar extends t.Component {
    static _template() {
      return {
        w: 300,
        h: 10,
        Background: {
          w: w => w,
          h: h => h,
          rect: true,
          rtt: true,
          shader: {
            type: t.shaders.RoundedRectangle,
            radius: 5
          },
          Progress: {
            h: h => h,
            w: 10,
            rect: true,
            shader: {
              type: t.shaders.RoundedRectangle,
              radius: 0
            }
          }
        }
      };
    }
    _construct() {
      this._progressColor = 0xff009245;
      this._progressColorFocused = undefined;
      this._backgroundColor = 0xff9d9d9d;
      this._backgroundColorFocused = undefined;
      this._backgroundRadius = 5;
      this._progressRadius = 0;
      this.value = 0.5;
      defineProperties(this, ['progressColor', 'backgroundColor', 'progressColorFocused', 'backgroundColorFocused']);
    }
    progress(p) {
      if (p > 1) {
        p = p / 100;
      }
      this._value = p;
      this.tag('Progress').w = this.w * p;
    }
    _createFocusAnimation() {
      this._focusAnimation = this.animation({
        duration: 0.2,
        stopMethod: 'reverse',
        actions: [{
          t: 'Background',
          p: 'color',
          v: {
            0: this._backgroundColor,
            1: this._backgroundColorFocused || this._backgroundColor
          }
        }, {
          t: 'Background.Progress',
          p: 'color',
          v: {
            0: this._progressColor,
            1: this._progressColorFocused || this._progressColor
          }
        }]
      });
    }
    _firstActive() {
      if (!this._focusAnimation) {
        this._createFocusAnimation();
      }
      this.patch({
        Background: {
          color: this._backgroundColor,
          shader: {
            radius: this._backgroundRadius
          },
          Progress: {
            color: this._progressColor,
            shader: {
              radius: this._progressRadius
            }
          }
        }
      });
      this.progress(this._value);
      if (this.hasFocus()) {
        this._focus();
      }
    }
    _focus() {
      if (this._focusAnimation) {
        this._focusAnimation.start();
      }
    }
    _unfocus() {
      if (this._focusAnimation) {
        this._focusAnimation.stop();
      }
    }
    set value(p) {
      this._value = p;
      if (this.active) {
        this.progress(p);
      }
    }
    get value() {
      return this._value;
    }
    set backgroundRadius(num) {
      this._backgroundRadius = num;
      if (this.active) {
        this.tag('Background').shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    set progressRadius(num) {
      this._progressRadius = num;
      if (this.active) {
        this.tag('Progress').shader.radius = num;
      }
    }
    get progressRadius() {
      return this._progressRadius;
    }
    get backgroundTag() {
      return this.tag('Background');
    }
    get progressTag() {
      return this.tag('Progress');
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */


  const win$6 = typeof window !== 'undefined' ? window : {};

  let listener$1;
  const setMockListener$1 = func => { listener$1 = func; };

  let mock$4;
  const pending$1 = [];
  const eventMap$1 = {};

  let callback$1;
  let testHarness$1;

  if (win$6.__firebolt && win$6.__firebolt.testHarness) {
    testHarness$1 = win$6.__firebolt.testHarness;
  }

  function send$1(message) {
    console.debug('Sending message to transport: ' + message);
    let json = JSON.parse(message);

    // handle bulk sends
    if (Array.isArray(json)) {
      json.forEach(j => send$1(JSON.stringify(j)));
      return
    }

    let [module, method] = json.method.split('.');

    if (testHarness$1 && testHarness$1.onSend) {
      testHarness$1.onSend(module, method, json.params, json.id);
    }

    // store the ID of the first listen for each event
    if (method.match(/^on[A-Z]/)) {
      if (json.params.listen) {
        eventMap$1[json.id] = module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3);
      } else {
        Object.keys(eventMap$1).forEach(key => {
          if (eventMap$1[key] === module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)) {
            delete eventMap$1[key];
          }
        });
      }
    }

    if (mock$4)
      handle$1(json);
    else
      pending$1.push(json);
  }

  function handle$1(json) {
    let result;
    try {
      result = getResult$1(json.method, json.params);
    }
    catch (error) {
      setTimeout(() => callback$1(JSON.stringify({ 
        jsonrpc: '2.0',
        error: {
          code: -32602,
          message: "Invalid params (this is a mock error from the mock transport layer)"
        },
        id: json.id
      })));
    }

    setTimeout(() => callback$1(JSON.stringify({ 
      jsonrpc: '2.0',
      result: result,
      id: json.id
    })));
  }

  function receive$1(_callback) {
    callback$1 = _callback;

    if (testHarness$1 && (typeof testHarness$1.initialize === 'function')) {
      testHarness$1.initialize({
        emit: event$1,
        listen: function(...args) { listener$1(...args); },
      });
    }
  }

  function event$1(module, event, value) {
   const listener = Object.entries(eventMap$1).find(([k, v]) => v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase());
    if (listener) {
      let message = JSON.stringify({
        jsonrpc: '2.0',
        id: parseInt(listener[0]),
        result: value
      });
      callback$1(message);
    }
  }

  function dotGrab$3(obj = {}, key) {
    const keys = key.split('.');
    let ref = obj;
    for (let i = 0; i < keys.length; i++) {
      ref = (Object.entries(ref).find( ([k, v]) => k.toLowerCase() === keys[i].toLowerCase()) || [null, {}])[1];
    }
    return ref
  }

  function getResult$1(method, params) {
    let api = dotGrab$3(mock$4, method);

    if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
      api = {
        event: method,
        listening: true
      };
    }

    if (typeof api === 'function') {
      return params == null ? api() : api(params)
    } else return api
  }

  function setMockResponses$1(m) {
    mock$4 = m;

    pending$1.forEach(json => handle$1(json));
    pending$1.length = 0;
  }

  var mock$5 = {
    send: send$1,
    receive: receive$1,
    event: event$1
  };

  const mocks$1 = {};

  function mock$3(module, method, args, def) {
    const fullMethod = `${module}.${method}`;
    if ((args == null) || args.length === 0 || (Object.values(args[0]).length === 0)) {
      // get
      const rv = mocks$1[fullMethod] && (mocks$1[fullMethod].value != null) ? mocks$1[fullMethod].value : def;
      return rv
    } else {
      // set
      let mockMethod = mocks$1[fullMethod];
      if (mockMethod == null) {
        mockMethod = {
          subscribers: []
        };
      }
      mocks$1[fullMethod] = mockMethod;
      mockMethod.value = args[0].value;
      mock$5.event(module, method + 'Changed', {
        value: args[0].value
      });
      return {}
    }
  }

  var MockProps$1 = {
    mock: mock$3
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Accessibility = {
      closedCaptions:  {"enabled":true,"styles":{"fontFamily":"Monospace sans-serif","fontSize":1,"fontColor":"#ffffff","fontEdge":"none","fontEdgeColor":"#7F7F7F","fontOpacity":100,"backgroundColor":"#000000","backgroundOpacity":100,"textAlign":"center","textAlignVertical":"middle","windowColor":"white","windowOpacity":50}},
      closedCaptionsSettings: function () { return MockProps$1.mock('Accessibility', 'closedCaptionsSettings', arguments, {"enabled":true,"styles":{"fontFamily":"Monospace sans-serif","fontSize":1,"fontColor":"#ffffff","fontEdge":"none","fontEdgeColor":"#7F7F7F","fontOpacity":100,"backgroundColor":"#000000","backgroundOpacity":100,"textAlign":"center","textAlignVertical":"middle","windowColor":"white","windowOpacity":50}}) },
      voiceGuidance:  {"enabled":true,"speed":2},
      voiceGuidanceSettings: function () { return MockProps$1.mock('Accessibility', 'voiceGuidanceSettings', arguments, {"enabled":true,"speed":2}) },
      audioDescriptionSettings: function () { return MockProps$1.mock('Accessibility', 'audioDescriptionSettings', arguments, {"enabled":true}) }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Account$1 = {
      id: function () { return MockProps$1.mock('Account', 'id', arguments, "123") },
      uid: function () { return MockProps$1.mock('Account', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Advertising$1 = {
      config:  {"adServerUrl":"https://demo.v.fwmrm.net/ad/p/1","adServerUrlTemplate":"https://demo.v.fwmrm.net/ad/p/1?flag=+sltp+exvt+slcb+emcr+amcb+aeti&prof=12345:caf_allinone_profile &nw=12345&mode=live&vdur=123&caid=a110523018&asnw=372464&csid=gmott_ios_tablet_watch_live_ESPNU&ssnw=372464&vip=198.205.92.1&resp=vmap1&metr=1031&pvrn=12345&vprn=12345&vcid=1X0Ce7L3xRWlTeNhc7br8Q%3D%3D","adNetworkId":"519178","adProfileId":"12345:caf_allinone_profile","adSiteSectionId":"caf_allinone_profile_section","adOptOut":true,"privacyData":"ew0KICAicGR0IjogImdkcDp2MSIsDQogICJ1c19wcml2YWN5IjogIjEtTi0iLA0KICAibG10IjogIjEiIA0KfQ0K","ifaValue":"01234567-89AB-CDEF-GH01-23456789ABCD","ifa":"ewogICJ2YWx1ZSI6ICIwMTIzNDU2Ny04OUFCLUNERUYtR0gwMS0yMzQ1Njc4OUFCQ0QiLAogICJpZmFfdHlwZSI6ICJzc3BpZCIsCiAgImxtdCI6ICIwIgp9Cg==","appName":"FutureToday","appBundleId":"FutureToday.comcast","distributorAppId":"1001","deviceAdAttributes":"ewogICJib0F0dHJpYnV0ZXNGb3JSZXZTaGFyZUlkIjogIjEyMzQiCn0=","coppa":0,"authenticationEntity":"60f72475281cfba3852413bd53e957f6"},
      policy: function () { return MockProps$1.mock('Advertising', 'policy', arguments, {"skipRestriction":"adsUnwatched","limitAdTracking":false}) },
      advertisingId:  {"ifa":"01234567-89AB-CDEF-GH01-23456789ABCD","ifa_type":"idfa","lmt":"0"},
      deviceAttributes:  {},
      appBundleId:  "operator.app"
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Authentication = {
      token:  {"value":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c","expires":"2022-04-23T18:25:43.511Z","type":"platform"},
      device:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      session:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
      root:  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Capabilities = {
      supported:  true,
      available:  true,
      permitted:  true,
      granted:  true,
      info:  [{"capability":"xrn:firebolt:capability:device:model","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}},{"capability":"xrn:firebolt:capability:input:keyboard","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}},{"capability":"xrn:firebolt:capability:protocol:bluetoothle","supported":false,"available":false,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["unsupported"]},{"capability":"xrn:firebolt:capability:token:device","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}},{"capability":"xrn:firebolt:capability:token:platform","supported":true,"available":false,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["unavailable"]},{"capability":"xrn:firebolt:capability:protocol:moca","supported":true,"available":false,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["disabled","unavailable"]},{"capability":"xrn:firebolt:capability:wifi:scan","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["unpermitted"]},{"capability":"xrn:firebolt:capability:localization:postal-code","supported":true,"available":true,"use":{"permitted":true,"granted":null},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["ungranted"]},{"capability":"xrn:firebolt:capability:localization:postal-code","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["ungranted"]},{"capability":"xrn:firebolt:capability:localization:locality","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true},"details":["grantDenied","ungranted"]}],
      request:  [{"capability":"xrn:firebolt:capability:commerce:purchase","supported":true,"available":true,"use":{"permitted":true,"granted":true},"manage":{"permitted":true,"granted":true},"provide":{"permitted":true,"granted":true}}]
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Device$1 = {
      id: function () { return MockProps$1.mock('Device', 'id', arguments, "123") },
      distributor: function () { return MockProps$1.mock('Device', 'distributor', arguments, "Company") },
      platform: function () { return MockProps$1.mock('Device', 'platform', arguments, "WPE") },
      uid: function () { return MockProps$1.mock('Device', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") },
      type: function () { return MockProps$1.mock('Device', 'type', arguments, "STB") },
      model: function () { return MockProps$1.mock('Device', 'model', arguments, "xi6") },
      sku: function () { return MockProps$1.mock('Device', 'sku', arguments, "AX061AEI") },
      make: function () { return MockProps$1.mock('Device', 'make', arguments, "Arris") },
      version: function () { return MockProps$1.mock('Device', 'version', arguments, {"sdk":{"major":0,"minor":8,"patch":0,"readable":"Firebolt JS SDK v0.8.0"},"api":{"major":0,"minor":8,"patch":0,"readable":"Firebolt API v0.8.0"},"firmware":{"major":1,"minor":2,"patch":3,"readable":"Device Firmware v1.2.3"},"os":{"major":0,"minor":1,"patch":0,"readable":"Firebolt OS v0.1.0"},"debug":"Non-parsable build info for error logging only."}) },
      hdcp: function () { return MockProps$1.mock('Device', 'hdcp', arguments, {"hdcp1.4":true,"hdcp2.2":true}) },
      hdr: function () { return MockProps$1.mock('Device', 'hdr', arguments, {"hdr10":true,"hdr10Plus":true,"dolbyVision":true,"hlg":true}) },
      audio: function () { return MockProps$1.mock('Device', 'audio', arguments, {"stereo":true,"dolbyDigital5.1":true,"dolbyDigital5.1+":true,"dolbyAtmos":true}) },
      screenResolution: function () { return MockProps$1.mock('Device', 'screenResolution', arguments, [1920,1080]) },
      videoResolution: function () { return MockProps$1.mock('Device', 'videoResolution', arguments, [1920,1080]) },
      name: function () { return MockProps$1.mock('Device', 'name', arguments, "Living Room") },
      network: function () { return MockProps$1.mock('Device', 'network', arguments, {"state":"connected","type":"wifi"}) }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Discovery$1 = {
      policy: function () { return MockProps$1.mock('Discovery', 'policy', arguments, {"enableRecommendations":true,"shareWatchHistory":true,"rememberWatchedPrograms":true}) },
      entityInfo:  true,
      purchasedContent:  true,
      watched:  true,
      watchNext:  true,
      entitlements:  true,
      contentAccess:  null,
      clearContentAccess:  null,
      launch:  true,
      signIn:  true,
      signOut:  true
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Keyboard$1 = {
      email:  "user@domain.com",
      password:  "abc123",
      standard:  "Living Room"
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  let inactive = {"state":"inactive","previous":"initializing"};
  let foreground = {"state":"foreground","previous":"inactive"};
  let unloading = {"state":"unloading","previous":"inactive"};

  const emit$2 = (value) => {
    mock$5.event('Lifecycle', value.state, value);
  };

  const win$5 = typeof window !== 'undefined' ? window : {};
  const automation = win$5.__firebolt ? !!win$5.__firebolt.automation : false;

  var _Lifecycle = {
    ready: function() {
      inactive.previous = 'initializing';
      setTimeout(() => emit$2(inactive), automation ? 1 : 500);
      foreground.previous = 'inactive';
      setTimeout(() => emit$2(foreground), automation ? 2 : 1000);
    },

    close: function(params) {
      let reason = params.reason;
      if (reason === 'remoteButton') {
        inactive.previous = 'foreground';
        setTimeout(() => emit$2(inactive), automation ? 1 : 500);
      }
      else if (['userExit', 'error'].includes(reason)) {
        inactive.previous = 'foreground';
        unloading.previous = 'inactive';
        setTimeout(() => emit$2(inactive), automation ? 1 : 500);
        setTimeout(() => emit$2(unloading), automation ? 2 : 1000);
      }
      else {
        throw "Invalid close reason"
      }
    },

    finished: function() {
      if (win$5.location)
        win$5.location.href = "about:blank";
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Localization$1 = {
      locality: function () { return MockProps$1.mock('Localization', 'locality', arguments, "Philadelphia") },
      postalCode: function () { return MockProps$1.mock('Localization', 'postalCode', arguments, "19103") },
      countryCode: function () { return MockProps$1.mock('Localization', 'countryCode', arguments, "US") },
      language: function () { return MockProps$1.mock('Localization', 'language', arguments, "en") },
      preferredAudioLanguages: function () { return MockProps$1.mock('Localization', 'preferredAudioLanguages', arguments, ["es","en"]) },
      locale: function () { return MockProps$1.mock('Localization', 'locale', arguments, "en-US") },
      latlon:  [39.9549,75.1699],
      additionalInfo:  {}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Metrics$1 = {
      ready:  true,
      signIn:  true,
      signOut:  true,
      startContent:  true,
      stopContent:  true,
      page:  true,
      action:  true,
      error:  true,
      mediaLoadStart:  true,
      mediaPlay:  true,
      mediaPlaying:  true,
      mediaPause:  true,
      mediaWaiting:  true,
      mediaProgress:  true,
      mediaSeeking:  true,
      mediaSeeked:  true,
      mediaRateChange:  true,
      mediaRenditionChange:  true,
      mediaEnded:  true
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Parameters = {
      initialization:  {"lmt":0,"us_privacy":"1-Y-","discovery":{"navigateTo":{"action":"entity","data":{"entityId":"abc","entityType":"program","programType":"movie"},"context":{"source":"voice"}}}}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Profile = {
      approveContentRating:  false,
      approvePurchase:  false,
      flags:  {"userExperience":"1000"}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _SecondScreen = {
      protocols:  {"dial1.7":true},
      device:  "device-id",
      friendlyName: function () { return MockProps$1.mock('SecondScreen', 'friendlyName', arguments, "Living Room") }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _SecureStorage$1 = {
      get:  "VGhpcyBub3QgYSByZWFsIHRva2VuLgo=",
      set:  null,
      remove:  null,
      clear:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Platform = {
    localization: _Localization$1,
    device: _Device$1,
    accessibility: _Accessibility,
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class Queue$1 {
    constructor () {
      this._callback = null;
      this._queue = [];
    }

    send (json) {
      this._queue.push(json);
    }

    receive (_callback) {
      this._callback = _callback;
    }

    flush (transport) {
      transport.receive(this._callback);
      this._queue.forEach(item => transport.send(item));
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const settings$1 = {};
  const subscribers$1 = {};

  const initSettings$1 = (appSettings, platformSettings) => {
    settings$1['app'] = appSettings;
    settings$1['platform'] = {
      logLevel: 'WARN',
      ...platformSettings
    };
    settings$1['user'] = {};
  };

  const publish$1 = (key, value) => {
    subscribers$1[key] && subscribers$1[key].forEach(subscriber => subscriber(value));
  };

  const dotGrab$2 = (obj = {}, key) => {
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
  };

  var Settings$1 = {
    get(type, key, fallback = undefined) {
      const val = dotGrab$2(settings$1[type], key);
      return val !== undefined ? val : fallback
    },
    has(type, key) {
      return !!this.get(type, key)
    },
    set(key, value) {
      settings$1['user'][key] = value;
      publish$1(key, value);
    },
    subscribe(key, callback) {
      subscribers$1[key] = subscribers$1[key] || [];
      subscribers$1[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers$1[key] && subscribers$1[key].findIndex(cb => cb === callback);
        index > -1 && subscribers$1[key].splice(index, 1);
      } else {
        if (key in subscribers$1) {
          subscribers$1[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers$1)) {
        delete subscribers$1[key];
      }
    },
    setLogLevel (logLevel) {
      settings$1.platform.logLevel = logLevel;
    },
    getLogLevel () {
      return settings$1.platform.logLevel
    }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const win$4 = typeof window !== 'undefined' ? window : {};

  class LegacyTransport$1 {
    constructor (bridge) {
      this.bridge = bridge;
    }

    send (msg) {
      this.bridge.JSMessageChanged(msg, () => {});
    }

    receive (callback) {
      win$4.$badger = win$4.$badger || {};
      /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
      const badgerCallback = win$4.$badger.callback ? win$4.$badger.callback.bind(win$4.$badger) : null;
      const badgerEvent = win$4.$badger.event ? win$4.$badger.event.bind(win$4.$badger) : null;
      win$4.$badger.callback = (pid, success, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerCallback) {
          badgerCallback(pid, success, json);
        }
      };
      win$4.$badger.event = (handlerId, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerEvent) {
          badgerEvent(handlerId, json);
        }
      };
    }

    static isLegacy (transport) {
      return LegacyTransport$1.isXREProxy(transport) || ((transport.send === undefined) && (transport.JSMessageChanged))
    }

    static isXREProxy (transport) {
      /** Set top boxes running XRE has a "Proxy" transport
       * native object that intercepts ALL method calls, so we
       * cannot test for transport.send existence because it will return true
       * even though it actually is not supported. Check if some obscure method
       * name like "proxyObjectTest" is defined. If it is then we know we are using a
       * Proxy object and thus is legacy transport.
       */
      return transport.proxyObjectTest !== undefined
    }
  }

  const MAX_QUEUED_MESSAGES$1 = 100;

  class WebsocketTransport$1 {
    constructor (endpoint) {
      this._endpoint = endpoint;
      this._ws = null;
      this._connected = false;
      this._queue = [];
      this._callbacks = [];
    }

    send (msg) {
      this._connect();

      if (this._connected) {
        this._ws.send(msg);
      } else {
        if (this._queue.length < MAX_QUEUED_MESSAGES$1) {
          this._queue.push(msg);
        }
      }
    }

    receive (callback) {
      if (!callback) return
      this._connect();
      this._callbacks.push(callback);
    }

    _notifyCallbacks (message) {
      for (let i = 0; i < this._callbacks.length; i++) {
        setTimeout(() => this._callbacks[i](message), 1);
      }
    }

    _connect () {
      if (this._ws) return
      this._ws = new WebSocket(this._endpoint, ['jsonrpc']);
      this._ws.addEventListener('message', message => {
        this._notifyCallbacks(message.data);
      });
      this._ws.addEventListener('error', message => {
      });
      this._ws.addEventListener('close', message => {
        this._ws = null;
        this._connected = false;
      });
      this._ws.addEventListener('open', message => {
        this._connected = true;
        for (let i = 0; i < this._queue.length; i++) {
          this._ws.send(this._queue[i]);
        }
        this._queue = [];
      });
    }
  }

  /*
  methods = Map<string, {
      x-this-param: 'accessory',
      x-additional-params: ['timeout'],
      x-method: 'Accessory.pair'
  }>
  */

  function transform$1(result, transforms) {

      if (!transforms || !transforms.methods) {
          return result
      }

      const { methods } = transforms;
      const transformed = JSON.parse(JSON.stringify(result));

      Object.keys(methods).forEach(key => {
          const method_info = methods[key];
          const rpc_method = method_info['x-method'];
          const [module, method] = rpc_method.split('.');
          const params = {};
          params[method_info['x-this-param']] = transformed;
          transformed[key] = (...args) => {
              // copy the args into the correct RPC param names
              for (var i=0; i<args.length; i++) {
                  params[method_info['x-additional-params'][i]] = args[i];
              }
              return Transport$1.send(module.toLowerCase(), method, params)
          };
      });
      return transformed
  }

  var Results$1 = {
      transform: transform$1
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const LEGACY_TRANSPORT_SERVICE_NAME$1 = 'com.comcast.BridgeObject_1';
  let moduleInstance$1 = null;

  const isEventSuccess$1 = x => x && (typeof x.event === 'string') && (typeof x.listening === 'boolean');

  const win$3 = typeof window !== 'undefined' ? window : {};

  class Transport$1 {
    constructor () {
      this._promises = [];
      this._transport = null;
      this._id = 1;
      this._eventEmitters = [];
      this._eventIds = [];
      this._queue = new Queue$1();
      this._deprecated = {};
      this.isMock = false;
    }

    static addEventEmitter (emitter) {
      Transport$1.get()._eventEmitters.push(emitter);
    }

    static registerDeprecatedMethod (module, method, alternative) {
      Transport$1.get()._deprecated[module.toLowerCase() + '.' + method.toLowerCase()] = {
        alternative: alternative || ''
      };
    }

    _endpoint () {
      if (win$3.__firebolt && win$3.__firebolt.endpoint) {
        return win$3.__firebolt.endpoint
      }
      return null
    }

    constructTransportLayer () {
      let transport;
      const endpoint = this._endpoint();
      if (endpoint && (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))) {
        transport = new WebsocketTransport$1(endpoint);
        transport.receive(this.receiveHandler.bind(this));
      } else if (
        typeof win$3.ServiceManager !== 'undefined' &&
        win$3.ServiceManager &&
        win$3.ServiceManager.version
      ) {
        // Wire up the queue
        transport = this._queue;
        // get the default bridge service, and flush the queue
        win$3.ServiceManager.getServiceForJavaScript(LEGACY_TRANSPORT_SERVICE_NAME$1, service => {
          if (LegacyTransport$1.isLegacy(service)) {
            transport = new LegacyTransport$1(service);
          } else {
            transport = service;
          }
          this.setTransportLayer(transport);
        });
      } else {
        this.isMock = true;
        transport = mock$5;
        transport.receive(this.receiveHandler.bind(this));
      }
      return transport
    }

    setTransportLayer (tl) {
      this._transport = tl;
      this._queue.flush(tl);
    }

    static send (module, method, params, transforms) {
      /** Transport singleton across all SDKs to keep single id map */
      return Transport$1.get()._send(module, method, params, transforms)
    }

    static listen(module, method, params, transforms) {
      return Transport$1.get()._sendAndGetId(module, method, params, transforms)
    }

    _send (module, method, params, transforms) {
      if (Array.isArray(module) && !method && !params) {
        return this._batch(module)
      }
      else {
        return this._sendAndGetId(module, method, params, transforms).promise
      }
    }

    _sendAndGetId (module, method, params, transforms) {
      const {promise, json, id } = this._processRequest(module, method, params, transforms);
      const msg = JSON.stringify(json);
      if (Settings$1.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return { id, promise }
    }

    _batch (requests) {
      const results = [];
      const json = [];

      requests.forEach( ({module, method, params, transforms}) => {
        const result = this._processRequest(module, method, params, transforms);
        results.push({
          promise: result.promise,
          id: result.id
        });
        json.push(result.json);
      });

      const msg = JSON.stringify(json);
      if (Settings$1.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return results
    }

    _processRequest (module, method, params, transforms) {

      const p = this._addPromiseToQueue(module, method, params, transforms);
      const json = this._createRequestJSON(module, method, params);

      const result = {
        promise: p,
        json: json,
        id: this._id
      };

      this._id++;

      return result
    }

    _createRequestJSON (module, method, params) {
      return { jsonrpc: '2.0', method: module.toLowerCase() + '.' + method, params: params, id: this._id }
    }

    _addPromiseToQueue (module, method, params, transforms) {
      return new Promise((resolve, reject) => {
        this._promises[this._id] = {};
        this._promises[this._id].promise = this;
        this._promises[this._id].resolve = resolve;
        this._promises[this._id].reject = reject;
        this._promises[this._id].transforms = transforms;

        const deprecated = this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()];
        if (deprecated) {
          console.warn(`WARNING: ${module}.${method}() is deprecated. ` + deprecated.alternative);
        }

        // store the ID of the first listen for each event
        // TODO: what about wild cards?
        if (method.match(/^on[A-Z]/)) {
          if (params.listen) {
            this._eventIds.push(this._id);
          } else {
            this._eventIds = this._eventIds.filter(id => id !== this._id);
          }
        }
      })
    }

    /**
     * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
     * @returns {Transport}
     */
    static get () {
      /** Set up singleton and initialize it */
      win$3.__firebolt = win$3.__firebolt || {};
      if ((win$3.__firebolt.transport == null) && (moduleInstance$1 == null)) {
        const transport = new Transport$1();
        transport.init();
        if (transport.isMock) {
          /** We should use the mock transport built with the SDK, not a global */
          moduleInstance$1 = transport;
        } else {
          win$3.__firebolt = win$3.__firebolt || {};
          win$3.__firebolt.transport = transport;
        }
        win$3.__firebolt.setTransportLayer = transport.setTransportLayer.bind(transport);
      }
      return win$3.__firebolt.transport ? win$3.__firebolt.transport : moduleInstance$1
    }

    receiveHandler (message) {
      if (Settings$1.getLogLevel() === 'DEBUG') {
        console.debug('Received message from transport: ' + message);
      }
      const json = JSON.parse(message);
      const p = this._promises[json.id];

      if (p) {
        if (json.error) p.reject(json.error);
        else {
          // Do any module-specific transforms on the result
          let result = json.result;

          if (p.transforms) {
            if (Array.isArray(json.result)) {
              result = result.map(x => Results$1.transform(x, p.transforms));
            }
            else {
              result = Results$1.transform(result, p.transforms);
            }
          }
          
          p.resolve(result);
        }
        delete this._promises[json.id];
      }

      // event responses need to be emitted, even after the listen call is resolved
      if (this._eventIds.includes(json.id) && !isEventSuccess$1(json.result)) {
        this._eventEmitters.forEach(emit => {
          emit(json.id, json.result);
        });
      }
    }

    init () {
      initSettings$1({}, { log: true });
      this._queue.receive(this.receiveHandler.bind(this));
      if (win$3.__firebolt) {
        if (win$3.__firebolt.mockTransportLayer === true) {
          this.isMock = true;
          this.setTransportLayer(mock$5);
        } else if (win$3.__firebolt.getTransportLayer) {
          this.setTransportLayer(win$3.__firebolt.getTransportLayer());
        }
      }
      if (this._transport == null) {
        this._transport = this.constructTransportLayer();
      }
    }
  }
  win$3.__firebolt = win$3.__firebolt || {};
  win$3.__firebolt.setTransportLayer = transport => {
    Transport$1.get().setTransportLayer(transport);
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  let listenerId$1 = 0;

  // holds two maps of ${module}.${event} => listenerId, e.g. callback method id
  // note that one callback can listen to multiple events, e.g. 'discovery.*'
  // internal is only available via a private export that we use to ensure our modules know about
  // events before the apps using the SDK (otherwise state errors can happen)
  const listeners$1 = {
    internal: {},
    external: {},

    // Several convenience functions below for checking both internal & external lists w/ one operation

    // gets a merge list of ids for a single event key
    get: (key) => {
      return Object.assign(Object.assign({}, listeners$1.internal[key]), listeners$1.external[key])
    },
    // adds a callback/id to a key on the external list only 
    set: (key, id, value) => {
      listeners$1.external[key] = listeners$1.external[key] || {};
      listeners$1.external[key][id] = value;
    },
    // adds a callback/id to a key on the internal list only 
    setInternal: (key, id, value) => {
      listeners$1.internal[key] = listeners$1.internal[key] || {};
      listeners$1.internal[key][id] = value;
    },
    // finds the key for an id in either list (it can only be in one)
    find: (id) => {
      let key;
      [listeners$1.internal, listeners$1.external].find(group => {
        key = Object.keys(group).find(key => group[key][id]);
        if (key) return true
      });
      return key
    },
    // removes an id from either list
    remove: (id) => {
      [listeners$1.internal, listeners$1.external].forEach(group => {
        Object.keys(group).forEach(key => {
          if (group[key] && group[key][id]) {
            delete group[key][id];
            if (Object.values(group[key]).length === 0) {
              delete group[key];
            }
          }
        });
      });
    },
    // removes a key from both lists if _internal is true, otherwise only the external list
    removeKey: (key, _internal=false) => {
      _internal && listeners$1.internal[key] && delete listeners$1.internal[key];
      listeners$1.external[key] && delete listeners$1.external[key];
    },
    // gives a list of all keys
    keys: () => {
      return Array.from(new Set(Object.keys(listeners$1.internal).concat(Object.keys(listeners$1.external))))
    },
    // counts how many listeners are in a key across both lists
    count: (key) => {
      return Object.values(listeners$1.get(key)).length
    }
  };

  // holds a map of RPC Ids => Context Key, e.g. the RPC id of an onEvent call mapped to the corresponding context parameters key for that RPC call
  const keys$1 = {};

  // holds a map of ${module}.${event} => Transport.send calls (only called once per event)
  // note that the keys here MUST NOT contain wild cards
  const oncers$1 = [];
  const validEvents$1 = {};
  const validContext$1 = {};

  let transportInitialized$1 = false;

  const emit$1 = (id, value) => {
    callCallbacks$1(listeners$1.internal[keys$1[id]], [value]);
    callCallbacks$1(listeners$1.external[keys$1[id]], [value]);
  };

  const registerEvents$1 = (module, events) => {
    validEvents$1[module.toLowerCase()] = events.concat();
  };

  const registerEventContext = (module, event, context) => {
    validContext$1[module.toLowerCase()] = validContext$1[module.toLowerCase()] || {};
    validContext$1[module.toLowerCase()][event] = context.concat();
  };

  const callCallbacks$1 = (cbs, args) => {
    cbs &&
      Object.keys(cbs).forEach(listenerId => {
        let callback = cbs[listenerId];
        if (oncers$1.indexOf(parseInt(listenerId)) >= 0) {
          oncers$1.splice(oncers$1.indexOf(parseInt(listenerId)), 1);
          delete cbs[listenerId];
        }
        callback.apply(null, args);
      });
  };

  const doListen$1 = function(module, event, callback, context, once, internal=false) {
    init$1();

    if (typeof callback !== 'function') {
      return Promise.reject('No valid callback function provided.')
    } else {
      if (module === '*') {
        return Promise.reject('No valid module name provided')
      }

      const wildcard = event === '*';
      const events = (wildcard ? validEvents$1[module] : [event]); // explodes wildcards into an array
      const promises = [];
      const hasContext = Object.values(context).length > 0;
      const contextKey = Object.keys(context).sort().map(key => key + '=' + JSON.stringify(context[key])).join('&');

      listenerId$1++;

      if (once) {
        oncers$1.push(listenerId$1);
      }

      events.forEach(event => {
        const key = module + '.' + event + (hasContext ? `.${contextKey}`  : '');

        if (Object.values(listeners$1.get(key)).length === 0) {
          const args = Object.assign({ listen: true }, context);
          const { id, promise } = Transport$1.listen(module, 'on' + event[0].toUpperCase() + event.substring(1), args);
          keys$1[id] = key;
          promises.push(promise);
        }

        const setter = internal ? listeners$1.setInternal : listeners$1.set;

        if (wildcard) {
          setter(key, ''+listenerId$1, value => callback(event, value));
        }
        else {
          setter(key, ''+listenerId$1, callback);
        }
      });

      let resolve, reject;
      let p = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });

      if (promises.length) {
        Promise.all(promises).then(responses => {
          resolve(listenerId$1);
        }).catch(error => {
          // Promise.all rejects if at least one promise rejects... we don't want that behavior here
          // TODO: Do something better than fail silently
          if (event === '*') {
            resolve(listenerId$1);
          }
          else {
            reject(error);
          }
        });
      }
      else {
        resolve(listenerId$1);
      }

      return p
    }
  };

  const getListenArgs$1 = function(...args) {
    const callback = args.pop();
    const [module, event, context] = getClearArgs$1(...args);

    return [module, event, callback, context]
  };

  const getClearArgs$1 = function(...args) {
    const module = (args.shift() || '*').toLowerCase();
    const event = args.shift() || '*';
    const context = {};
    
    for (let i = 0; args.length; i++) {
      context[validContext$1[module][event][i]] = args.shift();
    }

    return [module, event, context]
  };

  const once$5 = function(...args) {
    const [module, event, callback, context] = getListenArgs$1(...args);
    return doListen$1(module, event, callback, context, true)
  };

  const listen$5 = function(...args) {
    const [module, event, callback, context] = getListenArgs$1(...args);
    return doListen$1(module, event, callback, context, false)
  };

  const clear$5 = function(...args) {
    if (args && args.length && typeof args[0] === 'number') {
      return doClear$1(args[0])
    }
    else if (args && args.length && typeof args[1] === 'number') {
      return doClear$1(args[1])
    }
    else {
      const [moduleOrId, event, context] = getClearArgs$1(...args);
      return doClear$1(moduleOrId, event, context)
    }
  };

  // calls doListen with a priority flag for internal listeners to get priority
  const prioritize = function(...args) {
    const [module, event, callback, context] = getListenArgs$1(...args);
    return doListen$1(module, event, callback, context, false, true)
  };

  const unsubscribe$1 = (key, context) => {
    const [module, event] = key.split('.').slice(0, 2);
    const args = Object.assign({ listen: false }, context);
    Transport$1.send(module, 'on' + event[0].toUpperCase() + event.substr(1), args);
  };


  // TODO: clear needs to go through Transport Layer
  const doClear$1 = function (moduleOrId = false, event = false, context) {
    if (event === '*') {
      event = false;
    }

    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString();
      const key = listeners$1.find(searchId);

      if (key) {
        listeners$1.remove(searchId);
        if (listeners$1.count(key) === 0) {
          unsubscribe$1(key);
        }
        return true
      }
      return false
    } else {
      if (!moduleOrId && !event) {
        listeners$1.keys().forEach(key => {
          listeners$1.removeKey(key);
          unsubscribe$1(key);
        });
      } else if (!event) {
        listeners$1.keys().forEach(key => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            listeners$1.removeKey(key);
            unsubscribe$1(key);
          }
        });
      } else {
        const hasContext = Object.values(context).length > 0;
        const contextKey = Object.keys(context).sort().map(key => key + '=' + JSON.stringify(context[key])).join('&');
        const key = moduleOrId + '.' + event + (hasContext ? `.${contextKey}`  : '');

        listeners$1.removeKey(key);
        unsubscribe$1(key, context);
      }
    }
  };

  const init$1 = () => {
    if (!transportInitialized$1) {
      Transport$1.addEventEmitter(emit$1);
      setMockListener$1(listen$5);
      transportInitialized$1 = true;
    }
  };

  var Events$1 = {
    listen: listen$5,
    once: once$5,
    clear: clear$5,
    broadcast(event, value) {
      emit$1(Object.entries(keys$1).find( ([k, v]) => v === 'app.'+event)[0], value);
    },
  };

  function prop(moduleName, key, params, callbackOrValue = null, immutable, readonly, contextParameterCount) {
    const numArgs = Object.values(params).length;

    if (numArgs === contextParameterCount && callbackOrValue === null) {
      // getter
      return Transport$1.send(moduleName, key, params)
    } else if (numArgs === contextParameterCount && typeof callbackOrValue === 'function') {
      // subscribe
      if (immutable) {
        throw new Error('Cannot subscribe to an immutable property')
      }
      return Events$1.listen(moduleName, key + 'Changed', ...Object.values(params), callbackOrValue)
    } else if (numArgs === (contextParameterCount) && callbackOrValue !== null) {
      // setter
      if (immutable) {
        throw new Error('Cannot set a value to an immutable property')
      }
      if (readonly) {
        throw new Error('Cannot set a value to a readonly property')
      }
      return Transport$1.send(moduleName, 'set' + key[0].toUpperCase() + key.substring(1), Object.assign({
        value: callbackOrValue
      }, params))
    }
    else if (numArgs < contextParameterCount) {
      throw new Error('Cannot get a value without all required context parameters.')
    }
    else {
      throw new Error('Property accessed with unexpected number of parameters.')
    }
  }

  var Prop = {
    prop: prop
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Accessibility', ["audioDescriptionSettingsChanged","closedCaptionsSettingsChanged","voiceGuidanceSettingsChanged"]);


  Transport$1.registerDeprecatedMethod('Accessibility', 'closedCaptions', 'Use Accessibility.closedCaptionsSettings() instead.');
  Transport$1.registerDeprecatedMethod('Accessibility', 'voiceGuidance', 'Use Accessibility.voiceGuidanceSettings() instead.');

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Advertising', ["policyChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */



  Transport$1.registerDeprecatedMethod('Authentication', 'token', 'Use Authentication module has individual methods for each token type. instead.');

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Capabilities', ["available","granted","revoked","unavailable"]);



  // onAvailable is accessed via listen('available, ...)

  registerEventContext('Capabilities', 'available', ["capability"]);
  // onGranted is accessed via listen('granted, ...)

  registerEventContext('Capabilities', 'granted', ["role","capability"]);
  // onRevoked is accessed via listen('revoked, ...)

  registerEventContext('Capabilities', 'revoked', ["role","capability"]);
  // onUnavailable is accessed via listen('unavailable, ...)

  registerEventContext('Capabilities', 'unavailable', ["capability"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Device', ["audioChanged","deviceNameChanged","hdcpChanged","hdrChanged","nameChanged","networkChanged","screenResolutionChanged","videoResolutionChanged"]);


  Transport$1.registerDeprecatedMethod('Device', 'onDeviceNameChanged', 'Use Device.name() instead.');

  function version() {
    return new Promise( (resolve, reject) => {
        Transport$1.send('device', 'version').then( v => {
            v = v || {};
            v.sdk = v.sdk || {};
            v.sdk.major = parseInt('0');
            v.sdk.minor = parseInt('15');
            v.sdk.patch = parseInt('0');
            v.sdk.readable = 'Firebolt Core SDK 0.15.0';
            resolve(v);    
        }).catch(error => {
            reject(error);
        });
    })
  }


      // Methods
  function audio() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'audio', {  }, callbackOrValue, false, true, 0)
  }
    function clear$4(...args) {
      return Events$1.clear('Device', ...args)
    }

  function distributor() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'distributor', {  }, callbackOrValue, true, true, 0)
  }
  function hdcp() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'hdcp', {  }, callbackOrValue, false, true, 0)
  }
  function hdr() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'hdr', {  }, callbackOrValue, false, true, 0)
  }
  function id() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'id', {  }, callbackOrValue, true, true, 0)
  }
    function listen$4(...args) {
      return Events$1.listen('Device', ...args)
    } 
    
  function make() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'make', {  }, callbackOrValue, true, true, 0)
  }
  function model() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'model', {  }, callbackOrValue, true, true, 0)
  }
  function name() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'name', {  }, callbackOrValue, false, true, 0)
  }
  function network$1() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'network', {  }, callbackOrValue, false, true, 0)
  }
    function once$4(...args) {
      return Events$1.once('Device', ...args)
    }

  function platform$1() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'platform', {  }, callbackOrValue, true, true, 0)
  }
  function screenResolution() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'screenResolution', {  }, callbackOrValue, false, true, 0)
  }
  function sku() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'sku', {  }, callbackOrValue, true, true, 0)
  }
  function type() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'type', {  }, callbackOrValue, true, true, 0)
  }
  function uid() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'uid', {  }, callbackOrValue, true, true, 0)
  }
  function videoResolution() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Device',  'videoResolution', {  }, callbackOrValue, false, true, 0)
  }

  var Device = {

  events: {
      DEVICE_NAME_CHANGED: 'deviceNameChanged',
      NAME_CHANGED: 'nameChanged',
      HDCP_CHANGED: 'hdcpChanged',
      HDR_CHANGED: 'hdrChanged',
      AUDIO_CHANGED: 'audioChanged',
      SCREEN_RESOLUTION_CHANGED: 'screenResolutionChanged',
      VIDEO_RESOLUTION_CHANGED: 'videoResolutionChanged',
      NETWORK_CHANGED: 'networkChanged',
  },

  NetworkState: {
      CONNECTED: 'connected',
      DISCONNECTED: 'disconnected',
  },

  NetworkType: {
      WIFI: 'wifi',
      ETHERNET: 'ethernet',
      HYBRID: 'hybrid',
  },

  AudioProfile: {
      STEREO: 'stereo',
      DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
      DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
      DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
      DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
      DOLBY_ATMOS: 'dolbyAtmos',
  },


    version,
  audio,
clear:   clear$4,
  distributor,
  hdcp,
  hdr,
  id,
listen:   listen$4,
  make,
  model,
  name,
network:   network$1,
once:   once$4,
platform:   platform$1,
  screenResolution,
  sku,
  type,
  uid,
  videoResolution
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */




  function ready$1() {
    return Transport$1.send('metrics', 'ready', {})
  }

  function signIn$1() {
    return Transport$1.send('metrics', 'signIn', {})
  }

  function signOut$1() {
    return Transport$1.send('metrics', 'signOut', {})
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Discovery', ["navigateTo","policyChanged","pullEntityInfo","pullPurchasedContent"]);


  Transport$1.registerDeprecatedMethod('Discovery', 'entitlements', 'Use Discovery.contentAccess() instead.');

  // onNavigateTo is accessed via listen('navigateTo, ...)

  // onPolicyChanged is accessed via listen('policyChanged, ...)




      // Methods
    function clear$3(...args) {
      return Events$1.clear('Discovery', ...args)
    }


  function clearContentAccess() {

    const transforms = null;

    return Transport$1.send('Discovery', 'clearContentAccess', {  }, transforms)
  }

  function contentAccess(ids) {

    const transforms = null;

    return Transport$1.send('Discovery', 'contentAccess', { ids }, transforms)
  }

  function entitlements(entitlements) {

    const transforms = null;

    return Transport$1.send('Discovery', 'entitlements', { entitlements }, transforms)
  }

  let entityInfoHasCallback = false;

  function entityInfo (data) {
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      if (entityInfoHasCallback) {
        return Promise.reject('Cannot register more than one entityInfo handler.')
      }

      const callback = arguments[0];
      entityInfoHasCallback = true;
      return Events$1.listen('Discovery', 'pullEntityInfo', (request) => {
        if (typeof request === 'boolean') return

        try {
          const result = callback(request.parameters).then(result => {
            const params = {
              correlationId: request.correlationId,
              result: result
            };
            Transport$1.send('Discovery', 'entityInfo', params).catch(error => {
              const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
              console.error(`Failed to send entityInfo pull response through Transport Layer: ${msg}`);
            });
          }).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
            console.error(`App 'entityInfo' callback failed: ${msg}`);
          });
        }
        catch (error) {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`App 'entityInfo' callback failed: ${msg}`);
      }
      })
    }
    else {
      return Transport$1.send('Discovery', 'entityInfo', { correlationId: null, result: data })
    }
  }

  function launch(appId, intent) {

    const transforms = null;

    return Transport$1.send('Discovery', 'launch', { appId, intent }, transforms)
  }
    function listen$3(...args) {
      return Events$1.listen('Discovery', ...args)
    } 
    
    function once$3(...args) {
      return Events$1.once('Discovery', ...args)
    }

  function policy() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Discovery',  'policy', {  }, callbackOrValue, false, true, 0)
  }

  let purchasedContentHasCallback = false;

  function purchasedContent (data) {
    if (arguments.length === 1 && typeof arguments[0] === 'function') {
      if (purchasedContentHasCallback) {
        return Promise.reject('Cannot register more than one purchasedContent handler.')
      }

      const callback = arguments[0];
      purchasedContentHasCallback = true;
      return Events$1.listen('Discovery', 'pullPurchasedContent', (request) => {
        if (typeof request === 'boolean') return

        try {
          const result = callback(request.parameters).then(result => {
            const params = {
              correlationId: request.correlationId,
              result: result
            };
            Transport$1.send('Discovery', 'purchasedContent', params).catch(error => {
              const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
              console.error(`Failed to send purchasedContent pull response through Transport Layer: ${msg}`);
            });
          }).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
            console.error(`App 'purchasedContent' callback failed: ${msg}`);
          });
        }
        catch (error) {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`App 'purchasedContent' callback failed: ${msg}`);
      }
      })
    }
    else {
      return Transport$1.send('Discovery', 'purchasedContent', { correlationId: null, result: data })
    }
  }

  function signIn(entitlements) {
      const transforms = null;

      const p = Transport$1.send('Discovery', 'signIn', { entitlements }, transforms);
      
      p.then(_ => {
          setTimeout(_ => {
              signIn$1();
          });    
      }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`Metrics 'signIn' callback failed: ${msg}`);
      });

      return p
  }

  function signOut() {
      const transforms = null;

      const p = Transport$1.send('Discovery', 'signOut', {  }, transforms);
      
      p.then(_ => {
          setTimeout(_ => {
              signOut$1();
          });    
      }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error';
          console.error(`Metrics 'signOut' callback failed: ${msg}`);
      });

      return p
  }

  function watched(entityId, progress, completed, watchedOn) {
    const transforms = null;

    if (arguments.length === 1 && Array.isArray(arguments[0])) {
      return Transport$1.send('Discovery', 'watched', arguments[0], transforms)
    }
    else {
      return Transport$1.send('Discovery', 'watched', { entityId, progress, completed, watchedOn }, transforms)
    }
  }

  function watchNext(title, identifiers, expires, images) {

    const transforms = null;

    return Transport$1.send('Discovery', 'watchNext', { title, identifiers, expires, images }, transforms)
  }
    
  var Discovery = {

  events: {
      NAVIGATE_TO: 'navigateTo',
      POLICY_CHANGED: 'policyChanged',
      PULL_ENTITY_INFO: 'pullEntityInfo',
      PULL_PURCHASED_CONTENT: 'pullPurchasedContent',
  },

  ProgramType: {
      MOVIE: 'movie',
      EPISODE: 'episode',
      SEASON: 'season',
      SERIES: 'series',
      OTHER: 'other',
      PREVIEW: 'preview',
      EXTRA: 'extra',
      CONCERT: 'concert',
      SPORTING_EVENT: 'sportingEvent',
      ADVERTISEMENT: 'advertisement',
      MUSIC_VIDEO: 'musicVideo',
      MINISODE: 'minisode',
  },

  OfferingType: {
      FREE: 'free',
      SUBSCRIBE: 'subscribe',
      BUY: 'buy',
      RENT: 'rent',
  },

  AudioProfile: {
      STEREO: 'stereo',
      DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
      DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
      DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
      DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
      DOLBY_ATMOS: 'dolbyAtmos',
  },

clear:   clear$3,
  clearContentAccess,
  contentAccess,
  entitlements,
  entityInfo,
  launch,
listen:   listen$3,
once:   once$3,
  policy,
  purchasedContent,
  signIn,
  signOut,
  watched,
  watchNext
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Lifecycle', ["background","foreground","inactive","suspended","unloading"]);



  const store = {
    _current: 'initializing',
    get current() {
      return this._current
    }
  };

  async function ready() {
    let readyRes;
    await prioritize('Lifecycle', (event, value) => {
      store._current = event;
    });
    readyRes =await Transport$1.send('lifecycle', 'ready', {});
    setTimeout(_ => {
      ready$1();
    });
    return readyRes
  }


      // Methods
    function clear$2(...args) {
      return Events$1.clear('Lifecycle', ...args)
    }


  function close(reason) {

    const transforms = null;

    return Transport$1.send('Lifecycle', 'close', { reason }, transforms)
  }
    function listen$2(...args) {
      return Events$1.listen('Lifecycle', ...args)
    } 
    
    function once$2(...args) {
      return Events$1.once('Lifecycle', ...args)
    }


  function state() {
    return store.current
  }

  function finished() {
    if (store.current === 'unloading') {
      return Transport$1.send('lifecycle', 'finished')
    } else {
      throw 'Cannot call finished() except when in the unloading transition'
    }
  }

  // public API
  var Lifecycle = {

  events: {
      INACTIVE: 'inactive',
      FOREGROUND: 'foreground',
      BACKGROUND: 'background',
      SUSPENDED: 'suspended',
      UNLOADING: 'unloading',
  },


  CloseReason: {
      REMOTE_BUTTON: 'remoteButton',
      USER_EXIT: 'userExit',
      DONE: 'done',
      ERROR: 'error',
  },

  LifecycleState: {
      INITIALIZING: 'initializing',
      INACTIVE: 'inactive',
      FOREGROUND: 'foreground',
      BACKGROUND: 'background',
      UNLOADING: 'unloading',
      SUSPENDED: 'suspended',
  },


    ready,
    state,
    finished,

clear:   clear$2,
  close,
listen:   listen$2,
once:   once$2
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('Localization', ["countryCodeChanged","languageChanged","localeChanged","localityChanged","postalCodeChanged","preferredAudioLanguagesChanged"]);



  // onCountryCodeChanged is accessed via listen('countryCodeChanged, ...)

  // onLanguageChanged is accessed via listen('languageChanged, ...)

  // onLocaleChanged is accessed via listen('localeChanged, ...)

  // onLocalityChanged is accessed via listen('localityChanged, ...)

  // onPostalCodeChanged is accessed via listen('postalCodeChanged, ...)

  // onPreferredAudioLanguagesChanged is accessed via listen('preferredAudioLanguagesChanged, ...)


      // Methods

  function additionalInfo() {

    const transforms = null;

    return Transport$1.send('Localization', 'additionalInfo', {  }, transforms)
  }
    function clear$1(...args) {
      return Events$1.clear('Localization', ...args)
    }

  function countryCode() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Localization',  'countryCode', {  }, callbackOrValue, false, true, 0)
  }
  function language() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Localization',  'language', {  }, callbackOrValue, false, true, 0)
  }

  function latlon$1() {

    const transforms = null;

    return Transport$1.send('Localization', 'latlon', {  }, transforms)
  }
    function listen$1(...args) {
      return Events$1.listen('Localization', ...args)
    } 
    
  function locale() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Localization',  'locale', {  }, callbackOrValue, false, true, 0)
  }
  function locality() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Localization',  'locality', {  }, callbackOrValue, false, true, 0)
  }
    function once$1(...args) {
      return Events$1.once('Localization', ...args)
    }

  function postalCode() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Localization',  'postalCode', {  }, callbackOrValue, false, true, 0)
  }
  function preferredAudioLanguages() {
    const callbackOrValue = arguments[0];
    return Prop.prop('Localization',  'preferredAudioLanguages', {  }, callbackOrValue, false, true, 0)
  }
    
  var Localization = {

  events: {
      LOCALITY_CHANGED: 'localityChanged',
      POSTAL_CODE_CHANGED: 'postalCodeChanged',
      COUNTRY_CODE_CHANGED: 'countryCodeChanged',
      LANGUAGE_CHANGED: 'languageChanged',
      PREFERRED_AUDIO_LANGUAGES_CHANGED: 'preferredAudioLanguagesChanged',
      LOCALE_CHANGED: 'localeChanged',
  },

  additionalInfo,
clear:   clear$1,
  countryCode,
  language,
latlon:   latlon$1,
listen:   listen$1,
  locale,
  locality,
once:   once$1,
  postalCode,
  preferredAudioLanguages
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents$1('SecondScreen', ["closeRequest","friendlyNameChanged","launchRequest"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  setMockResponses$1({
      Accessibility: _Accessibility,
      Account: _Account$1,
      Advertising: _Advertising$1,
      Authentication: _Authentication,
      Capabilities: _Capabilities,
      Device: _Device$1,
      Discovery: _Discovery$1,
      Keyboard: _Keyboard$1,
      Lifecycle: _Lifecycle,
      Localization: _Localization$1,
      Metrics: _Metrics$1,
      Parameters: _Parameters,
      Profile: _Profile,
      SecondScreen: _SecondScreen,
      SecureStorage: _SecureStorage$1,
      Platform: _Platform,
  });

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTDeviceInfo {
    getaudio() {
      return new Promise((resolve, reject) => {
        Device.audio().then(supportedAudioProfiles => {
          console.log(supportedAudioProfiles);
          resolve(supportedAudioProfiles);
        }).catch(err => {
          console.error('firebolt getaudio error', err);
          reject(err);
        });
      });
    }
    getdistributor() {
      return new Promise((resolve, reject) => {
        Device.distributor().then(distributorId => {
          console.log(distributorId);
          resolve(distributorId);
        }).catch(err => {
          console.error('firebolt getdistributor error', err);
          reject(err);
        });
      });
    }
    gethdcp() {
      return new Promise((resolve, reject) => {
        Device.hdcp().then(supportedHdcpProfiles => {
          console.log(supportedHdcpProfiles);
          resolve(supportedHdcpProfiles);
        }).catch(err => {
          console.error('firebolt gethdcp error', err);
          reject(err);
        });
      });
    }
    gethdr() {
      return new Promise((resolve, reject) => {
        Device.hdr().then(supportedHdrProfiles => {
          console.log(supportedHdrProfiles);
          resolve(supportedHdrProfiles);
        }).catch(err => {
          console.error('firebolt gethdr error', err);
          reject(err);
        });
      });
    }
    getid() {
      return new Promise((resolve, reject) => {
        Device.id().then(id => {
          console.log(id);
          resolve(id);
        }).catch(err => {
          console.error('firebolt getid error', err);
          reject(err);
        });
      });
    }
    getmake() {
      return new Promise((resolve, reject) => {
        Device.make().then(make => {
          console.log(make);
          resolve(make);
        }).catch(err => {
          console.error('firebolt getmake error', err);
          reject(err);
        });
      });
    }
    getmodel() {
      return new Promise((resolve, reject) => {
        Device.model().then(model => {
          console.log(model);
          resolve(model);
        }).catch(err => {
          console.error('firebolt getmodel error', err);
          reject(err);
        });
      });
    }
    getname() {
      return new Promise((resolve, reject) => {
        Device.name().then(value => {
          console.log(value);
          resolve(value);
        }).catch(err => {
          console.error('firebolt getname error', err);
          reject(err);
        });
      });
    }
    getnetwork() {
      return new Promise((resolve, reject) => {
        Device.network().then(networkInfo => {
          console.log(networkInfo);
          resolve(networkInfo);
        }).catch(err => {
          console.error('firebolt getnetwork error', err);
          reject(err);
        });
      });
    }
    getplatform() {
      return new Promise((resolve, reject) => {
        Device.platform().then(platformId => {
          console.log(platformId);
          resolve(platformId);
        }).catch(err => {
          console.error('firebolt getplatform error', err);
          reject(err);
        });
      });
    }
    getscreenresolution() {
      return new Promise((resolve, reject) => {
        Device.screenResolution().then(screenResolution => {
          console.log(screenResolution);
          resolve(screenResolution);
        }).catch(err => {
          console.error('firebolt getscreenresolution error', err);
          reject(err);
        });
      });
    }
    getsku() {
      return new Promise((resolve, reject) => {
        Device.sku().then(sku => {
          console.log(sku);
          resolve(sku);
        }).catch(err => {
          console.error('firebolt getsku error', err);
          reject(err);
        });
      });
    }
    gettype() {
      return new Promise((resolve, reject) => {
        Device.type().then(deviceType => {
          console.log(deviceType);
          resolve(deviceType);
        }).catch(err => {
          console.error('firebolt gettype error', err);
          reject(err);
        });
      });
    }
    getuid() {
      return new Promise((resolve, reject) => {
        Device.uid().then(uniqueId => {
          console.log(uniqueId);
          resolve(uniqueId);
        }).catch(err => {
          console.error('firebolt getuid error', err);
          reject(err);
        });
      });
    }
    getversion() {
      return new Promise((resolve, reject) => {
        Device.version().then(versions => {
          console.log(versions);
          resolve(versions);
        }).catch(err => {
          console.error('firebolt getversion error', err);
          reject(err);
        });
      });
    }
    getvideoresolution() {
      return new Promise((resolve, reject) => {
        Device.videoResolution().then(videoResolution => {
          console.log(videoResolution);
          resolve(videoResolution);
        }).catch(err => {
          console.error('firebolt getvideoresolution error', err);
          reject(err);
        });
      });
    }
    listen(event) {
      return new Promise((resolve, reject) => {
        Device.listen(event, value => {
          console.log(value);
          resolve(value);
        }).catch(err => {
          console.error('firebolt listen error', err);
          reject(err);
        });
      });
    }
    once(event) {
      return new Promise((resolve, reject) => {
        Device.once(event, value => {
          console.log(value);
          resolve(value);
        }).catch(err => {
          console.error('firebolt listen error', err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTLifecycle {
    constructor() {
      this._events = new Map();
      Lifecycle.listen('background', value => {
        console.log('Fireboltapi background ' + JSON.stringify(value));
        if (this._events.has('background')) {
          this._events.get('background')(value);
        }
      });
      Lifecycle.listen('foreground', value => {
        console.log('Fireboltapi foreground ' + JSON.stringify(value));
        if (this._events.has('foreground')) {
          this._events.get('foreground')(value);
        }
      });
      Lifecycle.listen('inactive', value => {
        console.log('Fireboltapi inactive ' + JSON.stringify(value));
        if (this._events.has('inactive')) {
          this._events.get('inactive')(value);
        }
      });
      Lifecycle.listen('suspended', value => {
        console.log('Fireboltapi suspended ' + JSON.stringify(value));
        if (this._events.has('suspended')) {
          this._events.get('suspended')(value);
        }
      });
      Lifecycle.listen('unloading', value => {
        console.log('Fireboltapi unloading ' + JSON.stringify(value));
        if (this._events.has('unloading')) {
          this._events.get('unloading')(value);
        }
      });
    }
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }
    close() {
      return new Promise((resolve, reject) => {
        Lifecycle.close("remoteButton").then(success => {
          console.log(success);
          resolve(success);
        }).catch(err => {
          console.error('firebolt Lifecycle.close error', err);
          reject(err);
        });
      });
    }
    finished() {
      return new Promise((resolve, reject) => {
        Lifecycle.finished().then(results => {
          console.log(results);
          resolve(results);
        }).catch(err => {
          console.error('firebolt Lifecycle.finished error', err);
          reject(err);
        });
      });
    }
    ready() {
      return new Promise((resolve, reject) => {
        Lifecycle.ready().then(result => {
          console.log("getting result");
          console.log(result);
          resolve(result);
        }).catch(err => {
          console.error('firebolt Lifecycle.ready error', err);
          reject(err);
        });
      });
    }
    state() {
      return new Promise((resolve, reject) => {
        const state = Lifecycle.state();
        console.log(state);
        resolve(state);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTDiscovery {
    launch(appId, intent) {
      return new Promise((resolve, reject) => {
        Discovery.launch(appId, intent).then(success => {
          console.log("Discovery.launch result:" + success);
          resolve(success);
        }).catch(err => {
          console.error('firebolt Discovery.launch error', err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FBTLocalization {
    additionalInfo() {
      return new Promise((resolve, reject) => {
        Localization.additionalInfo().then(info => {
          console.log(info);
          resolve(info);
        }).catch(err => {
          console.error('firebolt Localization.additionalInfo error', err);
          reject(err);
        });
      });
    }
    countryCode() {
      return new Promise((resolve, reject) => {
        Localization.countryCode().then(code => {
          console.log(code);
          resolve(code);
        }).catch(err => {
          console.error('firebolt Localization.countryCode error', err);
          reject(err);
        });
      });
    }
    locality() {
      return new Promise((resolve, reject) => {
        Localization.locality().then(locality => {
          console.log(locality);
        }).catch(err => {
          console.error('firebolt Localization.locality error', err);
          reject(err);
        });
      });
    }
    latlon() {
      return new Promise((resolve, reject) => {
        Localization.latlon().then(latlong => {
          console.log(latlong);
          resolve(latlon);
        }).catch(err => {
          console.error('firebolt Localization.latlon error', err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance$1 = null;
  class FireBoltApi {
    constructor() {
      this.deviceinfo = new FBTDeviceInfo();
      this.lifecycle = new FBTLifecycle();
      this.discovery = new FBTDiscovery();
      this.localization = new FBTLocalization();
    }
    /**
    *
    * @returns {FireBoltApi}
    */
    static get() {
      if (instance$1 == null) {
        instance$1 = new FireBoltApi();
      }
      return instance$1;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for main view component in home UI */
  class MainView extends t.Component {
    /**
     * Function to render various elements in main view.
     */
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('home'));
    }
    static _template() {
      return {
        rect: true,
        color: CONFIG.theme.background,
        w: 1920,
        h: 1080,
        clipping: true,
        MainView: {
          w: 1720,
          h: 1200,
          xIndex: 2,
          y: 270,
          x: 200,
          clipping: false,
          Text0: {
            alpha: 0,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Popular Movies'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            },
            zIndex: 0
          },
          Gracenote: {
            y: 50,
            x: -20,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            type: t.components.ListComponent,
            w: 1745,
            h: 400,
            itemSize: 500,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -1,
            clipping: false
          },
          Inputs: {
            y: 0,
            visible: false,
            //false by default
            Title: {
              y: 0,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate('Input Select'),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Slider: {
              x: -20,
              y: 37,
              type: t.components.ListComponent,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              w: 1745,
              h: 300,
              itemSize: 288,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            }
          },
          Text1: {
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Featured Content'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            },
            zIndex: 0
          },
          AppList: {
            y: 37,
            x: 0,
            type: List,
            h: 400,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          Text2: {
            // x: 10 + 25,
            y: 395,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Lightning Apps'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          MetroApps: {
            x: -20,
            y: 435,
            type: t.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 300,
            itemSize: 288,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text3: {
            // x: 10 + 25,
            y: 673,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Featured Video on Demand'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          TVShows: {
            x: -20,
            y: 710,
            w: 1745,
            h: 400,
            type: t.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            roll: true,
            itemSize: 277,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text4: {
            // x: 10 + 25,
            y: 938,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Lightning Showcase'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          ShowcaseApps: {
            x: -20,
            y: 978,
            type: t.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 400,
            itemSize: 277,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          },
          Text5: {
            alpha: 0,
            // x: 10 + 25,
            y: 1203,
            h: 30,
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 25,
              text: Language$1.translate('Partner Apps'),
              fontStyle: 'normal',
              textColor: 0xFFFFFFFF
            }
          },
          UsbApps: {
            x: -20,
            y: 1243,
            type: t.components.ListComponent,
            flex: {
              direction: 'row',
              paddingLeft: 20,
              wrap: false
            },
            w: 1745,
            h: 400,
            itemSize: 277,
            roll: true,
            rollMax: 1745,
            horizontal: true,
            itemScrollOffset: -4,
            clipping: false
          }
        }
      };
    }
    pageTransition() {
      return 'up';
    }
    moveDownContent() {
      let inputSelectOffset = 0;
      if (this.inputSelect) {
        inputSelectOffset = 275;
      }
      this.tag('Text0').alpha = 1;
      this.tag("Inputs").y = 440;
      this.tag('Text1').y = 440 + inputSelectOffset;
      this.tag('AppList').y = 477 + inputSelectOffset;
      this.tag("Text2").y = 705 + inputSelectOffset;
      this.tag("MetroApps").y = 745 + inputSelectOffset;
      this.tag("Text3").y = 980 + inputSelectOffset;
      this.tag("TVShows").y = 1020 + inputSelectOffset;
      this.tag("Text4").y = 1248 + inputSelectOffset;
      this.tag("ShowcaseApps").y = 1288 + inputSelectOffset;
      this.tag("Text5").y = 1516 + inputSelectOffset;
      this.tag("UsbApps").y = 1556 + inputSelectOffset;
    }
    showInputSelect() {
      this.tag("Inputs").visible = true;
      let gracenoteOffset = 0;
      if (!this.gracenote) {
        gracenoteOffset = 440;
      }
      this.tag("Inputs").y = this.gracenote ? 440 : 0;
      this.tag('Text1').y = 440 + 275 - gracenoteOffset;
      this.tag('AppList').y = 477 + 275 - gracenoteOffset;
      this.tag("Text2").y = 705 + 275 - gracenoteOffset;
      this.tag("MetroApps").y = 745 + 275 - gracenoteOffset;
      this.tag("Text3").y = 980 + 275 - gracenoteOffset;
      this.tag("TVShows").y = 1020 + 275 - gracenoteOffset;
      this.tag("Text4").y = 1248 + 275 - gracenoteOffset;
      this.tag("ShowcaseApps").y = 1288 + 275 - gracenoteOffset;
      this.tag("Text5").y = 1516 + 275 - gracenoteOffset;
      this.tag("UsbApps").y = 1556 + 275 - gracenoteOffset;
    }

    /**
     * @param {any} data
     */
    setGracenoteData(data) {
      if (!this.gracenote) {
        this.gracenote = true;
        this.key = data.key;
        this.graceNoteItems = data.data;
        this.appItems = this.currentItems;
      }
    }
    _handleBack() {}
    async _init() {
      this.gracenote = false;
      this.inputSelect = false; //false by default
      this.settingsScreen = false;
      this.indexVal = 0;
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this.usbApi = new UsbApi();
      this.homeApi = new HomeApi();
      this.xcastApi = new XcastApi();
      this.hdmiApi = new HDMIApi();
      this.appApi = new AppApi();
      let thunder = thunderJS$1(config);

      // for initially showing/hiding usb icon

      let appItems = this.homeApi.getAppListInfo();
      let data = this.homeApi.getPartnerAppsInfo();
      let metroApps = this.homeApi.getOfflineMetroApps();
      let showcaseApps = this.homeApi.getShowCaseApps();
      await this.homeApi.checkAppCompatability(appItems).then(res => {
        appItems = res;
      });
      await this.appApi.isConnectedToInternet().then(result => {
        if (result) {
          metroApps = this.homeApi.getOnlineMetroApps();
        }
      }).catch(err => {
        console.log(err);
      });
      let prop_apps = 'applications';
      let prop_displayname = 'displayName';
      let prop_uri = 'uri';
      let prop_apptype = 'applicationType';
      let appdetails = [];
      let appdetails_format = [];
      let usbAppsArr = [];
      let usbApps = 0;
      try {
        if (data != null && JSON.parse(data).hasOwnProperty(prop_apps)) {
          appdetails = JSON.parse(data).applications;
          for (let i = 0; i < appdetails.length; i++) {
            if (appdetails[i].hasOwnProperty(prop_displayname) && appdetails[i].hasOwnProperty(prop_uri) && appdetails[i].hasOwnProperty(prop_apptype)) {
              usbAppsArr.push(appdetails[i]);
              usbApps++;
            }
          }
          for (let i = 0; i < appItems.length; i++) {
            appdetails_format.push(appItems[i]);
          }
        } else {
          appdetails_format = appItems;
        }
      } catch (e) {
        appdetails_format = appItems;
        console.log('Query data is not proper: ' + e);
      }
      this.firstRowItems = appdetails_format;
      this.tempRow = JSON.parse(JSON.stringify(this.firstRowItems));
      if (this.firstRowItems[0].uri === 'USB') {
        this.tempRow.shift();
      }
      this.appItems = this.tempRow;
      this.usbApps = usbAppsArr;
      this.hdmiApi.activate().then(() => {
        this.hdmiApi.registerEvent('onDevicesChanged', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('onDevicesChanged ', JSON.stringify(notification));
        });
        this.hdmiApi.registerEvent('onInputStatusChanged', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('onInputStatusChanged ', JSON.stringify(notification));
        });
        this.hdmiApi.registerEvent('onSignalChanged', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('onSignalChanged ', JSON.stringify(notification));
          if (notification.signalStatus !== 'stableSignal') {
            this.appApi.setVisibility(Storage$1.get("selfClientName"), true);
            this.widgets.fail.notify({
              title: this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data.displayName,
              msg: Language$1.translate("Input disconnected")
            });
            Router.focusWidget('Fail');
          }
        });
        this.hdmiApi.registerEvent('videoStreamInfoUpdate', notification => {
          this.fireAncestors("$hideImage", 0);
          console.log('videoStreamInfoUpdate ', JSON.stringify(notification));
        });
        this.inputSelect = true; //set the inputSelect to true if the device is tv, here considering hdmiApi is only available on tv
        this.appItems = this.tempRow;
        this.hdmiApi.getHDMIDevices().then(res => {
          if (res.length > 0) this.inputItems = res;
        });
      }).catch(err => {
        console.log('HDMIInput Plugin not activated', err);
      });
      //get the available input methods from the api

      // for USB event
      const registerListener = () => {
        let listener;
        listener = thunder.on('org.rdk.UsbAccess', 'onUSBMountChanged', notification => {
          console.log('onUsbMountChanged notification: ', JSON.stringify(notification));
          Storage$1.set('UsbMountedStatus', notification.mounted ? 'mounted' : 'unmounted');
          const currentPage = window.location.href.split('#').slice(-1)[0];
          if (Storage$1.get('UsbMedia') === 'ON') {
            if (notification.mounted) {
              this.appItems = this.firstRowItems;
              this._setState('AppList.0');
            } else if (!notification.mounted) {
              this.appItems = this.tempRow;
              this._setState('AppList.0');
            }
            console.log("app items = ".concat(this.appItems, " ; "));
            if (currentPage === 'menu') {
              //refresh page to hide or show usb icon
              console.log('page refreshed on unplug/plug');
            }
            if (!notification.mounted) {
              //if mounted is false
              if (currentPage === 'usb' || currentPage === 'usb/image' || currentPage === 'usb/player') {
                // hot exit if we are on usb screen or sub screens
                // this.$changeHomeText('Home')
                Router.navigate('menu');
              }
            }
          }
          console.log("usb event successfully registered");
        });
        return listener;
      };
      thunder.on('org.rdk.Network.1', 'onIPAddressStatusChanged', notification => {
        console.log('IP ADDRESS changed', JSON.stringify(notification));
        if (notification.status === 'ACQUIRED') {
          Storage$1.set('ipAddress', notification.ip4Address);
          metroApps = this.homeApi.getOnlineMetroApps();
        } else {
          Storage$1.set('ipAddress', null);
          //this.metroApps = this.homeApi.getMetroInfo()
        }
      });

      await this.homeApi.checkAppCompatability(metroApps).then(res => {
        this.metroApps = res;
      });
      await this.homeApi.checkAppCompatability(showcaseApps).then(res => {
        this.showcaseApps = res;
      });
      this.fireAncestors("$mountEventConstructor", registerListener.bind(this));
      this.refreshFirstRow();
      // this._setState('AppList.0')
    }

    _firstActive() {
      if (!Storage$1.get('UsbMedia')) {
        this.usbApi.activate().then(res => {
          Storage$1.set('UsbMedia', 'ON');
          this.fireAncestors('$registerUsbMount');
        });
      } else if (Storage$1.get('UsbMedia') === 'ON') {
        this.usbApi.activate().then(res => {
          this.fireAncestors('$registerUsbMount');
        });
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        // deactivate usb Plugin here
        this.usbApi.deactivate().then(res => {
          console.log("disabled the Usb Plugin");
        }).catch(err => {
          console.error("error while disabling the usb plugin = ".concat(err));
        });
      }
      if (this.gracenote) {
        this._setState("Gracenote");
      } else if (this.inputSelect) {
        this._setState("Inputs");
      } else {
        this._setState("AppList.0");
      }
    }
    _focus() {
      this._setState(this.state);
    }
    _firstEnable() {
      console.timeEnd('PerformanceTest');
      console.log('Mainview Screen timer end - ', new Date().toUTCString());
      this.networkApi = new Network();
      this.internetConnectivity = false;
    }
    scroll(val) {
      this.tag('MainView').patch({
        smooth: {
          y: [val, {
            timingFunction: 'ease',
            duration: 0.7
          }]
        }
      });
    }
    refreshFirstRow() {
      if (Storage$1.get('UsbMedia') === 'ON') {
        this.usbApi.activate().then(res => {
          this.usbApi.getMountedDevices().then(result => {
            if (result.mounted.length === 1) {
              this.appItems = this.firstRowItems;
            } else {
              this.appItems = this.tempRow;
            }
          });
        });
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        this.appItems = this.tempRow;
      } else {
        Storage$1.set('UsbMedia', 'ON');
        this.usbApi.activate().then(res => {
          this.usbApi.getMountedDevices().then(result => {
            if (result.mounted.length === 1) {
              this.appItems = this.firstRowItems;
            } else {
              this.appItems = this.tempRow;
            }
          });
        });
      }
    }

    /**
     * Function to set details of items in gracenote list.
     */
    set graceNoteItems(items) {
      this.moveDownContent();
      this.tag('Gracenote').items = items.map((info, idx) => {
        return {
          w: 480,
          h: 270,
          type: GracenoteItem,
          data: info,
          key: this.key,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 10
        };
      });
      this._setState('Gracenote');
    }
    set inputItems(items) {
      this.showInputSelect();
      this.tag("Inputs.Slider").items = items.map((info, idx) => {
        return {
          w: 268,
          h: 151,
          type: ListItem,
          data: {
            ...info,
            displayName: "Port ".concat(info.id),
            url: "/images/inputs/HDMI.jpg"
          },
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
      this._setState("Inputs.0");
    }
    set showcaseApps(items) {
      this.tag('ShowcaseApps').items = items.map((info, idx) => {
        return {
          w: 268,
          h: 151,
          type: ListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
    }

    /**
     * Function to set details of items in app list.
     */
    set appItems(items) {
      this.currentItems = items;
      this.tag('AppList').clear();
      this.tag('AppList').add(items.map((info, idx) => {
        return {
          w: this.gracenote || this.inputSelect ? 268 : 454,
          h: this.gracenote || this.inputSelect ? 151 : 255,
          type: ListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    set metroApps(items) {
      this.tag('MetroApps').items = items.map((info, index) => {
        return {
          w: 268,
          h: 151,
          type: ListItem,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: index,
          bar: 12
        };
      });
    }

    /**
     * Function to set details of items in tv shows list.
     */
    set tvShowItems(items) {
      this.tag('TVShows').items = items.map((info, idx) => {
        return {
          w: 257,
          h: 145,
          type: ListItem,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      });
    }
    set usbApps(items) {
      if (items.length > 0) {
        this.tag('Text5').alpha = 1;
      }
      this.tag('UsbApps').items = items.map((info, index) => {
        return {
          w: 257,
          h: 145,
          type: ListItem,
          data: info,
          focus: 1.15,
          unfocus: 1,
          idx: index,
          bar: 12
        };
      });
    }
    /**
     * Function to set the state in main view.
     */
    index(index) {
      if (index == 0) {
        this._setState('AppList');
      } else if (index == 1) {
        this._setState('MetroApps');
      } else if (index == 2) {
        this._setState('TVShows');
      } else if (index == 3) {
        if (this.tag('UsbApps').length) {
          this._setState('UsbApps');
        } else {
          this._setState('TVShows');
        }
      }
    }
    /**
     * Function to define various states needed for main view.
     */
    static _states() {
      return [class Gracenote extends this {
        $enter() {
          this.indexVal = 0;
          this.scroll(270);
        }
        $exit() {
          this.tag('Text0').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text0').text.fontStyle = 'bold';
          if (this.tag('Gracenote').length) {
            return this.tag('Gracenote').element;
          }
        }
        _handleDown() {
          if (this.inputSelect) {
            this._setState('Inputs');
          } else {
            this._setState('AppList');
          }
        }
        _handleRight() {
          if (this.tag('Gracenote').length - 1 != this.tag('Gracenote').index) {
            this.tag('Gracenote').setNext();
            return this.tag('Gracenote').element;
          }
        }
        _handleUp() {
          this.widgets.menu.notify('TopPanel');
        }
        _handleLeft() {
          this.tag('Text0').text.fontStyle = 'normal';
          if (0 != this.tag('Gracenote').index) {
            this.tag('Gracenote').setPrevious();
            return this.tag('Gracenote').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        _handleEnter() {
          Router.navigate('menu/details', {
            gracenoteItem: this.tag('Gracenote').element.data,
            key: this.key
          });
        }
      }, class Inputs extends this {
        $enter() {
          this.tag('Inputs.Title').text.fontStyle = 'bold';
          this.indexVal = 0;
          this.scroll(270);
        }
        $exit() {
          this.tag('Inputs.Title').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Inputs.Title').text.fontStyle = 'bold';
          if (this.tag("Inputs.Slider").length) {
            return this.tag("Inputs.Slider").element;
          }
        }
        _handleDown() {
          this._setState('AppList');
        }
        _handleUp() {
          if (this.gracenote) {
            this._setState('Gracenote');
          } else {
            this.widgets.menu.notify('TopPanel');
          }
        }
        _handleLeft() {
          if (0 != this.tag('Inputs.Slider').index) {
            this.tag('Inputs.Slider').setPrevious();
            return this.tag('Inputs.Slider').element;
          } else {
            this.tag('Inputs.Title').text.fontStyle = 'normal';
            Router.focusWidget('Menu');
          }
        }
        _handleRight() {
          if (this.tag('Inputs.Slider').length - 1 != this.tag('Inputs.Slider').index) {
            this.tag('Inputs.Slider').setNext();
            return this.tag('Inputs.Slider').element;
          }
        }
        _handleEnter() {
          console.log(this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data);
          this.hdmiApi.setHDMIInput(this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data).then(res => {
            console.log('completed');
            Storage$1.set('applicationType', 'HDMI');
            const currentInput = this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data;
            Storage$1.set("_currentInputMode", {
              id: currentInput.id,
              locator: currentInput.locator
            });
            this.appApi.setVisibility(Storage$1.get("selfClientName"), false);
          }).catch(err => {
            console.log('failed', err);
            this.widgets.fail.notify({
              title: this.tag('Inputs.Slider').items[this.tag('Inputs.Slider').index].data.displayName,
              msg: 'Select a different input.'
            });
            Router.focusWidget('Fail');
          });
        }
      }, class AppList extends this {
        $enter() {
          this.indexVal = 0;
          if (this.inputSelect && this.gracenote) {
            this.scroll(-100);
          } else {
            this.scroll(270);
          }
        }
        $exit() {
          this.tag('Text1').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text1').text.fontStyle = 'bold';
          if (this.tag('AppList').length) {
            return this.tag('AppList');
          }
        }
        _handleDown() {
          this._setState('MetroApps');
        }
        _handleUp() {
          if (this.inputSelect) {
            this._setState('Inputs');
          } else if (this.gracenote) {
            this._setState('Gracenote');
          } else {
            this.widgets.menu.notify('TopPanel');
          }
        }
        _handleLeft() {
          this.tag('Text1').text.fontStyle = 'normal';
          Router.focusWidget('Menu');
        }
        async _handleEnter() {
          let applicationType = this.tag('AppList').items[this.tag('AppList').index].data.applicationType;
          let uri = this.tag('AppList').items[this.tag('AppList').index].data.uri;
          let appIdentifier = this.tag('AppList').items[this.tag('AppList').index].data.appIdentifier;
          if (uri === 'USB') {
            this.usbApi.getMountedDevices().then(result => {
              if (result.mounted.length === 1) {
                Router.navigate('usb');
              }
            });
          } else {
            let params = {
              url: uri,
              launchLocation: "mainView",
              appIdentifier: appIdentifier
            };
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", err);
            });
          }
        }
      }, class MetroApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-200);
          } else {
            this.scroll(-100);
          }
          this.indexVal = 1;
        }
        $exit() {
          this.tag('Text2').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text2').text.fontStyle = 'bold';
          if (this.tag('MetroApps').length) {
            return this.tag('MetroApps').element;
          }
        }
        _handleUp() {
          this._setState('AppList');
        }
        _handleDown() {
          this._setState('TVShows');
        }
        _handleRight() {
          if (this.tag('MetroApps').length - 1 != this.tag('MetroApps').index) {
            this.tag('MetroApps').setNext();
            return this.tag('MetroApps').element;
          }
        }
        _handleLeft() {
          this.tag('Text2').text.fontStyle = 'normal';
          if (0 != this.tag('MetroApps').index) {
            this.tag('MetroApps').setPrevious();
            return this.tag('MetroApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          let applicationType = this.tag('MetroApps').items[this.tag('MetroApps').index].data.applicationType;
          let appIdentifier = this.tag('MetroApps').items[this.tag('MetroApps').index].data.appIdentifier;
          let params = {
            url: this.tag('MetroApps').items[this.tag('MetroApps').index].data.uri,
            launchLocation: "mainView",
            appIdentifier: appIdentifier
          };
          this.appApi.launchApp(applicationType, params).catch(err => {
            console.log("ApplaunchError: ", JSON.stringify(err), err);
          });
        }
      }, class TVShows extends this {
        $enter() {
          this.indexVal = 2;
          if (this.inputSelect && this.gracenote) {
            this.scroll(-600);
          } else {
            this.scroll(-400);
          }
        }
        _handleUp() {
          this.scroll(270);
          this._setState('MetroApps');
        }
        _getFocused() {
          this.tag('Text3').text.fontStyle = 'bold';
          if (this.tag('TVShows').length) {
            return this.tag('TVShows').element;
          }
        }
        _handleRight() {
          if (this.tag('TVShows').length - 1 != this.tag('TVShows').index) {
            this.tag('TVShows').setNext();
            return this.tag('TVShows').element;
          }
        }
        _handleLeft() {
          this.tag('Text3').text.fontStyle = 'normal';
          if (0 != this.tag('TVShows').index) {
            this.tag('TVShows').setPrevious();
            return this.tag('TVShows').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        _handleDown() {
          // if (this.tag('UsbApps').length) {
          this._setState("ShowcaseApps");
          //}
        }

        async _handleEnter() {
          try {
            this.internetConnectivity = await this.networkApi.isConnectedToInternet();
          } catch {
            this.internetConnectivity = false;
          }
          let displayName = this.tag('TVShows').items[this.tag('TVShows').index].data.displayName;
          if (this.internetConnectivity) {
            if (displayName === "FOG HLS") {
              let params = {
                url: "http://127.0.0.1:9080/tsb?clientId=FOG_AAMP&recordedUrl=https%3A%2F%2Fcph-p2p-msl.akamaized.net%2Fhls%2Flive%2F2000341%2Ftest%2Fmaster.m3u8"
              };
              Router.navigate("player", params);
            } else if (displayName === "FOG DASH") {
              let params = {
                url: "http://127.0.0.1:9080/tsb?clientId=FOG_AAMP&recordedUrl=https%3A%2F%2Flin001-gb-s8-tst-ll.cdn01.skycdp.com%2FSKYNEHD_HD_SUD_SKYUKD_4050_18_0000000000000018163.mpd"
              };
              Router.navigate("player", params);
            } else {
              //this.fireAncestors('$goToPlayer')
              Router.navigate('player');
            }
          }
        }
        $exit() {
          this.tag('Text3').text.fontStyle = 'normal';
        }
      }, class ShowcaseApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-750);
          } else {
            this.scroll(-550);
          }
        }
        $exit() {
          this.tag('Text4').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text4').text.fontStyle = 'bold';
          if (this.tag('ShowcaseApps').length) {
            return this.tag('ShowcaseApps').element;
          }
        }
        _handleUp() {
          this._setState('TVShows');
        }
        _handleRight() {
          if (this.tag('ShowcaseApps').length - 1 != this.tag('ShowcaseApps').index) {
            this.tag('ShowcaseApps').setNext();
            return this.tag('ShowcaseApps').element;
          }
        }
        _handleDown() {
          if (this.tag('UsbApps').length) {
            this._setState("UsbApps");
          }
        }
        _handleLeft() {
          this.tag('Text4').text.fontStyle = 'normal';
          if (0 != this.tag('ShowcaseApps').index) {
            this.tag('ShowcaseApps').setPrevious();
            return this.tag('ShowcaseApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          let applicationType = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.applicationType;
          let appIdentifier = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.appIdentifier;
          let appId = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.appId;
          let intent = this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.intent;
          let params = {
            url: this.tag('ShowcaseApps').items[this.tag('ShowcaseApps').index].data.uri,
            launchLocation: "mainView",
            appIdentifier: appIdentifier
          };
          if (applicationType == "FireboltApp") {
            FireBoltApi.get().discovery.launch(appId, intent).then(res => {
              console.log(res);
              // HOME key press won't bring back RefUI.
              Storage$1.set("applicationType", "FireboltApp");
            });
          } else {
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", JSON.stringify(err), err);
            });
          }
        }
      }, class UsbApps extends this {
        $enter() {
          if (this.inputSelect && this.gracenote) {
            this.scroll(-1000);
          } else {
            this.scroll(-750);
          }
        }
        $exit() {
          this.tag('Text5').text.fontStyle = 'normal';
        }
        _getFocused() {
          this.tag('Text5').text.fontStyle = 'bold';
          if (this.tag('UsbApps').length) {
            return this.tag('UsbApps').element;
          }
        }
        _handleUp() {
          this._setState('ShowcaseApps');
        }
        _handleRight() {
          if (this.tag('UsbApps').length - 1 != this.tag('MetroApps').index) {
            this.tag('UsbApps').setNext();
            return this.tag('UsbApps').element;
          }
        }
        _handleLeft() {
          this.tag('Text5').text.fontStyle = 'normal';
          if (0 != this.tag('UsbApps').index) {
            this.tag('UsbApps').setPrevious();
            return this.tag('UsbApps').element;
          } else {
            Router.focusWidget('Menu');
          }
        }
        async _handleEnter() {
          let applicationType = this.tag('UsbApps').items[this.tag('UsbApps').index].data.applicationType;
          let params = {
            url: this.tag('UsbApps').items[this.tag('UsbApps').index].data.uri,
            launchLocation: "mainView"
          };
          if (applicationType === "CameraApp") {
            let cameraParams = {
              cameraUrl: this.tag('UsbApps').items[this.tag('UsbApps').index].data.uri
            };
            Router.navigate("camera/player", cameraParams);
          } else {
            this.appApi.launchApp(applicationType, params).catch(err => {
              console.log("ApplaunchError: ", JSON.stringify(err), err);
            });
          }
        }
      }, class RightArrow extends this {
        //TODO
      }, class LeftArrow extends this {
        //TODO
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let _item$1;
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothPairingScreen$1 extends t.Component {
    set params(args) {
      if (args.bluetoothItem) {
        this.item(args.bluetoothItem);
      } else {
        Router.navigate('settings/bluetooth');
      }
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xff000000,
        BluetoothPair: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Pairing: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 0,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            ConnectDisconnect: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Unpair: {
              x: 0 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Unpair"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 0 + 220 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    item(item) {
      _item$1 = item;
      this._setState('ConnectDisconnect');
      this.tag('Title').text = item.name;
      if (item.connected) {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Disconnect');
      } else {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Connect');
      }
    }
    _init() {
      this._setState('ConnectDisconnect');
    }
    static _states() {
      return [class ConnectDisconnect extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          // this.tag('Pairing').text = "Someting is wrong " + _item.name
          if (_item$1.connected) {
            // this.tag('Pairing').text = "Connecting to " + _item.name
            //this.fireAncestors('$pressEnter', 'Disconnect')
            Router.navigate('settings/bluetooth', {
              action: 'Disconnect'
            });
          } else {
            // this.tag('Pairing').text = "Disconnecting from " + _item.name
            // this.fireAncestors('$pressEnter', 'Connect')
            Router.navigate('settings/bluetooth', {
              action: 'Connect'
            });
          }
        }
        _handleRight() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Unpair extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          //this.fireAncestors('$pressEnter', 'Unpair')
          Router.navigate('settings/bluetooth', {
            action: 'Unpair'
          });
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _handleLeft() {
          this._setState('ConnectDisconnect');
        }
        _focus() {
          this.tag('Unpair').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Unpair').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          //this.fireAncestors('$pressEnter', 'Cancel')
          Router.navigate('settings/bluetooth', {
            action: 'Cancel'
          });
        }
        _handleLeft() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for the item in the Bluetooth screen.
   */
  class BluetoothItem extends SettingsItem {
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents of an item in the Bluetooth screen.
     */
    set item(item) {
      this._item = item;
      this.connected = item.connected ? 'Connected' : 'Not Connected';
      this.status = item.paired ? Language$1.translate(this.connected) : Language$1.translate('Not Paired');
      this.tag('Item').patch({
        Left: {
          x: 10,
          y: 45,
          mountY: 0.5,
          text: {
            text: item.name,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        },
        Right: {
          x: 1600 - 200,
          y: 30,
          mountY: 0.5,
          mountX: 1,
          Text: {
            text: {
              text: this.status,
              fontSize: 25,
              fontFace: CONFIG.language.font,
              verticalAlign: "middle"
            }
          }
        }
        //  Debug:{
        //    x: 300,
        //    y:5,
        //    mountY: 0.5,
        //    mountX:1,
        //    Text: { text: { text: `item: ${JSON.stringify(item)}`, fontSize: 15,fontFace:CONFIG.language.font,verticalAlign:"middle" } },
        //  }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 10
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
    // _handleEnter() {
    //   // this.tag("Item").patch(
    //   //   {
    //   //     text: {
    //   //       text: "this works",
    //   //     }
    //   //   }
    //   // )
    //   this.fireAncestors('$connectBluetooth', this.tag('List').element.ref)
    // }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Bluetooth thunder plugin apis.
   */

  class BluetoothApi {
    constructor() {
      this._events = new Map();
      this._devices = [];
      this._pairedDevices = [];
      this._connectedDevices = [];
      this.btStatus = false;
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
    }

    /**
     * Function to activate the Bluetooth plugin
     */

    btactivate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    deactivateBluetooth() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'deactivate', {
          callsign: this.callsign
        }).then(result => {
          resolve(true);
        }).catch(err => {
          reject(err);
        });
      });
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.callsign = 'org.rdk.Bluetooth';
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.btStatus = true;
          this._thunder.on(this.callsign, 'onDiscoveredDevice', notification => {
            // this.getDiscoveredDevices().then(() => {
            this._events.get('onDiscoveredDevice')(notification);
            // })
          });

          this._thunder.on(this.callsign, 'onStatusChanged', notification => {
            if (notification.newStatus === 'PAIRING_CHANGE') {
              this.getPairedDevices();
            } else if (notification.newStatus === 'CONNECTION_CHANGE') {
              this.getConnectedDevices().then(() => {
                this._events.get('onConnectionChange')(notification);
              });
            } else if (notification.newStatus === 'DISCOVERY_STARTED') {
              this.getConnectedDevices().then(() => {
                this._events.get('onDiscoveryStarted')();
              });
            } else if (notification.newStatus === 'DISCOVERY_COMPLETED') {
              this.getConnectedDevices().then(() => {
                this._events.get('onDiscoveryCompleted')();
              });
            }
          });
          this._thunder.on(this.callsign, 'onPairingRequest', notification => {
            this._events.get('onPairingRequest')(notification);
          });
          this._thunder.on(this.callsign, 'onRequestFailed', notification => {
            this._events.get('onRequestFailed')(notification);
          });
          this._thunder.on(this.callsign, 'onConnectionRequest', notification => {
            this._events.get('onConnectionRequest')(notification);
          });
          resolve('Blutooth activated');
        }).catch(err => {
          console.error('Activation failure', err);
          reject('Bluetooth activation failed', err);
        });
      });
    }

    /**
     *
     * @param {string} eventId
     * @param {function} callback
     * Function to register the events for the Bluetooth plugin.
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Function to deactivate the Bluetooth plugin.
     */
    deactivate() {
      this._events = new Map();
    }

    /**
     * Function to disable the Bluetooth stack.
     */
    disable() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'disable').then(result => {
          this.btStatus = false;
          resolve(result);
        }).catch(err => {
          console.error("Can't disable : ".concat(JSON.stringify(err)));
        });
      });
    }

    /**
     * Function to enable the Bluetooth stack.
     */
    enable() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'enable').then(result => {
          resolve(result);
          this.btStatus = true;
        }).catch(err => {
          console.error("Can't enable : ".concat(JSON.stringify(err)));
          reject();
        });
      });
    }

    /**
     * Function to start scanning for the Bluetooth devices.
     */
    startScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'startScan', {
          timeout: 10,
          profile: "KEYBOARD,\n                    MOUSE,\n                    JOYSTICK,\n                    HUMAN INTERFACE DEVICE"
        }).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error', err);
          reject();
        });
      });
    }
    startScanBluetooth() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'startScan', {
          timeout: 1000,
          profile: "KEYBOARD,\n          MOUSE,\n          JOYSTICK,\n          HUMAN INTERFACE DEVICE"
        }).then(result => {
          if (result.success) resolve(result);else reject(result);
        }).catch(err => {
          console.error('Error', err);
          reject(err);
        });
      });
    }

    /**
     * Function to stop scanning for the Bluetooth devices.
     */
    stopScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'stopScan', {}).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error', err);
          reject();
        });
      });
    }

    /**
     * Function returns the discovered Bluetooth devices.
     */
    getDiscoveredDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getDiscoveredDevices').then(result => {
          this._devices = result.discoveredDevices;
          resolve(result.discoveredDevices);
        }).catch(err => {
          console.error("Can't get discovered devices : ".concat(JSON.stringify(err)));
        });
      });
    }
    get discoveredDevices() {
      return this._devices;
    }

    /**
     * Function returns the paired Bluetooth devices.
     */
    getPairedDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getPairedDevices').then(result => {
          this._pairedDevices = result.pairedDevices;
          resolve(result.pairedDevices);
        }).catch(err => {
          console.error("Can't get paired devices : ".concat(err));
          reject(false);
        });
      });
    }
    get pairedDevices() {
      return this._pairedDevices;
    }

    /**
     * Function returns the connected Bluetooth devices.
     */
    getConnectedDevices() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getConnectedDevices').then(result => {
          this._connectedDevices = result.connectedDevices;
          resolve(result.connectedDevices);
        }).catch(err => {
          console.error("Can't get connected devices : ".concat(err));
          reject();
        });
      });
    }
    get connectedDevices() {
      return this._connectedDevices;
    }

    /**
     *
     * Function to connect a Bluetooth device.
     * @param {number} deviceID Device ID of the Bluetoth client.
     * @param {string} deviceType Device type of the Bluetooth client.
     */
    connect(deviceID, deviceType) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'connect', {
          deviceID: deviceID,
          deviceType: deviceType,
          connectedProfile: deviceType
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('Connection failed', err);
          reject();
        });
      });
    }

    /**
     * Function to disconnect a Bluetooth device.
     *@param {number} deviceID Device ID of the Bluetoth client.
     *@param {string} deviceType Device type of the Bluetooth client.
     */
    disconnect(deviceID, deviceType) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'disconnect', {
          deviceID: deviceID,
          deviceType: deviceType
        }).then(result => {
          if (result.success) resolve(true);else reject();
        }).catch(err => {
          console.error('disconnect failed', err);
          reject();
        });
      });
    }

    /**
     * Function to unpair a Bluetooth device.
     * @param {number} deviceId
     */
    unpair(deviceId) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'unpair', {
          deviceID: deviceId
        }).then(result => {
          if (result.success) resolve(result.success);else resolve(false);
        }).catch(err => {
          console.error('unpair failed', err);
          resolve(false);
        });
      });
    }

    /**
     * Function to pair a Bluetooth device.
     * @param {number} deviceId
     */
    pair(deviceId) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'pair', {
          deviceID: deviceId
        }).then(result => {
          if (result.success) resolve(result);else reject(result);
        }).catch(err => {
          console.error('Error on pairing', err);
          reject();
        });
      });
    }

    /**
     * Function to respond to client the Bluetooth event.
     * @param {number} deviceID Device ID of the Bluetooth client.
     * @param {string} eventType Name of the event.
     * @param {string} responseValue Response sent to the Bluetooth client.
     */
    respondToEvent(deviceID, eventType, responseValue) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'respondToEvent', {
          deviceID: deviceID,
          eventType: eventType,
          responseValue: responseValue
        }).then(result => {
          if (result.success) resolve();else reject();
        }).catch(err => {
          console.error('Error on respondToEvent', err);
          reject();
        });
      });
    }

    /**
     * Function to get the discoverable name of the Bluetooth plugin.
     */
    getName() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'getName').then(result => {
          resolve(result.name);
        });
      });
    }
    setAudioStream(deviceID) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Bluetooth', 'setAudioStream', {
          "deviceID": deviceID,
          "audioStreamName": "AUXILIARY"
        }).then(result => {
          // console.log(JSON.stringify(result))
          this._connectedDevices = result.connectedDevices;
          resolve(result.connectedDevices);
        }).catch(err => {
          console.error("Can't get connected devices : ".concat(err));
          reject();
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothConfirmation extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Title: {
          mountX: 0.5,
          text: {
            text: "",
            fontFace: CONFIG.language.font,
            fontSize: 40,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 0,
          y: 75,
          w: 1558,
          h: 3,
          rect: true,
          mountX: 0.5
        },
        Pairing: {
          x: 0,
          y: 125,
          mountX: 0.5,
          text: {
            text: "",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        RectangleDefault: {
          x: 0,
          y: 200,
          w: 200,
          mountX: 0.5,
          h: 50,
          rect: true,
          color: CONFIG.theme.hex,
          Ok: {
            x: 100,
            y: 25,
            mount: 0.5,
            text: {
              text: "OK",
              fontFace: CONFIG.language.font,
              fontSize: 22
            }
          }
        },
        BorderBottom: {
          x: 0,
          y: 300,
          w: 1558,
          h: 3,
          rect: true,
          mountX: 0.5
        }
      };
    }
    set item(item) {
      this.tag('Title').text = item.name;
    }
    _handleEnter() {
      this.fireAncestors('$pressOK');
    }
    _handleBack() {
      this.fireAncestors('$pressOK');
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth screen.
   */
  class BluetoothScreen$2 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Bluetooth On/Off'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        Bluetooth: {
          y: 275,
          x: 200,
          Confirmation: {
            x: 780,
            y: 100,
            type: BluetoothConfirmation,
            visible: false
          },
          PairingScreen: {
            x: 780,
            y: 100,
            type: BluetoothPairingScreen$1,
            zIndex: 100,
            visible: false
          },
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Searching: {
            visible: false,
            h: 90,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Searching for Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              // x: 1600,
              x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            }
          },
          Networks: {
            PairedNetworks: {
              y: 180,
              List: {
                type: t.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            AvailableNetworks: {
              y: 90,
              visible: false,
              List: {
                w: 1920 - 300,
                type: t.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            visible: false
          },
          AddADevice: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Add A Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }

    /**
     * @param {{ action: String; }} args
     */
    set params(args) {
      if (args.action) {
        this.pressEnter(args.action);
      }
    }
    _unfocus() {
      this._disable();
    }
    pageTransition() {
      return 'left';
    }
    _firstEnable() {
      this._bt = new BluetoothApi();
      this._bluetooth = false;
      this._activateBluetooth();
      this._setState('Switch');
      //this.switch()
      //this._bluetooth = false
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this.renderDeviceList();
      this.loadingAnimation = this.tag('Searching.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('AddADevice');
      this._enable();
      if (this._bluetooth) {
        this.tag('Networks').visible = true;
        this.tag('AddADevice').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.renderDeviceList();
        //this._bt.startScan()
      }
    }

    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    /**
     * Function to be excuted when the Bluetooth screen is enabled.
     */
    _enable() {
      if (this._bluetooth) {
        this._bt.startScan();
      }
      this.scanTimer = Registry.setInterval(() => {
        if (this._bluetooth) {
          this._bt.startScan();
        }
      }, 5000);
    }

    /**
     * Function to be executed when the Bluetooth screen is disabled from the screen.
     */
    _disable() {
      if (this.scanTimer) {
        Registry.clearInterval(this.scanTimer);
      }
      this._bt.stopScan();
    }

    /**
     * Function to be executed when add a device is pressed
     */

    showAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: true
      });
      this.tag('AvailableNetworks').patch({
        visible: true
      });
      //  this.loadingAnimation.stop()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hideAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      //  this.loadingAnimation.start()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    showPairingScreen() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: true
      });
      this.fireAncestors('$hideTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hidePairingScreen() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.fireAncestors('$showTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    showConfirmation() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: true
      });
      this.fireAncestors('$hideTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hideConfirmation() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      this.tag('PairingScreen').patch({
        visible: false
      });
      this.tag('Confirmation').patch({
        visible: false
      });
      this.fireAncestors('$showTopPanel');
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    /**
     * Function to render list of Bluetooth devices
     */
    renderDeviceList() {
      this._bt.getPairedDevices().then(result => {
        this._pairedList = result;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.paired = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
      this._bt.getDiscoveredDevices().then(result => {
        this._discoveredList = result;
        this._otherList = this._discoveredList.filter(device => {
          if (!device.paired) {
            result = this._pairedList.map(a => a.deviceID);
            if (result.includes(device.deviceID)) {
              return false;
            } else return device;
          }
        });
        this._availableNetworks.tag('List').rollMax = this._otherList.length * 90;
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          return {
            ref: 'Other' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this._setState('Switch');
      } else if (option === 'Pair') {
        this._bt.pair(this._availableNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._availableNetworks.tag('List').element._item.name;
          if (result.success) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Pairing Successful')
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Pairing Failed')
            });
            Router.focusWidget('Fail');
          }
          this.hideAvailableDevices();
        });
      } else if (option === 'Connect') {
        this._bt.connect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Connection Failed')
            });
            Router.focusWidget('Fail');
          } else {
            this._bt.setAudioStream(this._pairedNetworks.tag('List').element._item.deviceID);
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Connection Successful')
            });
            Router.focusWidget('Fail');
          }
        });
      } else if (option === 'Disconnect') {
        this._bt.disconnect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Failed to Disconnect')
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Disconnected')
            });
            Router.focusWidget('Fail');
          }
        });
      } else if (option === 'Unpair') {
        this._bt.unpair(this._pairedNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (result) {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Unpaired')
            });
            Router.focusWidget('Fail');
          } else {
            this.widgets.fail.notify({
              title: btName,
              msg: Language$1.translate('Unpairing Failed')
            });
            Router.focusWidget('Fail');
          }
        });
      }
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          this.hideAvailableDevices();
          this.hidePairingScreen();
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this.switch();
        }
      }, class Confirmation extends this {
        $enter() {
          this.showConfirmation();
        }
        _getFocused() {
          return this.tag('Confirmation');
        }
        $pressOK() {
          this._setState('Switch');
          this.hideConfirmation();
        }
      }, class PairedDevices extends this {
        $enter() {
          this.hideAvailableDevices();
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          //this.showPairingScreen()
          //this.tag('PairingScreen').item = this._pairedNetworks.tag('List').element._item
          Router.navigate('settings/bluetooth/pairing', {
            bluetoothItem: this._pairedNetworks.tag('List').element._item
          });
          //this._setState('PairingScreen')
        }
      }, class AvailableDevices extends this {
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          this.pressEnter('Pair');
          //this.tag('Confirmation').item = this._availableNetworks.tag('List').element._item
        }

        _handleBack() {
          this.hideAvailableDevices();
          this._setState('Switch');
        }
      }, class AddADevice extends this {
        $enter() {
          this.tag('AddADevice')._focus();
          this.hideAvailableDevices();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleDown() {
          if (this._bluetooth) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('AddADevice')._unfocus();
        }
        _handleEnter() {
          if (this._bluetooth) {
            this.showAvailableDevices();
            this._setState('AvailableDevices');
          }
        }
      }, class PairingScreen extends this {
        $enter() {
          this._disable();
          this._bt.stopScan();
          return this.tag('PairingScreen');
        }
        _getFocused() {
          return this.tag('PairingScreen');
        }
        $exit() {
          this.tag('PairingScreen').visible = false;
          this._enable();
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) ;
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) ; else if (listname === 'MyDevices') {
            this._setState('AddADevice');
          }
        }
      }
    }

    /**
     * Function to turn on and off Bluetooth.
     */
    switch() {
      if (this._bluetooth) {
        this._bt.disable().then(result => {
          if (result.success) {
            this._bluetooth = false;
            this.tag('Networks').visible = false;
            this.tag('AddADevice').visible = false;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
        }).catch(() => {
          console.log('Cannot turn off Bluetooth');
        });
      } else {
        this._bt.enable().then(result => {
          if (result.success) {
            this._bluetooth = true;
            this.tag('Networks').visible = true;
            this.tag('AddADevice').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.renderDeviceList();
            this._bt.startScan();
          }
        }).catch(() => {
          console.log('Cannot turn on Bluetooth');
        });
      }
    }

    /**
     * Function to activate Bluetooth plugin.
     */
    _activateBluetooth() {
      this._bt.activate().then(res => {
        console.log(res);
        this._bluetooth = true;
        this._bt.registerEvent('onDiscoveredDevice', () => {
          this.renderDeviceList();
        });
        this._bt.registerEvent('onPairingRequest', notification => {
          this.respondToPairingRequest(notification.deviceID, 'ACCEPTED');
        });
        this._bt.registerEvent('onConnectionChange', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          let btName = notification.name;
          if (notification.connected) {
            if (this.widgets.fail) {
              this.widgets.fail.notify({
                title: btName,
                msg: Language$1.translate('Connected')
              });
              Router.focusWidget('Fail');
            }
          } else {
            if (this.widgets.fail) {
              this.widgets.fail.notify({
                title: btName,
                msg: Language$1.translate('Disconnected')
              });
              Router.focusWidget('Fail');
            }
          }
        });
        this._bt.registerEvent('onDiscoveryCompleted', () => {
          this.tag('Searching.Loader').visible = false;
          this.loadingAnimation.stop();
          this.renderDeviceList();
        });
        this._bt.registerEvent('onDiscoveryStarted', () => {
          this.loadingAnimation.start();
          this.tag('Searching.Loader').visible = true;
        });
        this._bt.registerEvent('onRequestFailed', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          if (this.widgets.fail) {
            this.widgets.fail.notify({
              title: notification.name,
              msg: notification.newStatus
            });
            Router.focusWidget('Fail');
          }
        });
      }).catch(err => {
        console.log(err);
      });
    }

    /**
     * Function to respond to Bluetooth client.
     * @param {number} deviceID
     * @param {string} responseValue
     */
    respondToPairingRequest(deviceID, responseValue) {
      this._bt.respondToEvent(deviceID, 'onPairingRequest', responseValue);
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Colors
   *
   * Contains global color style information to easily maintain consistency throughout components.
   */

  /**
   * Combines rgb hex string and alpha into argb hexadecimal number
   * @param {string} hex - 6 alphanumeric characters between 0-f
   * @param {number} [alpha] - number between 0-100 (0 is invisible, 100 is opaque)
   */
  function getHexColor$1(hex) {
    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    if (!hex) {
      return 0x00;
    }
    let hexAlpha = Math.round(alpha / 100 * 255).toString(16);
    let str = "0x".concat(hexAlpha).concat(hex);
    return parseInt(Number(str), 10);
  }

  /**
   * Pair color values with color names in the "Neutral" palette
   */
  const COLORS_NEUTRAL = {
    dark1: '000000',
    dark2: '080808',
    dark3: '101010',
    light1: 'FFFFFF',
    light2: 'F5F5F5',
    light3: 'E8E8E8'
  };

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  /**
   * Returns a styles object for use by components
   * @param {Object|function} styles - Object or callback that takes theme as an argument, ultimately the returned value
   * @param {Object} theme - theme to be provided to styles
   */
  var createStyles = ((styles, theme) => {
    return typeof styles === 'function' ? styles(theme) : styles;
  });

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  /**
   * Helpers for lng.Tools.getRoundRect
   */
  const RoundRect = {
    /**
     * Returns a value that will render as the given width (w)
     * when passed to lng.Tools.getRoundRect
     * @param {number} w - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both left and right padding
     * @param {number} options.paddingLeft - px value for left padding, overrides options.padding
     * @param {number} options.paddingRight - px value for right padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getWidth(w) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        padding,
        paddingLeft,
        paddingRight,
        strokeWidth
      } = {
        padding: 0,
        paddingLeft: 0,
        paddingRight: 0,
        strokeWidth: 0,
        ...options
      };
      if (!w) return 0;
      return w - (paddingLeft || padding) - (paddingRight || padding) - strokeWidth;
    },
    /**
     * Returns a value that will render as the given height (h)
     * when passed to lng.Tools.getRoundRect
     * @param {number} h - px value for expected width
     * @param {*} options
     * @param {number} options.padding - px value for both bottom and top padding
     * @param {number} options.paddingBottom - px value for bottom padding, overrides options.padding
     * @param {number} options.paddingTop - px value for top padding, overrides options.padding
     * @param {number} options.strokeWidth - px value for stroke width
     */
    getHeight(h) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        padding,
        paddingBottom,
        paddingTop,
        strokeWidth
      } = {
        padding: 0,
        paddingBottom: 0,
        paddingTop: 0,
        strokeWidth: 0,
        ...options
      };
      if (!h) return 0;
      return h - (paddingBottom || padding) - (paddingTop || padding) - strokeWidth;
    }
  };

  /**
   * Merges two objects together and returns the duplicate.
   *
   * @param {Object} target - object to be cloned
   * @param {Object} [object] - secondary object to merge into clone
   */
  function clone$1(target, object) {
    const _clone = {
      ...target
    };
    if (!object || target === object) return _clone;
    for (let key in object) {
      const value = object[key];
      if (target.hasOwnProperty(key)) {
        _clone[key] = getMergeValue$1(key, target, object);
      } else {
        _clone[key] = value;
      }
    }
    return _clone;
  }
  function getMergeValue$1(key, target, object) {
    const targetVal = target[key];
    const objectVal = object[key];
    const targetValType = typeof targetVal;
    const objectValType = typeof objectVal;
    if (targetValType !== objectValType || objectValType === 'function' || Array.isArray(objectVal)) {
      return objectVal;
    }
    if (objectVal && objectValType === 'object') {
      return clone$1(targetVal, objectVal);
    }
    return objectVal;
  }

  /**
   * Returns the rendered width of a given text texture
   * @param {Object} text - text texture properties
   * @param {string} text.text - text value
   * @param {string} text.fontStyle - css font-style property
   * @param {(string|number)} text.fontWeight - css font-weight property
   * @param {string} [fontSize=0] - css font-size property (in px)
   * @param {string} [text.fontFamily=sans-serif] - css font-weight property
   * @param {string} text.fontFace - alias for fontFamily
   *
   * @returns {number} text width
   * */
  function measureTextWidth$1() {
    let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const {
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily = text.fontFace || 'sans-serif'
    } = text;
    const fontCss = [fontStyle, fontWeight, fontSize ? "".concat(fontSize, "px") : '0', "'".concat(fontFamily, "'")].filter(Boolean).join(' ');
    ctx.font = fontCss;
    const textMetrics = ctx.measureText(text.text || '');
    return Math.round(textMetrics.width);
  }

  /**
   * Returns first argument that is a number. Useful for finding ARGB numbers. Does not convert strings to numbers
   * @param {...*} number - maybe a number
   **/
  function getFirstNumber() {
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    return numbers.find(Number.isFinite);
  }

  /**
   * Naively looks for dimensional prop (i.e. w, h, x, y, etc.), first searching for
   * a transition target value then defaulting to the current set value
   * @param {string} prop - property key
   * @param {lng.Component} component - Lightning component to operate against
   */
  function getDimension$1(prop, component) {
    if (!component) return 0;
    const transition = component.transition(prop);
    if (transition.isRunning()) return transition.targetValue;
    return component[prop];
  }
  const getX = getDimension$1.bind(null, 'x');
  const getY = getDimension$1.bind(null, 'y');
  const getW = component => getDimension$1('w', component) || component.renderWidth;
  const getH = component => getDimension$1('h', component) || component.renderHeight;

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const gradientColor = COLORS_NEUTRAL.light2;
  ({
    duration: 0.6,
    actions: [{
      p: 'colorUl',
      v: {
        0: getHexColor$1(gradientColor, 72),
        1: getHexColor$1(gradientColor, 56)
      }
    }, {
      p: 'colorUr',
      v: {
        0: getHexColor$1(gradientColor, 24),
        1: getHexColor$1(gradientColor, 16)
      }
    }, {
      p: 'colorBr',
      v: {
        0: 0x00,
        1: getHexColor$1(gradientColor, 0)
      }
    }, {
      p: 'colorBl',
      v: {
        0: getHexColor$1(gradientColor, 24),
        1: getHexColor$1(gradientColor, 16)
      }
    }]
  });

  /**
   * Returns a function, that, as long as it continues to be invoked, will not
   * be triggered. The function will be called after it stops being called for
   * N milliseconds. If `immediate` is passed, trigger the function on the
   * leading edge, instead of the trailing. The function also has a property 'clear' 
   * that is a function which will clear the timer to prevent previously scheduled executions. 
   *
   * @source underscore.js
   * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
   * @param {Function} function to wrap
   * @param {Number} timeout in ms (`100`)
   * @param {Boolean} whether to execute at the beginning (`false`)
   * @api public
   */
  function debounce(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (null == wait) wait = 100;
    function later() {
      var last = Date.now() - timestamp;
      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    }
    var debounced = function () {
      context = this;
      args = arguments;
      timestamp = Date.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
    debounced.clear = function () {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
    };
    debounced.flush = function () {
      if (timeout) {
        result = func.apply(context, args);
        context = args = null;
        clearTimeout(timeout);
        timeout = null;
      }
    };
    return debounced;
  }

  // Adds compatibility for ES modules
  debounce.debounce = debounce;
  var debounce_1 = debounce;

  /**
  * Copyright 2020 Comcast Cable Communications Management, LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * SPDX-License-Identifier: Apache-2.0
  */
  function withStyles(Base, styles, theme) {
    const _theme = theme || Base.theme;
    const _styles = Base.styles ? clone$1(Base.styles, createStyles(styles, _theme)) : createStyles(styles, _theme);
    return class extends Base {
      static get name() {
        return Base.name;
      }
      static get styles() {
        return _styles;
      }
      get styles() {
        return _styles;
      }
    };
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Icon extends t.Component {
    static _template() {
      return {
        color: 0xffffffff,
        w: 0,
        h: 0
      };
    }
    get icon() {
      return this._icon;
    }
    set icon(icon) {
      this._icon = icon;
      this._update();
    }
    _init() {
      this._update();
    }
    _update() {
      const {
        icon,
        w,
        h
      } = this;
      const template = getIconTemplate(icon, w, h);
      this.patch(template);
    }
  }
  const [isSvgTag, isSvgURI, isImageURI] = [/^<svg.*<\/svg\>$/, /\.svg$/, /\.(a?png|bmp|gif|ico|cur|jpe?g|pjp(eg)?|jfif|tiff?|webp)$/].map(regex => RegExp.prototype.test.bind(regex));
  function getIconTemplate(icon, w, h) {
    const template = {
      w,
      h
    };
    switch (true) {
      case isSvgTag(icon):
        template.texture = t.Tools.getSvgTexture("data:image/svg+xml,".concat(encodeURIComponent(icon)), w, h);
        break;
      case isSvgURI(icon):
        template.texture = t.Tools.getSvgTexture(icon, w, h);
        break;
      case isImageURI(icon):
        template.src = icon;
        break;
    }
    return template;
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const styles = {
    w: 113,
    //150
    h: 90,
    //40
    radius: 0,
    background: {
      color: 0xffffffff
    },
    // 0xff1f1f1f
    icon: {
      color: 0xffffffff
    },
    text: {
      fontSize: 30,
      fontFace: CONFIG.language.font,
      color: 0xff000000
    },
    padding: 50,
    stroke: {
      color: 0x00,
      weight: 2
    },
    focused: {
      background: {
        color: CONFIG.theme.hex
      },
      text: {
        color: 0xff1f1f1f
      },
      icon: {
        color: 0xff1f1f1f
      }
    }
  };
  class Button extends t.Component {
    static _template() {
      return {
        w: this.styles.w,
        h: this.styles.h,
        radius: this.styles.radius,
        strokeColor: this.styles.stroke.color,
        strokeWeight: this.styles.stroke.weight,
        Content: {
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2,
          flex: {
            direction: 'row',
            alignContent: 'center',
            alignItems: 'center'
          },
          Icon: {
            type: Icon
          },
          Title: {
            y: 2
          }
        },
        Stroke: {
          zIndex: -1,
          mount: 0.5,
          x: w => w / 2,
          y: h => h / 2
        }
      };
    }
    _construct() {
      this._focused = false;
      this._whenEnabled = new Promise(resolve => this._enable = resolve, console.error);
      this._strokeWeight = 2;
      this._strokeColor = 0x00;
    }
    _init() {
      this._update();
    }
    _focus() {
      if (this._smooth === undefined) this._smooth = true;
      this._focused = true;
      this._update();
    }
    _unfocus() {
      this._focused = false;
      this._update();
    }
    _updateColor() {
      const color = this._focused ? getFirstNumber(this.focusedBackground, this.styles.focused.background.color) : getFirstNumber(this.background, this.styles.background.color);
      if (this._smooth) {
        this.smooth = {
          color
        };
      } else {
        this.color = color;
      }
    }
    _updateTitle() {
      if (this.title) {
        this._Title.text = {
          ...this.styles.text,
          fontColor: this.styles.text.color,
          fontSize: this.fontSize || this.styles.text.fontSize,
          fontFamily: this.styles.text.fontFace || this.styles.text.fontFamily || this.stage._options.defaultFontFace,
          text: this.title
        };
        const color = this._focused ? getFirstNumber(this.focusedTextColor, this.styles.focused.text.color) : getFirstNumber(this.textColor, this.styles.text.color);
        if (this._smooth) {
          this._Title.smooth = {
            color
          };
        } else {
          this._Title.color = color;
        }
      } else {
        this._Title.texture = false;
      }
    }
    _updateIcon() {
      if (this.icon) {
        const {
          color,
          size,
          spacing,
          src
        } = this.icon;
        this._Icon.patch({
          w: size,
          h: size,
          icon: src,
          flexItem: {
            marginRight: this.title ? spacing : 0
          }
        });
        const iconColor = this._focused ? getFirstNumber(this.focusedIconColor, this.styles.focused.icon.color) : getFirstNumber(color, this.styles.icon.color);
        if (this._smooth) {
          this._Icon.smooth = {
            color: iconColor
          };
        } else {
          this._Icon.color = iconColor;
        }
      } else {
        this._Icon.patch({
          w: 0,
          h: 0,
          texture: false,
          flexItem: false
        });
      }
    }
    _updateStroke() {
      if (this.stroke && !this._focused) {
        const radius = this.radius || this.styles.radius;
        this.texture = t.Tools.getRoundRect(RoundRect.getWidth(this.w), RoundRect.getHeight(this.h), radius, 0x00, true, 0xffffffff);
        this._Stroke.color = this.strokeColor;
        this._Stroke.texture = t.Tools.getRoundRect(RoundRect.getWidth(this.w), RoundRect.getHeight(this.h), radius, this.strokeWeight, 0xffffffff, true, this.background);
      } else {
        const radius = this.radius || this.styles.radius;
        this.texture = t.Tools.getRoundRect(RoundRect.getWidth(this.w), RoundRect.getHeight(this.h), radius);
        this._Stroke.texture = false;
      }
    }
    _updateWidth() {
      if (!this.fixed) {
        const iconSize = this._icon ? this._icon.size + this._icon.spacing : 0;
        const padding = getFirstNumber(this.padding, this.styles.padding, 10);
        const w = measureTextWidth$1(this._Title.text || {}) + padding * 2 + iconSize;
        if (w && w !== this.w) {
          this.w = w > this.styles.w ? w : this.styles.w;
          this.fireAncestors('$itemChanged');
          this.signal('buttonWidthChanged', {
            w: this.w
          });
        }
      }
    }
    _update() {
      this._whenEnabled.then(() => {
        this._updateColor();
        this._updateTitle();
        this._updateIcon();
        this._updateStroke();
        this._updateWidth();
      });
    }
    _handleEnter() {
      if (typeof this.onEnter === 'function') {
        this.onEnter(this);
      }
    }
    get radius() {
      return this._radius;
    }
    set radius(radius) {
      if (this._radius !== radius) {
        this._radius = radius;
        this._update();
      }
    }
    get title() {
      return this._title;
    }
    set title(title) {
      if (this._title !== title) {
        this._title = title;
        this._update();
      }
    }
    get icon() {
      return this._icon;
    }
    set icon(_ref) {
      let {
        src,
        size = 20,
        spacing = 5,
        color = 0xffffffff
      } = _ref;
      if (src) {
        this._icon = {
          src,
          size,
          spacing,
          color
        };
      } else {
        this._icon = null;
      }
      this._update();
    }
    get strokeWeight() {
      return this._strokeWeight;
    }
    set strokeWeight(strokeWeight) {
      if (this._strokeWeight !== strokeWeight) {
        this._strokeWeight = strokeWeight;
        this._update();
      }
    }
    get strokeColor() {
      return this._strokeColor;
    }
    set strokeColor(strokeColor) {
      if (this._strokeColor !== strokeColor) {
        this._strokeColor = strokeColor;
        this._update();
      }
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(stroke) {
      if (this._stroke !== stroke) {
        this._stroke = stroke;
        this._update();
      }
    }
    get w() {
      return this._w;
    }
    set w(w) {
      if (this._w !== w) {
        this._w = w;
        this._update();
      }
    }
    set label(label) {
      this._label = label;
    }
    get label() {
      return this._label || this._title;
    }
    get announce() {
      // TODO - Localization?
      // Do we need a locale file with
      // component translations?
      return this.label + ', Button';
    }
    get _Content() {
      return this.tag('Content');
    }
    get _Title() {
      return this.tag('Content.Title');
    }
    get _Icon() {
      return this.tag('Content.Icon');
    }
    get _Stroke() {
      return this.tag('Stroke');
    }
  }
  var Button$1 = withStyles(Button, styles);

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class FocusManager extends t.Component {
    constructor(stage) {
      super(stage);
      this.patch({
        Items: {}
      });
      this._direction = this.direction || 'row';
    }
    _construct() {
      this._selectedIndex = 0;
    }
    get direction() {
      return this._direction;
    }
    set direction(direction) {
      this._direction = direction;
      let state = {
        none: 'None',
        column: 'Column',
        row: 'Row'
      }[direction];
      if (state) {
        this._setState(state);
      }
    }
    get Items() {
      return this.tag('Items');
    }
    get items() {
      return this.Items.children;
    }
    set items(items) {
      this.Items.childList.clear();
      this._selectedIndex = 0;
      this.appendItems(items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.Items.childList.a(items);
      this._refocus();
    }
    get selected() {
      return this.Items.children[this.selectedIndex];
    }
    get selectedIndex() {
      return this._selectedIndex;
    }
    set selectedIndex(index) {
      const prevSelected = this.selected;
      if (index !== this._selectedIndex) {
        this._selectedIndex = index;
      }
      // Have items update (change height or width) before we render
      this._refocus();
      if (this.selected) {
        this.render(this.selected, prevSelected);
        this.signal('selectedChange', this.selected, prevSelected);
      }
    }

    // Override
    render() {}
    selectPrevious() {
      if (this.selectedIndex > 0) {
        let prevIndex = this.selectedIndex - 1;
        let previous = this.items[prevIndex];
        while (prevIndex && previous.skipFocus) {
          this._selectedIndex = prevIndex;
          this.render(previous, this.items[prevIndex + 1]);
          prevIndex -= 1;
          previous = this.items[prevIndex];
        }
        this.selectedIndex = prevIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = this.Items.children.length - 1;
        return true;
      }
      return false;
    }
    selectNext() {
      if (this.selectedIndex < this.Items.children.length - 1) {
        let nextIndex = this.selectedIndex + 1;
        let next = this.items[nextIndex];
        while (nextIndex < this.items.length - 1 && next.skipFocus) {
          this._selectedIndex = nextIndex;
          this.render(next, this.items[nextIndex - 1]);
          nextIndex += 1;
          next = this.items[nextIndex];
        }
        this.selectedIndex = nextIndex;
        return true;
      } else if (this.wrapSelected) {
        this.selectedIndex = 0;
        return true;
      }
      return false;
    }
    _getFocused() {
      let {
        selected
      } = this;
      // Make sure we're focused on a component
      if (selected) {
        if (selected.focusRef) {
          return selected.tag(selected.focusRef);
        } else if (selected.cparent) {
          return selected;
        }
      }
      return this;
    }
    static _states() {
      return [class None extends this {}, class Row extends this {
        _handleLeft() {
          return this.selectPrevious();
        }
        _handleRight() {
          return this.selectNext();
        }
      }, class Column extends this {
        _handleUp() {
          return this.selectPrevious();
        }
        _handleDown() {
          return this.selectNext();
        }
      }];
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Column extends FocusManager {
    static _template() {
      return {
        direction: 'column'
      };
    }
    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
      this._h = this.stage.h;
      this.debounceDelay = Number.isInteger(this.debounceDelay) ? this.debounceDelay : 30;
      this._update = debounce_1.debounce(this._updateLayout, this.debounceDelay);
      this._updateImmediate = debounce_1.debounce(this._updateLayout, this.debounceDelay, true);
    }
    get _itemTransition() {
      return this.itemTransition || {
        duration: 0.4,
        timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
      };
    }
    _focus() {
      this.items.forEach(item => item.parentFocus = true);
    }
    _unfocus() {
      this.items.forEach(item => item.parentFocus = false);
    }
    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }
    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollUp() {
      let shouldScroll = false;
      if (this._lastScrollIndex) {
        shouldScroll = this.selectedIndex < this._lastScrollIndex;
        if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
          shouldScroll = true;
        }
      } else {
        shouldScroll = this.selectedIndex >= this._scrollIndex;
      }
      return this._itemsY < 0 && shouldScroll;
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollDown() {
      const lastChild = this.Items.childList.last;
      return this.selectedIndex > this._scrollIndex &&
      // end of Items container < end of last item
      Math.abs(this._itemsY - this.h) < lastChild.y + this.Items.childList.last.h;
    }
    render(next, prev) {
      this._prevLastScrollIndex = this._lastScrollIndex;
      if (this.plinko && prev && (prev.currentItem || prev.selected)) {
        next.selectedIndex = this._getIndexOfItemNear(next, prev);
      }

      // Rows are changing height, so we'll render via updateLayout
      if (this.itemsChangeable) {
        return;
      }
      this._performRender();
    }
    _performRender() {
      this._whenEnabled.then(() => {
        const scrollOffset = (this.Items.children[this._scrollIndex] || {
          y: 0
        }).y;
        const firstChild = this.Items.childList.first;
        const lastChild = this.Items.childList.last;
        const shouldScroll = this.alwaysScroll || lastChild && (this.shouldScrollUp() || this.shouldScrollDown());
        if (shouldScroll) {
          const scrollItem = this.selectedIndex > this._lastScrollIndex ? this.Items.children[this._lastScrollIndex - this._scrollIndex] : this.selected;
          if (this._smooth) {
            this.Items.smooth = {
              y: [-(scrollItem || firstChild).transition('y').targetValue + (scrollItem === this.selected ? scrollOffset : 0), this._itemTransition]
            };
          } else {
            this.Items.patch({
              y: -scrollItem.y + (scrollItem === this.selected ? scrollOffset : 0)
            });
          }
        }
        this.onScreenEffect(this.onScreenItems);
      });
    }
    get onScreenItems() {
      return this.Items.children.filter(child => this._isOnScreen(child));
    }
    _isOnScreen(child) {
      const y = getY(child);
      const {
        h
      } = child;
      const withinLowerBounds = y + h + this._itemsY > 0;
      const withinUpperBounds = y + this._itemsY < this.h;
      return withinLowerBounds && withinUpperBounds;
    }
    _updateLayout() {
      this._whenEnabled.then(() => {
        let nextY = 0;
        let nextW = 0;
        // layout items in row
        for (let i = 0; i < this.Items.children.length; i++) {
          const child = this.Items.children[i];
          nextW = Math.max(nextW, getW(child));
          if (this._smooth) {
            child.smooth = {
              y: [nextY, this._itemTransition]
            };
          } else {
            child.patch({
              y: nextY
            });
          }
          nextY += child.h;
          if (i < this.Items.children.length - 1) {
            nextY += this.itemSpacing;
          }
          if (child.centerInParent) {
            // if the child is another focus manager, check the width of the item container
            const childWidth = child.Items && child.Items.w || child.w;
            // only center the child if it is within the bounds of this focus manager
            if (childWidth < this.w) {
              child.x = (this.w - childWidth) / 2;
            }
          }
        }
        this.Items.patch({
          w: nextW,
          h: nextY
        });
        const lastChild = this.Items.childList.last;
        const endOfLastChild = lastChild ? getY(lastChild) + lastChild.h : 0;
        const scrollOffset = (this.Items.children[this._scrollIndex] || {
          y: 0
        }).y;

        // determine when to stop scrolling down
        if (this.alwaysScroll) {
          this._lastScrollIndex = this.Items.children.length - 1;
        } else if (endOfLastChild > this.h) {
          for (let i = this.Items.children.length - 1; i >= 0; i--) {
            const child = this.Items.children[i];
            const childY = getY(child);
            if (childY + this.h - scrollOffset > endOfLastChild) {
              this._lastScrollIndex = i;
            } else {
              break;
            }
          }
        } else if (this._lastScrollIndex > this.items.length) {
          this._lastScrollIndex = this.items.length - 1;
        }
        this._performRender();
      });
    }

    // finds the index of the item with the closest middle to the previously selected item
    _getIndexOfItemNear(selected, prev) {
      // edge case
      if (selected.items.length < 2) return 0;
      let prevItem = prev.selected || prev.currentItem;
      let prevOffset = prev.transition('x').targetValue || 0;
      let [itemX] = prevItem.core.getAbsoluteCoords(-prevOffset, 0);
      let prevMiddle = itemX + prevItem.w / 2;

      // set the first item to be closest
      let closest = selected.items[0];
      let closestMiddle = closest.core.getAbsoluteCoords(0, 0)[0] + closest.w / 2;

      // start at the 2nd item
      for (let i = 1; i < selected.items.length; i++) {
        // for some reason here !!/!.. evals returning number
        if (selected.items[i].skipFocus === true) {
          continue;
        }
        const item = selected.items[i];
        const middle = item.core.getAbsoluteCoords(0, 0)[0] + item.w / 2;
        if (Math.abs(middle - prevMiddle) < Math.abs(closestMiddle - prevMiddle)) {
          // current item is the closest
          closest = item;
          closestMiddle = middle;
        } else {
          if (!closest.skipFocus) {
            // weve already found closest return its index
            return selected.items.indexOf(closest);
          } else if (!selected.items[i - 1].skipFocus) {
            // previous item is focusable return it
            return i - 1;
          } else {
            // return closest left or right of index
            const prevIndex = prev.items.indexOf(prevItem);
            return this._getIndexofClosestFocusable(prevIndex, selected, prevMiddle);
          }
        }
      }
      // if last index is focusable return
      return selected.items.length - 1;
    }
    _getIndexofClosestFocusable(selectedIndex, selected, prevMiddle) {
      // dont want to mutate the original selected.items using spread for copy
      // get first focusable item before and after the current focused item's index
      const prevIndex = [...selected.items].slice(0, selectedIndex).map(item => !!item.skipFocus).lastIndexOf(false);
      const nextIndex = [...selected.items].slice(selectedIndex + 1).map(item => !!item.skipFocus).indexOf(false) + selectedIndex + 1;
      const prevItem = selected.items[prevIndex];
      const nextItem = selected.items[nextIndex];

      // Check if the items exist if not return the other
      // covers case where at 0 idx, previous would not exist
      // and opposite for last index next would not exist
      if (prevIndex === -1 || !prevItem) {
        return nextIndex;
      }
      if (nextIndex === -1 || !nextItem) {
        return prevIndex;
      }

      // If both items compare coordinates to determine which direction of plinko
      const next = nextItem.core.getAbsoluteCoords(0, 0)[0] + nextItem.w / 2;
      const prev = prevItem.core.getAbsoluteCoords(0, 0)[0] + prevItem.w / 2;
      return Math.abs(prev - prevMiddle) < Math.abs(next - prevMiddle) ? prevIndex : nextIndex;
    }
    get itemSpacing() {
      return this._itemSpacing;
    }
    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._update();
      }
    }
    get scrollIndex() {
      return this._scrollIndex;
    }
    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._update();
      }
    }
    get _itemsY() {
      return getY(this.Items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let itemWidth = this.renderWidth;
      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.w = getW(item) || itemWidth;
      });
      this.stage.update();
      this._updateLayout();
      this._update.clear();
      this._refocus();
    }
    scrollTo(index) {
      let duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._itemTransition.duration * 100;
      if (duration === 0) this.selectedIndex = index;
      for (let i = 0; i !== Math.abs(this.selectedIndex - index); i++) {
        setTimeout(() => {
          this.selectedIndex > index ? this.selectPrevious() : this.selectNext();
        }, duration * i);
      }
      this.Items.transition('y').on('finish', () => this._smooth = false);
    }
    $itemChanged() {
      this.itemsChangeable = true;
      this._updateImmediate();
    }
    $removeItem(item) {
      if (item) {
        let wasSelected = item === this.selected;
        this.Items.childList.remove(item);
        this._updateImmediate();
        if (wasSelected || this.selectedIndex >= this.items.length) {
          // eslint-disable-next-line no-self-assign
          this.selectedIndex = this._selectedIndex;
        }
        if (!this.items.length) {
          this.fireAncestors('$columnEmpty');
        }
      }
    }
    $columnChanged() {
      this._updateImmediate();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class FadeShader extends t.shaders.WebGLDefaultShader {
    constructor(context) {
      super(context);
      this._margin = {
        left: 0,
        right: 0
      };
    }
    set positionLeft(v) {
      this._positionLeft = v;
    }
    set positionRight(v) {
      this._positionRight = v;
    }
    setupUniforms(operation) {
      super.setupUniforms(operation);
      const owner = operation.shaderOwner;
      if (this._positionLeft === 0) {
        this._positionLeft = 0.001;
      }
      if (this._positionRight === 0) {
        this._positionRight = 0.001;
      }
      const renderPrecision = this.ctx.stage.getRenderPrecision();
      this._setUniform('margin', [this._positionLeft * renderPrecision, this._positionRight * renderPrecision], this.gl.uniform1fv);
      this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
  }
  FadeShader.fragmentShaderSource = "\n  #ifdef GL_ES\n  precision lowp float;\n  #endif\n\n  #define PI 3.14159265359\n\n  varying vec2 vTextureCoord;\n  varying vec4 vColor;\n\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n  uniform float margin[2];\n\n  void main() {\n      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n      vec2 halfRes = 0.5 * resolution.xy;\n      vec2 point = vTextureCoord.xy * resolution;\n\n\n      vec2 pos1 = vec2(point.x, point.y);\n      vec2 pos2 = pos1;\n      pos2.x += margin[0];\n\n      vec2 d = pos2 - pos1;\n      float t = dot(pos1, d) / dot(d, d);\n      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n\n      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);\n      pos3.x -= resolution.x - margin[1];\n      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);\n\n      vec2 d2 = pos4 - pos3;\n      float t2 = dot(pos3, d2) / dot(d2, d2);\n      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));\n\n      color = mix(vec4(0.0), color, t);\n      color = mix(color, vec4(0.0), t2);\n\n      gl_FragColor = color;\n  }\n";

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class MarqueeText extends t.Component {
    static _template() {
      return {
        TextClipper: {
          boundsMargin: [],
          // overwrite boundsMargin so text won't de-render if moved offscreen
          TextBox: {
            Text: {},
            TextLoopTexture: {}
          }
        }
      };
    }
    get title() {
      return (this._Text && this._Text.text || {}).text;
    }
    set title(text) {
      this.patch({
        TextClipper: {
          w: this.finalW + 14,
          h: text.lineHeight + 10,
          TextBox: {
            Text: {
              rtt: true,
              text: {
                ...text
              }
            },
            TextLoopTexture: {}
          }
        }
      });
      this._Text.on('txLoaded', () => {
        if (this.autoStart) {
          this.startScrolling();
        }
      });
      this._Text.loadTexture();
      this._updateShader(this.finalW);
      this._scrolling && this.startScrolling();
    }
    set color(color) {
      this.tag('TextBox.Text').smooth = {
        color
      };
    }
    startScrolling() {
      let finalW = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.finalW;
      if (this._textRenderedW === 0) {
        this._Text.on('txLoaded', () => {
          this.startScrolling();
        });
      }
      if (this._textRenderedW > finalW - this._fadeW) {
        this._scrolling = true;
        this._TextLoopTexture.x = this._textRenderedW + this._offset;
        this._TextLoopTexture.texture = this._Text.getTexture();
        this._updateShader(finalW);
        this._updateAnimation();
        this._scrollAnimation.start();
      } else {
        // in case the metadata width gets larger on focus and the text goes from being clipped to not
        this._TextClipper.shader = null;
        if (this._Text.text && this._Text.text.textAlign === 'center') {
          this._centerText(finalW);
        }
        this._scrolling = false;
      }
    }
    stopScrolling() {
      let finalW = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.finalW;
      this._scrolling = false;
      if (this._scrollAnimation) {
        this._scrollAnimation.stopNow();
        this._TextLoopTexture.texture = null;
      }
      this._updateShader(finalW);
    }
    _updateShader(finalW) {
      this.stage.update();
      this._Text.loadTexture();
      this._TextClipper.patch({
        w: finalW > 0 ? finalW + this._fadeW / 2 : 0,
        shader: {
          type: FadeShader,
          positionLeft: 0,
          positionRight: this._fadeW
        },
        rtt: true
      });
    }
    _updateAnimation() {
      this._scrollAnimation && this._scrollAnimation.stopNow();
      this._scrollAnimation = this.animation({
        duration: this._textRenderedW / 50,
        delay: isNaN(this.delay) ? 1.5 : this.delay,
        repeat: isNaN(this.repeat) ? -1 : this.repeat,
        actions: [{
          t: 'TextBox',
          p: 'x',
          v: {
            sm: 0,
            0: {
              v: 0
            },
            0.5: {
              v: -(this._textRenderedW + this._offset)
            }
          }
        }, {
          t: 'TextClipper',
          p: 'shader.positionLeft',
          v: {
            sm: 0,
            0: {
              v: 0
            },
            0.1: {
              v: this._fadeW
            },
            0.4: {
              v: this._fadeW
            },
            0.5: {
              v: 0
            }
          }
        }]
      });
    }
    _centerText(finalW) {
      this._TextBox.x = ((finalW || this.finalW) - this._textRenderedW) / 2;
    }
    get _TextClipper() {
      return this.tag('TextClipper');
    }
    get _TextBox() {
      return this.tag('TextBox');
    }
    get _Text() {
      return this.tag('Text');
    }
    get _TextLoopTexture() {
      return this.tag('TextLoopTexture');
    }
    get _offset() {
      return 32;
    }
    get _fadeW() {
      return 30;
    }
    get _textRenderedW() {
      return this._Text.renderWidth;
    }
  }

  /**
   * Copyright 2020 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  class Row extends FocusManager {
    static _template() {
      return {
        direction: 'row'
      };
    }
    _construct() {
      super._construct();
      this._smooth = false;
      this._itemSpacing = 0;
      this._scrollIndex = 0;
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
      this._w = this.stage.w;
      this.debounceDelay = Number.isInteger(this.debounceDelay) ? this.debounceDelay : 1;
      this._update = debounce_1.debounce(this._updateLayout, this.debounceDelay);
    }
    get _itemTransition() {
      return this.itemTransition || {
        duration: 0.4,
        timingFunction: 'cubic-bezier(0.20, 1.00, 0.30, 1.00)'
      };
    }
    _focus() {
      this.items.forEach(item => item.parentFocus = true);
    }
    _unfocus() {
      this.items.forEach(item => item.parentFocus = false);
    }
    selectNext() {
      this._smooth = true;
      return super.selectNext();
    }
    selectPrevious() {
      this._smooth = true;
      return super.selectPrevious();
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollLeft() {
      let shouldScroll = false;
      if (this._lastScrollIndex) {
        shouldScroll = this.selectedIndex < this._lastScrollIndex;
        if (this._prevLastScrollIndex !== undefined && this._prevLastScrollIndex !== this._lastScrollIndex) {
          shouldScroll = true;
        }
      } else {
        shouldScroll = this.selectedIndex >= this._scrollIndex;
      }
      return this._itemsX < 0 && shouldScroll;
    }

    // TODO: can be documented in API when lastScrollIndex is made public
    shouldScrollRight() {
      const lastChild = this.Items.childList.last;
      return this.selectedIndex > this._scrollIndex &&
      // end of Items container < end of last item
      Math.abs(this._itemsX - this.w) < lastChild.x + this.Items.childList.last.w;
    }
    get onScreenItems() {
      return this.Items.children.filter(child => this._isOnScreen(child));
    }
    _isOnScreen(child) {
      const x = getX(child);
      const {
        w
      } = child;
      const withinLowerBounds = x + w + this._itemsX > 0;
      const withinUpperBounds = x + this._itemsX < this.w;
      return withinLowerBounds && withinUpperBounds;
    }
    _isOnScreenCompletely(child) {
      let itemX = child.core.renderContext.px;
      let rowX = this.core.renderContext.px;
      return itemX >= rowX && itemX + child.w <= rowX + this.w;
    }
    _shouldScroll() {
      const lastChild = this.Items.childList.last;
      let shouldScroll = this.alwaysScroll;
      if (!shouldScroll) {
        if (this.lazyScroll) {
          shouldScroll = !this._isOnScreenCompletely(this.selected);
        } else {
          shouldScroll = lastChild && (this.shouldScrollLeft() || this.shouldScrollRight() || !this._isOnScreenCompletely(this.selected));
        }
      }
      return shouldScroll;
    }
    _getLazyScrollX(prev) {
      let itemsContainerX;
      const prevIndex = this.Items.childList.getIndex(prev);
      if (prevIndex > this.selectedIndex) {
        itemsContainerX = -this.selected.x;
      } else if (prevIndex < this.selectedIndex) {
        itemsContainerX = this.w - this.selected.x - this.selected.w;
      }
      return itemsContainerX;
    }
    _getScrollX() {
      let itemsContainerX;
      let itemIndex = this.selectedIndex - this.scrollIndex;
      itemIndex = itemIndex < 0 ? 0 : itemIndex;
      if (this.Items.children[itemIndex]) {
        itemsContainerX = this.Items.children[itemIndex].transition('x') ? -this.Items.children[itemIndex].transition('x').targetValue : -this.Items.children[itemIndex].x;
      }
      return itemsContainerX;
    }
    render(next, prev) {
      this._whenEnabled.then(() => {
        this._prevLastScrollIndex = this._lastScrollIndex;
        if (this._shouldScroll()) {
          const itemsContainerX = this.lazyScroll && prev ? this._getLazyScrollX(prev) : this._getScrollX();
          if (itemsContainerX !== undefined) {
            if (this._smooth) {
              this.Items.smooth = {
                x: [itemsContainerX, this._itemTransition]
              };
            } else {
              this.Items.x = itemsContainerX;
            }
          }
        }
        this.onScreenEffect(this.onScreenItems);
      });
    }
    _updateLayout() {
      let nextX = 0;
      let nextH = 0;
      // layout items in row
      for (let i = 0; i < this.Items.children.length; i++) {
        const child = this.Items.children[i];
        nextH = Math.max(nextH, getH(child));
        if (this._smooth) {
          child.smooth = {
            x: [nextX, this._itemTransition]
          };
        } else {
          child.patch({
            x: nextX
          });
        }
        nextX += child.w;
        if (i < this.Items.children.length - 1) {
          nextX += this.itemSpacing;
        }
        if (child.centerInParent) {
          // if the child is another focus manager, check the height of the item container
          const childHeight = child.Items && child.Items.h || child.h;
          // only center the child if it is within the bounds of this focus manager
          if (childHeight < this.h) {
            child.y = (this.h - childHeight) / 2;
          }
        }
      }
      this.Items.patch({
        h: nextH,
        w: nextX
      });
      const lastChild = this.Items.childList.last;
      const endOfLastChild = lastChild ? getX(lastChild) + lastChild.w : 0;
      const scrollOffset = (this.Items.children[this._scrollIndex] || {
        x: 0
      }).x;

      // determine when to stop scrolling right
      if (this.alwaysScroll) {
        this._lastScrollIndex = this.Items.children.length - 1;
      } else if (endOfLastChild > this.w) {
        for (let i = this.Items.children.length - 1; i >= 0; i--) {
          const child = this.Items.children[i];
          const childX = getX(child);
          if (childX + this.w - scrollOffset > endOfLastChild) {
            this._lastScrollIndex = i;
          } else {
            break;
          }
        }
      }
      this.fireAncestors('$itemChanged');
      this.render(this.selected, null);
    }
    get itemSpacing() {
      return this._itemSpacing;
    }
    set itemSpacing(itemSpacing) {
      if (itemSpacing !== this._itemSpacing) {
        this._itemSpacing = itemSpacing;
        this._update();
      }
    }
    get scrollIndex() {
      return this._scrollIndex;
    }
    set scrollIndex(scrollIndex) {
      if (scrollIndex !== this._scrollIndex) {
        this._scrollIndex = scrollIndex;
        this._update();
      }
    }
    get _itemsX() {
      return getX(this.Items);
    }
    appendItems() {
      let items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let itemHeight = this.renderHeight;
      items.forEach(item => {
        item.parentFocus = this.hasFocus();
        item = this.Items.childList.a(item);
        item.h = item.h || itemHeight;
      });
      this.stage.update();
      this._updateLayout();
      this._update.clear();
      this._refocus();
    }
    $itemChanged() {
      this._update();
    }

    // can be overridden
    onScreenEffect() {}
  }

  /**
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */
  const KEY_DIMENSIONS = {
    h: 90,
    w: 109,
    padding: 0,
    fixed: true
  }; // actualize key values : 60 ,60  ; 90,100
  const isUpperCase = string => /^[A-Z]$/.test(string);
  class Key extends Button$1 {
    static _template() {
      return {
        ...super._template(),
        ...KEY_DIMENSIONS
      };
    }
    set config(config) {
      if (config) {
        this.sizes = config.sizes;
      }
    }
    set icon(src) {
      if (src) {
        this._Icon.patch({
          color: 0xffffffff,
          size: 32,
          spacing: 16,
          src
        });
      }
    }
    set size(size) {
      this.w = this._sizes[size] || this.h;
    }
    set char(char) {
      this.title = char;
    }
    set announce(value) {
      this._announce = value;
    }
    get announce() {
      if (this._announce) {
        return this._announce;
      }
      if (isUpperCase(this.title)) {
        return "Capital ".concat(this.title, ", button");
      }
      return this.title + ', button';
    }
    set label(label) {
      this.title = label;
    }
    get _sizes() {
      return this.styles.sizes ? {
        ...this.styles.sizes,
        ...this.sizes
      } : {
        small: 50,
        medium: 110,
        large: 273,
        xlarge: 718,
        done_size: 340,
        ...this.sizes
      }; // actualize values 50,110,212,350 ; 50,110,212,750
    }

    _handleEnter() {
      if (this.toggle) {
        this.fireAncestors('$toggleKeyboard', this.toggle);
      }
      this.fireAncestors('$onSoftKey', {
        key: this.title
      });
    }
  }

  /*
  * If not stated otherwise in this file or this component's LICENSE file the
  * following copyright and licenses apply:
  *
  * Copyright 2021 RDK Management
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  * Copyright 2021 Comcast Cable Communications Management, LLC
  * Licensed under the Apache License, Version 2.0
  */
  class Keyboard$1 extends t.Component {
    _construct() {
      this._whenEnabled = new Promise(resolve => this._firstEnable = resolve);
    }
    get announce() {
      return 'Keyboard' + (this.title ? ", ".concat(this.title) : '');
    }
    get announceContext() {
      return ['PAUSE-2', 'Use arrow keys to choose characters, press center to select'];
    }
    set formats(formats) {
      if (formats === void 0) {
        formats = {};
      }
      this._formats = formats;
      this._currentFormat = this._defaultFormat;
      // Ensure formats prop is set last
      this._whenEnabled.then(() => {
        Object.entries(formats).forEach(_ref => {
          let [key, value] = _ref;
          let keyboardData = this._formatKeyboardData(value);
          this._createKeyboard(key, this._createRows(keyboardData));
        });
        this.tag(this._currentFormat).alpha = 1;
        this._refocus();
      });
    }
    _createKeyboard(key) {
      let rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      key = key.charAt(0).toUpperCase() + key.slice(1);
      if (rows.length === 1) {
        this.patch({
          [key]: {
            ...rows[0],
            alpha: 0
          }
        });
      } else {
        this.patch({
          [key]: {
            type: Column,
            alpha: 0,
            plinko: true,
            itemSpacing: this._spacing,
            items: rows
          }
        });
      }
    }
    _createRows() {
      let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return rows.map(keys => {
        let h = this.keysConfig && this.keysConfig.h || KEY_DIMENSIONS.h;
        return {
          type: Row,
          h,
          wrapSelected: this.rowWrap === undefined ? true : this.rowWrap,
          itemSpacing: this._spacing,
          items: this._createKeys(keys)
        };
      });
    }
    _createKeys() {
      let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return keys.map(keyProps => {
        const key = {
          type: this.keyComponent || Key,
          config: this.keysConfig
        };
        if (!keyProps) {
          return {
            ...KEY_DIMENSIONS,
            skipFocus: true
          };
        } else if (typeof keyProps === 'object') {
          return {
            ...key,
            ...keyProps
          };
        }
        return {
          ...key,
          label: keyProps
        };
      });
    }
    _formatKeyboardData() {
      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (Array.isArray(data) && data.length) {
        if (!Array.isArray(data[0]) && !this.inline) {
          let keyRows = [],
            idx,
            counter;
          for (idx = 0, counter = -1; idx < data.length; idx++) {
            if (idx % this.columnCount === 0) {
              counter++;
              keyRows[counter] = [];
            }
            keyRows[counter].push(data[idx]);
          }
          return keyRows;
        } else if (this.inline) {
          return [data];
        }
        return data;
      }
    }
    $toggleKeyboard(keyboardFormat) {
      keyboardFormat = keyboardFormat.charAt(0).toUpperCase() + keyboardFormat.slice(1);
      if (keyboardFormat !== this._currentFormat) {
        this.selectKeyOn(this.tag(keyboardFormat));
        this.tag(this._currentFormat).alpha = 0;
        this.tag(keyboardFormat).alpha = 1;
        this._currentFormat = keyboardFormat;
      }
    }
    selectKeyOn(keyboard) {
      let {
        row,
        column
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getSelectedKey();
      let type = keyboard.constructor.name;
      if (type === 'Row') {
        keyboard.selectedIndex = column;
      } else {
        keyboard.selectedIndex = row;
        keyboard.Items.children[row].selectedIndex = column;
      }
    }
    getSelectedKey() {
      let row, column;
      let keyboard = this.tag(this._currentFormat);
      let type = keyboard.constructor.name;
      if (type === 'Row') {
        row = 0;
        column = keyboard.selectedIndex;
      } else {
        row = keyboard.selectedIndex;
        column = keyboard.Items.children[row].selectedIndex;
      }
      return {
        row,
        column
      };
    }
    _getFocused() {
      return this.tag(this._currentFormat) || this;
    }
    _focus() {
      this.fireAncestors('$keyboardFocused', true);
    }
    _unfocus() {
      this.tag(this._currentFormat).alpha = 0;
      this._currentFormat = this._defaultFormat;
      this.tag(this._currentFormat).alpha = 1;
      this._refocus();
      this.fireAncestors('$keyboardFocused', false);
    }
    set columnCount(columnCount) {
      this._columnCount = columnCount;
    }
    set rowCount(rowCount) {
      this._rowCount = rowCount;
    }
    get columnCount() {
      if (this._columnCount) return this._columnCount;
      if (this._rowCount) return this._formats[this._defaultFormat.toLowerCase()].length / this._rowCount;
      if (this.inline) return this._formats[this._defaultFormat.toLowerCase()].length;else return 11;
    }
    get _spacing() {
      return this.spacing || 8;
    }
    get _defaultFormat() {
      let defaultFormat = this.defaultFormat || Object.keys(this._formats)[0];
      return defaultFormat.charAt(0).toUpperCase() + defaultFormat.slice(1);
    }
  }
  const KEYBOARD_FORMATS = {
    fullscreen: {
      letters: [['', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'large',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }, {
        label: 'Space',
        size: 'large'
      }, {
        label: 'Delete',
        size: 'large'
      }, '', '', '', '', '', '', '', '', ''], ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']],
      symbols: [['', '', '', '', '', '', '', '', '', {
        label: 'ABC',
        size: 'large',
        toggle: 'letters',
        announce: 'caps on, button'
      }, {
        label: 'Space',
        size: 'large'
      }, {
        label: 'Delete',
        size: 'large'
      }, '', '', '', '', '', '', '', '', ''], ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: '!',
        announce: 'exclamation, button'
      }, '@', '#', '$', '%', {
        label: '^',
        announce: 'caret circumflex, button'
      }, '&', '*', {
        label: '(',
        announce: 'open parenthesis, button'
      }, {
        label: ')',
        announce: 'close parenthesis, button'
      }, {
        label: '`',
        announce: 'grave accent, button'
      }, '~', '_', '.', '-', '+']]
    },
    qwerty: {
      uppercase: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '@', {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], ['Z', 'X', 'C', 'V', 'B', 'N', 'M', {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: 'shift',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      lowercase: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', '@', {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], ['z', 'x', 'c', 'v', 'b', 'n', 'm', {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: 'shift',
        size: 'medium',
        toggle: 'uppercase',
        announce: 'shift on, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      accents: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'shift',
        size: 'medium',
        toggle: 'accentsUpper',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      accentsUpper: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: '#@!',
        size: 'medium',
        toggle: 'symbols',
        announce: 'symbol mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], ['', '', '', '', '', '', '', '', '', '', {
        label: 'shift',
        size: 'medium',
        toggle: 'accents',
        announce: 'shift off, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]],
      symbols: [['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', {
        label: 'Clear',
        size: 'medium'
      }], [{
        label: '!',
        announce: 'exclamation, button'
      }, '@', '#', '$', '%', {
        label: '^',
        announce: 'caret circumflex, button'
      }, '&', '*', {
        label: '(',
        announce: 'open parenthesis, button'
      }, {
        label: ')',
        announce: 'close parenthesis, button'
      }, {
        label: 'abc',
        size: 'medium',
        toggle: 'lowercase',
        announce: 'alpha mode, button'
      }], [{
        label: '{',
        announce: 'open brace, button'
      }, {
        label: '}',
        announce: 'close brace, button'
      }, {
        label: '[',
        announce: 'open bracket, button'
      }, {
        label: ']',
        announce: 'close bracket, button'
      }, {
        label: ';',
        announce: 'semicolon, button'
      }, {
        label: '"',
        announce: 'doublequote, button'
      }, {
        label: "'",
        announce: 'singlequote, button'
      }, {
        label: '|',
        announce: 'vertical bar, button'
      }, {
        label: '\\',
        announce: 'backslash, button'
      }, {
        label: '/',
        announce: 'forwardslash, button'
      }, {
        label: '',
        size: 'medium',
        toggle: 'accents',
        announce: 'accents, button'
      }], [{
        label: '<',
        announce: 'less than, button'
      }, {
        label: '>',
        announce: 'greater than, button'
      }, {
        label: '?',
        announce: 'question mark, button'
      }, {
        label: '=',
        announce: 'equals, button'
      }, {
        label: '`',
        announce: 'grave accent, button'
      }, {
        label: '~',
        announce: 'tilde, button'
      }, {
        label: '_',
        announce: 'underscore, button'
      }, {
        label: '.',
        announce: 'period, button'
      }, {
        label: '-',
        announce: 'dash, button'
      }, {
        label: '+',
        announce: 'plus sign, button'
      }], [{
        label: 'Delete',
        size: 'large'
      }, {
        label: 'Space',
        size: 'xlarge'
      }, {
        label: 'Done',
        size: 'large'
      }]]
    },
    numbers: {
      // numbers: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
      // dialpad: [
      //   ['1', '2', '3'],
      //   ['4', '5', '6'],
      //   ['7', '8', '9'],
      //   ['', '0', '']
      // ],
      dialpadExtended: [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9'], ['Delete', '0', 'Clear'], [{
        label: 'Done',
        size: 'done_size'
      }]]
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class PasswordSwitch extends t.Component {
    static _template() {
      return {
        src: Utils.asset('images/settings/ToggleOffWhite.png')
      };
    }
    _handleEnter() {
      if (this.isOn) {
        this.patch({
          src: Utils.asset("images/settings/ToggleOffWhite.png")
        });
      } else {
        this.patch({
          src: Utils.asset("images/settings/ToggleOnOrange.png")
        });
      }
      this.isOn = !this.isOn;
      this.fireAncestors('$handleEnter', this.isOn);
    }
    _init() {
      this.isOn = false;
    }
    _disable() {
      if (this.isOn) {
        this.isOn = false;
        this.patch({
          src: Utils.asset("images/settings/ToggleOffWhite.png")
        });
        this.fireAncestors('$handleEnter', this.isOn);
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const WiFiState = {
    UNINSTALLED: 0,
    DISABLED: 1,
    DISCONNECTED: 2,
    PAIRING: 3,
    CONNECTING: 4,
    CONNECTED: 5,
    FAILED: 6
  };
  class Wifi {
    constructor() {
      this._events = new Map();
      const config = {
        host: '127.0.0.1',
        port: 9998
      };
      this._thunder = thunderJS$1(config);
      this.callsign = 'org.rdk.Wifi';
    }

    /**
     * Function to activate the wifi plugin.
     */
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this.getCurrentState().then(state => {
            if (state === WiFiState.DISABLED) {
              this.setEnabled(true);
            }
            if (state === WiFiState.CONNECTED) {
              this.setInterface('WIFI', true).then(res => {
                if (res.success) {
                  this.setDefaultInterface('WIFI', true);
                }
              });
            }
          });
          this._thunder.on(this.callsign, 'onWIFIStateChanged', notification => {
            if (this._events.has('onWIFIStateChanged')) {
              this._events.get('onWIFIStateChanged')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onError', notification => {
            if (this._events.has('onError')) {
              this._events.get('onError')(notification);
            }
          });
          this._thunder.on(this.callsign, 'onAvailableSSIDs', notification => {
            if (notification.moreData === false) {
              this.stopScan();
              notification.ssids = notification.ssids.filter((item, pos) => notification.ssids.findIndex(e => e.ssid === item.ssid) === pos);
              if (this._events.has('onAvailableSSIDs')) {
                this._events.get('onAvailableSSIDs')(notification);
              }
            }
          });
          resolve(result);
        }).catch(err => {
          console.error("Wifi activation failed: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     *Register events and event listeners.
     * @param {string} eventId
     * @param {function} callback
     *
     */
    registerEvent(eventId, callback) {
      this._events.set(eventId, callback);
    }

    /**
     * Deactivates wifi plugin.
     */
    deactivate() {
      this._events = new Map();
    }

    /**
     * Returns connected SSIDs
     */
    getConnectedSSID() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getConnectedSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.error("getConnectedSSID fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Start scanning for available wifi.
     */
    discoverSSIDs() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'startScan', {
          incremental: false,
          ssid: '',
          frequency: ''
        }).then(result => {
          //console.log('startScan success')
          resolve(result);
        }).catch(err => {
          console.error("startScan fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Stops scanning for networks.
     */
    stopScan() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'stopScan').then(result => {
          //console.log('stopScan success')
          resolve(result);
        }).catch(err => {
          console.error("stopScan fail: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Function to connect to an SSID
     * @param {object} device
     * @param {string} passphrase
     */
    connect(device, passphrase) {
      let params = {};
      if (device && passphrase) {
        params = {
          ssid: device.ssid,
          passphrase: passphrase,
          securityMode: device.security
        };
      }
      return new Promise((resolve, reject) => {
        this.disconnect().then(() => {
          this._thunder.call(this.callsign, 'connect', params).then(result => {
            this.setInterface('WIFI', true).then(res => {
              if (res.success) {
                this.setDefaultInterface('WIFI', true);
              }
            });
            resolve(result);
          }).catch(err => {
            console.error("Connection failed: ".concat(err));
            reject(err);
          });
        });
      });
    }

    /**
     * Function to disconnect from the SSID.
     */
    disconnect() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'disconnect').then(result => {
          console.log('WiFi disconnected: ' + JSON.stringify(result));
          this.setInterface('ETHERNET', true).then(res => {
            if (res.success) {
              this.setDefaultInterface('ETHERNET', true);
            }
          });
          resolve(result);
        }).catch(err => {
          console.error("Can't disconnect WiFi: ".concat(err));
          reject(false);
        });
      });
    }

    /**
     * Returns current state of the Wi-Fi plugin.
     */
    getCurrentState() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getCurrentState').then(result => {
          console.log("WiFi state: ".concat(result.state));
          resolve(result.state);
        }).catch(err => {
          console.error("Can't get WiFi state: ".concat(err));
          reject(err);
        });
      });
    }

    /**
     * Enables/Disables the Wi-Fi.
     * @param {bool} bool
     */
    setEnabled(bool) {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'setEnabled', {
          enable: bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }

    /**
     * Function to get paired SSID.
     */
    getPaired() {
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'getPairedSSID', {}).then(result => {
          resolve(result);
        }).catch(err => {
          console.error("Can't get paired: ".concat(err));
          reject(err);
        });
      });
    }
    getDefaultInterface() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'getDefaultInterface', {}).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getInterfaces() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'getInterfaces').then(result => {
          resolve(result);
        }).catch(err => {
          console.log('Failed to get Interfaces');
        });
      });
    }
    setInterface(inter, bool) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'setInterfaceEnabled', {
          interface: inter,
          persist: true,
          enabled: bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('SetInterface Error', JSON.stringify(err));
        });
      });
    }
    setDefaultInterface(interfaceName, bool) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.Network', 'setDefaultInterface', {
          interface: interfaceName,
          persist: bool
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('SetDefaultInterface Error', JSON.stringify(err));
        });
      });
    }
    saveSSID(ssid, password, securityMode) {
      console.log("SAVESSID");
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'saveSSID', {
          ssid: ssid,
          passphrase: password,
          securityMode: securityMode
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('SaveSSID Error', JSON.stringify(err));
        });
      });
    }
    clearSSID() {
      console.log("CLEARSSID");
      return new Promise((resolve, reject) => {
        this._thunder.call(this.callsign, 'clearSSID').then(result => {
          resolve(result);
        }).catch(err => {
          console.log('Error in clear ssid');
        });
      });
    }
    SaveSSIDKey(value1) {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.PersistentStore', 'setValue', {
          namespace: "wifi",
          key: "SSID",
          value: value1
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('storage SSID failed', err);
          reject();
        });
      });
    }
    //get SSID value from Persistence Store
    getSSIDKey() {
      return new Promise(resolve => {
        this._thunder.call('org.rdk.PersistentStore', 'getValue', {
          namespace: 'wifi',
          key: 'SSID'
        }).then(result => {
          resolve(result.value);
        }).catch(err => {
          resolve('');
        });
      });
    }
    deleteNameSpace() {
      return new Promise((resolve, reject) => {
        this._thunder.call('org.rdk.PersistentStore', 'deleteNamespace', {
          namespace: "wifi"
        }).then(result => {
          resolve(result.success);
        }).catch(err => {
          console.error('delete namespace failed', err);
          reject();
        });
      });
    }
    activateOnError() {
      return new Promise((resolve, reject) => {
        this._thunder.call('Controller', 'activate', {
          callsign: this.callsign
        }).then(result => {
          this._thunder.on(this.callsign, 'onError', notification => {
            if (this._events.has('onError')) {
              this._events.get('onError')(notification);
            }
          });
          resolve(result);
        }).catch(err => {
          console.error("Wifi activation failed: ".concat(err));
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$5 = new Wifi();
  class JoinAnotherNetworkComponent$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _active() {
      this.hidePasswd = true;
      this.star = "";
      this.tag("Keyboard").visible = false;
    }
    handleDone() {
      this.tag("Keyboard").visible = false;
      let securityCode = this.securityCodes[this.securityCodeIndex].value;
      if (!this.textCollection['EnterSSID']) {
        this._setState("EnterSSID");
      } else if (securityCode < 0 || securityCode > 14 || securityCode === 0 && !this.scode) {
        this.scode = true;
        this._setState("EnterSecurity");
      } else if (securityCode !== 0 && !this.textCollection['EnterPassword']) {
        this._setState("EnterPassword");
      } else {
        if (this.textCollection['EnterSecurity'] === "0") {
          this.textCollection['EnterPassword'] = "";
          this.tag("Pwd").text.text = "";
        }
        let self = this;
        this.startConnectForAnotherNetwork({
          ssid: self.textCollection['EnterSSID'],
          security: securityCode
        }, self.textCollection['EnterPassword']);
      }
    }
    startConnectForAnotherNetwork(device, passphrase) {
      wifi$5.connect({
        ssid: device.ssid,
        security: device.security
      }, passphrase).then(() => {
        wifi$5.saveSSID(device.ssid, passphrase, device.security).then(response => {
          if (response.result === 0 && response.success === true) {
            wifi$5.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
          } else if (response.result !== 0) {
            wifi$5.clearSSID();
          }
        });
      });
      Router.back();
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xCC000000
        },
        Text: {
          x: 758,
          y: 70,
          text: {
            text: Language$1.translate("Find and join a WiFi network"),
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 190,
          y: 130,
          w: 1488,
          h: 2,
          rect: true
        },
        Network: {
          x: 190,
          y: 176,
          text: {
            text: Language$1.translate("Network Name") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        NetworkBox: {
          x: 400,
          y: 160,
          texture: t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        NetworkText: {
          x: 420,
          y: 170,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        NetworkType: {
          x: 190,
          y: 246,
          text: {
            text: Language$1.translate("Security") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        TypeBox: {
          x: 400,
          y: 230,
          texture: t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false),
          ArrowForward: {
            h: 30,
            w: 45,
            y: 15,
            x: 1220,
            src: Utils.asset('images/settings/Arrow.png')
          },
          ArrowBackward: {
            h: 30,
            w: 45,
            x: 10,
            scaleX: -1,
            y: 15,
            src: Utils.asset('images/settings/Arrow.png')
          }
        },
        TypeText: {
          x: 470,
          y: 263,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Password: {
          x: 190,
          y: 316,
          text: {
            text: Language$1.translate("Password") + ":",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        PasswordBox: {
          x: 400,
          y: 300,
          texture: t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        Pwd: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        BorderBottom: {
          x: 190,
          y: 396,
          w: 1488,
          h: 2,
          rect: true
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard$1,
          visible: false,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        },
        PasswrdSwitch: {
          h: 45,
          w: 66.9,
          x: 1642,
          y: 330,
          zIndex: 2,
          type: PasswordSwitch,
          mount: 0.5,
          visible: true
        },
        ShowPassword: {
          x: 1405,
          y: 312,
          w: 300,
          h: 75,
          zIndex: 2,
          text: {
            text: Language$1.translate('Show Password'),
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            textAlign: 'left'
          },
          visible: true
        }
      };
    }
    _focus() {
      this.scode = false;
      this._setState('EnterSSID');
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': ''
      };
      this.tag('Pwd').text.text = Language$1.translate("Press OK to enter Password");
      this.tag("NetworkText").text.text = Language$1.translate("Press OK to enter SSID");
      this.tag('NetworkText').text.textColor = 0xff808080;
      this.tag('Pwd').text.textColor = 0xff808080;
      this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
      if (this.securityCodes[this.securityCodeIndex].value === 0) {
        this.pwdUnReachable = true;
        this.tag("PasswordBox").alpha = 0.5;
        this.tag("Password").alpha = 0.5;
      } else {
        this.pwdUnReachable = false;
        this.tag("PasswordBox").alpha = 1;
        this.tag("Password").alpha = 1;
      }
    }
    encrypt() {
      if (this.prevState === "EnterPassword" && this.hidePasswd) return true;else return false;
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    static _states() {
      return [class EnterSSID extends this {
        $enter() {
          this.tag('NetworkBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("EnterSecurity");
        }
        _handleEnter() {
          this._setState('Keyboard');
          this.tag('NetworkText').text.text = this.textCollection['EnterSSID'];
          this.tag('NetworkText').text.textColor = 0xffffffff;
          this.tag("Keyboard").visible = true;
        }
        $exit() {
          this.tag('NetworkBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterSecurity extends this {
        $enter() {
          this.tag("TypeBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSSID");
        }
        isPasswordUnReachable(secCode) {
          if (secCode === 0) {
            this.tag("PasswordBox").alpha = 0.5;
            this.tag("Password").alpha = 0.5;
            return true;
          } else {
            this.tag("PasswordBox").alpha = 1;
            this.tag("Password").alpha = 1;
            return false;
          }
        }
        _handleLeft() {
          this.securityCodeIndex = (15 + --this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleEnter() {
          this.handleDone();
        }
        _handleRight() {
          this.securityCodeIndex = (15 + ++this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleDown() {
          if (!this.pwdUnReachable) {
            this._setState("EnterPassword");
          }
        }
        $exit() {
          this.tag("TypeBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterPassword extends this {
        $enter() {
          if (this.pwdUnReachable) {
            this._setState("EnterSecurity");
          }
          this.tag('PasswordBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleDown() {
          this._setState("EnterSSID");
        }
        _handleRight() {
          this._setState("PasswordSwitchState");
        }
        _handleEnter() {
          this.tag("Keyboard").visible = true;
          this._setState('Keyboard');
          this.tag('Pwd').text.text = this.hidePasswd ? this.star : this.textCollection['EnterPassword'];
          this.tag('Pwd').text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag('PasswordBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
          this.tag('ShowPassword').text.textColor = CONFIG.theme.hex;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleLeft() {
          this._setState("EnterPassword");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.textCollection['EnterPassword']);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
          this.tag('ShowPassword').text.textColor = 0xffffffff;
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'EnterSSID') {
            this.element = 'NetworkText';
          }
          if (this.prevState === 'EnterPassword') {
            this.element = 'Pwd';
          }
          if (this.prevState === 'EnterSecurity') {
            this.element = 'TypeText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (this.prevState === 'PasswordSwitchState') {
            this.prevState = "EnterPassword";
          }
          console.log("Prev state:", this.prevState);
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection[this.prevState] = this.textCollection[this.prevState].substring(0, this.textCollection[this.prevState].length - 1);
            this.star = this.prevState === "EnterPassword" ? this.star.substring(0, this.star.length - 1) : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.textCollection[this.prevState] += ' ';
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === 'Delete') {
            this.textCollection[this.prevState] = '';
            this.star = this.prevState === "EnterPassword" ? '' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else {
            this.textCollection[this.prevState] += key;
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          }
        }
        _handleUp() {
          this._setState(this.prevState);
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }];
    }
    _init() {
      this.securityCodeIndex = 0;
      this.pwdUnReachable = true;
      this.star = '';
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': '0'
      };
      this.securityCodes = [{
        name: "Open/None (Unsecure)",
        value: 0
      }, {
        name: "WEP - Deprecated, not needed",
        value: 1
      }, {
        name: "WEP",
        value: 2
      }, {
        name: "WPA Personal TKIP",
        value: 3
      }, {
        name: "WPA Personal AES",
        value: 4
      }, {
        name: "WPA2 Personal TKIP",
        value: 5
      }, {
        name: "WPA2 Personal AES",
        value: 6
      }, {
        name: "WPA Enterprise TKIP",
        value: 7
      }, {
        name: "WPA Enterprise AES",
        value: 8
      }, {
        name: "WPA2 Enterprise TKIP",
        value: 9
      }, {
        name: "WPA2 Enterprise AES",
        value: 10
      }, {
        name: "Mixed Personal",
        value: 11
      }, {
        name: "Mixed Enterprise",
        value: 12
      }, {
        name: "WPA3 Personal AES",
        value: 13
      }, {
        name: "WPA3 Personal SAE",
        value: 14
      }];
      this.tag("Pwd").text.text = this.textCollection['EnterPassword'];
      this.tag("NetworkText").text.text = this.textCollection['EnterSSID'];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Network Config Screen.
    */

  class NetworkConfigurationScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkConfigurationScreenContents: {
          x: 200,
          y: 275,
          NetworkInfo: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NetworkInterface: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Interface: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TestInternetAccess: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Test Internet Access: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 420,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          },
          StaticMode: {
            alpha: 0,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Static Mode'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _firstEnable() {
      this._setState('NetworkInfo');
      let _currentIPSettings = {};
      let _newIPSettings = {};
      this._network = new Network();
      this._network.getDefaultInterface().then(interfaceName => {
      });
      _newIPSettings = _currentIPSettings;
      _newIPSettings.ipversion = "IPV6"; // this fails, need to verify how to set proper ip settings

      // loader animation for testing internet
      this.loadingAnimation = this.tag('TestInternetAccess.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState(this.state); //can be used on init as well

      this._network.getDefaultInterface().then(interfaceName => {
        this.$NetworkInterfaceText(interfaceName);
      });
    }
    _unfocus() {
      this.tag('TestInternetAccess.Title').text.text = Language$1.translate('Test Internet Access: ');
    }
    $NetworkInterfaceText(text) {
      this.tag('NetworkInterface.Title').text.text = Language$1.translate('Network Interface: ') + text;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration'));
    }
    static _states() {
      return [class NetworkInfo extends this {
        $enter() {
          this.tag('NetworkInfo')._focus();
        }
        $exit() {
          this.tag('NetworkInfo')._unfocus();
        }
        _handleDown() {
          this._setState('NetworkInterface');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/info');
          }
        }
      }, class NetworkInterface extends this {
        $enter() {
          this.tag('NetworkInterface')._focus();
        }
        $exit() {
          this.tag('NetworkInterface')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInfo');
        }
        _handleDown() {
          this._setState('TestInternetAccess');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/interface');
          }
        }
      }, class TestInternetAccess extends this {
        $enter() {
          this.tag('TestInternetAccess')._focus();
        }
        $exit() {
          this.tag('TestInternetAccess')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInterface');
        }
        _handleDown() {
          // this._setState('NetworkInfo')
        }
        _handleEnter() {
          this.loadingAnimation.start();
          this.tag('TestInternetAccess.Loader').visible = true;
          this._network.isConnectedToInternet().then(result => {
            var connectionStatus = Language$1.translate("Internet Access: ");
            if (result) {
              connectionStatus += Language$1.translate("Connected");
            } else {
              connectionStatus += Language$1.translate("Not Connected");
            }
            setTimeout(() => {
              this.tag('TestInternetAccess.Loader').visible = false;
              this.tag('TestInternetAccess.Title').text.text = connectionStatus;
              this.loadingAnimation.stop();
            }, 2000);
          });
        }
      }, class StaticMode extends this {
        $enter() {
          this.tag('StaticMode')._focus();
        }
        $exit() {
          this.tag('StaticMode')._unfocus();
        }
        _handleUp() {
          this._setState('TestInternetAccess');
        }
        _handleDown() {
          this._setState('NetworkInfo');
        }
        _handleEnter() {}
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Settings Screen.
    */

  var appApi$c = new AppApi();
  var defaultInterface$1 = "";
  var currentInterface$1 = [];
  class NetworkInfo$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/network');
      }
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration  Network Info'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkInfoScreenContents: {
          x: 200,
          y: 275,
          Status: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          ConnectionType: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Connection Type: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          IPAddress: {
            //alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('IP Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Gateway: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Gateway: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MACAddress: {
            //alpha: 0.3, // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('MAC Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          InternetProtocol: {
            //alpha: 0.3, // disabled
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Internet Protocol: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SSID: {
            //alpha: 0.3, // disabled
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('SSID: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SignalStrength: {
            //alpha: 0.3, // disabled
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Signal Strength: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    getIPSetting(interfaceName) {
      appApi$c.getIPSetting(interfaceName).then(result => {
        this.tag('InternetProtocol.Value').text.text = result.ipversion;
      }).catch(err => console.log(err));
    }
    _focus() {
      //Getting the default interface
      appApi$c.getDefaultInterface().then(result => {
        defaultInterface$1 = result.interface;
        this.getIPSetting(defaultInterface$1);
        if (defaultInterface$1 === "WIFI") {
          this.tag("ConnectionType.Value").text.text = Language$1.translate("Wireless");
          this.tag("SSID").alpha = 1;
          this.tag("SignalStrength").alpha = 1;
        } else if (defaultInterface$1 === "ETHERNET") {
          this.tag("ConnectionType.Value").text.text = "Ethernet";
          this.tag("SSID").alpha = 0;
          this.tag("SignalStrength").alpha = 0;
        } else {
          this.tag("ConnectionType.Value").text.text = "NA";
          this.tag("Status.Value").text.text = Language$1.translate('Disconnected');
          this.tag("IPAddress.Value").text.text = "NA";
          this.tag("Gateway.Value").text.text = "NA";
          this.tag("MACAddress.Value").text.text = "NA";
        }

        //Filtering the current interface
        appApi$c.getInterfaces().then(result => {
          currentInterface$1 = result.interfaces.filter(data => data.interface === defaultInterface$1);
          //console.log(currentInterface);
          if (currentInterface$1[0].connected) {
            this.tag("Status.Value").text.text = Language$1.translate('Connected');
            appApi$c.getConnectedSSID().then(result => {
              if (parseInt(result.signalStrength) >= -50) {
                this.tag("SignalStrength.Value").text.text = "Excellent";
              } else if (parseInt(result.signalStrength) >= -60) {
                this.tag("SignalStrength.Value").text.text = "Good";
              } else if (parseInt(result.signalStrength) >= -67) {
                this.tag("SignalStrength.Value").text.text = "Fair";
              } else {
                this.tag("SignalStrength.Value").text.text = "Poor";
              }
              this.tag("SSID.Value").text.text = "".concat(result.ssid);
            }).catch(error => console.log(error));
            appApi$c.getIPSetting(defaultInterface$1).then(result => {
              this.tag('IPAddress.Value').text.text = "".concat(result.ipaddr);
              this.tag("Gateway.Value").text.text = "".concat(result.gateway);
            }).catch(error => console.log(error));
          } else {
            this.tag('Status.Value').text.text = Language$1.translate('Disconnected');
          }
          this.tag('MACAddress.Value').text.text = "".concat(currentInterface$1[0].macAddress);
        }).catch(error => console.log(error));
      }).catch(error => console.log(error));
    }
    _unfocus() {
      this.tag('SSID.Value').text.text = 'NA';
      this.tag('SignalStrength.Value').text.text = 'NA';
      this.tag('MACAddress.Value').text.text = 'NA';
      this.tag('Gateway.Value').text.text = 'NA';
      this.tag('IPAddress.Value').text.text = 'NA';
      this.tag('ConnectionType.Value').text.text = 'NA';
      this.tag('InternetProtocol.Value').text.text = 'NA';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$4 = new Wifi();
  class NetworkInterfaceScreen$1 extends t.Component {
    _construct() {
      this.LoadingIcon = Utils.asset('images/settings/Loading.png');
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        NetworkInterfaceScreenContents: {
          x: 200,
          y: 275,
          WiFi: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Ethernet: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Ethernet'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 175,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          }
        }
      };
    }
    _focus() {
      this._setState('WiFi');
    }
    _init() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
      const systemcCallsign = 'org.rdk.Network';
      const eventName = 'onDefaultInterfaceChanged';
      this._thunder.on(systemcCallsign, eventName, notification => {
        console.log('onDefaultInterfaceChanged notification from networkInterfaceScreen: ', notification);
        if (notification.newInterfaceName === "ETHERNET") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate("Connected");
        } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate('Error') + ', ' + Language$1.translate('Retry') + '!';
        } else if (notification.newInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet';
        }
      });
      this.loadingAnimation = this.tag('Ethernet.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag('Ethernet.Loader').src = this.LoadingIcon;
    }
    _firstActive() {
      this.tag('Ethernet.Loader').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png';
        this.tag('Ethernet.Loader').src = url;
      });
    }
    hide() {
      this.tag('NetworkInterfaceScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkInterfaceScreenContents').visible = true;
    }
    setEthernetInterface() {
      wifi$4.getInterfaces().then(res => {
        res.interfaces.forEach(element => {
          if (element.interface === "ETHERNET" && element.connected) {
            wifi$4.setInterface('ETHERNET', true).then(result => {
              if (result.success) {
                wifi$4.setDefaultInterface('ETHERNET', true);
                this.tag('Ethernet.Title').text.text = 'Ethernet';
                this.tag('Ethernet.Loader').visible = true;
                this.loadingAnimation.start();
              }
            });
          }
        });
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/network');
      }
    }
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration  Network Interface'));
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/network/interface/wifi');
          }
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          wifi$4.getDefaultInterface().then(res => {
            if (res.success) {
              if (res.interface !== "ETHERNET") {
                this.setEthernetInterface();
              }
            }
          });
        }
        _handleDown() {
          // this._setState('WiFi')
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class ConfirmAndCancel extends t.Component {
    static _template() {
      return {
        Item: {
          w: 325,
          // previous value : ((1920 / 2) - 350) / 2
          h: 85,
          // previous value: 65
          rect: true,
          color: 0xffffffff,
          shader: {
            type: t.shaders.RoundedRectangle,
            radius: 0
          }
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Left: {
          x: this.tag("Item").w / 2,
          // orginal = 10
          y: this.tag('Item').h / 2,
          mountX: 0.5,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xff000000,
            fontFace: CONFIG.language.font
          }
        }
      });
    }

    /**
     * Set width of the item.
     */
    set width(width) {
      this.tag('Item').w = width;
    }

    /**
     * Set height of the item.
     */
    set height(height) {
      this.tag('Item').h = height;
    }
    _focus() {
      this.tag('Item').color = CONFIG.theme.hex;
    }
    _unfocus() {
      this.tag('Item').color = 0xffffffff;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WifiPairingScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        PairingScreen: {
          Title: {
            x: 960,
            y: 95,
            mountX: 0.5,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          RectangleWithColor: {
            x: 180,
            y: 164,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          PasswordLabel: {
            x: 180,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate('Password') + ": ",
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          Pwd: {
            x: 437,
            y: 240,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 1000,
              wordWrap: false,
              textOverflow: 'ellipsis'
            }
          },
          PasswordBox: {
            x: 417,
            y: 208,
            zIndex: 2,
            texture: t.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false)
          },
          PasswrdSwitch: {
            h: 45,
            w: 66.9,
            x: 1656,
            y: 255,
            zIndex: 2,
            type: PasswordSwitch,
            mount: 0.5
          },
          ShowPassword: {
            x: 1390,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate('Show Password'),
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          List: {
            x: 417,
            y: 331,
            type: t.components.ListComponent,
            w: 1080,
            h: 400,
            itemSize: 28,
            horizontal: true,
            invertDirection: false,
            roll: true,
            zIndex: 2
          },
          RectangleWithColor2: {
            x: 180,
            y: 451,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          KeyBoard: {
            y: 501,
            x: 420,
            type: Keyboard$1,
            visible: true,
            zIndex: 2,
            formats: KEYBOARD_FORMATS.qwerty
          }
        }
      };
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    _handleBack() {
      Router.back();
    }

    /**
     * @param {{ item: Wifi Response Object; }} args
     */
    set params(args) {
      if (args.wifiItem) {
        this.item(args.wifiItem);
      } else {
        Router.navigate('settings/network/interface/wifi');
      }
    }
    item(item) {
      this.star = "";
      this.passwd = "";
      this.tag("Pwd").text.text = "";
      this.tag('Title').text = item.ssid;
      let options = [];
      this._item = item;
      if (item.connected) {
        options = ['Disconnect', 'Cancel'];
      } else {
        options = ['Connect', 'Cancel'];
      }
      this.tag('List').items = options.map((item, index) => {
        return {
          ref: item,
          x: index === 0 ? 0 : 325 * index,
          w: 325,
          h: 85,
          type: ConfirmAndCancel,
          item: item
        };
      });
      this._setState('Pair');
    }
    _focus() {
      this.hidePasswd = true;
      this._setState('Pair');
    }
    _unfocus() {}
    _init() {
      this.star = "";
      this.passwd = "";
      this.isOn = false;
      this._wifi = new Wifi();
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        Router.back();
      } else if (option === 'Connect') {
        if (this._item) {
          console.log('trying to connect wifi');
          this._wifi.connect(this._item, '').then(() => {}).catch(err => {
            console.log('Not able to connect to wifi', JSON.stringify(err));
          });
        }
        Router.back();
      } else if (option === 'Disconnect') {
        this._wifi.disconnect().then(() => {
          Router.back();
        });
      }
    }

    // startConnect(password) {
    //   this._wifi.connect(this._item, password).then(() => {
    //     Router.back()
    //   })

    // }
    startConnect(password) {
      let flag = 0;
      this._wifi.activateOnError();
      this._wifi.registerEvent('onError', notification => {
        if (notification.code === 0 || notification.code === 4) {
          this._wifi.deleteNameSpace();
          flag = 1;
        }
      });
      this._wifi.connect(this._item, password).then(() => {
        this._wifi.saveSSID(this._item.ssid, password, this._item.security).then(response => {
          if (response.result === 0 && response.success === true && flag === 0) {
            this._wifi.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // console.log(response);
          } else if (response.result !== 0) {
            this._wifi.clearSSID().then(response => {
              // console.log(response)
            });
          }
        });
        Router.back();
      });
    }
    static _states() {
      return [class Password extends this {
        $enter() {
          this.shifter = false;
          this.capsLock = false;
        }
        _getFocused() {
          return this.tag("KeyBoard");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.startConnect(this.passwd);
          } else if (key === 'Clear') {
            this.passwd = this.passwd.substring(0, this.passwd.length - 1);
            this.star = this.star.substring(0, this.star.length - 1);
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.star += '\u25CF';
            this.passwd += ' ';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === 'Delete') {
            this.star = '';
            this.passwd = '';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else {
            this.star += '\u25CF';
            this.passwd += key;
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          }
        }
        _handleUp() {
          this._setState("Pair");
        }
      }, class Pair extends this {
        $enter() {}
        _getFocused() {
          return this.tag('List').element;
        }
        _handleRight() {
          this.tag('List').setNext();
        }
        _handleLeft() {
          this.tag('List').setPrevious();
        }
        _handleUp() {
          this._setState("PasswordSwitchState");
        }
        _handleDown() {
          this._setState("Password");
        }
        _handleEnter() {
          if (this.tag('List').element.ref == 'Connect' && this._item.security != 0) {
            if (this.star === '') {
              this._setState('Password');
            } else {
              this.startConnect(this.passwd);
            }
          } else {
            this.pressEnter(this.tag('List').element.ref);
          }
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1279, 88, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Pair");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.passwd);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WiFiItem extends t.Component {
    _construct() {
      this.Lock = Utils.asset('/images/settings/Lock.png');
      this.WiFi1 = Utils.asset('/images/settings/WiFi1.png');
      this.WiFi2 = Utils.asset('/images/settings/WiFi2.png');
      this.WiFi3 = Utils.asset('/images/settings/WiFi3.png');
      this.WiFi4 = Utils.asset('/images/settings/WiFi4.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    _init() {
      this.tag('Item.Tick').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png';
        this.tag('Item.Tick').src = url;
      });
    }
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents of an item in the Bluetooth screen.
     */
    set item(item) {
      this._item = item;
      if (item.ssid) {
        this.status = item.connected ? 'Connected' : 'Not Connected';
      }
      let wifiicon = "";
      if (item.signalStrength >= -50) {
        wifiicon = this.WiFi4;
      } else if (item.signalStrength >= -60) {
        wifiicon = this.WiFi3;
      } else if (item.signalStrength >= -67) {
        wifiicon = this.WiFi2;
      } else {
        wifiicon = this.WiFi1;
      }
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          //texture: Lightning.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item.connected ? true : false
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item.ssid,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        },
        Right: {
          x: 1560,
          mountX: 1,
          y: 45,
          mountY: 0.5,
          flex: {
            direction: 'row'
          },
          Lock: {
            color: 0xffffffff,
            texture: t.Tools.getSvgTexture(this.Lock, 32.5, 32.5),
            alpha: 1
          },
          Icon: {
            color: 0xffffffff,
            flexItem: {
              marginLeft: 15
            },
            texture: t.Tools.getSvgTexture(wifiicon, 32.5, 32.5)
          }
        }
      });
      if (item.security == '0' || item.security == '15') {
        this.tag('Item.Right.Lock').visible = false;
      } else {
        this.tag('Item.Right.Lock').visible = true;
      }
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for WiFi screen.
  */

  var previousFocusedItemSSid;
  class WiFiScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        WifiContents: {
          x: 200,
          y: 275,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              visible: false,
              h: 45,
              w: 45,
              x: 1500,
              // x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Networks: {
            y: 180,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: t.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: t.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }
    _active() {
      this._setState('Switch');
    }
    _focus() {
      this._setState('Switch');
      this._enable();
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Switch.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.onError = {
        0: 'SSID_CHANGED - The SSID of the network changed',
        1: 'CONNECTION_LOST - The connection to the network was lost',
        2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
        3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
        4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
        5: 'NO_SSID - The SSID does not exist',
        6: 'UNKNOWN - Any other error.'
      };
      this._wifi = new Wifi();
      this._network = new Network();
      this.wifiStatus = false;
      this._wifiIcon = true;
      this._activateWiFi();
      this._setState('Switch');
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this._network.activate().then(result => {
        if (result) {
          this.wifiStatus = true;
          this._network.registerEvent('onIPAddressStatusChanged', notification => {
            console.log("onIPAddressStatusChanged", JSON.stringify(notification));
            if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                this._wifi.setInterface('ETHERNET', true).then(res => {
                  if (res.success) {
                    this._wifi.setDefaultInterface('ETHERNET', true);
                  }
                });
              }
            }
          });
          this._network.registerEvent('onDefaultInterfaceChanged', notification => {
            if (notification.newInterfaceName === 'ETHERNET') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
            if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              this._wifi.disconnect();
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
            if (notification.newInterfaceName == '' && notification.oldInterfaceName == 'WIFI') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
          });
          this._network.registerEvent('onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              this._wifi.setInterface('ETHERNET', true).then(res => {
                if (res.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
          });
        }
      });
    }

    /**
     * Function to be executed when the Wi-Fi screen is enabled.
     */
    _enable() {
      if (this.wifiStatus) {
        this._wifi.discoverSSIDs();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _disable() {
      this._wifi.stopScan();
    }
    pairedDevices() {
      this._pairedNetworks.tag('List').items = [];
      this._availableNetworks.tag('List').items = [];
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      this._pairedList = [];
      this._pairedNetworks.h = 0;
      this._availableNetworks.tag('List').rollMax = ssids.length * 90;
      this._pairedNetworks.tag('List').items = [];
      this._pairedNetworks.tag('List').h = 0;
      this._wifi.getConnectedSSID().then(result => {
        console.log("getconnectedSSID response", result);
        if (result.ssid != '') {
          this._pairedList = [result];
          this._pairedNetworks.h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
            item.connected = true;
            return {
              ref: 'Paired' + index,
              w: 1920 - 300,
              h: 90,
              type: WiFiItem,
              item: item
            };
          });
        }
        this._otherList = ssids.filter(device => {
          console.log("SSID filter", device);
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        //this._availableNetworks.tag('List').y = this._pairedNetworks.tag('List').h
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            index: index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
      let IndexVal = 0;
      console.log("previousFocusedItemSSid:::", previousFocusedItemSSid);
      this._availableNetworks.tag('List').items.forEach(element => {
        if (element._item.ssid == previousFocusedItemSSid) {
          IndexVal = element.index;
        }
      });
      this._availableNetworks.tag('List').setIndex(IndexVal);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/network/interface');
      }
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Network Configuration  Network Interface  WiFi'));
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.tag('Switch.Button').scaleX = 1;
          }
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          if (this.wifiStatus === true) {
            this._setState('JoinAnotherNetwork');
          }
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          Router.navigate('settings/network/interface/wifi/connect', {
            wifiItem: this._pairedNetworks.tag('List').element._item
          });
        }
      }, class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          previousFocusedItemSSid = this._availableNetworks.tag('List').element._item.ssid;
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log("SSID check", this._availableNetworks.tag('List').element._item);
          let item = this._availableNetworks.tag('List').element._item;
          console.log("enter connect method");
          this._wifi.getSSIDKey().then(response => {
            console.log("ssid check");
            if (response === item.ssid) {
              this._wifi.connect().then(response => {
                this._wifi.registerEvent('onError', notification => {
                  if (notification.code === 0 || notification.code === 4) {
                    this._wifi.clearSSID();
                    Router.navigate('settings/network/interface/wifi/connect', {
                      wifiItem: this._availableNetworks.tag('List').element._item
                    });
                  }
                });
                console.log(response);
              }).catch(err => {
                Router.navigate('settings/network/interface/wifi/connect', {
                  wifiItem: this._availableNetworks.tag('List').element._item
                });
                this._wifi.SaveSSIDKey("").then(() => {});
              });
            } else {
              Router.navigate('settings/network/interface/wifi/connect', {
                wifiItem: this._availableNetworks.tag('List').element._item
              });
            }
          });
          //Router.navigate('settings/network/interface/wifi/connect', { wifiItem: this._availableNetworks.tag('List').element._item })
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleEnter() {
          if (this.wifiStatus) {
            Router.navigate('settings/network/interface/wifi/another');
          }
        }
        _handleDown() {
          if (this.wifiStatus) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */

    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          this._wifi.discoverSSIDs();
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }
    /**
     * Function to turn on and off Wi-Fi.
     */
    switch() {
      if (this.wifiStatus) {
        this._wifi.disconnect();
        console.log('turning off wifi');
        this._wifi.setInterface('ETHERNET', true).then(result => {
          if (result.success) {
            this._wifi.setDefaultInterface('ETHERNET', true).then(result => {
              if (result.success) {
                this._wifi.disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Switch.Loader').visible = false;
                this.wifiLoading.stop();
                this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        this.wifiStatus = true;
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Switch.Loader').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this._wifi.discoverSSIDs();
        this.pairedDevices();
      }
    }

    /**
     * Function to activate Wi-Fi plugin.
     */
    _activateWiFi() {
      this._wifi.activate().then(() => {
        this.switch();
      });
      this._wifi.registerEvent('onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === 2 || notification.state === 5) {
          this._wifi.discoverSSIDs();
        }
        if (notification.state === 5) {
          this._wifi.getConnectedSSID().then(result => {
            this._wifi.SaveSSIDKey(result.ssid).then(response => {
              console.log(response);
            });
          });
        }
      });
      this._wifi.registerEvent('onError', notification => {
        if (notification.code === 4) {
          this._wifi.clearSSID();
        }
        console.log('on errro');
        this._wifi.discoverSSIDs();
        this._wifi.setInterface('ETHERNET', true).then(res => {
          if (res.success) {
            this._wifi.setDefaultInterface('ETHERNET', true);
          }
        });
        if (this.widgets) {
          this.widgets.fail.notify({
            title: 'WiFi Error',
            msg: this.onError[notification.code]
          });
          Router.focusWidget('Fail');
        }
      });
      this._wifi.registerEvent('onAvailableSSIDs', notification => {
        console.log("Notification[onAvailableSSIDs]:", notification.ssids);
        this.renderDeviceList(notification.ssids);
        if (!notification.moreData) {
          setTimeout(() => {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
    _inactive() {
      previousFocusedItemSSid = undefined;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2023 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let instance = null;
  class RCApi {
    constructor() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this.thunder = thunderJS$1(config);
      this.INFO = console.info;
      this.LOG = console.log;
      this.ERR = console.error;
    }
    static get() {
      if (instance == null) {
        instance = new RCApi();
      }
      return instance;
    }
    activate() {
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: activate.");
        this.thunder.Controller.activate({
          callsign: 'org.rdk.RemoteControl'
        }).then(result => {
          resolve(true);
        }).catch(err => {
          this.ERR('RCApi: Error Activation ', err);
          reject(err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        this.thunder.Controller.deactivate({
          callsign: 'org.rdk.RemoteControl'
        }).then(res => {
          this.INFO("RCApi: deactivated org.rdk.RemoteControl");
          resolve(true);
        }).catch(err => {
          this.ERR('RCApi: Error deactivation ', err);
          reject(err);
        });
      });
    }
    getApiVersionNumber() {
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: getApiVersionNumber");
        this.thunder.call('org.rdk.RemoteControl', 'getApiVersionNumber').then(result => {
          this.INFO("RCApi: getApiVersionNumber result: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          this.ERR("RCApi: getApiVersionNumber error:", err);
          reject(err);
        });
      });
    }
    getNetStatus() {
      let netType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: getNetStatus of netType:", netType);
        this.thunder.call('org.rdk.RemoteControl', 'getNetStatus', {
          netType: netType
        }).then(result => {
          this.INFO("RCApi: getNetStatus result: ", JSON.stringify(result));
          if (result.success) resolve(result);
          reject(false);
        }).catch(err => {
          this.ERR("RCApi: getNetStatus error:", err);
          reject(err);
        });
      });
    }
    startPairing() {
      let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;
      let netType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: startPairing netType " + netType + " timeout " + timeout);
        this.thunder.call('org.rdk.RemoteControl', 'startPairing', {
          netType: netType,
          timeout: timeout
        }).then(result => {
          this.INFO("RCApi: startPairing result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: startPairing error:", err);
          reject(err);
        });
        resolve(true);
      });
    }
    initializeIRDB() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    clearIRCodes() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    setIRCode() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    getIRCodesByAutoLookup() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    getIRCodesByNames() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    getIRDBManufacturers() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    getIRDBModels() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    getLastKeypressSource() {
      return new Promise((resolve, reject) => {
        /*TODO: implement when requirement comes.*/
        reject("NotImplemented");
      });
    }
    configureWakeupKeys() {
      let netType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      let wakeupConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "custom";
      let customKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "3,1";
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: configureWakeupKeys netType:" + netType + " wakeupConfig:" + wakeupConfig + " customKeys:" + customKeys);
        this.thunder.call('org.rdk.RemoteControl', 'configureWakeupKeys', {
          netType: netType,
          wakeupConfig: wakeupConfig,
          customKeys: customKeys
        }).then(result => {
          this.INFO("RCApi: configureWakeupKeys result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: configureWakeupKeys error:", err);
          reject(err);
        });
      });
    }
    findMyRemote() {
      let netType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "mid";
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: findMyRemote netType:" + netType + " level:" + level);
        this.thunder.call('org.rdk.RemoteControl', 'findMyRemote', {
          netType: netType,
          level: level
        }).then(result => {
          this.INFO("RCApi: findMyRemote result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: findMyRemote error:", err);
          reject(err);
        });
      });
    }
    factoryReset() {
      return new Promise((resolve, reject) => {
        this.INFO("RCApi: factoryReset");
        this.thunder.call('org.rdk.RemoteControl', 'factoryReset').then(result => {
          this.INFO("RCApi: factoryReset result: ", JSON.stringify(result));
          resolve(result.success);
        }).catch(err => {
          this.ERR("RCApi: factoryReset error:", err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  new AppApi();
  new BluetoothApi();
  const config$e = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const _thunder$1 = thunderJS$1(config$e);
  let onStatusCBhandle = null;
  class RCInformationScreen extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Bluetooth Voice Remote Control'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: 0xCC000000,
        DeviceInfoContents: {
          x: 200,
          y: 275,
          Line1: {
            y: 0,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          MacAddress: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("MacAddress"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 45,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line2: {
            y: 90,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          RCUName: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("RCU Name"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 135,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line3: {
            y: 180,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          Status: {
            Title: {
              x: 10,
              y: 225,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Connection Status"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 225,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line4: {
            y: 270,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          BatteryPercent: {
            Title: {
              x: 10,
              y: 315,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Battery percent'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1600,
                wordWrap: true,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 315,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1200,
                wordWrap: true,
                fontSize: 25
              }
            }
          },
          Line5: {
            y: 360,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SwVersion: {
            Title: {
              x: 10,
              y: 405,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Software Version"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 405,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line6: {
            y: 450,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          }
        }
      };
    }
    async _active() {
      await RCApi.get().activate().catch(err => {
        console.error("RCInformationScreen error:", err);
      });
      await RCApi.get().getNetStatus().then(result => {
        console.info("RCInformationScreen getNetStatus:", result);
        onStatusCBhandle = _thunder$1.on('org.rdk.RemoteControl', 'onStatus', data => {
          this.onStatusCB(data);
        });
        this.onStatusCB(result);
      }).catch(err => console.error("RCInformationScreen error:", err));
    }
    _inactive() {
      console.warn("RCInformationScreen _inactive.");
      onStatusCBhandle.dispose();
      //RCApi.get().deactivate().catch(err=> { console.error("RCInformationScreen error:", err)});
    }

    onStatusCB(cbData) {
      // getStatus response has 'success' property; notification payload does not have that.
      if (cbData !== undefined && (cbData.hasOwnProperty("success") ? cbData.success : true)) {
        if (cbData.status.remoteData.length) {
          console.log("RCInformationScreen rcPairingApis RemoteData Length", cbData.status.remoteData.length);
          let RemoteName = [];
          let connectedStatus = [];
          let MacAddress = [];
          let swVersion = [];
          let BatteryPercent = [];
          cbData.status.remoteData.map(item => {
            RemoteName.push(item.name);
          });
          cbData.status.remoteData.map(item => {
            MacAddress.push(item.macAddress);
          });
          cbData.status.remoteData.map(item => {
            swVersion.push(item.swVersion);
          });
          cbData.status.remoteData.map(item => {
            BatteryPercent.push(item.batteryPercent);
          });
          cbData.status.remoteData.map(item => {
            connectedStatus.push(item.connected);
          });
          this.tag("Status.Value").text.text = connectedStatus;
          this.tag("MacAddress.Value").text.text = MacAddress;
          this.tag("SwVersion.Value").text.text = swVersion;
          this.tag("BatteryPercent.Value").text.text = BatteryPercent;
          this.tag("RCUName.Value").text.text = RemoteName;
        } else {
          console.log("RCInformationScreen rcPairingApis pairingState: ", cbData.status.pairingState);
          switch (cbData.status.pairingState) {
            case "IDLE":
            case "FAILED":
              RCApi.get().startPairing(30).catch(err => {
                console.err("RCInformationScreen startPairing error:", err);
              });
              break;
          }
        }
      }
    }
    _focus() {
      this._setState("RCInformationScreen");
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > 215) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 275) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const networkRoutes = [{
    path: 'settings/network',
    component: NetworkConfigurationScreen$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/info',
    component: NetworkInfo$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface',
    component: NetworkInterfaceScreen$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface/wifi',
    component: WiFiScreen$1,
    widgets: ['Menu', 'Fail', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface/wifi/connect',
    component: WifiPairingScreen$1,
    widgets: ['Volume', "AppCarousel"]
  }, {
    path: 'settings/network/interface/wifi/another',
    component: JoinAnotherNetworkComponent$1,
    widgets: ['Volume', "AppCarousel"]
  }, {
    path: 'settings/bluetooth',
    component: BluetoothScreen$2,
    widgets: ['Menu', 'Fail', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/bluetooth/pairing',
    component: BluetoothPairingScreen$1,
    widgets: ['Volume', "AppCarousel"]
  }, {
    path: 'settings/bluetooth/RCVolumeInfoScreen',
    component: RCInformationScreen,
    widgets: ["Menu", 'Volume', "Fail", "AppCarousel"]
  }];
  var route$1 = {
    network: networkRoutes
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Variable to store the timer
   */
  var timeout;

  /**
   * Class to render the UI controls for the video player.
   */
  class LightningPlayerControls extends t.Component {
    /**
     * Function to create components for the player controls.
     */
    static _template() {
      return {
        TimeBar: {
          x: 90,
          y: 93.5,
          texture: t.Tools.getRoundRect(1740, 20, 10, 0, 0, true, 0xffffffff)
        },
        ProgressWrapper: {
          x: 90,
          y: 93.5,
          w: 0,
          h: 35,
          clipping: true,
          ProgressBar: {
            texture: t.Tools.getRoundRect(1740, 20, 10, 0, 0, true, CONFIG.theme.hex)
            // x: 90,
            // y: 93.5,
          }
        },

        Duration: {
          x: 1690,
          y: 125,
          text: {
            text: "00:00:00",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: 0xffFFFFFF
          }
        },
        CurrentTime: {
          x: 140,
          // 140 = 90 + 50 | 50 is approzimately 1/2 of length(in px) of the text "00:00:00" and 90 is padding from left
          y: 60,
          mountX: 0.5,
          text: {
            text: "00:00:00",
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffFFFFFF
          }
        },
        Buttons: {
          x: 820,
          y: 125,
          children: [{
            src: Utils.asset('images/player/rewind.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Back_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Pause_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/Media Player/Icon_Next_White_16k.png'),
            x: 17,
            y: 17
          }, {
            src: Utils.asset('images/player/fast-forward.png'),
            x: 17,
            y: 17
          }].map((item, idx) => ({
            x: idx * 75,
            // texture: Lightning.Tools.getRoundRect(80, 80, 40, 0, 0, true, 0xff8e8e8e),
            ControlIcon: {
              x: item.x,
              y: item.y,
              texture: t.Tools.getSvgTexture(item.src, 50, 50)
            }
          }))
        }
      };
    }
    _init() {
      /**
       * Variable to store the duration of the video content.
       */
      this.videoDuration = 0;
      this.tag('Buttons').children[1].patch({
        alpha: 1
      });
      this.tag('Buttons').children[3].patch({
        alpha: 1
      });
      this.toggle = false;
    }

    /**
     * Function to set focus to player controls when the player controls are shown.
     */
    _focus() {
      this._index = 1;
      this._setState('PlayPause');
    }

    /**
     * Function to handle the player controls when they are hidden.
     */
    _unfocus() {
      this._setState('Hidden');
      clearTimeout(timeout);
    }
    /**
     * Function to set the duration of the video.
     * @param {String} duration video duration to be set.
     */
    set duration(duration) {
      console.log("duration was set = ".concat(duration));
      this.videoDuration = duration;
      this.tag('Duration').text.text = this.SecondsTohhmmss(duration);
    }

    /**
     * Function to set the current video time.
     * @param {String} currentTime current time to be set.
     */
    set currentTime(currentTime) {
      let value = 1740 * currentTime / this.videoDuration;
      this.tag('ProgressWrapper').patch({
        w: value
      });
      this.tag('CurrentTime').text.text = this.SecondsTohhmmss(currentTime);
      if (value >= 50 && value <= 1690) {
        // 1740 - 50 = 1690
        this.tag('CurrentTime').x = 90 + value; //90 is padding from left
      } else if (currentTime === 0) {
        this.tag('CurrentTime').x = 140; //initial position 140 = 90 + 50
      }
    }

    /**
     * Function to convert time in seconds to hh:mm:ss format.
     * @param {String} totalSeconds time in seconds.
     */
    SecondsTohhmmss(totalSeconds) {
      this.hours = Math.floor(totalSeconds / 3600);
      this.minutes = Math.floor((totalSeconds - this.hours * 3600) / 60);
      this.seconds = totalSeconds - this.hours * 3600 - this.minutes * 60;
      this.seconds = Math.round(totalSeconds) - this.hours * 3600 - this.minutes * 60;
      this.result = this.hours < 10 ? '0' + this.hours : this.hours;
      this.result += ':' + (this.minutes < 10 ? '0' + this.minutes : this.minutes);
      this.result += ':' + (this.seconds < 10 ? '0' + this.seconds : this.seconds);
      return this.result;
    }

    /**
     * Function to hide player controls.
     */
    hideLightningPlayerControls() {
      this.signal('hide');
    }
    hideNextPrevious() {
      this.isChannel = true;
      this.tag('Buttons').children[1].visible = false;
      this.tag('Buttons').children[3].visible = false;
    }
    showNextPrevious() {
      this.isChannel = false;
      this.tag('Buttons').children[1].visible = true;
      this.tag('Buttons').children[3].visible = true;
    }
    /**
     * Timer function to track the inactivity of the player controls.
     */
    timer() {
      clearTimeout(timeout);
      timeout = setTimeout(this.hideLightningPlayerControls.bind(this), 5000);
    }

    /**
     * Function that defines the different states of the player controls.
     */
    static _states() {
      return [class PlayPause extends this {
        $enter() {
          this.focus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_Orange_16k.png') : Utils.asset('images/Media Player/Icon_Pause_Orange_16k.png');
          this.timer();
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(this.focus, 50, 50)
          });
        }
        $exit() {
          this.unfocus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_White_16k.png') : Utils.asset('images/Media Player/Icon_Pause_White_16k.png');
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(this.unfocus, 50, 50)
          });
        }
        _handleEnter() {
          if (this.toggle) {
            //this.fireAncestors('$play');
            this.signal('play');
          } else {
            //this.fireAncestors('$pause');
            this.signal('pause');
          }
          this.toggle = !this.toggle;
          this.focus = this.toggle ? Utils.asset('images/Media Player/Icon_Play_Orange_16k.png') : Utils.asset('images/Media Player/Icon_Pause_Orange_16k.png');
          this.timer();
          this.tag('Buttons').children[2].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(this.focus, 50, 50)
          });
        }
        _handleRight() {
          if (!this.isChannel) {
            this._setState('Forward');
          } else {
            this._setState('seekFwd');
          }
        }
        _handleLeft() {
          if (!this.isChannel) {
            this._setState('Rewind');
          } else {
            this._setState('seekRwd');
          }
        }
        _getFocused() {
          this.timer();
        }
      }, class Forward extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[3].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Next_Orange_16k.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[3].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Next_White_16k.png'), 50, 50)
          });
        }
        _handleRight() {
          this._setState('seekFwd');
        }
        _handleLeft() {
          this._setState('PlayPause');
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('nextTrack');
        }
        _getFocused() {
          this.timer();
        }
      }, class Rewind extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Back_Orange_16k.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[1].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/Media Player/Icon_Back_White_16k.png'), 50, 50)
          });
        }
        _handleLeft() {
          this._setState('seekRwd');
        }
        _handleRight() {
          this._setState('PlayPause');
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('prevTrack');
        }
        _getFocused() {
          this.timer();
        }
      }, class seekFwd extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[4].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/Media Player/SeekFwd.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[4].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/player/fast-forward.png'), 50, 50)
          });
        }
        _handleLeft() {
          if (!this.isChannel) {
            this._setState('Forward');
          } else {
            this._setState('PlayPause');
          }
        }
        _handleRight() {}
        _handleEnter() {
          this.toggle = false;
          this.signal('seekFwd');
        }
        _getFocused() {
          this.timer();
        }
      }, class seekRwd extends this {
        $enter() {
          this.timer();
          this.tag('Buttons').children[0].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/Media Player/SeekRwd.png'), 50, 50)
          });
        }
        $exit() {
          this.tag('Buttons').children[0].tag('ControlIcon').patch({
            texture: t.Tools.getSvgTexture(Utils.asset('images/player/rewind.png'), 50, 50)
          });
        }
        _handleLeft() {}
        _handleRight() {
          if (!this.isChannel) {
            this._setState('Rewind');
          } else {
            this._setState('PlayPause');
          }
        }
        _handleEnter() {
          this.toggle = false;
          this.signal('seekRwd');
        }
        _getFocused() {
          this.timer();
        }
      }, class Hidden extends this {
        _getFocused() {}
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelItem$1 extends t.Component {
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 232,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 232,
          h: 81
        },
        BottomLine: {
          y: 81,
          mountY: 0.5,
          w: 232,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    set item(item) {
      //  this.shows = item.shows;
      this._item = item;
      this.tag('Item').patch({
        Title: {
          x: 10,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.index + 1 + "\t\t\t\t" + item.shortname,
            fontFace: CONFIG.language.font,
            fontSize: 21,
            textColor: 0xffFFFFFF,
            wordWrap: false,
            wordWrapWidth: 232 - 20,
            maxLines: 1,
            textOverflow: '...'
          } // update the text
        }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.tag('TopLine').h = 5;
      this.tag('BottomLine').h = 5;
      this.tag('Item.Title').text.fontStyle = "bold";
      this.patch({
        zIndex: 2
      });
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
      this.tag('Item.Title').text.fontStyle = "normal";
      this.patch({
        zIndex: 1
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelOverlay extends t.Component {
    /**
     * Function to create components for the player controls.
     */
    static _template() {
      return {
        Wrapper: {
          x: -235,
          y: 90,
          clipping: true,
          w: 232,
          h: 900,
          Channels: {
            y: 5,
            w: 232,
            h: 891,
            type: t.components.ListComponent,
            // clipping:true,
            itemSize: 81,
            roll: true,
            horizontal: false,
            invertDirection: true,
            itemScrollOffset: -10
          }
        }
      };
    }
    _init() {
      this.activeChannelIdx = 0; //this must be initialised in init
    }

    _firstEnable() {
      this.homeApi = new HomeApi();
      this.dtvApi = new DTVApi();
      this.appApi = new AppApi();
      this.options = [];
      this.overlayTimeout = null;
      this.timeoutDuration = 10000;
      this.dtvApi.serviceList().then(async channels => {
        await this.homeApi.checkChannelComapatability(channels).then(res => {
          channels = res;
        });
        this.options = channels;
        this.tag('Channels').items = this.options.map((item, index) => {
          return {
            type: ChannelItem$1,
            index: index,
            item: item,
            ref: "Channel" + index
          };
        });
      }).catch(err => {
        console.log("Failed to fetch channels: ", JSON.stringify(err));
      });
      this._overlayAnimation = this.tag("Wrapper").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "x",
          v: {
            0: -235,
            1: 0
          }
        }]
      });
    }
    _focus() {
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
      this.$focusChannel(this.activeChannelIdx);
      this._overlayAnimation.start();
    }
    _unfocus() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this._overlayAnimation.stop();
    }
    resetTimeout() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $focusChannel(index) {
      this.activeChannelIdx = index;
      this.tag('Channels').setIndex(this.activeChannelIdx);
    }
    _getFocused() {
      return this.tag('Channels').element; // add logic to focus on current channel
    }

    _handleDown() {
      this.resetTimeout();
      this.tag('Channels').setNext();
    }
    _handleUp() {
      this.resetTimeout();
      this.tag('Channels').setPrevious();
    }
    _handleBack() {
      if (Router.getActiveHash() === "player") {
        //for normal video player channel overlay is not a widget
        return false; //handleback of parent class will be executed
      }

      Router.focusPage();
    }
    _handleLeft() {
      if (Router.getActiveHash() === "player") {
        //for normal video player channel overlay is not a widget
        return false; //handleback of parent class will be executed
      }

      Router.focusPage();
    }
    _handleRight() {
      if (Router.getActiveHash() === "player") {
        //for normal video player channel overlay is not a widget
        return false; //handleback of parent class will be executed
      }

      Router.focusPage();
    }
    _handleEnter() {
      this.resetTimeout();
      let focusedChannelIdx = this.tag("Channels").index;
      let channel = this.options[focusedChannelIdx];
      if (channel.dvburi === "OTT") {
        let params = {
          launchLocation: "epgScreen",
          url: channel.url
        };
        this.appApi.launchApp(channel.callsign, params).then(res => {
          this.dtvApi.exitChannel();
        }).catch(err => {
          this.dtvApi.exitChannel(); //to exit previous channel regardless the app launch succeeds or fails
        });
      } else if (channel.dvburi.startsWith("C_")) {
        if (!Router.isNavigating()) {
          let playerParams = {
            url: channel.iptvuri,
            //video url for playing
            isChannel: true,
            channelName: channel.channelName,
            showName: "sample show name",
            showDescription: "sample description",
            channelIndex: focusedChannelIdx
          };
          if (Router.getActiveHash() === "player") {
            this.activeChannelIdx = focusedChannelIdx;
            this.fireAncestors("$changeChannel", channel.iptvuri, playerParams.showName, playerParams.channelName);
          } else {
            Router.navigate("player", playerParams);
          }
        }
      } else {
        if (focusedChannelIdx !== this.activeChannelIdx) {
          this.dtvApi.exitChannel().then(res => {
            console.log("Current channel exit successful, launching new channel: ", JSON.stringify(res));
            this.dtvApi.launchChannel(this.options[focusedChannelIdx].dvburi).then(res => {
              console.log("Change Channel successfull: ", JSON.stringify(res));
              this.activeChannelIdx = focusedChannelIdx;
            }).catch(err => {
              console.log("Failed to launch new channel", JSON.stringify(err));
            });
          }).catch(err => {
            console.log("Failed to exit current playing channel: ", JSON.stringify(err));
          });
        }
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let player = null;
  let position = null;
  /**
   * Class to render AAMP video player.
   */
  class AAMPVideoPlayer extends t.Component {
    /**
     * Function to render player controls.
     */

    set params(args) {
      this.currentIndex = args.currentIndex;
      this.data = args.list;
      if (args.isUSB) {
        this.isUSB = args.isUSB;
      } else if (args.isChannel) {
        this.isChannel = args.isChannel;
        this.channelName = args.channelName;
        this.showName = args.showName;
        this.showDescription = args.description;
        this.channelIndex = args.channelIndex;
      }
      let url = args.url ? args.url : 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/m3u8s/f08e80da-bf1d-4e3d-8899-f0f6155f6efa.m3u8';
      if (args.isAudio) {
        this.tag('Image').alpha = 1;
      }
      try {
        this.load({
          title: 'Parkour event',
          url: url,
          drmConfig: null
        });
        this.setVideoRect(0, 0, 1920, 1080);
      } catch (error) {
        console.error('Playback Failed ' + error);
      }
    }
    static _template() {
      return {
        Image: {
          alpha: 0,
          x: 960,
          y: 560,
          mount: 0.5,
          texture: {
            type: t.textures.ImageTexture,
            src: 'static/images/Media Player/Audio_Background_16k.jpg',
            resizeMode: {
              type: 'contain',
              w: 1920,
              h: 1080
            }
          }
        },
        InfoOverlay: {
          x: 90,
          y: 820,
          alpha: 0,
          zIndex: 3,
          ShowName: {
            text: {
              text: "Show Name",
              fontFace: CONFIG.language.font,
              fontSize: 48,
              fontStyle: 'bold',
              textColor: 0xffFFFFFF,
              wordWrap: true,
              wordWrapWidth: 1350,
              maxLines: 1
            }
          },
          ChannelName: {
            y: 50,
            visible: false,
            text: {
              text: "Channel Name",
              fontFace: CONFIG.language.font,
              fontSize: 35,
              textColor: 0xffFFFFFF,
              wordWrap: true,
              wordWrapWidth: 1350,
              maxLines: 1
            }
          }
        },
        PlayerControlsWrapper: {
          alpha: 0,
          h: 330,
          w: 1920,
          y: 750,
          rect: true,
          colorBottom: 0xFF000000,
          colorTop: 0x00000000,
          PlayerControls: {
            y: 70,
            type: LightningPlayerControls,
            signals: {
              pause: 'pause',
              play: 'play',
              hide: 'hidePlayerControls',
              fastfwd: 'fastfwd',
              fastrwd: 'fastrwd',
              nextTrack: 'nextTrack',
              prevTrack: 'prevTrack',
              seekFwd: 'seekFwd',
              seekRwd: 'seekRwd'
            }
          }
        },
        ChannelWrapper: {
          h: 1080,
          w: 350,
          x: -360,
          rect: true,
          colorLeft: 0xFF000000,
          colorRight: 0x00000000,
          ChannelOverlay: {
            type: ChannelOverlay,
            x: 50,
            y: 92
          }
        }
      };
    }
    _init() {
      this.x = 0;
      this.y = 0;
      this.w = 0;
      this.h = 0;
      this.videoEl = document.createElement('video');
      this.videoEl.setAttribute('id', 'video-player');
      this.videoEl.style.position = 'absolute';
      this.videoEl.style.zIndex = '1';
      this.videoEl.setAttribute('width', '100%');
      this.videoEl.setAttribute('height', '100%');
      this.videoEl.setAttribute('type', 'video/ave');
      document.body.appendChild(this.videoEl);
      this.playbackSpeeds = [-16, -8, -4, -2, 1, 2, 4, 8, 16];
      this.playerStatesEnum = {
        idle: 0,
        initializing: 1,
        playing: 8,
        paused: 6,
        seeking: 7
      };
      player = null;
      this.playbackRateIndex = this.playbackSpeeds.indexOf(1);
      this.defaultInitConfig = {
        initialBitrate: 2500000,
        offset: 0,
        networkTimeout: 10,
        preferredAudioLanguage: 'en',
        liveOffset: 15,
        drmConfig: null
      };
    }

    /**
     * Function to set video coordinates.
     * @param {int} x x position of video
     * @param {int} y y position of video
     * @param {int} w width of video
     * @param {int} h height of video
     */
    setVideoRect(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }

    /**
     * Event handler to store the current playback state.
     * @param  event playback state of the video.
     */
    _playbackStateChanged(event) {
      switch (event.state) {
        case player.playerStatesEnum.idle:
          this.playerState = player.playerStatesEnum.idle;
          break;
        case player.playerStatesEnum.initializing:
          this.playerState = player.playerStatesEnum.initializing;
          break;
        case player.playerStatesEnum.playing:
          this.playerState = player.playerStatesEnum.playing;
          break;
        case player.playerStatesEnum.paused:
          this.playerState = player.playerStatesEnum.paused;
          break;
        case player.playerStatesEnum.seeking:
          this.playerState = player.playerStatesEnum.seeking;
          break;
      }
    }

    /**
     * Event handler to handle the event of completion of a video playback.
     */
    _mediaEndReached() {
      this.load(this.videoInfo);
      this.setVideoRect(this.x, this.y, this.w, this.h);
    }

    /**
     * Event handler to handle the event of changing the playback speed.
     */
    _mediaSpeedChanged() {}

    /**
     * Event handler to handle the event of bit rate change.
     */
    _bitrateChanged() {}

    /**
     * Function to handle the event of playback failure.
     */
    _mediaPlaybackFailed() {
      this.load(this.videoInfo);
    }

    /**
     * Function to handle the event of playback progress.
     * @param event playback event.
     */
    _mediaProgressUpdate(event) {
      position = event.positionMiliseconds / 1000;
      this.tag('PlayerControls').currentTime = position;
    }

    /**
     * Function to handle the event of starting the playback.
     */
    _mediaPlaybackStarted() {
      this.tag('PlayerControls').reset();
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 1);
      this.tag('PlayerControlsWrapper').setSmooth('y', 750, {
        duration: 1
      });
      if (this.isUSB) {
        this.tag("InfoOverlay").setSmooth('alpha', 1);
      }
      this.timeout = setTimeout(this.hidePlayerControls.bind(this), 5000);
    }

    /**
     * Function to handle the event of change in the duration of the playback content.
     */
    _mediaDurationChanged() {}

    /**
     * Function to create the video player instance for video playback and its initial settings.
     */
    createPlayer() {
      if (player !== null) {
        this.destroy();
        player = null;
      }
      try {
        player = new AAMPMediaPlayer();
        player.addEventListener('playbackStateChanged', this._playbackStateChanged);
        player.addEventListener('playbackCompleted', this._mediaEndReached.bind(this));
        player.addEventListener('playbackSpeedChanged', this._mediaSpeedChanged);
        player.addEventListener('bitrateChanged', this._bitrateChanged);
        player.addEventListener('playbackFailed', this._mediaPlaybackFailed.bind(this));
        player.addEventListener('playbackProgressUpdate', this._mediaProgressUpdate.bind(this));
        player.addEventListener('playbackStarted', this._mediaPlaybackStarted.bind(this));
        player.addEventListener('durationChanged', this._mediaDurationChanged);
        this.playerState = this.playerStatesEnum.idle;
      } catch (error) {
        console.error('AAMPMediaPlayer is not defined');
      }
    }

    /**
     * Loads the player with video URL.
     * @param videoInfo the url and the info regarding the video like title.
     */
    load(videoInfo) {
      this.createPlayer();
      this.videoInfo = videoInfo;
      this.configObj = this.defaultInitConfig;
      this.configObj.drmConfig = this.videoInfo.drmConfig;
      player.initConfig(this.configObj);
      player.load(videoInfo.url);
      this.tag('PlayerControls').title = videoInfo.title;
      this.tag('PlayerControls').duration = player.getDurationSec();
      console.log('Duration of video', player.getDurationSec());
      this.tag('PlayerControls').currentTime = 0;
      this.play();
    }

    /**
     * Starts playback when enough data is buffered at play head.
     */
    play() {
      player.play();
      this.playbackRateIndex = this.playbackSpeeds.indexOf(1);
    }

    /**
     * Pauses playback.
     */
    pause() {
      player.pause();
    }

    /**
     * Stop playback and free resources.
     */
    stop() {
      player.stop();
      this.hidePlayerControls();
    }
    $changeChannel(url, showName, channelName) {
      this.stop();
      this.destroy();
      try {
        this.load({
          title: showName,
          url: url,
          drmConfig: null
        });
        this.tag('ShowName').text.text = showName;
        this.tag('ChannelName').text.text = channelName;
        this.setVideoRect(0, 0, 1920, 1080);
      } catch (error) {
        console.error('Playback Failed ' + error);
      }
    }
    seekFwd() {
      player.seek(position + 10);
    }
    seekRwd() {
      player.seek(position - 10);
    }
    voiceSeek(time) {
      player.seek(position + time);
    }
    nextTrack() {
      if (this.data[this.currentIndex + 1]) {
        this.currentIndex += 1;
        this.stop();
        this.destroy();
        try {
          this.load({
            title: 'Parkour event',
            url: this.data[this.currentIndex].data.uri,
            drmConfig: null
          });
          this.updateInfo();
          this.setVideoRect(0, 0, 1920, 1080);
        } catch (error) {
          console.error('Playback Failed ' + error);
        }
      }
    }
    prevTrack() {
      if (this.data[this.currentIndex - 1]) {
        this.currentIndex -= 1;
        this.stop();
        this.destroy();
        try {
          this.load({
            title: 'Parkour event',
            url: this.data[this.currentIndex].data.uri,
            drmConfig: null
          });
          this.updateInfo();
          this.setVideoRect(0, 0, 1920, 1080);
        } catch (error) {
          console.error('Playback Failed ' + error);
        }
      }
    }

    /**
     * Function to perform fast forward of the video content.
     */
    fastfwd() {
      if (this.playbackRateIndex < this.playbackSpeeds.length - 1) {
        this.playbackRateIndex++;
      }
      this.rate = this.playbackSpeeds[this.playbackRateIndex];
      player.setPlaybackRate(this.rate);
    }

    /**
     * Function to perform fast rewind of the video content.
     */
    fastrwd() {
      if (this.playbackRateIndex > 0) {
        this.playbackRateIndex--;
      }
      this.rate = this.playbackSpeeds[this.playbackRateIndex];
      player.setPlaybackRate(this.rate);
    }

    /**
     * Function that returns player instance.
     * @returns player instance.
     */
    getPlayer() {
      return player;
    }

    /**
     * Function to release the video player instance when not in use.
     */
    destroy() {
      if (player.getCurrentState() !== this.playerStatesEnum.idle) {
        player.stop();
      }
      player.removeEventListener('playbackStateChanged', this._playbackStateChanged);
      player.removeEventListener('playbackCompleted', this._mediaEndReached);
      player.removeEventListener('playbackSpeedChanged', this._mediaSpeedChanged);
      player.removeEventListener('bitrateChanged', this._bitrateChanged);
      player.removeEventListener('playbackFailed', this._mediaPlaybackFailed.bind(this));
      player.removeEventListener('playbackProgressUpdate', this._mediaProgressUpdate.bind(this));
      player.removeEventListener('playbackStarted', this._mediaPlaybackStarted.bind(this));
      player.removeEventListener('durationChanged', this._mediaDurationChanged);
      player.release();
      player = null;
      this.hidePlayerControls();
    }

    /**
     * Function to hide the player controls.
     */
    hidePlayerControls() {
      this.tag('PlayerControlsWrapper').setSmooth('y', 1080, {
        duration: 0.7
      });
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 0, {
        duration: 0.7
      });
      this._setState('HideControls');
      this.hideInfo();
    }

    /**
     * Function to show the player controls.
     */
    showPlayerControls() {
      // this.tag('PlayerControls').reset()
      this.tag('PlayerControlsWrapper').setSmooth('alpha', 1);
      this.tag('PlayerControlsWrapper').setSmooth('y', 750, {
        duration: 0.7
      });
      this._setState('ShowControls');
      this.timeout = setTimeout(this.hidePlayerControls.bind(this), 5000);
    }
    showInfo() {
      if (this.isUSB || this.isChannel) {
        this.tag("InfoOverlay").setSmooth('alpha', 1, {
          duration: 0.3,
          delay: 0.7
        });
      }
    }
    hideInfo() {
      if (this.isUSB || this.isChannel) {
        this.tag("InfoOverlay").setSmooth('alpha', 0, {
          duration: 0.3
        });
      }
    }
    updateInfo() {
      if (this.isUSB) {
        this.tag('ShowName').text.text = this.data[this.currentIndex].data.displayName;
      } else if (this.isChannel) {
        this.tag('ShowName').text.text = this.showName;
        this.tag('ChannelName').text.text = this.channelName;
      }
    }
    /**
     * Function to display player controls on down key press.
     */

    /**
     *Function to hide player control on up key press.
     */

    _handleBack() {
      Router.back();
    }
    _inactive() {
      this.tag('Image').alpha = 0;
      this.tag('InfoOverlay').alpha = 0;
      this.isUSB = false;
      this.isChannel = false;
      this.stop();
      this.destroy();
    }
    _focus() {
      this._setState('HideControls');
      this.updateInfo();
      if (this.isChannel) {
        this.tag('ChannelOverlay').$focusChannel(this.channelIndex);
        this.tag('InfoOverlay').y = 790;
        this.tag('ChannelName').visible = true;
        this.tag('PlayerControls').hideNextPrevious();
      } else {
        this.tag('InfoOverlay').y = 820;
        this.tag('ChannelName').visible = false;
        this.tag('PlayerControls').showNextPrevious();
      }
      if (this.data == undefined || this.data.length <= 1) {
        this.tag('PlayerControls').hideNextPrevious();
      }
    }
    /**
     * Function to define the different states of the video player.
     */
    static _states() {
      return [class ShowControls extends this {
        _getFocused() {
          return this.tag('PlayerControls');
        }
        _handleDown() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleUp() {
          if (this.isChannel) {
            this.hidePlayerControls();
            this._setState('ChannelOverlay');
          }
        }
      }, class HideControls extends this {
        // _handleBack(){
        //   console.log('go back from hidecontrol')
        // }
        _handleUp() {
          // this.tag('PlayerControlsWrapper').setSmooth('alpha', 1, { duration: 1 })
          // this.tag('PlayerControlsWrapper').setSmooth('y', 820, { duration: 1 })
          this.showPlayerControls();
          this._setState('ShowControls');
          this.showInfo();
          clearTimeout(this.timeout);
        }
        _handleLeft() {
          if (this.isChannel) {
            this._setState('ChannelOverlay');
          }
        }
      }, class ChannelOverlay extends this {
        $enter() {
          this.tag('ChannelWrapper').setSmooth('x', 0, {
            duration: 1
          });
        }
        $exit() {
          this.tag('ChannelWrapper').setSmooth('x', -360, {
            duration: 1
          });
        }
        _handleLeft() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleRight() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _handleBack() {
          this.hidePlayerControls();
          this._setState('HideControls');
        }
        _getFocused() {
          return this.tag('ChannelOverlay');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Other Settings Screen.
   */

  class OtherSettingsScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        OtherSettingsScreenContents: {
          x: 200,
          y: 275,
          SleepTimer: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Sleep Timer: Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          RemoteControl: {
            alpha: 0.3,
            // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          ScreenSaver: {
            //  alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Screen-Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          EnergySaver: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Energy Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Language: {
            //alpha: 0.3, // disabled
            y: 450 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Language'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Privacy: {
            //alpha: 0.3, // disabled
            y: 540 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AdvancedSettings: {
            y: 630 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Advanced Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('SleepTimer');
    }
    $updateStandbyMode(standbyMode) {
      this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + Language$1.translate(standbyMode);
    }
    $sleepTimerText(text) {
      this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + text;
    }
    $screenSaverTime(text) {
      this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + text;
    }
    _focus() {
      this._setState(this.state);
      if (Storage$1.get('TimeoutInterval')) {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + Storage$1.get('TimeoutInterval');
      } else {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + 'Off';
      }
      this._appApi.getPreferredStandbyMode().then(result => {
        let currentStandbyMode = "";
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          currentStandbyMode = "Light Sleep";
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          currentStandbyMode = "Deep Sleep";
        }
        this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + Language$1.translate(currentStandbyMode);
      });
      if (Storage$1.get('ScreenSaverTimeoutInterval')) {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + Storage$1.get('ScreenSaverTimeoutInterval') + ' min';
      } else {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + 'Off';
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    static _states() {
      return [class SleepTimer extends this {
        $enter() {
          this.tag('SleepTimer')._focus();
        }
        $exit() {
          this.tag('SleepTimer')._unfocus();
        }
        _handleUp() {
          // this._setState('AdvancedSettings')
        }
        _handleDown() {
          // this._setState('RemoteControl')
          this._setState('ScreenSaver');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/timer');
          }
        }
      }, class RemoteControl extends this {
        $enter() {
          this.tag('RemoteControl')._focus();
        }
        $exit() {
          this.tag('RemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('ScreenSaver');
        }
        _handleEnter() {}
      }, class ScreenSaver extends this {
        $enter() {
          this.tag('ScreenSaver')._focus();
        }
        $exit() {
          this.tag('ScreenSaver')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('EnergySaver');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/ScreenSaver');
          }
        }
      }, class EnergySaver extends this {
        $enter() {
          this.tag('EnergySaver')._focus();
        }
        $exit() {
          this.tag('EnergySaver')._unfocus();
        }
        _handleUp() {
          this._setState('ScreenSaver');
        }
        _handleDown() {
          // this._setState('Theme')
          this._setState('Language');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/energy');
          }
        }
      }, class Language extends this {
        $enter() {
          this.tag('Language')._focus();
        }
        $exit() {
          this.tag('Language')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/language');
          }
        }
      }, class Privacy extends this {
        $enter() {
          this.tag('Privacy')._focus();
        }
        $exit() {
          this.tag('Privacy')._unfocus();
        }
        _handleUp() {
          this._setState('Language');
        }
        _handleDown() {
          this._setState('AdvancedSettings');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/privacy');
          }
        }
      }, class AdvancedSettings extends this {
        $enter() {
          this.tag('AdvancedSettings')._focus();
        }
        $exit() {
          this.tag('AdvancedSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Privacy');
        }
        _handleDown() {
          // this._setState('SleepTimer')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SleepTimerScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Sleep Timer'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: t.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.lastElement = false;
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '1 Hour',
        tick: false
      }, {
        value: '1.5 Hours',
        tick: false
      }, {
        value: '2 Hours',
        tick: false
      }, {
        value: '3 Hours',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage$1.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this.fireAncestors('$registerInactivityMonitoringEvents').then(res => {
        this.fireAncestors('$resetSleepTimer', timeoutInterval);
      }).catch(err => {
        console.error("error while registering the inactivity monitoring event");
      });
      this._setState('Options');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            //if (element.tick) {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
            //this.options[idx].tick = false
            //}
          });

          this.tag('List').element.tag('Tick').visible = true;
          //this.options[this.tag('List').index].tick = true
          this.fireAncestors('$sleepTimerText', this.options[this.tag('List').index].value);
          this.fireAncestors('$resetSleepTimer', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsItem extends t.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {
      if (this.isTicked) {
        this.fireAncestors("$resetPrevTickObject", this);
      }
      this.appApi = new AppApi();
    }
    _handleEnter() {
      let self = this;
      let standbyMode = "";
      if (this._item === Language$1.translate("Deep Sleep")) {
        standbyMode = "DEEP_SLEEP";
      } else if (this._item === Language$1.translate("Light Sleep")) {
        standbyMode = "LIGHT_SLEEP";
      }
      this.appApi.setPreferredStandbyMode(standbyMode).then(result => {
        console.log("setPreferredStandbyMode " + JSON.stringify(result));
        self.fireAncestors("$resetPrevTickObject", self);
        this.fireAncestors("$updateStandbyMode", this._item);
        self.tag("Item.Tick").visible = true;
      });
    }
    set item(item) {
      this._item = item;
      let self = this;
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: self.isTicked ? true : false //implement the logic to show the tick
        },

        Left: {
          x: 50,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xffFFFFFF,
            fontFace: CONFIG.language.font
          } // update the text
        }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Energy Saver'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        EnerygySavingContents: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          // this.tag("List").element.patch({ "Item.Tick.visible": true });
          this.tag("List").element.tag("Tick").visible = true;
          // enable the tick mark in VideoAudioItem.js
          //to update the resolution value on Video Screen
        }
      }];
    }

    _firstEnable() {
      this._appApi = new AppApi();
      this.options = [Language$1.translate("Deep Sleep"), Language$1.translate("Light Sleep")];
      this.tag('EnerygySavingContents').h = this.options.length * 90;
      this.tag('EnerygySavingContents.List').h = this.options.length * 90;
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      var standbyMode = "";
      this._appApi.getPreferredStandbyMode().then(result => {
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          standbyMode = Language$1.translate("Light Sleep");
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          standbyMode = Language$1.translate("Deep Sleep");
        }
        this.tag('List').items = this.options.map((item, index) => {
          return {
            ref: 'Option' + index,
            w: 1920 - 300,
            h: 90,
            type: EnergySavingsItem,
            isTicked: standbyMode === item ? true : false,
            item: item,
            energyItem: true
          };
        });
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
        this._setState("Options");
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class LanguageItem extends SettingsItem {
    static _template() {
      return {
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {}

    /**
     * Function to set contents of an item in the Language screen.
     */
    set item(item) {
      // console.log(item)
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          w: 32.5,
          h: 32.5,
          src: Utils.asset('images/settings/Tick.png'),
          color: 0xffffffff,
          visible: localStorage.getItem('Language') === item ? true : item === 'English' && localStorage.getItem('Language') === null ? true : false
        },
        Left: {
          x: 60,
          y: 45,
          mountY: 0.5,
          text: {
            text: Language$1.translate(item),
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$b = new AppApi();
  const thunder$g = thunderJS$1({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });
  const loader$2 = 'Loader';
  class LanguageScreen$2 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Language'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        LanguageScreenContents: {
          x: 200,
          y: 275,
          Languages: {
            flexItem: {
              margin: 0
            },
            List: {
              type: t.components.ListComponent,
              w: 1920 - 300,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      appApi$b.deactivateResidentApp(loader$2);
      appApi$b.setVisibility(Storage$1.get("selfClientName"), true);
      thunder$g.call('org.rdk.RDKShell', 'moveToFront', {
        client: Storage$1.get("selfClientName")
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      });
      thunder$g.call('org.rdk.RDKShell', 'setFocus', {
        client: Storage$1.get("selfClientName")
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('Error', err);
      });
    }
    _focus() {
      this._setState('Languages');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleDown() {
          this._navigate('down');
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleEnter() {
          if (localStorage.getItem('Language') !== availableLanguages[this._Languages.tag('List').index]) {
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let updatedLanguage = availableLanguageCodes[localStorage.getItem('Language')];
            if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError") {
              AlexaApi.get().getAlexaDeviceSettings();
              thunder$g.on('org.rdk.VoiceControl', 'onServerMessage', notification => {
                if (notification.xr_speech_avs.deviceSettings.currentLocale.toString() != updatedLanguage) {
                  for (let i = 0; i < notification.xr_speech_avs.deviceSettings.supportedLocales.length; i++) {
                    if (updatedLanguage === notification.xr_speech_avs.deviceSettings.supportedLocales[i].toString()) {
                      AlexaApi.get().updateDeviceLanguageInAlexa(updatedLanguage);
                    }
                  }
                }
              });
            }
            appApi$b.setUILanguage(updatedLanguage);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$b.launchResident(notification_url, loader$2).catch(err => {});
            appApi$b.setVisibility(Storage$1.get("selfClientName"), false);
            location.reload();
          }
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Privacy Screen.
   */

  const xcastApi$2 = new XcastApi();
  let cookieToggle = false;
  class PrivacyScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Privacy'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        PrivacyScreenContents: {
          x: 200,
          y: 275,
          LocalDeviceDiscovery: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Local Device Discovery'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          UsbMediaDevices: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('USB Media Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          AudioInput: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Input'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          ClearCookies: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Clear Cookies and App Data'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          PrivacyPolicy: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy Policy and License'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _firstEnable() {
      this._setState('LocalDeviceDiscovery');
      this.checkLocalDeviceStatus();
      this.USBApi = new UsbApi();
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState(this.state);
      this.checkLocalDeviceStatus();
      this.checkUSBDeviceStatus();
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    checkUSBDeviceStatus() {
      if (!Storage$1.get('UsbMedia')) {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        Storage$1.set('UsbMedia', 'ON');
      } else if (Storage$1.get('UsbMedia') === 'ON') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
    }
    checkLocalDeviceStatus() {
      xcastApi$2.getEnabled().then(res => {
        if (res.enabled) {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        } else {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        }
      }).catch(err => {
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    toggleLocalDeviceDiscovery() {
      xcastApi$2.getEnabled().then(res => {
        if (!res.enabled) {
          xcastApi$2.activate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            }
          });
        } else {
          xcastApi$2.deactivate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            }
          });
        }
      }).catch(err => {
        console.log('Service not active');
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    static _states() {
      return [class LocalDeviceDiscovery extends this {
        $enter() {
          this.tag('LocalDeviceDiscovery')._focus();
        }
        $exit() {
          this.tag('LocalDeviceDiscovery')._unfocus();
        }
        _handleUp() {
          // this._setState('PrivacyPolicy')
        }
        _handleDown() {
          this._setState('UsbMediaDevices');
        }
        _handleEnter() {
          this.toggleLocalDeviceDiscovery();
        }
      }, class UsbMediaDevices extends this {
        $enter() {
          this.tag('UsbMediaDevices')._focus();
        }
        $exit() {
          this.tag('UsbMediaDevices')._unfocus();
        }
        _handleUp() {
          this._setState('LocalDeviceDiscovery');
        }
        _handleDown() {
          this._setState('AudioInput');
        }
        _handleEnter() {
          let _UsbMedia = Storage$1.get('UsbMedia');
          if (_UsbMedia === 'ON') {
            this.fireAncestors('$deRegisterUsbMount');
            this.USBApi.deactivate().then(res => {
              Storage$1.set('UsbMedia', 'OFF');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this.widgets.menu.refreshMainView();
            }).catch(err => {
              console.error("error while disabling the usb plugin = ".concat(err));
              this.fireAncestors('$registerUsbMount');
            });
          } else if (_UsbMedia === 'OFF') {
            this.USBApi.activate().then(res => {
              Storage$1.set('UsbMedia', 'ON');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
              this.fireAncestors('$registerUsbMount');
              this.widgets.menu.refreshMainView();
            });
          }
        }
      }, class AudioInput extends this {
        $enter() {
          this.tag('AudioInput')._focus();
        }
        $exit() {
          this.tag('AudioInput')._unfocus();
        }
        _handleUp() {
          this._setState('UsbMediaDevices');
        }
        _handleDown() {
          this._setState('ClearCookies');
        }
        _handleEnter() {
          //
        }
      }, class ClearCookies extends this {
        $enter() {
          this.tag('ClearCookies')._focus();
        }
        $exit() {
          this.tag('ClearCookies')._unfocus();
        }
        _handleUp() {
          this._setState('AudioInput');
        }
        _handleDown() {
          this._setState('PrivacyPolicy');
        }
        _handleEnter() {
          cookieToggle = !cookieToggle;

          //TOGGLE BUTTON
          if (cookieToggle) {
            this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data') + " - " + Language$1.translate('In Progress');
          } else {
            this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data');
          }
          this.AppApi.clearCache().then(() => {
            //location.reload(true)
          });
          setTimeout(() => {
            AlexaApi.get().resetAVSCredentials().then(result => {
              console.log("Triggering AVS credential reset.", result);
              if (result.success) {
                AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
                this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data') + " - " + Language$1.translate('Finished');
                setTimeout(() => {
                  this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data');
                  this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
                  cookieToggle = !cookieToggle;
                }, 2000);
              } else {
                //UNSUCCESSFULL API CALL
                this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data') + " - " + Language$1.translate("Error!");
                setTimeout(() => {
                  this.tag('ClearCookies.Title').text = Language$1.translate('Clear Cookies and App Data');
                  this.tag('ClearCookies.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
                  cookieToggle = !cookieToggle;
                }, 2000);
              }
            });
          }, 2000);
        }
      }, class PrivacyPolicy extends this {
        $enter() {
          this.tag('PrivacyPolicy')._focus();
        }
        $exit() {
          this.tag('PrivacyPolicy')._unfocus();
        }
        _handleUp() {
          this._setState('ClearCookies');
        }
        _handleDown() {
          // this._setState('LocalDeviceDiscovery')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/other/privacyPolicy');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _privacyPolicy$1 = "Privacy\n Welcome to RDKCentral.com, a website owned and operated by RDK Management, LLC (\u201CRDK Management,\u201D \u201Cwe,\u201D or \u201Cus\u201D). This privacy policy discloses the privacy practices for this website only, including an explanation of:\n\n the categories of personally identifiable information about you that may be collected and how that information is used;\n how we collect and use non-personally identifiable information about your use of the website;\n the categories of persons or entities with whom the information may be shared;\n the choices that are available to you regarding collection, use, and distribution of the information;\n how you can opt out of RDK-related promotional e-mail;\n the kind of security procedures that are in place to protect the loss, misuse or alteration of information;\n how you can review and request changes to the information; and\n how we notify users of this website of changes to this privacy policy.\n Questions regarding this policy should be directed to \u201CRDK Management \u2013 Privacy Feedback\u201D and can be submitted via e-mail to info@rdkcentral.com.\n\n\n What categories of information do we collect?\n The information collected by RDK Management falls into two categories: (1) information voluntarily supplied by users of the website and (2) tracking information recorded as users navigate through the website. Some of this information is personally identifiable information (i.e., information that identifies a particular person, such as e-mail address), but much of it is not.\n\n To make use of some features on our website, like the RDK Wiki, users need to register and provide certain information as part of the registration process. We may ask, for example, for your name, e-mail address, street address, and zip code. We might also request information about your employer and the type of work that you do, in order to determine whether your employer is a member of the RDK program, to help us ensure that you are given access to the correct portions of the website, and to tailor our website content and e-mail (if you\u2019ve registered to receive e-mail) to your interests to make it more useful to you. If you are a registered user, our systems will remember some of this information the next time you log in and use our website, but you can always review and change your information by logging in and editing your profile here.\n\n The more you tell us about yourself, the more value we can offer you. Supplying this information is entirely voluntary. But if you choose not to supply the information, we may be unable to provide you with access to all of the features of this website. There are certain features of this website, including the Wiki and requesting to receive RDK-related promotional e-mail, that you will not be able to use unless you provide certain personally identifiable information about yourself. When you submit any personally identifiable information over this website, RDK Management (i) will use the information for the purposes described at the time you submit it and (ii) may use the information to contact you, subject to the contact preferences in your profile. If you want to remain completely anonymous, you\u2019re still free to take advantage of the publicly available content on our website without registration.\n\n Does RDK Management analyze my interaction with this website?\n Some of the third-party service providers that RDK Management uses to deliver services, like analytics providers, may collect information on this website as disclosed in this privacy policy. This information may include personally identifiable information or may be used to contact you online.\n\n We and our service providers may use cookies to provide these services. The World Wide Web Consortium (W3C) has started a process to develop a \u201CDo Not Track\u201D Standard. Since the definitions and rules for such a standard have not yet been defined, RDK Management does not yet respond to \u201CDo Not Track\u201D signals sent from browsers.\n\n You may opt out of receiving cookies from the companies that provide services on this website by going to www.networkadvertising.org/consumer/opt_out.asp or http://www.aboutads.info/choices.\n\n What categories of persons or entities do we share personally identifiable information with?\n We consider the personally identifiable information contained in our business records to be confidential. We may sometimes disclose personally identifiable information about you to our affiliates or to others who work for us. We may also disclose personally identifiable information about you to service providers and vendors, and to others who provide products and services to us. For example, when you use certain functions on this website you may notice that the website actually collecting or processing the information may be other than an RDK Management website. We may be required by law or legal process to disclose certain personally identifiable information about you to lawyers and parties in connection with litigation and to law enforcement personnel. For example, we may be required by law to disclose personally identifiable information about you without your consent and without notice in order to comply with a valid legal process such as a subpoena, court order, or search warrant.\n\n What do we do to personalize your use of this website?\n We, or our service providers, may customize this website based on non-personal information including: (i) the IP address associated with your computer for purposes of determining your approximate geographic location; (ii) the type of web page that is being displayed; or (iii) the content on the page that is shown. Because this activity automatically applies to all users and it is purely contextual, this type of content delivery cannot be customized or controlled by individual users. We may also personalize this website based on the information that you provided us during registration. You may modify this information as further described in this Privacy Policy.\n\n To help make our website more responsive to the needs of our users, we use a standard feature of browser software called a \u201Ccookie.\u201D We use cookies to help us tailor our website to your needs, to deliver a better, more personalized service, and to remember certain choices you\u2019ve made so you don\u2019t have to re-enter them.\n\n RDK Management uses cookies, among other things, to remember your username and password, if you choose to store them, as well as to remember some of your personalization preferences and website features. RDK Management does not store your name or other personal information in cookies. You may read about enabling, disabling, and deleting cookies here. Of course, if you set your browser not to accept cookies or you delete them, you may not be able to take advantage of the personalized features enjoyed by other users of our website.\n\n The cookies we use don\u2019t directly identify users of our website as particular persons. Rather, they contain information sufficient to simplify and improve a user\u2019s experience on our website. For example, we may use session-based cookies to track the pages on our website visited by our users. We can build a better website if we know which pages our users are visiting and how often. Or, we may use persistent cookies to simplify access to a user\u2019s account information over our website, for example.\n\n In connection with the standard operation of RDK Management\u2019s systems, certain non-personally identifiable information about users of this website is recorded. This information is used primarily to tailor and enhance users\u2019 experience using the website. We may use this information in an aggregate, non-personally identifiable form to, among other things, measure the use of our website and determine which pages are the most popular with website users.\n\n We may also use one or more audience segmenting technology providers to help present content on this website. These providers uses cookies, web beacons, or similar technologies on your computer or mobile or other device to serve you advertisements or content tailored to interests you have shown by browsing on this and other websites you have visited. It also helps determine whether you have seen a particular piece of content before and in order to avoid sending you duplicates. In doing so, these providers collect non-personally identifiable information such as your browser type, your operating system, web pages visited, time of visits, content viewed, ads viewed, and other click stream data. When you visit this website, these providers may use cookies or web beacons to note which product and service descriptions your browser visited. The use of cookies, web beacons, or similar technologies by these providers is subject to their own privacy policies, not RDK Management\u2019s privacy policy for this website. If you do not want the benefits of the cookies used by these providers, you may opt-out of them by visiting http://www.networkadvertising.org/consumer/opt_out.asp or by visiting their opt-out pages.\n\n Your Access to and Control over your information?\n You may opt out of any future contacts from us at any time. You can do the following at any time via email to support@rdkcentral.com or info@rdkcentral.com or unsubscribe to emails.\n\n Request to see all the information stored in the system\n Accuracy of your data can be checked or corrected.\n Personal data will be archived, in case user does not access our system for 90 days. However, user can request for deletion by writing to us at support@rdkcentral.com\n Express any concern you have about our use of your data\n Opt out from receiving emails by clicking unsubscribe.\n How do users opt out of RDK-related promotional e-mail?\n You can opt out of receiving RDK-related promotional e-mail from RDK Management using the opt-out link found in the footer of any of these e-mails. You can also e-mail the request to the attention of \u201CRDK Management \u2013 E-mail Opt Out\u201D via e-mail to info@rdkcentral.com.\n\n Other Websites\n\n To make our website more valuable to our users, we may offer some features in conjunction with other providers. Our website may also include links to other websites whose privacy policies and practices we don\u2019t control. Once you leave our website by linking to another one (you can tell where you are by checking the address \u2013 known as a URL \u2013 in the location bar on your browser), use of any information you provide is governed by the privacy policy of the operator of the website you\u2019re visiting. That policy may differ from ours. If you can\u2019t find the privacy policy of any of these websites via a link from the site\u2019s homepage, you should contact the website directly for more information.\n\n Security\n\n All information gathered on our website is stored within a database accessible only to RDK Management, its affiliates, and their specifically-authorized contractors and vendors. However, as effective as any security measure implemented by RDK Management may be, no security system is impenetrable. We cannot guarantee the complete security of our database, nor can we guarantee that information you supply won\u2019t be intercepted while being transmitted to us over the Internet. If you don\u2019t want us to know any particular information about you, don\u2019t include it in anything that you submit or post to this website or send to us in e-mail. We will retain and use your information to the extent necessary to comply with our legal obligations, resolve disputes, and enforce our policies.\n\n Changes to this Privacy Policy\n\n We may change this privacy policy from time to time. If we change this privacy policy at some point in the future, we\u2019ll post the changes on our website and by continuing to use the website after we post any changes, you accept and agree to this privacy statement, as modified.\n\n A Special Note About Children\n\n This website is not directed to children under the age of 13, and RDK Management does not knowingly collect personally identifiable information from anyone under the age of 18 on this website.\n\n Contacting us:\n\n If you have any questions about RDK Management, LLC privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\n\n Data Protection Officer:  Herman-Jan Smith\n\n Email us at: hj.smith@rdkcentral.com\n\n Contacting the appropriate authority:\n\n Should you wish to report a complaint or if you feel that Our Company has not addressed your concern in a satisfactory manner, you may contact the Information Commissioner\u2019s Office.\n\n Email: compliance_team@rdkcentral.com\n\n Address:  1701 JFK Boulevard, Philadelphia, PA 19103 U.S.A";
  class PrivacyPolicyScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Privacy  Policy'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        clipping: true,
        PrivacyPolicy: {
          x: 200,
          y: 270,
          Title: {
            x: 10,
            y: 45,
            mountY: 0.5,
            text: {
              text: Language$1.translate('Privacy Policy'),
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontStyle: "bold",
              fontSize: 40
            }
          },
          Content: {
            x: 10,
            y: 100,
            text: {
              text: _privacyPolicy$1,
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontSize: 20,
              wordWrapWidth: 1500,
              wordWrap: true
            }
          }
        }
      };
    }
    _handleDown() {
      if (this.tag("PrivacyPolicy").y > -2400) {
        this.tag("PrivacyPolicy").y -= 35;
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other/privacy');
      }
    }
    _handleUp() {
      if (this.tag("PrivacyPolicy").y <= 235) {
        this.tag("PrivacyPolicy").y += 35;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$d = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const thunder$f = thunderJS$1(config$d);
  class CECApi {
    activate() {
      return new Promise((resolve, reject) => {
        thunder$f.Controller.activate({
          callsign: 'org.rdk.HdmiCec_2'
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log('CEC Error Activation', err);
        });
      });
    }
    deactivate() {
      return new Promise((resolve, reject) => {
        thunder$f.Controller.deactivate({
          callsign: 'org.rdk.HdmiCec_2'
        }).then(() => {
          resolve(true);
        }).catch(err => {
          console.log('CEC Error Deactivation', err);
        });
      });
    }
    getEnabled() {
      return new Promise((resolve, reject) => {
        thunder$f.call('org.rdk.HdmiCec_2', 'getEnabled').then(result => {
          resolve(result);
        }).catch(err => {
          resolve({
            enabled: false
          });
        });
      });
    }
    setEnabled() {
      return new Promise((resolve, reject) => {
        thunder$f.call('org.rdk.HdmiCec_2', 'setEnabled', {
          enabled: true
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Set Enabled', err);
          resolve({
            success: false
          });
        });
      });
    }
    getOSDName() {
      return new Promise((resolve, reject) => {
        thunder$f.call('org.rdk.HdmiCec_2', 'getOSDName').then(result => {
          resolve(result);
        }).catch(err => {
          resolve({
            enabled: false
          });
        });
      });
    }
    setOSDName(osdname) {
      return new Promise((resolve, reject) => {
        thunder$f.call('org.rdk.HdmiCec_2', 'setOSDName', {
          name: osdname
        }).then(result => {
          resolve(result);
        }).catch(err => {
          console.error('setOSDName', err);
          resolve({
            success: false
          });
        });
      });
    }
    performOTP() {
      return new Promise((resolve, reject) => {
        thunder$f.call('org.rdk.HdmiCec_2', 'performOTPAction').then(result => {
          resolve(result);
        }).catch(err => {
          console.error('CEC Otp Error', err);
          resolve({
            success: false
          });
        });
      });
    }
    getActiveSourceStatus() {
      return new Promise((resolve, reject) => {
        thunder$f.call('org.rdk.HdmiCec_2', 'getActiveSourceStatus').then(result => {
          resolve(result.status);
        }).catch(err => {
          console.error("CECApi HdmiCec_2 getActiveSourceStatus failed." + err);
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for AdvancedSettings screen.
   */

  class AdvanceSettingsScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        AdvanceScreenContents: {
          x: 200,
          y: 275,
          TTSOptions: {
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('TTS Options'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CECControl: {
            y: 90,
            // alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('CEC Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Bug: {
            y: 180,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bug Report'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Contact: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Contact Support'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Device: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.cecApi = new CECApi();
      this.cecApi.activate().then(() => {
        this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.performOTPAction();
      });
      this._setState('CECControl');
    }
    _focus() {
      this._setState(this.state);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    performOTPAction() {
      this.cecApi.setEnabled().then(res => {
        if (res.success) {
          this.cecApi.performOTP().then(otpRes => {
            if (otpRes.success) {
              console.log('Otp Action success full');
            }
          });
        }
      });
    }
    toggleCEC() {
      this.cecApi.getEnabled().then(res => {
        console.log(res);
        if (res.enabled) {
          this.cecApi.deactivate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          });
        } else {
          this.cecApi.activate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          });
        }
      });
    }
    static _states() {
      return [class UIVoice extends this {
        $enter() {
          this.tag('UIVoice')._focus();
        }
        $exit() {
          this.tag('UIVoice')._unfocus();
        }
        _handleUp() {
          //this._setState('Reset');
        }
        _handleDown() {
          //this._setState('TTSOptions')
        }
        _handleEnter() {}
      }, class TTSOptions extends this {
        $enter() {
          this.tag('TTSOptions')._focus();
        }
        $exit() {
          this.tag('TTSOptions')._unfocus();
        }
        _handleUp() {
          //this._setState('UIVoice');
        }
        _handleDown() {
          //this._setState('CECControl')
        }
        _handleEnter() {}
      }, class CECControl extends this {
        $enter() {
          this.tag('CECControl')._focus();
        }
        $exit() {
          this.tag('CECControl')._unfocus();
        }
        _handleUp() {
          //this._setState('TTSOptions');
        }
        _handleDown() {
          this._setState('Device');
        }
        _handleEnter() {
          this.toggleCEC();
        }
      }, class Bug extends this {
        $enter() {
          this.tag('Bug')._focus();
        }
        $exit() {
          this.tag('Bug')._unfocus();
        }
        _handleUp() {
          //this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('Contact')
        }
        _handleEnter() {}
      }, class Contact extends this {
        $enter() {
          this.tag('Contact')._focus();
        }
        $exit() {
          this.tag('Contact')._unfocus();
        }
        _handleUp() {
          //this._setState('Bug');
        }
        _handleDown() {
          //this._setState('Device')
        }
        _handleEnter() {}
      }, class Device extends this {
        $enter() {
          this.tag('Device')._focus();
        }
        $exit() {
          this.tag('Device')._unfocus();
        }
        _handleUp() {
          this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('UI Voice')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video and Audio screen.
   */

  class DeviceScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        DeviceScreenContents: {
          x: 200,
          y: 275,
          Info: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TimeZone: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Time Zone'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Firmware: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Check for Firmware Update'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Reboot: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Reboot'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Reset: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Factory Reset'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._network = new Network();
      this._setState('Info');
    }
    _focus() {
      this._setState(this.state);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced');
      }
    }
    static _states() {
      return [class Info extends this {
        $enter() {
          this.tag('Info')._focus();
        }
        $exit() {
          this.tag('Info')._unfocus();
        }
        _handleUp() {
          // this._setState('Reboot');
        }
        _handleDown() {
          this._setState('TimeZone');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/info');
          }
        }
      }, class TimeZone extends this {
        $enter() {
          this.tag('TimeZone')._focus();
        }
        $exit() {
          this.tag('TimeZone')._unfocus();
        }
        _handleUp() {
          this._setState('Info');
        }
        _handleDown() {
          this._setState('Firmware');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/timezone');
          }
        }
      }, class Firmware extends this {
        $enter() {
          this.tag('Firmware')._focus();
        }
        $exit() {
          this.tag('Firmware')._unfocus();
        }
        _handleUp() {
          this._setState('TimeZone');
        }
        _handleDown() {
          this._setState('Reboot');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/firmware');
          }
        }
      }, class Reboot extends this {
        $enter() {
          this.tag('Reboot')._focus();
        }
        $exit() {
          this.tag('Reboot')._unfocus();
        }
        _handleUp() {
          this._setState('Firmware');
        }
        _handleDown() {
          this._setState('Reset');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/reboot');
          }
        }
      }, class Reset extends this {
        $enter() {
          this.tag('Reset')._focus();
        }
        $exit() {
          this.tag('Reset')._unfocus();
        }
        _handleUp() {
          this._setState('Reboot');
        }
        _handleDown() {
          //this._setState('Info')
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/advanced/device/factoryReset');
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video and Audio screen.
   */

  class DeviceInformationScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device  Info'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: 0xCC000000,
        DeviceInfoContents: {
          x: 200,
          y: 275,
          Line1: {
            y: 0,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          ChipSet: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Chipset"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 45,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line2: {
            y: 90,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SerialNumber: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Serial Number"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 135,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line3: {
            y: 180,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          Location: {
            Title: {
              x: 10,
              y: 225,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Location"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 225,
              mountY: 0.5,
              text: {
                text: "CountryCode:",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line4: {
            y: 270,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          SupportedDRM: {
            Title: {
              x: 10,
              y: 360,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Supported DRM & Key-System"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1600,
                wordWrap: true,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 360,
              mountY: 0.5,
              text: {
                text: "N/A",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                wordWrapWidth: 1200,
                wordWrap: true,
                fontSize: 25
              }
            }
          },
          Line5: {
            y: 450,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          FirmwareVersions: {
            Title: {
              x: 10,
              y: 540,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Firmware version"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 540,
              mountY: 0.5,
              text: {
                text: "UI Version: ".concat(Settings$2.get('platform', 'version'), ", Build Version: , Firebolt API Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line6: {
            y: 630,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          },
          AppVersions: {
            Title: {
              x: 10,
              y: 720,
              mountY: 0.5,
              text: {
                text: Language$1.translate("App Info"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 400,
              y: 720,
              mountY: 0.5,
              text: {
                text: "Youtube:\nAmazon Prime:\nNetflix ESN:",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Line7: {
            y: 810,
            mountY: 0.5,
            w: 1600,
            h: 3,
            rect: true,
            color: 0xFFFFFFFF
          }
        }
      };
    }
    _init() {
      this._network = new Network();
      this.appApi = new AppApi();
    }
    _focus() {
      this._setState('DeviceInformationScreen');
      this.appApi.getSerialNumber().then(result => {
        this.tag("SerialNumber.Value").text.text = "".concat(result.serialNumber);
      });
      if ("ResidentApp" === Storage$1.get("selfClientName")) {
        this.appApi.getSystemVersions().then(res => {
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.stbVersion, " \nTime Stamp - ").concat(res.stbTimestamp, " ");
        }).catch(err => {
          console.error("error while getting the system versions");
        });
        this._network.isConnectedToInternet().then(result => {
          if (result.connectedToInternet === true) {
            this.appApi.getLocation().then(result => {
              console.log("getLocation from device info " + JSON.stringify(result));
              let locationInfo = "";
              if (result.city.length !== 0) {
                locationInfo = "City: " + result.city;
              } else {
                locationInfo = "City: N/A ";
              }
              if (result.country.length !== 0) {
                locationInfo += ", Country: " + result.country;
              } else {
                locationInfo += ", Country: N/A ";
              }
              this.tag('Location.Value').text.text = "".concat(locationInfo);
            });
          } else {
            this.tag('Location.Value').text.text = "City: N/A, Country: N/A";
          }
        });
      } else {
        // Firebolt mode
        FireBoltApi.get().deviceinfo.getversion().then(res => {
          console.log("build verion".concat(res.firmware.readable, " Firebolt API Version - ").concat(res.api.readable));
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.firmware.readable, " \nFirebolt API Version - ").concat(res.api.readable, " ");
        }).catch(err => {
          console.error("error while getting the system versions from Firebolt.getversion API");
        });
        FireBoltApi.get().localization.countryCode().then(res => {
          this.tag('Location.Value').text.text = "CountryCode: ".concat(res);
        });
      }
      this.appApi.getDRMS().then(result => {
        console.log('from device info supported drms ' + JSON.stringify(result));
        let drms = "";
        result.forEach(element => {
          drms += "".concat(element.name, " :");
          if (element.keysystems) {
            drms += "\t";
            element.keysystems.forEach(keySystem => {
              drms += "".concat(keySystem, ", ");
            });
            drms += "\n";
          } else {
            drms += "\n";
          }
        });
        this.tag('SupportedDRM.Value').text.text = "".concat(drms.substring(0, drms.length - 1));
      });
      this.appApi.getDeviceIdentification().then(result => {
        console.log('from device Information screen getDeviceIdentification: ' + JSON.stringify(result));
        this.tag('ChipSet.Value').text.text = "".concat(result.chipset);
        // this.tag('FirmwareVersions.Value').text.text = `${result.firmwareversion}`
      });

      let self = this;
      if (Storage$1.get('Netflix_ESN')) {
        self.tag('AppVersions.Value').text.text = "Youtube: NA\nAmazon Prime: NA\nNetflix ESN: ".concat(Storage$1.get('Netflix_ESN'));
      } else {
        self.appApi.getPluginStatus('Netflix').then(result => {
          let sel = self;
          console.log("Netflix : plugin status : ", JSON.stringify(result));
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            sel.appApi.launchPremiumAppInSuspendMode("Netflix").then(res => {
              console.log("Netflix : netflix launch for esn value in suspend mode returns : ", JSON.stringify(res));
              let se = sel;
              se.appApi.getNetflixESN().then(res => {
                Storage$1.set('Netflix_ESN', res);
                console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
                se.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
              }).catch(err => {
                console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
              });
            }).catch(err => {
              console.error("Netflix : error while launching netflix in suspendMode : ", JSON.stringify(err));
            });
          } else {
            self.appApi.getNetflixESN().then(res => {
              Storage$1.set('Netflix_ESN', res);
              console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
              self.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
            }).catch(err => {
              console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
            });
          }
        }).catch(err => {
          console.error("Netflix : error while getting netflix plugin status ie. ", JSON.stringify(err));
          self.netflixESN = "Youtube: NA \nAmazon Prime: NA \nNetflix ESN: \"Not Detected\"";
        });
      }
      this.appApi.registerChangeLocation();
    }
    set netflixESN(v) {
      console.log("setting netflix ESN value to ".concat(v));
      this.tag('AppVersions.Value').text.text = v;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > 215) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 275) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Firmware screen.
   */

  class FirmwareScreen$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device  Firmware Update'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        FirmwareContents: {
          x: 200,
          y: 270,
          State: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware State: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          Version: {
            Title: {
              x: 10,
              y: 90,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware Versions: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedVersion: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Downloaded Firmware Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedPercent: {
            Title: {
              x: 10,
              y: 180,
              mountY: 0.5,
              text: {
                text: "",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          FirmwareUpdate: {
            RectangleDefault: {
              x: 110,
              y: 200,
              w: 300,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: CONFIG.theme.hex,
              Update: {
                x: 170,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Check for Update"),
                  fontFace: CONFIG.language.font,
                  fontSize: 24
                }
              }
            }
          }
        }
      };
    }
    _firstEnable() {
      let state = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      const thunder = thunderJS$1(config);
      thunder.Controller.activate({
        callsign: "org.rdk.System"
      }).then(res => {
        thunder.on(callsign, "onFirmwareUpdateStateChange", notification => {
          console.log("Tanjirou's notification : on Firmware update state changed notifcation = ".concat(JSON.stringify(notification)));
          if (state[notification.firmwareUpdateStateChange] == "Downloading") {
            this.downloadInterval = setInterval(() => {
              console.log("Downloading...");
              this.getDownloadPercent();
            }, 1000);
          } else if (state[notification.firmwareUpdateStateChange] != "Downloading" && this.downloadInterval) {
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }, err => {
          console.error("error while fetching notification ie. ".concat(err));
        });
      }).catch(err => {
        console.error("error while activating the system plugin");
      });
    }
    _unfocus() {
      if (this.downloadInterval) {
        clearInterval(this.downloadInterval);
        this.downloadInterval = null;
      }
    }
    _focus() {
      this.downloadInterval = null;
      this._appApi = new AppApi();
      const downloadState = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      this._appApi.getFirmwareUpdateState().then(res => {
        console.log("getFirmwareUpdateState from firmware screen " + JSON.stringify(res));
        this.tag('State.Title').text.text = Language$1.translate("Firmware State: ") + downloadState[res.firmwareUpdateState];
      });
      this._appApi.getDownloadFirmwareInfo().then(res => {
        console.log("getDownloadFirmwareInfo from firmware screen " + JSON.stringify(res));
        this.tag('Version.Title').text.text = Language$1.translate("Firmware Versions: ") + res.currentFWVersion;
      });
      this._setState('FirmwareUpdate');
    }
    getDownloadPercent() {
      this._appApi.getFirmwareDownloadPercent().then(res => {
        console.log("getFirmwareDownloadPercent : ".concat(JSON.stringify(res)));
        if (res.downloadPercent < 0) {
          this.tag('DownloadedPercent.Title').text.text = "";
        } else {
          this.tag('DownloadedPercent.Title').text.text = Language$1.translate("Download Progress: ") + res.downloadPercent + "%";
        }
      }).catch(err => {
        console.error(err);
      });
    }
    getDownloadFirmwareInfo() {
      this._appApi.updateFirmware().then(res => {
        this._appApi.getDownloadFirmwareInfo().then(result => {
          console.log("getDownloadFirmwareInfo : ".concat(JSON.stringify(result.downloadFWVersion)));
          this.tag('DownloadedVersion.Title').text.text = Language$1.translate('Downloaded Firmware Version: ') + "".concat(result.downloadFWVersion ? result.downloadFWVersion : 'NA');
        }).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    static _states() {
      return [class FirmwareUpdate extends this {
        _handleEnter() {
          this.getDownloadFirmwareInfo();
          this.getDownloadPercent();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$a = new AppApi();
  /**
   * Class for Reboot Confirmation Screen.
   */
  class RebootConfirmationScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Reboot"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to reboot!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState('Confirm');
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          appApi$a.reboot().then(result => {
            console.log('device rebooting' + JSON.stringify(result));
            this._setState('Rebooting');
          });
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = Language$1.translate("Rebooting") + "...";
          this.tag('Buttons').visible = false;
          this.tag('Info').visible = false;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeZoneItem extends t.Component {
    _construct() {
      this.Arrow = Utils.asset('/images/settings/Arrow.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Right: {
          y: 45,
          x: 1600,
          mountX: 1,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Arrow, 45, 45),
          color: 0xffffffff
        },
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[2]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _handleEnter() {
      console.log('enter', this._item[1]);
      Router.navigate('settings/advanced/device/timezone/item', {
        time_region: this._item[1],
        zone: this._item[0],
        isActive: this.zone
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  class TimeZone$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Advanced Settings  Device  Time'));
    }

    /**
     * @param {object} args
     */
    set params(args) {
      if (args.refresh) {
        this._firstEnable();
      }
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        TimeZone: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -1
          },
          Error: {
            alpha: 0,
            x: 560,
            y: 340,
            mountX: 0.5,
            MSG: {
              text: {
                text: Language$1.translate('Not supported'),
                fontFace: CONFIG.language.font,
                fontSize: 40,
                textColor: 0xffffffff
              }
            }
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    async _firstEnable() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.loadingAnimation.start();
      this.tag('Loader').visible = true;
      this.appApi = new AppApi();
      this.resp = await this.appApi.fetchTimeZone();
      let data = [];
      this.zone = await this.appApi.getZone();
      try {
        console.log(this.resp, this.zone);
        delete this.resp.Etc;
        for (const i in this.resp) {
          if (typeof this.resp[i] === 'object') {
            data.push([i, this.resp[i], this.zone !== undefined ? this.zone.split('/')[0] === i : false]);
          }
        }
        if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError" && this.zone.length) {
          AlexaApi.get().updateDeviceTimeZoneInAlexa(this.zone);
        }
      } catch (error) {
        console.log('no api present', error);
      }
      console.log(data);
      if (data.length > 1) {
        this.tag('List').h = data.length * 90;
        this.tag('List').items = data.map((item, idx) => {
          return {
            ref: 'Time' + idx,
            w: 1620,
            h: 90,
            type: TimeZoneItem,
            item: item,
            zone: this.zone !== undefined ? this.zone.split('/')[1] : ''
          };
        });
      } else {
        this.tag('Error').alpha = 1;
      }
      this.loadingAnimation.stop();
      this.tag('Loader').visible = false;
    }
    _getFocused() {
      return this.tag('List').element;
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
      }
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    static _states() {
      return [];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeItem extends t.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[1]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeItems extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        Time: {
          x: 200,
          y: 185,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            itemScrollOffset: -2
          }
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set params(item) {
      console.log(item);
      this._item = item;
      this.tag('List').h = Object.keys(item.time_region).length * 90;
      this.tag('List').items = Object.keys(item.time_region).map((ele, idx) => {
        return {
          ref: 'Time' + idx,
          w: 1620,
          h: 90,
          type: TimeItem,
          item: [ele, ele === item.isActive]
        };
      });
    }
    _init() {
      this.appApi = new AppApi();
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleEnter() {
      console.log("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.widgets.menu.updateTimeZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.appApi.setZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      Router.navigate('settings/advanced/device/timezone', {
        refresh: true
      });
    }
    _getFocused() {
      return this.tag('List').element;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$9 = new AppApi();
  const _btApi = new BluetoothApi();
  const _wfApi = new Wifi();

  /**
   * Class for Reboot Confirmation Screen.
   */
  class RebootConfirmationScreen extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Factory Reset"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to FactoryReset!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _init() {
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState('Confirm');
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/advanced/device');
      }
    }
    async _performFactoryReset() {
      // Deactivate SmartScreen instance to prevent overlay when Auth is revoked.
      AlexaApi.get().disableSmartScreen();
      AlexaApi.get().resetAVSCredentials();
      AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
      let getsuportedmode = await appApi$9.getSupportedAudioPorts();
      for (let i = 0; i < getsuportedmode.supportedAudioPorts.length; i++) {
        if (getsuportedmode.supportedAudioPorts[i] != 'SPDIF0') {
          let rsbass = await appApi$9.resetBassEnhancer(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetBassEnhancer", err);
          });
          if (rsbass.success != true) {
            console.log("resetBassEnhancer", rsbass);
          } //throw new Error(rsbass); }//{Promise.reject(false); return}
          let rsDialog = await appApi$9.resetDialogEnhancement(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetDialogEnhancement", err);
          }); //{Promise.reject(JSON.stringify(err))});
          if (rsDialog.success != true) {
            console.log("resetDialogEnhancement", rsDialog);
          }
          let rsVirtualizer = await appApi$9.resetSurroundVirtualizer(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetSurroundVirtualizer", err);
          });
          if (rsVirtualizer.success != true) {
            console.log("resetSurroundVirtualizer", rsVirtualizer);
          }
          let rsvolumelvel = await appApi$9.resetVolumeLeveller(getsuportedmode.supportedAudioPorts[i]).catch(err => {
            console.log("resetVolumeLeveller", err);
          });
          if (rsvolumelvel.success != true) {
            console.log("resetVolumeLeveller", rsvolumelvel);
          }
        }
      }
      await _btApi.btactivate().then(result => console.log("Btactivate", result));
      let getPairedDevices = await _btApi.getPairedDevices();
      console.log("getpairedDevices", getPairedDevices);
      for (let i = 0; i < getPairedDevices.length; i++) {
        if (getPairedDevices.length > 0) {
          let btunpair = await _btApi.unpair(getPairedDevices[i].deviceId).catch(err => {
            console.log("btunpair", err);
          });
          if (btunpair.success != true) {
            console.log("btunpair", btunpair);
          }
        }
      }
      await RCApi.get().activate().then(() => {
        RCApi.get().factoryReset();
      });
      let contollerStat = await appApi$9.checkStatus("Monitor");
      for (let i = 0; i < contollerStat[0].configuration.observables.length; i++) {
        let monitorstat = await appApi$9.monitorStatus(contollerStat[0].configuration.observables[i].callsign).catch(err => {
          console.log("monitorStatus", err);
        });
        if (monitorstat.length < 0) {
          console.log("monitorStatus", monitorstat);
        }
      }
      // warehouse apis
      let internalReset = await appApi$9.internalReset().catch(err => {
        console.error("internalReset", err);
      });
      if (internalReset.success != true || internalReset.error) {
        console.log("internalReset", internalReset);
      }
      let isClean = await appApi$9.isClean().catch(err => {
        console.error("isClean", err);
      });
      if (isClean.success != true) {
        console.log("isClean", isClean);
      }
      let lightReset = await appApi$9.lightReset().catch(err => {
        console.error("lightReset", err);
      });
      if (lightReset.success != true || lightReset.error) {
        console.log("lightReset", lightReset);
      }
      let resetDevice = await appApi$9.resetDevice().catch(err => {
        console.error("resetDevice", err);
      });
      if (resetDevice.success != true || resetDevice.error) {
        console.log("resetDevice", resetDevice);
      }
      let rsactivitytime = await appApi$9.resetInactivityTime().catch(err => {
        console.error("resetInactivityTime", err);
      });
      if (rsactivitytime.success != true) {
        console.log("rsactivitytime", rsactivitytime);
      }
      let clearLastDeepSleepReason = await appApi$9.clearLastDeepSleepReason().catch(err => {
        console.error("clearLastDeepSleepReason", err);
      });
      if (clearLastDeepSleepReason.success != true) {
        console.log("clearLastDeepSleepReason", clearLastDeepSleepReason);
      }
      let clearSSID = await _wfApi.clearSSID().catch(err => {
        console.error("clearSSID", err);
      });
      if (clearSSID.success != true) {
        console.log("clearSSID", clearSSID);
      }
      let wifidisconnect = await _wfApi.disconnect().catch(err => {
        console.error("wifidisconnect", err);
      });
      if (wifidisconnect.success != true) {
        console.log("wifidisconnect", wifidisconnect);
      }
      await appApi$9.clearCache().catch(err => {
        console.error("clearCache error: ", err);
      });
      await appApi$9.reboot().then(result => {
        console.log('device rebooting' + JSON.stringify(result));
      });
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this._setState('Rebooting');
          /* Do any clean-up before _performFactoryReset() as it ends with a reboot. */
          this._performFactoryReset();
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = Language$1.translate("Rebooting") + "...";
          this.tag('Buttons').visible = false;
          this.tag('Info').visible = false;
        }
        $exit() {
          this.loadingAnimation.stop();
          this.tag("Loader").visible = false;
          this.tag('Buttons').visible = true;
          this.tag('Info').visible = true;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var appApi$8 = new AppApi();
  const config$c = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var thunder$e = thunderJS$1(config$c);
  class SreenSaverScreen extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Other Settings  Screen Saver'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: t.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }

    // _init(){
    //     let timerValue = "off";
    //     appApi.SaveTimerValue(this.timerValue);
    //     let persistenceValue = appApi.getTimerValue().then(resp =>console.log(rep))
    //     if(!persistenceValue){
    //         this.timerValue = "off";
    //     }
    //     else{
    //         this.timerValue = persistenceValue;
    //     }
    // }
    _firstEnable() {
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '5 Minutes',
        tick: false
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '30 Minutes',
        tick: false
      }, {
        value: '60 Minutes',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage$1.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this._setState('Options');
      // this.setTimerValue(this.timerValue);
    }

    async _focus() {
      let FocusedValue = await appApi$8.getTimerValue();
      console.log("focusedValue", FocusedValue);
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '5 Minutes',
        tick: false
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '30 Minutes',
        tick: false
      }, {
        value: '60 Minutes',
        tick: false
      }];
      //let timeoutInterval = Storage.get('TimeoutInterval');
      if (!FocusedValue) {
        FocusedValue = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (item.value.startsWith(FocusedValue)) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this._setState('Options');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/other');
      }
    }
    setTimerValue(time) {
      if (time === "Off") {
        appApi$8.enabledisableinactivityReporting(false).then(resp => console.log(resp));
        Storage$1.remove('ScreenSaverTimeoutInterval');
      } else {
        // 10
        appApi$8.enabledisableinactivityReporting(true).then(resp => {
          appApi$8.setInactivityInterval(parseInt(time)).then(res => {
            console.log("setinactivityres", res);
            Storage$1.set('ScreenSaverTimeoutInterval', time);
            console.log("successfully set the timer to ".concat(time, " minutes"));
            thunder$e.on('org.rdk.RDKShell', 'onUserInactivity', notification => {
              console.log("UserInactivityStatusNotification: ", JSON.stringify(notification));
              appApi$8.getAvCodeStatus().then(result => {
                console.log("Avdecoder", result.avDecoderStatus);
                if ((result.avDecoderStatus === "IDLE" || result.avDecoderStatus === "PAUSE") && Storage$1.get("applicationType") === "") {
                  this.fireAncestors("$hideImage", 1);
                }
              });
            });
          }).catch(err => {
            console.error("error while setting the timer");
          });
        });
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
          });
          this.tag('List').element.tag('Tick').visible = true;
          this.timerValue = this.options[this.tag('List').index].value; //10 minutes
          this.timerValue = this.timerValue === "Off" ? "Off" : this.timerValue.substring(0, 2); // 10
          console.log("TimerValue", this.timerValue);
          appApi$8.SaveTimerValue(this.timerValue); // storing in persistence store
          this.setTimerValue(this.timerValue); // enable and setinactivity process
          this.fireAncestors('$screenSaverTime', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const CONSTANTS = {
    LOCK_TIME: 20000,
    MAX_FAILURES: 3,
    PINS: {
      purchase: "1111"
    }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */


  const win$2 = typeof window !== 'undefined' ? window : {};

  let listener;
  const setMockListener = func => { listener = func; };

  let mock$1;
  const pending = [];
  const eventMap = {};

  let callback;
  let testHarness;

  if (win$2.__firebolt && win$2.__firebolt.testHarness) {
    testHarness = win$2.__firebolt.testHarness;
  }

  function send(message) {
    console.debug('Sending message to transport: ' + message);
    let json = JSON.parse(message);

    // handle bulk sends
    if (Array.isArray(json)) {
      json.forEach(j => send(JSON.stringify(j)));
      return
    }

    let [module, method] = json.method.split('.');

    if (testHarness && testHarness.onSend) {
      testHarness.onSend(module, method, json.params, json.id);
    }

    // store the ID of the first listen for each event
    if (method.match(/^on[A-Z]/)) {
      if (json.params.listen) {
        eventMap[json.id] = module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3);
      } else {
        Object.keys(eventMap).forEach(key => {
          if (eventMap[key] === module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)) {
            delete eventMap[key];
          }
        });
      }
    }

    if (mock$1)
      handle(json);
    else
      pending.push(json);
  }

  function handle(json) {
    let result;
    try {
      result = getResult(json.method, json.params);
    }
    catch (error) {
      setTimeout(() => callback(JSON.stringify({ 
        jsonrpc: '2.0',
        error: {
          code: -32602,
          message: "Invalid params (this is a mock error from the mock transport layer)"
        },
        id: json.id
      })));
    }

    setTimeout(() => callback(JSON.stringify({ 
      jsonrpc: '2.0',
      result: result,
      id: json.id
    })));
  }

  function receive(_callback) {
    callback = _callback;

    if (testHarness && (typeof testHarness.initialize === 'function')) {
      testHarness.initialize({
        emit: event,
        listen: function(...args) { listener(...args); },
      });
    }
  }

  function event(module, event, value) {
   const listener = Object.entries(eventMap).find(([k, v]) => v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase());
    if (listener) {
      let message = JSON.stringify({
        jsonrpc: '2.0',
        id: parseInt(listener[0]),
        result: value
      });
      callback(message);
    }
  }

  function dotGrab$1(obj = {}, key) {
    const keys = key.split('.');
    let ref = obj;
    for (let i = 0; i < keys.length; i++) {
      ref = (Object.entries(ref).find( ([k, v]) => k.toLowerCase() === keys[i].toLowerCase()) || [null, {}])[1];
    }
    return ref
  }

  function getResult(method, params) {
    let api = dotGrab$1(mock$1, method);

    if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
      api = {
        event: method,
        listening: true
      };
    }

    if (typeof api === 'function') {
      return params == null ? api() : api(params)
    } else return api
  }

  function setMockResponses(m) {
    mock$1 = m;

    pending.forEach(json => handle(json));
    pending.length = 0;
  }

  var mock$2 = {
    send: send,
    receive: receive,
    event: event
  };

  const mocks = {};

  function mock(module, method, args, def) {
    const fullMethod = `${module}.${method}`;
    if ((args == null) || args.length === 0 || (Object.values(args[0]).length === 0)) {
      // get
      const rv = mocks[fullMethod] && (mocks[fullMethod].value != null) ? mocks[fullMethod].value : def;
      return rv
    } else {
      // set
      let mockMethod = mocks[fullMethod];
      if (mockMethod == null) {
        mockMethod = {
          subscribers: []
        };
      }
      mocks[fullMethod] = mockMethod;
      mockMethod.value = args[0].value;
      mock$2.event(module, method + 'Changed', {
        value: args[0].value
      });
      return {}
    }
  }

  var MockProps = {
    mock: mock
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Localization = {
      locality: function () { return MockProps.mock('Localization', 'locality', arguments, "Philadelphia") },
      postalCode: function () { return MockProps.mock('Localization', 'postalCode', arguments, "19103") },
      countryCode: function () { return MockProps.mock('Localization', 'countryCode', arguments, "US") },
      language: function () { return MockProps.mock('Localization', 'language', arguments, "en") },
      preferredAudioLanguages: function () { return MockProps.mock('Localization', 'preferredAudioLanguages', arguments, ["es","en"]) },
      locale: function () { return MockProps.mock('Localization', 'locale', arguments, "en-US") },
      additionalInfo:  {},
      addAdditionalInfo:  null,
      removeAdditionalInfo:  null,
      timeZone: function () { return MockProps.mock('Localization', 'timeZone', arguments, "America/New_York") },
      setLocality:  null,
      setPostalCode:  null,
      setCountryCode:  null,
      setLanguage:  null,
      setPreferredAudioLanguages:  null,
      setLocale:  null,
      setTimeZone:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Metrics = {
      event:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Wifi = {
      scan:  {"list":[{"ssid":"DND","security":"wpa2Psk","signalStrength":-70,"frequency":2.4},{"ssid":"Fortnite","security":"WPA2_ENTERPRISE_AES","signalStrength":-70,"frequency":5},{"ssid":"Guardian","security":"none","signalStrength":-70,"frequency":2.4}]},
      connect:  {"ssid":"DND","security":"wpa2Psk","signalStrength":-70,"frequency":2.4},
      disconnect:  null,
      wps:  {"ssid":"DND","security":"wpa2Psk","signalStrength":-70,"frequency":2.4}
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _ClosedCaptions = {
      enabled: function () { return MockProps.mock('ClosedCaptions', 'enabled', arguments, true) },
      fontFamily: function () { return MockProps.mock('ClosedCaptions', 'fontFamily', arguments, "monospace") },
      fontSize: function () { return MockProps.mock('ClosedCaptions', 'fontSize', arguments, 1) },
      fontColor: function () { return MockProps.mock('ClosedCaptions', 'fontColor', arguments, "#ffffff") },
      fontEdge: function () { return MockProps.mock('ClosedCaptions', 'fontEdge', arguments, "none") },
      fontEdgeColor: function () { return MockProps.mock('ClosedCaptions', 'fontEdgeColor', arguments, "#000000") },
      fontOpacity: function () { return MockProps.mock('ClosedCaptions', 'fontOpacity', arguments, 99) },
      backgroundColor: function () { return MockProps.mock('ClosedCaptions', 'backgroundColor', arguments, "#000000") },
      backgroundOpacity: function () { return MockProps.mock('ClosedCaptions', 'backgroundOpacity', arguments, 99) },
      textAlign: function () { return MockProps.mock('ClosedCaptions', 'textAlign', arguments, "center") },
      textAlignVertical: function () { return MockProps.mock('ClosedCaptions', 'textAlignVertical', arguments, "middle") },
      setEnabled:  null,
      setFontFamily:  null,
      setFontSize:  null,
      setFontColor:  null,
      setFontEdge:  null,
      setFontEdgeColor:  null,
      setFontOpacity:  null,
      setBackgroundColor:  null,
      setBackgroundOpacity:  null,
      setTextAlign:  null,
      setTextAlignVertical:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _AudioDescriptions = {
      enabled: function () { return MockProps.mock('AudioDescriptions', 'enabled', arguments, true) },
      setEnabled:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _VoiceGuidance = {
      enabled: function () { return MockProps.mock('VoiceGuidance', 'enabled', arguments, true) },
      speed: function () { return MockProps.mock('VoiceGuidance', 'speed', arguments, 1) },
      setEnabled:  null,
      setSpeed:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Device = {
      name: function () { return MockProps.mock('Device', 'name', arguments, "Living Room") },
      provision:  null,
      setName:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _UserGrants = {
      app:  [{"app":{"id":"certapp","title":"Firebolt Certification"},"state":"granted","capability":"xrn:firebolt:capability:data:app-usage","role":"use","lifespan":"seconds","expires":"2022-12-14T20:20:39+00:00"},{"app":{"id":"certapp","title":"Firebolt Certification"},"state":"denied","capability":"xrn:firebolt:capability:localization:postal-code","role":"use","lifespan":"appActive"}],
      device:  [{"state":"granted","capability":"xrn:firebolt:capability:localization:postal-code","role":"use","lifespan":"powerActive"}],
      capability:  [{"state":"granted","capability":"xrn:firebolt:capability:localization:postal-code","role":"use","lifespan":"powerActive"}],
      grant:  null,
      deny:  null,
      clear:  null,
      request:  [{"app":{"id":"certapp","title":"Certification App"},"state":"granted","capability":"xrn:firebolt:capability:localization:postal-code","role":"use","lifespan":"powerActive"}]
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Privacy = {
      allowResumePoints: function () { return MockProps.mock('Privacy', 'allowResumePoints', arguments, true) },
      allowUnentitledResumePoints: function () { return MockProps.mock('Privacy', 'allowUnentitledResumePoints', arguments, true) },
      allowWatchHistory: function () { return MockProps.mock('Privacy', 'allowWatchHistory', arguments, true) },
      allowProductAnalytics: function () { return MockProps.mock('Privacy', 'allowProductAnalytics', arguments, true) },
      allowPersonalization: function () { return MockProps.mock('Privacy', 'allowPersonalization', arguments, true) },
      allowUnentitledPersonalization: function () { return MockProps.mock('Privacy', 'allowUnentitledPersonalization', arguments, true) },
      allowRemoteDiagnostics: function () { return MockProps.mock('Privacy', 'allowRemoteDiagnostics', arguments, true) },
      allowPrimaryContentAdTargeting: function () { return MockProps.mock('Privacy', 'allowPrimaryContentAdTargeting', arguments, true) },
      allowPrimaryBrowseAdTargeting: function () { return MockProps.mock('Privacy', 'allowPrimaryBrowseAdTargeting', arguments, true) },
      allowAppContentAdTargeting: function () { return MockProps.mock('Privacy', 'allowAppContentAdTargeting', arguments, true) },
      allowACRCollection: function () { return MockProps.mock('Privacy', 'allowACRCollection', arguments, true) },
      allowCameraAnalytics: function () { return MockProps.mock('Privacy', 'allowCameraAnalytics', arguments, true) },
      settings:  {"allowACRCollection":true,"allowResumePoints":false,"allowAppContentAdTargeting":false,"allowCameraAnalytics":true,"allowPersonalization":true,"allowPrimaryBrowseAdTargeting":false,"allowPrimaryContentAdTargeting":false,"allowProductAnalytics":true,"allowRemoteDiagnostics":true,"allowUnentitledPersonalization":true,"allowUnentitledResumePoints":false,"allowWatchHistory":true},
      setAllowResumePoints:  null,
      setAllowUnentitledResumePoints:  null,
      setAllowWatchHistory:  null,
      setAllowProductAnalytics:  null,
      setAllowPersonalization:  null,
      setAllowUnentitledPersonalization:  null,
      setAllowRemoteDiagnostics:  null,
      setAllowPrimaryContentAdTargeting:  null,
      setAllowPrimaryBrowseAdTargeting:  null,
      setAllowAppContentAdTargeting:  null,
      setAllowACRCollection:  null,
      setAllowCameraAnalytics:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Advertising = {
      skipRestriction: function () { return MockProps.mock('Advertising', 'skipRestriction', arguments, "none") },
      resetIdentifier:  null,
      setSkipRestriction:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Account = {
      session:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Keyboard = {
      standardFocus:  null,
      passwordFocus:  null,
      emailFocus:  null,
      standardResponse:  null,
      standardError:  null,
      passwordResponse:  null,
      passwordError:  null,
      emailResponse:  null,
      emailError:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _AcknowledgeChallenge = {
      challengeFocus:  null,
      challengeResponse:  null,
      challengeError:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _PinChallenge = {
      challengeFocus:  null,
      challengeResponse:  null,
      challengeError:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _SecureStorage = {
      setForApp:  null,
      removeForApp:  null,
      clearForApp:  null
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  var _Discovery = {
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  class Queue {
    constructor () {
      this._callback = null;
      this._queue = [];
    }

    send (json) {
      this._queue.push(json);
    }

    receive (_callback) {
      this._callback = _callback;
    }

    flush (transport) {
      transport.receive(this._callback);
      this._queue.forEach(item => transport.send(item));
    }
  }

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const settings = {};
  const subscribers = {};

  const initSettings = (appSettings, platformSettings) => {
    settings['app'] = appSettings;
    settings['platform'] = {
      logLevel: 'WARN',
      ...platformSettings
    };
    settings['user'] = {};
  };

  const publish = (key, value) => {
    subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value));
  };

  const dotGrab = (obj = {}, key) => {
    const keys = key.split('.');
    for (let i = 0; i < keys.length; i++) {
      obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {};
    }
    return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
  };

  var Settings = {
    get(type, key, fallback = undefined) {
      const val = dotGrab(settings[type], key);
      return val !== undefined ? val : fallback
    },
    has(type, key) {
      return !!this.get(type, key)
    },
    set(key, value) {
      settings['user'][key] = value;
      publish(key, value);
    },
    subscribe(key, callback) {
      subscribers[key] = subscribers[key] || [];
      subscribers[key].push(callback);
    },
    unsubscribe(key, callback) {
      if (callback) {
        const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback);
        index > -1 && subscribers[key].splice(index, 1);
      } else {
        if (key in subscribers) {
          subscribers[key] = [];
        }
      }
    },
    clearSubscribers() {
      for (const key of Object.getOwnPropertyNames(subscribers)) {
        delete subscribers[key];
      }
    },
    setLogLevel (logLevel) {
      settings.platform.logLevel = logLevel;
    },
    getLogLevel () {
      return settings.platform.logLevel
    }
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const win$1 = typeof window !== 'undefined' ? window : {};

  class LegacyTransport {
    constructor (bridge) {
      this.bridge = bridge;
    }

    send (msg) {
      this.bridge.JSMessageChanged(msg, () => {});
    }

    receive (callback) {
      win$1.$badger = win$1.$badger || {};
      /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
      const badgerCallback = win$1.$badger.callback ? win$1.$badger.callback.bind(win$1.$badger) : null;
      const badgerEvent = win$1.$badger.event ? win$1.$badger.event.bind(win$1.$badger) : null;
      win$1.$badger.callback = (pid, success, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerCallback) {
          badgerCallback(pid, success, json);
        }
      };
      win$1.$badger.event = (handlerId, json) => {
        if (json.jsonrpc) {
          callback(JSON.stringify(json));
        } else if (badgerEvent) {
          badgerEvent(handlerId, json);
        }
      };
    }

    static isLegacy (transport) {
      return LegacyTransport.isXREProxy(transport) || ((transport.send === undefined) && (transport.JSMessageChanged))
    }

    static isXREProxy (transport) {
      /** Set top boxes running XRE has a "Proxy" transport
       * native object that intercepts ALL method calls, so we
       * cannot test for transport.send existence because it will return true
       * even though it actually is not supported. Check if some obscure method
       * name like "proxyObjectTest" is defined. If it is then we know we are using a
       * Proxy object and thus is legacy transport.
       */
      return transport.proxyObjectTest !== undefined
    }
  }

  const MAX_QUEUED_MESSAGES = 100;

  class WebsocketTransport {
    constructor (endpoint) {
      this._endpoint = endpoint;
      this._ws = null;
      this._connected = false;
      this._queue = [];
      this._callbacks = [];
    }

    send (msg) {
      this._connect();

      if (this._connected) {
        this._ws.send(msg);
      } else {
        if (this._queue.length < MAX_QUEUED_MESSAGES) {
          this._queue.push(msg);
        }
      }
    }

    receive (callback) {
      if (!callback) return
      this._connect();
      this._callbacks.push(callback);
    }

    _notifyCallbacks (message) {
      for (let i = 0; i < this._callbacks.length; i++) {
        setTimeout(() => this._callbacks[i](message), 1);
      }
    }

    _connect () {
      if (this._ws) return
      this._ws = new WebSocket(this._endpoint, ['jsonrpc']);
      this._ws.addEventListener('message', message => {
        this._notifyCallbacks(message.data);
      });
      this._ws.addEventListener('error', message => {
      });
      this._ws.addEventListener('close', message => {
        this._ws = null;
        this._connected = false;
      });
      this._ws.addEventListener('open', message => {
        this._connected = true;
        for (let i = 0; i < this._queue.length; i++) {
          this._ws.send(this._queue[i]);
        }
        this._queue = [];
      });
    }
  }

  /*
  methods = Map<string, {
      x-this-param: 'accessory',
      x-additional-params: ['timeout'],
      x-method: 'Accessory.pair'
  }>
  */

  function transform(result, transforms) {

      if (!transforms || !transforms.methods) {
          return result
      }

      const { methods } = transforms;
      const transformed = JSON.parse(JSON.stringify(result));

      Object.keys(methods).forEach(key => {
          const method_info = methods[key];
          const rpc_method = method_info['x-method'];
          const [module, method] = rpc_method.split('.');
          const params = {};
          params[method_info['x-this-param']] = transformed;
          transformed[key] = (...args) => {
              // copy the args into the correct RPC param names
              for (var i=0; i<args.length; i++) {
                  params[method_info['x-additional-params'][i]] = args[i];
              }
              return Transport.send(module.toLowerCase(), method, params)
          };
      });
      return transformed
  }

  var Results = {
      transform
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const LEGACY_TRANSPORT_SERVICE_NAME = 'com.comcast.BridgeObject_1';
  let moduleInstance = null;

  const isEventSuccess = x => x && (typeof x.event === 'string') && (typeof x.listening === 'boolean');

  const win = typeof window !== 'undefined' ? window : {};

  class Transport {
    constructor () {
      this._promises = [];
      this._transport = null;
      this._id = 1;
      this._eventEmitters = [];
      this._eventIds = [];
      this._queue = new Queue();
      this._deprecated = {};
      this.isMock = false;
    }

    static addEventEmitter (emitter) {
      Transport.get()._eventEmitters.push(emitter);
    }

    static registerDeprecatedMethod (module, method, alternative) {
      Transport.get()._deprecated[module.toLowerCase() + '.' + method.toLowerCase()] = {
        alternative: alternative || ''
      };
    }

    _endpoint () {
      if (win.__firebolt && win.__firebolt.endpoint) {
        return win.__firebolt.endpoint
      }
      return null
    }

    constructTransportLayer () {
      let transport;
      const endpoint = this._endpoint();
      if (endpoint && (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))) {
        transport = new WebsocketTransport(endpoint);
        transport.receive(this.receiveHandler.bind(this));
      } else if (
        typeof win.ServiceManager !== 'undefined' &&
        win.ServiceManager &&
        win.ServiceManager.version
      ) {
        // Wire up the queue
        transport = this._queue;
        // get the default bridge service, and flush the queue
        win.ServiceManager.getServiceForJavaScript(LEGACY_TRANSPORT_SERVICE_NAME, service => {
          if (LegacyTransport.isLegacy(service)) {
            transport = new LegacyTransport(service);
          } else {
            transport = service;
          }
          this.setTransportLayer(transport);
        });
      } else {
        this.isMock = true;
        transport = mock$2;
        transport.receive(this.receiveHandler.bind(this));
      }
      return transport
    }

    setTransportLayer (tl) {
      this._transport = tl;
      this._queue.flush(tl);
    }

    static send (module, method, params, transforms) {
      /** Transport singleton across all SDKs to keep single id map */
      return Transport.get()._send(module, method, params, transforms)
    }

    static listen(module, method, params, transforms) {
      return Transport.get()._sendAndGetId(module, method, params, transforms)
    }

    _send (module, method, params, transforms) {
      if (Array.isArray(module) && !method && !params) {
        return this._batch(module)
      }
      else {
        return this._sendAndGetId(module, method, params, transforms).promise
      }
    }

    _sendAndGetId (module, method, params, transforms) {
      const {promise, json, id } = this._processRequest(module, method, params, transforms);
      const msg = JSON.stringify(json);
      if (Settings.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return { id, promise }
    }

    _batch (requests) {
      const results = [];
      const json = [];

      requests.forEach( ({module, method, params, transforms}) => {
        const result = this._processRequest(module, method, params, transforms);
        results.push({
          promise: result.promise,
          id: result.id
        });
        json.push(result.json);
      });

      const msg = JSON.stringify(json);
      if (Settings.getLogLevel() === 'DEBUG') {
        console.debug('Sending message to transport: ' + msg);
      }
      this._transport.send(msg);

      return results
    }

    _processRequest (module, method, params, transforms) {

      const p = this._addPromiseToQueue(module, method, params, transforms);
      const json = this._createRequestJSON(module, method, params);

      const result = {
        promise: p,
        json: json,
        id: this._id
      };

      this._id++;

      return result
    }

    _createRequestJSON (module, method, params) {
      return { jsonrpc: '2.0', method: module.toLowerCase() + '.' + method, params: params, id: this._id }
    }

    _addPromiseToQueue (module, method, params, transforms) {
      return new Promise((resolve, reject) => {
        this._promises[this._id] = {};
        this._promises[this._id].promise = this;
        this._promises[this._id].resolve = resolve;
        this._promises[this._id].reject = reject;
        this._promises[this._id].transforms = transforms;

        const deprecated = this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()];
        if (deprecated) {
          console.warn(`WARNING: ${module}.${method}() is deprecated. ` + deprecated.alternative);
        }

        // store the ID of the first listen for each event
        // TODO: what about wild cards?
        if (method.match(/^on[A-Z]/)) {
          if (params.listen) {
            this._eventIds.push(this._id);
          } else {
            this._eventIds = this._eventIds.filter(id => id !== this._id);
          }
        }
      })
    }

    /**
     * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
     * @returns {Transport}
     */
    static get () {
      /** Set up singleton and initialize it */
      win.__firebolt = win.__firebolt || {};
      if ((win.__firebolt.transport == null) && (moduleInstance == null)) {
        const transport = new Transport();
        transport.init();
        if (transport.isMock) {
          /** We should use the mock transport built with the SDK, not a global */
          moduleInstance = transport;
        } else {
          win.__firebolt = win.__firebolt || {};
          win.__firebolt.transport = transport;
        }
        win.__firebolt.setTransportLayer = transport.setTransportLayer.bind(transport);
      }
      return win.__firebolt.transport ? win.__firebolt.transport : moduleInstance
    }

    receiveHandler (message) {
      if (Settings.getLogLevel() === 'DEBUG') {
        console.debug('Received message from transport: ' + message);
      }
      const json = JSON.parse(message);
      const p = this._promises[json.id];

      if (p) {
        if (json.error) p.reject(json.error);
        else {
          // Do any module-specific transforms on the result
          let result = json.result;

          if (p.transforms) {
            if (Array.isArray(json.result)) {
              result = result.map(x => Results.transform(x, p.transforms));
            }
            else {
              result = Results.transform(result, p.transforms);
            }
          }
          
          p.resolve(result);
        }
        delete this._promises[json.id];
      }

      // event responses need to be emitted, even after the listen call is resolved
      if (this._eventIds.includes(json.id) && !isEventSuccess(json.result)) {
        this._eventEmitters.forEach(emit => {
          emit(json.id, json.result);
        });
      }
    }

    init () {
      initSettings({}, { log: true });
      this._queue.receive(this.receiveHandler.bind(this));
      if (win.__firebolt) {
        if (win.__firebolt.mockTransportLayer === true) {
          this.isMock = true;
          this.setTransportLayer(mock$2);
        } else if (win.__firebolt.getTransportLayer) {
          this.setTransportLayer(win.__firebolt.getTransportLayer());
        }
      }
      if (this._transport == null) {
        this._transport = this.constructTransportLayer();
      }
    }
  }
  win.__firebolt = win.__firebolt || {};
  win.__firebolt.setTransportLayer = transport => {
    Transport.get().setTransportLayer(transport);
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  let listenerId = 0;

  // holds two maps of ${module}.${event} => listenerId, e.g. callback method id
  // note that one callback can listen to multiple events, e.g. 'discovery.*'
  // internal is only available via a private export that we use to ensure our modules know about
  // events before the apps using the SDK (otherwise state errors can happen)
  const listeners = {
    internal: {},
    external: {},

    // Several convenience functions below for checking both internal & external lists w/ one operation

    // gets a merge list of ids for a single event key
    get: (key) => {
      return Object.assign(Object.assign({}, listeners.internal[key]), listeners.external[key])
    },
    // adds a callback/id to a key on the external list only 
    set: (key, id, value) => {
      listeners.external[key] = listeners.external[key] || {};
      listeners.external[key][id] = value;
    },
    // adds a callback/id to a key on the internal list only 
    setInternal: (key, id, value) => {
      listeners.internal[key] = listeners.internal[key] || {};
      listeners.internal[key][id] = value;
    },
    // finds the key for an id in either list (it can only be in one)
    find: (id) => {
      let key;
      [listeners.internal, listeners.external].find(group => {
        key = Object.keys(group).find(key => group[key][id]);
        if (key) return true
      });
      return key
    },
    // removes an id from either list
    remove: (id) => {
      [listeners.internal, listeners.external].forEach(group => {
        Object.keys(group).forEach(key => {
          if (group[key] && group[key][id]) {
            delete group[key][id];
            if (Object.values(group[key]).length === 0) {
              delete group[key];
            }
          }
        });
      });
    },
    // removes a key from both lists if _internal is true, otherwise only the external list
    removeKey: (key, _internal=false) => {
      _internal && listeners.internal[key] && delete listeners.internal[key];
      listeners.external[key] && delete listeners.external[key];
    },
    // gives a list of all keys
    keys: () => {
      return Array.from(new Set(Object.keys(listeners.internal).concat(Object.keys(listeners.external))))
    },
    // counts how many listeners are in a key across both lists
    count: (key) => {
      return Object.values(listeners.get(key)).length
    }
  };

  // holds a map of RPC Ids => Context Key, e.g. the RPC id of an onEvent call mapped to the corresponding context parameters key for that RPC call
  const keys = {};

  // holds a map of ${module}.${event} => Transport.send calls (only called once per event)
  // note that the keys here MUST NOT contain wild cards
  const oncers = [];
  const validEvents = {};
  const validContext = {};

  let transportInitialized = false;

  const emit = (id, value) => {
    callCallbacks(listeners.internal[keys[id]], [value]);
    callCallbacks(listeners.external[keys[id]], [value]);
  };

  const registerEvents = (module, events) => {
    validEvents[module.toLowerCase()] = events.concat();
  };

  const callCallbacks = (cbs, args) => {
    cbs &&
      Object.keys(cbs).forEach(listenerId => {
        let callback = cbs[listenerId];
        if (oncers.indexOf(parseInt(listenerId)) >= 0) {
          oncers.splice(oncers.indexOf(parseInt(listenerId)), 1);
          delete cbs[listenerId];
        }
        callback.apply(null, args);
      });
  };

  const doListen = function(module, event, callback, context, once, internal=false) {
    init();

    if (typeof callback !== 'function') {
      return Promise.reject('No valid callback function provided.')
    } else {
      if (module === '*') {
        return Promise.reject('No valid module name provided')
      }

      const wildcard = event === '*';
      const events = (wildcard ? validEvents[module] : [event]); // explodes wildcards into an array
      const promises = [];
      const hasContext = Object.values(context).length > 0;
      const contextKey = Object.keys(context).sort().map(key => key + '=' + JSON.stringify(context[key])).join('&');

      listenerId++;

      if (once) {
        oncers.push(listenerId);
      }

      events.forEach(event => {
        const key = module + '.' + event + (hasContext ? `.${contextKey}`  : '');

        if (Object.values(listeners.get(key)).length === 0) {
          const args = Object.assign({ listen: true }, context);
          const { id, promise } = Transport.listen(module, 'on' + event[0].toUpperCase() + event.substring(1), args);
          keys[id] = key;
          promises.push(promise);
        }

        const setter = internal ? listeners.setInternal : listeners.set;

        if (wildcard) {
          setter(key, ''+listenerId, value => callback(event, value));
        }
        else {
          setter(key, ''+listenerId, callback);
        }
      });

      let resolve, reject;
      let p = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });

      if (promises.length) {
        Promise.all(promises).then(responses => {
          resolve(listenerId);
        }).catch(error => {
          // Promise.all rejects if at least one promise rejects... we don't want that behavior here
          // TODO: Do something better than fail silently
          if (event === '*') {
            resolve(listenerId);
          }
          else {
            reject(error);
          }
        });
      }
      else {
        resolve(listenerId);
      }

      return p
    }
  };

  const getListenArgs = function(...args) {
    const callback = args.pop();
    const [module, event, context] = getClearArgs(...args);

    return [module, event, callback, context]
  };

  const getClearArgs = function(...args) {
    const module = (args.shift() || '*').toLowerCase();
    const event = args.shift() || '*';
    const context = {};
    
    for (let i = 0; args.length; i++) {
      context[validContext[module][event][i]] = args.shift();
    }

    return [module, event, context]
  };

  const once = function(...args) {
    const [module, event, callback, context] = getListenArgs(...args);
    return doListen(module, event, callback, context, true)
  };

  const listen = function(...args) {
    const [module, event, callback, context] = getListenArgs(...args);
    return doListen(module, event, callback, context, false)
  };

  const clear = function(...args) {
    if (args && args.length && typeof args[0] === 'number') {
      return doClear(args[0])
    }
    else if (args && args.length && typeof args[1] === 'number') {
      return doClear(args[1])
    }
    else {
      const [moduleOrId, event, context] = getClearArgs(...args);
      return doClear(moduleOrId, event, context)
    }
  };

  const unsubscribe = (key, context) => {
    const [module, event] = key.split('.').slice(0, 2);
    const args = Object.assign({ listen: false }, context);
    Transport.send(module, 'on' + event[0].toUpperCase() + event.substr(1), args);
  };


  // TODO: clear needs to go through Transport Layer
  const doClear = function (moduleOrId = false, event = false, context) {
    if (event === '*') {
      event = false;
    }

    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString();
      const key = listeners.find(searchId);

      if (key) {
        listeners.remove(searchId);
        if (listeners.count(key) === 0) {
          unsubscribe(key);
        }
        return true
      }
      return false
    } else {
      if (!moduleOrId && !event) {
        listeners.keys().forEach(key => {
          listeners.removeKey(key);
          unsubscribe(key);
        });
      } else if (!event) {
        listeners.keys().forEach(key => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            listeners.removeKey(key);
            unsubscribe(key);
          }
        });
      } else {
        const hasContext = Object.values(context).length > 0;
        const contextKey = Object.keys(context).sort().map(key => key + '=' + JSON.stringify(context[key])).join('&');
        const key = moduleOrId + '.' + event + (hasContext ? `.${contextKey}`  : '');

        listeners.removeKey(key);
        unsubscribe(key, context);
      }
    }
  };

  const init = () => {
    if (!transportInitialized) {
      Transport.addEventEmitter(emit);
      setMockListener(listen);
      transportInitialized = true;
    }
  };

  var Events = {
    listen: listen,
    once: once,
    clear: clear,
    broadcast(event, value) {
      emit(Object.entries(keys).find( ([k, v]) => v === 'app.'+event)[0], value);
    },
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Localization', ["countryCodeChanged","languageChanged","localeChanged","localityChanged","postalCodeChanged","preferredAudioLanguagesChanged","timeZoneChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('ClosedCaptions', ["backgroundColorChanged","backgroundOpacityChanged","enabledChanged","fontColorChanged","fontEdgeChanged","fontEdgeColorChanged","fontFamilyChanged","fontOpacityChanged","fontSizeChanged","textAlignChanged","textAlignVerticalChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('AudioDescriptions', ["enabledChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('VoiceGuidance', ["enabledChanged","speedChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Device', ["deviceNameChanged","nameChanged"]);


  Transport.registerDeprecatedMethod('Device', 'onDeviceNameChanged', 'Use Device.name() instead.');

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Privacy', ["allowACRCollectionChanged","allowAppContentAdTargetingChanged","allowCameraAnalyticsChanged","allowPersonalizationChanged","allowPrimaryBrowseAdTargetingChanged","allowPrimaryContentAdTargetingChanged","allowProductAnalyticsChanged","allowRemoteDiagnosticsChanged","allowResumePointsChanged","allowUnentitledPersonalizationChanged","allowUnentitledResumePointsChanged","allowWatchHistoryChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Advertising', ["skipRestrictionChanged"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  const providerInterfaces = {};

  const registerProviderInterface = (capability, module, methods) => {
    if (providerInterfaces[capability]) {
      throw `Capability ${capability} has multiple provider interfaces registered.`
    }

    methods.forEach(m => m.name = `${module}.${m.name}`);
    providerInterfaces[capability] = methods.concat();
  };

  const provide$3 = function(capability, provider) {
    const methods = [];
    const iface = providerInterfaces[capability];

    if (provider.constructor.name !== 'Object') {
      methods.push(...Object.getOwnPropertyNames(Object.getPrototypeOf(provider)).filter(item => typeof provider[item] === 'function' && item !== 'constructor'));
    }
    else {
      methods.push(...Object.getOwnPropertyNames(provider).filter(item => typeof provider[item] === 'function'));
    }

    if (!iface) {
      throw "Ignoring unknown provider capability."
    }

    // make sure every interfaced method exists in the providers methods list
    const valid = iface.every(method => methods.find(m => m === method.name.split('.').pop()));

    if (!valid) {
      throw `Provider that does not fully implement ${capability}:\n\t${iface.map(m=>m.name.split('.').pop()).join('\n\t')}`
    }

    iface.forEach(imethod => {
      const parts = imethod.name.split('.');
      const method = parts.pop();
      const module = parts.pop().toLowerCase();
      const defined = !!methods.find(m => m === method); 

      if (!defined) {
        return // returns from this cycle of iface.forEach
      }

      Events.listen(module, `request${method.charAt(0).toUpperCase() + method.substr(1)}`, function (request) {
        const providerCallArgs = [];
        
        // only pass in parameters object if schema exists
        if (imethod.parameters) {
          providerCallArgs.push(request.parameters);
        }
        else {
          providerCallArgs.push(null);
        }

        const session = {
          correlationId: () => {
            return request.correlationId
          }
        };
        
        // only pass in the focus handshake if needed
        if (imethod.focus) {
          session.focus = () => {
            Transport.send(module, `${method}Focus`, {
              correlationId: request.correlationId
            });
          };
        }

        providerCallArgs.push(session);

        const response = {
          correlationId: request.correlationId
        };

        try {
          const result = provider[method].apply(provider, providerCallArgs);

          if (!(result instanceof Promise)) {
            throw `Provider method ${method} did not return a Promise.`
          }
        
          result.then(result => {
            if (imethod.response) {
              response.result = result;
            }

            Transport.send(module, `${method}Response`, response);
          });
        }
        catch(error) {
          response.error = {
            code: error.code || 1000, // todo: should be some reserved code for "Unknown"
            message: error.message || `An error occured while calling provided ${method} method.`
          };

          if (error.data) {
            response.error.data = JSON.parse(JSON.stringify(error.data));
          }

          Transport.send(module, `${method}Error`, response);
        }
      });
    });
  };

  var ProvideManager = {
    provide: provide$3
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */


  registerProviderInterface('xrn:firebolt:capability:input:keyboard', 'Keyboard', [{"name":"standard","focus":true,"response":true,"parameters":true},{"name":"password","focus":true,"response":true,"parameters":true},{"name":"email","focus":true,"response":true,"parameters":true}]);






      // Methods






  function provide$2(capability, provider) {
      return ProvideManager.provide(capability, provider)
  }




    
  var Keyboard = {

provide:   provide$2
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */


  registerProviderInterface('xrn:firebolt:capability:usergrant:acknowledgechallenge', 'AcknowledgeChallenge', [{"name":"challenge","focus":true,"response":true,"parameters":true}]);




      // Methods



  function provide$1(capability, provider) {
      return ProvideManager.provide(capability, provider)
  }

    
  var AcknowledgeChallenge = {

provide:   provide$1
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */


  registerProviderInterface('xrn:firebolt:capability:usergrant:pinchallenge', 'PinChallenge', [{"name":"challenge","focus":true,"response":true,"parameters":true}]);




      // Methods



  function provide(capability, provider) {
      return ProvideManager.provide(capability, provider)
  }

    
  var PinChallenge = {

  ResultReason: {
      NO_PIN_REQUIRED: 'noPinRequired',
      NO_PIN_REQUIRED_WINDOW: 'noPinRequiredWindow',
      EXCEEDED_PIN_FAILURES: 'exceededPinFailures',
      CORRECT_PIN: 'correctPin',
      CANCELLED: 'cancelled',
  },

  provide
  };

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  registerEvents('Discovery', ["signIn","signOut"]);

  /*
   * Copyright 2021 Comcast Cable Communications Management, LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   */

  setMockResponses({
      Localization: _Localization,
      Metrics: _Metrics,
      Wifi: _Wifi,
      ClosedCaptions: _ClosedCaptions,
      AudioDescriptions: _AudioDescriptions,
      VoiceGuidance: _VoiceGuidance,
      Device: _Device,
      UserGrants: _UserGrants,
      Privacy: _Privacy,
      Advertising: _Advertising,
      Account: _Account,
      Keyboard: _Keyboard,
      AcknowledgeChallenge: _AcknowledgeChallenge,
      PinChallenge: _PinChallenge,
      SecureStorage: _SecureStorage,
      Discovery: _Discovery,
  });

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SecurityPinScreen extends t.Component {
    set params(args) {
      console.log("args:", args);
      if (args.message !== "") {
        this.tag('Description').text.text = Language$1.translate(args.message);
      }
      this.responder = args.responder;
      this.challenge = args.challenge;
      this.numFailures = 0;
      this.lockedTime = 0;
    }
    pageTransition() {
      return 'left';
    }
    handleDone() {
      console.log("Inside handle done");
      this.onPinEntered(this.textCollection['TextBox']);
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          alpha: 1,
          color: 0xCC000000
        },
        KeypadBg: {
          x: 730,
          y: 200,
          w: 380,
          h: 600,
          rect: true,
          color: 0xCC000000,
          alpha: 1
        },
        Title: {
          x: 730,
          y: 70,
          text: {
            text: Language$1.translate('Security PIN input'),
            fontFace: CONFIG.language.font,
            fontSize: 40,
            textColor: CONFIG.theme.hex
          }
        },
        Description: {
          x: 730,
          y: 130,
          text: {
            text: Language$1.translate('Default description'),
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffffffff
          }
        },
        BorderTop: {
          x: 570,
          y: 125,
          w: 700,
          h: 2,
          rect: true
        },
        TextBox: {
          x: 750,
          y: 220,
          texture: t.Tools.getRoundRect(340, 65, 0, 3, 0xffffffff, false)
        },
        PinText: {
          x: 770,
          y: 240,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Keyboard: {
          y: 300,
          x: 750,
          type: Keyboard$1,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.numbers
        }
      };
    }
    onPinEntered(pin) {
      if (pin === CONSTANTS.PINS[this.challenge.pinSpace]) {
        console.log("Correct pin");
        this.responder({
          granted: true,
          reason: PinChallenge.ResultReason.CORRECT_PIN
        });
        Router.back();
      } else {
        console.log("Wrong pin");
        this.numFailures++;
        if (this.numFailures >= CONSTANTS.MAX_FAILURES) {
          this.lockedTime = Date.now();
          this.responder({
            granted: false,
            reason: PinChallenge.ResultReason.EXCEEDED_PIN_FAILURES
          });
          Router.back();
        }
      }
    }
    _focus() {
      this.tag("PinText").text.text = "";
      this.textCollection = {
        'TextBox': '',
        'encrypted': ''
      };
    }
    _handleDown() {
      this._setState('TextBox');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    static _states() {
      return [class TextBox extends this {
        $enter() {
          this.tag('TextBox').texture = t.Tools.getRoundRect(340, 65, 0, 3, CONFIG.theme.hex, false);
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('TextBox').texture = t.Tools.getRoundRect(340, 65, 0, 3, 0xffffffff, false);
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'TextBox') {
            this.element = 'PinText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection['TextBox'] = '';
            this.textCollection['encrypted'] = '';
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          } else if (key === 'Space') {
            this.textCollection['encrypted'] += '\u25CF';
            this.textCollection['TextBox'] += ' ';
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          } else if (key === 'Delete') {
            this.textCollection['encrypted'] = this.textCollection['encrypted'].substring(0, this.textCollection['encrypted'].length - 1);
            this.textCollection['TextBox'] = this.textCollection['TextBox'].substring(0, this.textCollection['TextBox'].length - 1);
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          } else {
            this.textCollection['TextBox'] += key;
            this.textCollection['encrypted'] += '\u25CF';
            this.tag('PinText').text.text = this.textCollection['encrypted'];
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class KeyboardScreen extends t.Component {
    set params(args) {
      if (args.message !== "") {
        this.tag('Description').text.text = Language$1.translate(args.message);
      }
      this.tag('InputType').text.text = args.type;
      this.hidePasswd = false;
      this.password = false;
      if (args.type === 'password') {
        this.password = true;
        this.hidePasswd = true;
        console.log("Making the password switch visible");
        this.tag('PasswrdSwitch').patch({
          visible: true
        });
        this.tag('ShowPassword').patch({
          visible: true
        });
      }
      this.responder = args.responder;
    }
    pageTransition() {
      return 'left';
    }
    handleDone() {
      this.responder({
        text: this.textCollection['TextBox'],
        canceled: false
      });
      Router.back();
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          alpha: 1,
          color: 0xCC000000
        },
        Title: {
          x: 200,
          y: 70,
          text: {
            text: "Keyboard challenge",
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        Description: {
          x: 200,
          y: 130,
          text: {
            text: Language$1.translate('Default description'),
            fontFace: CONFIG.language.font,
            fontSize: 25,
            textColor: 0xffffffff
          }
        },
        BorderTop: {
          x: 190,
          y: 125,
          w: 1488,
          h: 2,
          rect: true
        },
        InputType: {
          x: 190,
          y: 316,
          text: {
            text: "Password: ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        InputBox: {
          x: 400,
          y: 300,
          texture: t.Tools.getRoundRect(1279, 70, 0, 3, 0xffffffff, false)
        },
        InputText: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        PasswrdSwitch: {
          h: 45,
          w: 66.9,
          x: 1642,
          y: 340,
          zIndex: 2,
          type: PasswordSwitch,
          mount: 0.5,
          visible: false
        },
        ShowPassword: {
          x: 1420,
          y: 322,
          w: 300,
          h: 75,
          zIndex: 2,
          text: {
            text: 'Show Password',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            textAlign: 'left'
          },
          visible: false
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard$1,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        },
        Cancel: {
          x: 1580,
          y: 60,
          w: 150,
          mountX: 0.5,
          h: 60,
          rect: true,
          color: 0xFFFFFFFF,
          Title: {
            x: 75,
            y: 30,
            mount: 0.5,
            text: {
              text: "Cancel",
              fontFace: CONFIG.language.font,
              fontSize: 22,
              textColor: 0xFF000000,
              fontStyle: 'bold'
            }
          },
          visible: true
        }
      };
    }
    _focus() {
      this._setState("InputBox");
      this.tag("InputText").text.text = "";
      this.textCollection = {
        'TextBox': '',
        'encrypted': ''
      };
    }
    get session() {
      return this._session;
    }
    set session(session) {
      this.donePending = false;
      this._session = session;
      this.onDone = session.onDone;
      this.onCancel = session.onCancel;
    }
    _getFocused() {
      return this;
    }
    _handleBack() {
      this.responder({
        text: '',
        canceled: true
      });
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    _updateText(txt) {
      this.tag("InputText").text.text = txt;
    }
    static _states() {
      return [class InputBox extends this {
        $enter() {
          this.tag('InputBox').texture = t.Tools.getRoundRect(1279, 70, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("Cancel");
        }
        _handleEnter() {
          this._setState('Keyboard');
        }
        $exit() {
          this.tag('InputBox').texture = t.Tools.getRoundRect(1279, 70, 0, 3, 0xffffffff, false);
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'InputBox') {
            this.element = 'InputText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        _handleUp() {
          if (this.password) this._setState("PasswordSwitchState");else this._setState("Cancel");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Delete') {
            this.textCollection['encrypted'] = this.textCollection['encrypted'].substring(0, this.textCollection['encrypted'].length - 1);
            this.textCollection['TextBox'] = this.textCollection['TextBox'].substring(0, this.textCollection['TextBox'].length - 1);
            this.tag("InputText").text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          } else if (key === 'Space') {
            this.textCollection['TextBox'] += ' ';
            this.textCollection['encrypted'] += '\u25CF';
            this.tag(this.element).text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          } else if (key === 'Clear') {
            this.textCollection['encrypted'] = '';
            this.textCollection['TextBox'] = '';
            this.tag("InputText").text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else {
            this.textCollection['TextBox'] += key;
            this.textCollection['encrypted'] += '\u25CF';
            this.tag("InputText").text.text = this.hidePasswd ? this.textCollection['encrypted'] : this.textCollection['TextBox'];
          }
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("InputBox").texture = t.Tools.getRoundRect(1279, 70, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("Cancel");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.textCollection['TextBox']);
            this.hidePasswd = false;
          } else {
            this._updateText(this.textCollection['encrypted']);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("InputBox").texture = t.Tools.getRoundRect(1279, 70, 0, 3, 0xffffffff, false);
        }
      }, class Cancel extends this {
        $enter() {
          this.tag("Cancel");
          this._focus();
        }
        _handleEnter() {
          this.responder({
            text: '',
            canceled: true
          });
          Router.back();
        }
        _handleDown() {
          if (this.hidePasswd) this._setState("PasswordSwitchState");else this._setState("InputBox");
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AcknowledgeScreen extends t.Component {
    pageTransition() {
      return 'left';
    }
    set params(args) {
      console.log("args:", args);
      if (args.message !== "") {
        this.tag('Info').text.text = Language$1.translate(args.message);
      }
      this.responder = args.responder;
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: "Acknowledge",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Default text"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            YesButton: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "Grant",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            NoButton: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "Deny",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _focus() {
      this._setState('NoButton');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        this.responder({
          granted: null
        });
        Router.back();
      }
    }
    static _states() {
      return [class YesButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.responder({
            granted: true
          });
          Router.back();
        }
        _handleRight() {
          this._setState('NoButton');
        }
        _focus() {
          this.tag('YesButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('YesButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class NoButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.responder({
            granted: false
          });
          Router.back();
        }
        _handleLeft() {
          this._setState('YesButton');
        }
        _focus() {
          this.tag('NoButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('NoButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var otherSettingsRoutes = {
    otherSettingsRoutes: [{
      path: 'settings/other',
      component: OtherSettingsScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/timer',
      component: SleepTimerScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/energy',
      component: EnergySavingsScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/language',
      component: LanguageScreen$2,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/privacy',
      component: PrivacyScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: "settings/other/SecurityPinScreen",
      component: SecurityPinScreen
    }, {
      path: "settings/other/KeyboardScreen",
      component: KeyboardScreen
    }, {
      path: "settings/other/AcknowledgeScreen",
      component: AcknowledgeScreen
    }, {
      path: 'settings/advanced',
      component: AdvanceSettingsScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device',
      component: DeviceScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/info',
      component: DeviceInformationScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/timezone',
      component: TimeZone$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/timezone/item',
      component: TimeItems,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/firmware',
      component: FirmwareScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/advanced/device/reboot',
      component: RebootConfirmationScreen$1
    }, {
      path: 'settings/advanced/device/factoryReset',
      component: RebootConfirmationScreen
    }, {
      path: 'settings/other/ScreenSaver',
      component: SreenSaverScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/other/privacyPolicy',
      component: PrivacyPolicyScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Audio screen.
   */

  class AudioScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Audio'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        Wrapper: {
          x: 200,
          y: 275,
          AudioOutput: {
            alpha: 0.3,
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Output: ') + " HDMI",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputMode: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Mode: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          DynamicRange: {
            alpha: 0.3,
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Full Dynamic Range'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AudioLanguage: {
            y: 270,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Language: ') + "Auto",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NavigationFeedback: {
            y: 360,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Navigation Feedback'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 66,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOnWhite.png')
            }
          },
          Bluetooth: {
            alpha: 0.3,
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth: ') + "None",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('OutputMode');
    }
    _focus() {
      this._setState(this.state);
      this.appApi.getSoundMode().then(result => {
        this.tag('OutputMode.Title').text.text = Language$1.translate('Output Mode: ') + result.soundMode;
      });
    }
    hide() {
      this.tag('Wrapper').visible = false;
    }
    show() {
      this.tag('Wrapper').visible = true;
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    static _states() {
      return [class AudioOutput extends this {
        $enter() {
          this.tag('AudioOutput')._focus();
        }
        $exit() {
          this.tag('AudioOutput')._unfocus();
        }
        _handleDown() {
          this._setState('OutputMode');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/audio/output');
          }
        }
      }, class OutputMode extends this {
        $enter() {
          this.tag('OutputMode')._focus();
        }
        $exit() {
          this.tag('OutputMode')._unfocus();
        }
        _handleUp() {
          // this._setState('AudioOutput')
        }
        _handleDown() {
          // this._setState('DynamicRange');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/audio/output');
          }
        }
      }, class DynamicRange extends this {
        $enter() {
          this.tag('DynamicRange')._focus();
        }
        $exit() {
          this.tag('DynamicRange')._unfocus();
        }
        _handleUp() {
          this._setState('OutputMode');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          /**
           * This handle Enter has api calls -
           * 1 - get DRC Mode which doesnot return a drc mode and the success value is mostly false
           * 2- set Volume - able to set the value to 100
           * 3- get Volume - able to get the volume successfully as well
           * 4- 
           * 
           */
          //console.log(`Enter input was given to dynamic range ... `);
          // gets the drc mode
          this.appApi.getDRCMode().then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.setVolumeLevel(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0", 100).then(res => {
            this.appApi.getVolumeLevel().catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
          this.appApi.getConnectedAudioPorts().then(res => {}).catch(err => {
            console.log(err);
          });
          // gets the enabled Audio Port
          this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.getSupportedAudioPorts().catch(err => {
            console.log("Error while getting the supported Audio ports ie. ".concat(err));
          });

          // set enable Audio POrt
          this.appApi.setEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {
            this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });

          // set zoom setting ,possible values : FULL, NONE, Letterbox 16x9, Letterbox 14x9, CCO, PanScan, Letterbox 2.21 on 4x3, Letterbox 2.21 on 16x9, Platform, Zoom 16x9, Pillarbox 4x3, Widescreen 4x3
          this.appApi.setZoomSetting("FULL").then(res => {
            this.appApi.getZoomSetting().then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
        }
      }, class NavigationFeedback extends this {
        $enter() {
          this.tag('NavigationFeedback')._focus();
        }
        $exit() {
          this.tag('NavigationFeedback')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          //
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class VideoAndAudioItem extends t.Component {
    _construct() {
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1920 - 300,
          h: 90,
          rect: true,
          color: 0x00000000
        },
        BottomLine: {
          y: 0 + 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }
    _init() {
      if (this.isTicked) {
        this.fireAncestors("$resetPrevTickObject", this);
      }
      this.appApi = new AppApi();
    }
    _handleEnter() {
      if (this.videoElement === true) {
        this.appApi.setResolution(this._item).catch(err => {
          console.log("there was an error while setting the resolution.");
        });
      } else {
        this.appApi.setSoundMode(this._item).then(result => {
          if (result.success === true) {
            this.fireAncestors("$resetPrevTickObject", this);
            this.tag("Item.Tick").visible = true;
            // this.tag('HdmiAudioOutputStereo.Title').text.text = 'HdmiAudioOutputStereo: ' + soundMode
          }
          //this.tag('HdmiAudioOutputStereo.Title').text.text = 'HdmiAudioOutputStereo: ' + result.soundMode
          this.fireAncestors("$updateSoundMode", this._item);
        }).catch(err => {
          console.log('Some error while setting the sound mode ', err);
        });
      }
    }
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: this.isTicked ? true : false //implement the logic to show the tick
        },

        Left: {
          x: 50,
          y: 45,
          mountY: 0.5,
          text: {
            text: item,
            fontSize: 25,
            textColor: 0xffFFFFFF,
            fontFace: CONFIG.language.font
          } // update the text
        }
      });
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI Output Screen.
   */
  var appApi$7 = new AppApi();
  class HdmiOutputScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Audio  Output Mode'));
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        HdmiOutputScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _init() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      appApi$7.getSoundMode().then(result => {
        appApi$7.getSupportedAudioModes().then(res => {
          options = [...res.supportedAudioModes];
          this.tag('HdmiOutputScreenContents').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').items = options.map((item, index) => {
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: result.soundMode === item ? true : false,
              item: item,
              videoElement: false
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this._setState("Options");
        }).catch(err => {
          console.log('error', err);
        });
      }).catch(err => {
        console.log('error', JSON.stringify(err));
      });
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/audio');
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('HdmiOutputScreenContents.List').element;
        }
        _handleDown() {
          this.tag('HdmiOutputScreenContents.List').setNext();
        }
        _handleUp() {
          this.tag('HdmiOutputScreenContents.List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$d = thunderJS$1({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });

  /**
   * Class for Resolution Screen.
   */

  class ResolutionScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Video  Resolution'));
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xCC000000,
        ResolutionScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.appApi.activateDisplaySettings();
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      thunder$d.on('org.rdk.DisplaySettings', 'resolutionPreChange', notification => {
        console.log(new Date().toISOString() + " ResolutionScreen got resolutionPreChange");
        Storage$1.set("ResolutionChangeInProgress", true);
      });
      thunder$d.on('org.rdk.DisplaySettings', 'resolutionChanged', notification => {
        console.log(new Date().toISOString() + " ResolutionScreen got resolutionChanged");
        const items = this.tag('List').items;
        items.forEach(element => {
          element.tag('Item.Tick').visible = false;
          if (element._item === notification.resolution) {
            element.tag('Item.Tick').visible = true;
          }
        });
        Storage$1.set("ResolutionChangeInProgress", false);
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings/video');
      }
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      let sIndex = 0;
      this.appApi.getResolution().then(resolution => {
        this.appApi.getSupportedResolutions().then(res => {
          options = [...res];
          this.tag('ResolutionScreenContents').h = options.length * 90;
          this.tag('ResolutionScreenContents.List').h = options.length * 90;
          this.tag('List').items = options.map((item, index) => {
            let bool = false;
            if (resolution === item) {
              bool = true;
              sIndex = index;
            }
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: bool,
              item: item,
              videoElement: true
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this.tag('List').setIndex(sIndex);
          this._setState("Options");
        }).catch(err => {
          console.log("error while fetching the supported resolution ".concat(err));
        });
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video screen.
   */

  class VideoScreen$1 extends t.Component {
    pageTransition() {
      return 'left';
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings  Video'));
    }
    static _template() {
      return {
        rect: true,
        color: 0xCC000000,
        w: 1920,
        h: 1080,
        VideoScreenContents: {
          x: 200,
          y: 275,
          Resolution: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Resolution: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDR: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('High Dynamic Range: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MatchContent: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Match Content: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputFormat: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Format:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Chroma: {
            alpha: 0.3,
            // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Chroma:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDCP: {
            y: 450,
            h: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('HDCP Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Resolution');
    }
    _focus() {
      this._appApi.getResolution().then(resolution => {
        this.tag("Resolution.Title").text.text = Language$1.translate('Resolution: ') + resolution;
      }).catch(err => {
        console.log("Error fetching the Resolution");
      });
      this._appApi.getHDCPStatus().then(result => {
        if (result.isHDCPCompliant && result.isHDCPEnabled) {
          this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Enabled, Version: ").concat(result.currentHDCPVersion);
        } else {
          this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Not Supported ");
        }
      });
      this._appApi.getHDRSetting().then(result => {
        const availableHDROptions = {
          "HdrOff": "Off",
          "Hdr10": "HDR 10",
          "Hdr10Plus": "HDR 10+",
          "HdrHlg": "HLG",
          "HdrDolbyvision": "Dolby Vision",
          "HdrTechnicolor": "Technicolor HDR"
        };
        this.tag("HDR.Title").text.text = Language$1.translate('High Dynamic Range: ') + availableHDROptions[result];
      });
      this._setState(this.state);
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('settings');
      }
    }
    static _states() {
      return [class Resolution extends this {
        $enter() {
          this.tag('Resolution')._focus();
        }
        $exit() {
          this.tag('Resolution')._unfocus();
        }
        _handleDown() {
          this._setState('HDR');
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('settings/video/resolution');
          }
        }
      }, class HDR extends this {
        $enter() {
          this.tag('HDR')._focus();
        }
        $exit() {
          this.tag('HDR')._unfocus();
        }
        _handleUp() {
          this._setState('Resolution');
        }
        _handleDown() {
          this._setState('HDCP');
        }
      }, class MatchContent extends this {
        $enter() {
          this.tag('MatchContent')._focus();
        }
        $exit() {
          this.tag('MatchContent')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleDown() {
          this._setState('OutputFormat');
        }
        _handleEnter() {
          //
        }
      }, class OutputFormat extends this {
        $enter() {
          this.tag('OutputFormat')._focus();
        }
        $exit() {
          this.tag('OutputFormat')._unfocus();
        }
        _handleUp() {
          this._setState('MatchContent');
        }
        _handleDown() {
          this._setState('Chroma');
        }
        _handleEnter() {
          //
        }
      }, class Chroma extends this {
        $enter() {
          this.tag('Chroma')._focus();
        }
        $exit() {
          this.tag('Chroma')._unfocus();
        }
        _handleUp() {
          this._setState('OutputFormat');
        }
        _handleDown() {
          // this._setState('HDCP') 
        }
        _handleEnter() {
          //
        }
      }, class HDCP extends this {
        // class not required
        $enter() {
          this.tag('HDCP')._focus();
        }
        $exit() {
          this.tag('HDCP')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleEnter() {
          //
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var audioScreenRoutes = {
    audioScreenRoutes: [{
      path: 'settings/audio',
      component: AudioScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/audio/output',
      component: HdmiOutputScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/video',
      component: VideoScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'settings/video/resolution',
      component: ResolutionScreen$1,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const errorTitle$1 = 'Error Title';
  const errorMsg$1 = 'Error Message';
  class Failscreen extends t.Component {
    notify(args) {
      console.log(args);
      if (args.title && args.msg) {
        this.tag('FailScreen.Title').text.text = args.title;
        this.tag('FailScreen.Message').text.text = Language$1.translate(args.msg);
      }
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this.alpha = 1;
      setTimeout(function () {
        Router.focusPage();
      }, 20000);
    }
    _unfocus() {
      this.alpha = 0;
      this.tag('FailScreen.Title').text.text = errorTitle$1;
      this.tag('FailScreen.Message').text.text = errorMsg$1;
    }
    static _template() {
      return {
        alpha: 0,
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xff000000,
        FailScreen: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: errorTitle$1,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Message: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: errorMsg$1,
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          RectangleDefault: {
            x: 0,
            y: 200,
            w: 200,
            mountX: 0.5,
            h: 50,
            rect: true,
            color: CONFIG.theme.hex,
            Ok: {
              x: 100,
              y: 25,
              mount: 0.5,
              text: {
                text: Language$1.translate("OK"),
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    set item(error) {
      this.tag('Pairing').text = error;
    }
    _handleEnter() {
      Router.focusPage();
    }
    _handleBack() {
      Router.focusPage();
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in main view.
   */
  class UsbListItem extends t.Component {
    /**
     * Function to render various elements in the main view item.
     */
    static _template() {
      return {
        Item: {
          Shadow: {
            alpha: 0
          },
          y: 20,
          Image: {},
          Info: {}
        }
      };
    }
    _init() {
      this.tag('Shadow').patch({
        color: CONFIG.theme.hex,
        rect: true,
        h: this.h + 24,
        w: this.w,
        x: this.x,
        y: this.y - 12
      });
      if (this.data.url.startsWith('/images')) {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: Utils.asset(this.data.url),
          scale: this.unfocus
        });
      } else {
        this.tag('Image').patch({
          rtt: true,
          x: this.x,
          y: this.y,
          w: this.w,
          h: this.h,
          src: this.data.url
        });
      }

      /* Used static data for develpment purpose ,
      it wil replaced with Dynamic data once implimetation is completed.*/
      this.tag('Info').patch({
        x: this.x - 20,
        y: this.y + this.h + 10,
        w: this.w,
        h: 140,
        alpha: 0,
        PlayIcon: {
          Label: {
            x: this.idx === 0 ? this.x + 20 : this.x + 10,
            y: this.y + 10,
            text: {
              fontFace: CONFIG.language.font,
              text: this.data.displayName,
              fontSize: 20,
              maxLines: 2,
              wordWrapWidth: this.w
            }
          }
        }
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        zIndex: 1,
        scale: this.focus
      });
      this.tag('Info').alpha = 1;
      this.tag('Item').patch({
        zIndex: 2
      });
      this.tag('Shadow').patch({
        scale: this.focus,
        alpha: 1
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
      this.tag('Item').patch({
        zIndex: 0
      });
      this.tag('Info').alpha = 0;
      this.tag('Shadow').patch({
        alpha: 0
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var usbApi = new UsbApi();
  class UsbAppsScreen extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText('USB');
    }
    static _template() {
      return {
        UsbAppsScreenContents: {
          rect: true,
          color: 0xff000000,
          x: 200,
          y: 270,
          w: 1765,
          h: 1250,
          clipping: true,
          Wrapper: {
            x: 0,
            w: 1765,
            h: 1250,
            clipping: true,
            Text1: {
              y: 0,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Videos"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row1: {
              y: 30,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: t.components.ListComponent,
              w: 1745,
              h: 300,
              itemSize: 277,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text2: {
              // x: 10 + 25,
              y: 243,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Audio"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row2: {
              y: 273,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: t.components.ListComponent,
              w: 1745,
              h: 300,
              itemSize: 171,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text3: {
              // x: 10 + 25,
              y: 486,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Photos"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row3: {
              y: 516,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: t.components.ListComponent,
              w: 1745,
              h: 400,
              itemSize: 165,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            },
            Text4: {
              // x: 10 + 25,
              y: 729,
              h: 30,
              text: {
                fontFace: CONFIG.language.font,
                fontSize: 25,
                text: Language$1.translate("Folders"),
                fontStyle: 'normal',
                textColor: 0xFFFFFFFF
              },
              zIndex: 0
            },
            Row4: {
              y: 759,
              x: -20,
              flex: {
                direction: 'row',
                paddingLeft: 20,
                wrap: false
              },
              type: t.components.ListComponent,
              w: 1745,
              h: 400,
              itemSize: 165,
              roll: true,
              rollMax: 1745,
              horizontal: true,
              itemScrollOffset: -4,
              clipping: false
            }
          },
          NoUSB: {
            x: 0,
            w: 1765,
            h: 800,
            clipping: true,
            visible: false,
            Image: {
              x: 800,
              y: 400,
              mount: 0.5,
              texture: {
                type: t.textures.ImageTexture,
                src: 'static/images/usb/Unsupported_file_640x360.jpg',
                resizeMode: {
                  type: 'contain',
                  w: 640,
                  h: 360
                }
              }
            }
          }
        },
        AudioInfo: {
          zIndex: 2,
          visible: false,
          h: 1080,
          w: 1920,
          // x: -200,
          // y: -286,
          Image: {
            scale: 0.5,
            x: 960,
            y: 560,
            mount: 0.5,
            texture: {
              type: t.textures.ImageTexture,
              src: 'static/images/Media Player/Audio_Background_16k.jpg'
            }
          },
          Title: {
            x: 960,
            y: 900,
            mount: 0.5,
            text: {
              fontFace: CONFIG.language.font,
              text: 'file_name.mp3',
              fontSize: 35
            }
          }
        },
        PlayerControls: {
          type: LightningPlayerControls,
          y: 810,
          alpha: 0,
          signals: {
            pause: 'pause',
            play: 'play',
            hide: 'hidePlayerControls',
            fastfwd: 'fastfwd',
            fastrwd: 'fastrwd'
          },
          zIndex: 4
        }
      };
    }
    _handleBack() {
      if (!(this.cwd.length === 0)) {
        let clone = [...this.cwd];
        clone.pop();
        let cwdname = clone.join("/");
        usbApi.cd(cwdname).then(res => {
          this.cwd.pop();
          this.loadData();
        }).catch(err => {
          console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
        });
      } else {
        Router.navigate('menu');
      }
    }
    reset() {
      for (let i = this.tag('Row1').index; i > 0; i--) {
        this.tag('Row1').setPrevious();
      }
      for (let i = this.tag('Row2').index; i > 0; i--) {
        this.tag('Row2').setPrevious();
      }
      for (let i = this.tag("Row3").index; i > 0; i--) {
        this.tag('Row3').setPrevious();
      }
      for (let i = this.tag("Row3").index; i > 0; i--) {
        this.tag('Row4').setPrevious();
      }
    }
    hide() {
      this.tag('UsbAppsScreenContents').visible = false;
      this.fireAncestors('$hideAllforVideo');
    }
    show() {
      this.tag('UsbAppsScreenContents').visible = true;
      this.fireAncestors('$showAllforVideo');
    }
    traverseMinus() {
      this.index = (this.traversableRows.length + --this.index) % this.traversableRows.length;
      this._setState(this.traversableRows[this.index]);
    }
    traversePlus() {
      this.index = ++this.index % this.traversableRows.length;
      this._setState(this.traversableRows[this.index]);
    }
    static _states() {
      return [class Video extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text1').text.fontStyle = 'bold';
          if (this.tag('Row1').length) {
            return this.tag('Row1').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleRight() {
          if (this.tag('Row1').length - 1 != this.tag('Row1').index) {
            this.tag('Row1').setNext();
            return this.tag('Row1').element;
          }
        }
        _handleEnter() {
          Router.navigate('usb/player', {
            url: this.tag('Row1').element.data.uri,
            currentIndex: this.tag('Row1').element.idx,
            list: this.tag('Row1').items,
            isUSB: true
          });
        }
        _handleLeft() {
          this.tag('Text1').text.fontStyle = 'normal';
          if (0 != this.tag('Row1').index) {
            this.tag('Row1').setPrevious();
            return this.tag('Row1').element;
          } else {
            this.reset();
          }
        }
      }, class Audio extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text2').text.fontStyle = 'bold';
          if (this.tag('Row2').length) {
            return this.tag('Row2').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          Router.navigate('usb/player', {
            url: this.tag('Row2').element.data.uri,
            isAudio: true,
            list: this.tag('Row2').items,
            currentIndex: this.tag('Row2').element.idx,
            isUSB: true
          });
        }
        _handleRight() {
          if (this.tag('Row2').length - 1 != this.tag('Row2').index) {
            this.tag('Row2').setNext();
            return this.tag('Row2').element;
          }
        }
        _handleLeft() {
          this.tag('Text2').text.fontStyle = 'normal';
          if (0 != this.tag('Row2').index) {
            this.tag('Row2').setPrevious();
            return this.tag('Row2').element;
          } else {
            this.reset();
          }
        }
      }, class Picture extends this {
        $enter() {
          this.scroll(0);
        }
        _getFocused() {
          this.tag('Text3').text.fontStyle = 'bold';
          if (this.tag('Row3').length) {
            return this.tag('Row3').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          // console.log(this.tag('Row3').items)
          Router.navigate('usb/image', {
            src: this.tag('Row3').element.data.uri,
            currentIndex: this.tag('Row3').element.idx,
            list: this.tag('Row3').items,
            cwd: this.cwd
          });
        }
        _handleRight() {
          if (this.tag('Row3').length - 1 != this.tag('Row3').index) {
            this.tag('Row3').setNext();
            return this.tag('Row3').element;
          }
        }
        _handleLeft() {
          this.tag('Text3').text.fontStyle = 'normal';
          if (0 != this.tag('Row3').index) {
            this.tag('Row3').setPrevious();
            return this.tag('Row3').element;
          } else {
            this.reset();
          }
        }
      }, class Folder extends this {
        $enter() {
          if (this.traversableRows.length > 3) {
            this.scroll(-243);
          }
        }
        _getFocused() {
          this.tag('Text4').text.fontStyle = 'bold';
          if (this.tag('Row4').length) {
            return this.tag('Row4').element;
          }
        }
        _handleDown() {
          this.traversePlus();
        }
        _handleUp() {
          this.traverseMinus();
        }
        _handleEnter() {
          //do something after folder click.
          let dname = this.cwd.join("/") + "/" + this.tag('Row4').element.data.displayName;
          usbApi.cd(dname).then(res => {
            this.cwd.push(this.tag('Row4').element.data.displayName);
            // console.log(`loading the data from the directory ${this.cwd}

            // and its data = music:${JSON.stringify(musicListInfo)}

            // Pictures : ${JSON.stringify(imageListInfo)}

            // videos : ${JSON.stringify(videoListInfo)}

            // folders : ${JSON.stringify(UsbInnerFolderListInfo)}

            // `);
            this.loadData();
          }).catch(err => {
            console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
          });
        }
        _handleRight() {
          if (this.tag('Row4').length - 1 != this.tag('Row4').index) {
            this.tag('Row4').setNext();
            return this.tag('Row4').element;
          }
        }
        _handleLeft() {
          this.tag('Text4').text.fontStyle = 'normal';
          if (0 != this.tag('Row4').index) {
            this.tag('Row4').setPrevious();
            return this.tag('Row4').element;
          } else {
            this.reset();
          }
        }
      }];
    }
    set params(args) {
      this.currentIndex = args.currentIndex;
      this.thisDir = args.cwd;
    }
    set Row1Items(items) {
      this.tag('Row1').items = items.map((info, idx) => {
        return {
          w: 257,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row1').start();
    }
    set Row2Items(items) {
      this.tag('Row2').items = items.map((info, idx) => {
        return {
          w: 151,
          h: 151,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row2').start();
    }
    set Row3Items(items) {
      this.tag('Row3').items = items.map((info, idx) => {
        return {
          w: 145,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row3').start();
    }
    set Row4Items(items) {
      this.tag('Row4').items = items.map((info, idx) => {
        return {
          w: 145,
          h: 145,
          type: UsbListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx
        };
      });
      this.tag('Row4').start();
    }
    scroll(y) {
      this.tag('Wrapper').setSmooth('y', y, {
        duration: 0.5
      });
    }
    loadData() {
      // console.log(`loading data from the directory ${this.cwd}`);
      let sumY = 0;
      this.index = 0;
      this.traversableRows = [];
      this.Row1Items = videoListInfo;
      this.Row2Items = musicListInfo;
      this.Row3Items = imageListInfo;
      this.Row4Items = UsbInnerFolderListInfo;
      let text1 = this.tag("Text1");
      let row1 = this.tag('Row1');
      let text2 = this.tag("Text2");
      let row2 = this.tag('Row2');
      let text3 = this.tag("Text3");
      let row3 = this.tag('Row3');
      let text4 = this.tag('Text4');
      let row4 = this.tag('Row4');
      if (videoListInfo.length === 0 && musicListInfo.length === 0 && imageListInfo.length === 0 && UsbInnerFolderListInfo.length === 0) {
        this.tag('NoUSB').visible = true;
        text1.visible = false;
        row1.visible = false;
        text2.visible = false;
        row2.visible = false;
        text3.visible = false;
        row3.visible = false;
        text4.visible = false;
        row4.visible = false;
        //either the usb is not mounted or there aren't any videos , images or audio files.
      } else {
        this.tag('NoUSB').visible = false;
        if (videoListInfo.length === 0) {
          text1.visible = false;
          row1.visible = false;
        } else {
          this.traversableRows.push("Video");
          text1.visible = true;
          row1.visible = true;
          text1.y = sumY;
          row1.y = sumY + 30;
          sumY += 243;
        }
        if (musicListInfo.length === 0) {
          text2.visible = false;
          row2.visible = false;
        } else {
          this.traversableRows.push("Audio");
          text2.visible = true;
          row2.visible = true;
          text2.y = sumY;
          row2.y = sumY + 30;
          sumY += 243;
        }
        if (imageListInfo.length === 0) {
          text3.visible = false;
          row3.visible = false;
        } else {
          this.traversableRows.push("Picture");
          text3.visible = true;
          row3.visible = true;
          text3.y = sumY;
          row3.y = sumY + 30;
          sumY += 243;
        }
        if (UsbInnerFolderListInfo.length === 0) {
          text4.visible = false;
          row4.visible = false;
        } else {
          this.traversableRows.push("Folder");
          text4.visible = true;
          row4.visible = true;
          text4.y = sumY;
          row4.y = sumY + 30;
          sumY += 243;
        }
        this._setState(this.traversableRows[0]);
      }
    }
    _focus() {
      if (this.thisDir) {
        if (this.thisDir.length > 0) {
          this.cwd = [...this.thisDir];
          let dname = this.cwd.join("/");
          usbApi.cd(dname).then(res => {
            this.loadData();
            this._setState(this.traversableRows[this.index] + ".".concat(this.currentIndex)); //focus on first element
          }).catch(err => {
            console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
          });
        }
      } else {
        this.index = 0;
        this.traversableRows = [];
        this.cwd = [];
        usbApi.retrieUsb().then(res => {
          this.loadData();
          this._setState(this.traversableRows[this.index]);
        }).catch(err => {
          console.error("error while getting the usb contents; error = ".concat(JSON.stringify(err)));
        });
      }
      // this._setState(this.traversableRows[this.index])
    }

    _unfocus() {
      //this.exitFunctionality()
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const defaultImage = 'static/images/usb/USB_Photo_Placeholder.jpg';
  class ImageViewer extends t.Component {
    set params(args) {
      this.currentIndex = args.currentIndex;
      this.data = args.list;
      this.cwd = args.cwd;
      if (this.data != undefined && this.data.length > 1) {
        this.tag('Controls').alpha = 1;
      } else {
        this.tag('Controls').alpha = 0;
      }
      if (args.src) {
        this.tag('Image').texture.src = args.src;
      }
    }
    _handleRight() {
      if (this.data[this.currentIndex + 1]) {
        this.currentIndex += 1;
        this.tag('Image').texture.src = this.data[this.currentIndex].data.uri;
      }
    }
    _handleLeft() {
      if (this.data[this.currentIndex - 1]) {
        this.currentIndex -= 1;
        this.tag('Image').texture.src = this.data[this.currentIndex].data.uri;
      }
    }
    _handleBack() {
      if (this.cwd) {
        Router.navigate('usb', {
          currentIndex: this.currentIndex,
          cwd: this.cwd
        });
      } else {
        Router.back();
      }
    }
    _unfocus() {
      this.tag('Image').texture.src = defaultImage;
    }
    static _template() {
      return {
        h: 1080,
        w: 1920,
        rect: true,
        color: 0xff000000,
        zIndex: 2,
        visible: false,
        Image: {
          x: 960,
          y: 540,
          mount: 0.5,
          texture: {
            type: t.textures.ImageTexture,
            src: defaultImage,
            resizeMode: {
              type: 'contain',
              w: 1920,
              h: 1080
            }
          }
        },
        Controls: {
          x: 960,
          y: 930,
          h: 75,
          w: 100,
          Previous: {
            x: -50,
            w: 75,
            h: 75,
            mount: 0.5,
            texture: {
              type: t.textures.ImageTexture,
              src: 'static/images/Media Player/Icon_Back_White_16k.png'
            }
          },
          Next: {
            x: 50,
            w: 75,
            h: 75,
            mount: 0.5,
            texture: {
              type: t.textures.ImageTexture,
              src: 'static/images/Media Player/Icon_Next_White_16k.png'
            }
          }
        }
      };
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class LogoScreen extends t.Component {
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        Logo: {
          mount: 0.5,
          x: 960,
          y: 540,
          src: Utils.asset('/images/splash/RDKLogo.png')
        },
        Sub: {
          mountY: 1,
          mountX: 0.5,
          x: 960,
          y: 1000,
          w: 216,
          h: 121,
          src: Utils.asset('/images/splash/gracenote.png')
        }
      };
    }
    pageTransition() {
      return 'right';
    }
    _init() {
      this.btApi = new BluetoothApi();
    }
    checkPath(path) {
      if (path === 'ui') {
        return 'ui';
      }
      return 'menu';
    }
    _firstEnable() {
      console.timeEnd('PerformanceTest');
      console.log('Splash Screen timer end - ', new Date().toUTCString());
    }
    async _focus() {
      let path = Storage$1.get('setup') === "true" ? 'menu' : 'splash/bluetooth';
      var map = {
        37: false,
        38: false,
        39: false,
        40: false
      };
      this.handler = e => {
        if (e.keyCode in map) {
          map[e.keyCode] = true;
          if (map[37] && map[38] && map[39] && map[40]) {
            path = 'ui';
          }
        }
      };
      Registry.addEventListener(document, 'keydown', this.handler);
      await this.btApi.btactivate().then(res => {
        console.log("btactivate", res);
      });
      this.btApi.getPairedDevices().then(devices => {
        console.log(devices);
        if (devices.length > 0 || Storage$1.get('setup')) {
          path = this.checkPath(path);
        }
      }).catch(() => {
        console.log('Paired Device Error');
        path = this.checkPath(path);
      });
      setTimeout(() => {
        Router.navigate(path);
      }, 5000);
    }
    _unfocus() {
      Registry.removeEventListener(document, 'keydown', this.handler);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var appApi$6 = new AppApi();
  var bluetoothApi = new BluetoothApi();
  const config$b = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const _thunder = thunderJS$1(config$b);
  class BluetoothScreen$1 extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Bluetooth: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Pair your remote control"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex,
              fontStyle: 'bold'
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 135,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Put the remote control in pairing mode; scan will start in one moment"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            },
            visible: true
          },
          Timer: {
            x: 0,
            y: 200,
            mountX: 0.5,
            text: {
              text: "0:30",
              fontFace: CONFIG.language.font,
              fontSize: 80
            },
            visible: true
          },
          Loader: {
            x: 0,
            y: 200,
            mountX: 0.5,
            w: 110,
            h: 110,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          },
          Buttons: {
            Continue: {
              x: 0,
              y: 210,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Continue Setup"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: false
            },
            StartPairing: {
              x: 0,
              y: 410,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("SKIP"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true,
              alpha: 0.5
            }
          },
          BorderBottom: {
            x: 0,
            y: 350,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _active() {
      this.timeout = 30;
    }
    _PairingApis() {
      //bluetoothApi.btactivate().then(enableResult =>{
      //  console.log('1')
      bluetoothApi.enable().then(res => {
        console.log("SplashBluetoothScreen enable result: ", res);
        bluetoothApi.startScanBluetooth().then(startScanresult => {
          console.log('SplashBluetoothScreen startScanresult ', startScanresult);
          var SubscribeEvent = _thunder.on('org.rdk.Bluetooth', 'onDiscoveredDevice', notification => {
            bluetoothApi.getDiscoveredDevices().then(getdocoveredInfo => {
              console.log('SplashBluetoothScreen onDiscoveredDevice ', getdocoveredInfo[0].name);
              this.tag('Info').text.text = "pairing this device ".concat(getdocoveredInfo[0].name);
              //bluetoothApi.connect(getdocoveredInfo[0].deviceID, getdocoveredInfo[0].deviceType).then(connectresult=>{
              //  console.log("connectresult",connectresult)
              bluetoothApi.pair(getdocoveredInfo[0].deviceID).then(Pairresult => {
                console.log("SplashBluetoothScreen Pairresult", Pairresult);
                bluetoothApi.getConnectedDevices().then(getCdresult => {
                  console.log("SplashBluetoothScreen getConnectedDevices", getCdresult);
                  bluetoothApi.getPairedDevices().then(getpairedDevices => {
                    console.log("SplashBluetoothScreen getpairedDevices", getpairedDevices);
                    bluetoothApi.stopScan().then(stopScan => {
                      console.log("SplashBluetoothScreen stopscan", stopScan);
                      SubscribeEvent.dispose();
                      //bluetoothApi.disable().then(disable =>{
                      //console.log("disable")
                      bluetoothApi.deactivateBluetooth().then(deactivateBluetooth => {
                        console.log("SplashBluetoothScreen DeactivatedBluetooth", deactivateBluetooth);
                        if (Router.getActiveHash() === "splash/bluetooth") {
                          Router.navigate('splash/language');
                        }
                      });
                    }).catch(err => {
                      console.error("SplashBluetoothScreen cant stopscan device : ".concat(JSON.stringify(err)));
                    });
                  }).catch(err => {
                    console.error("SplashBluetoothScreen cant getpaired device : ".concat(JSON.stringify(err)));
                  });
                }).catch(err => {
                  console.error("SplashBluetoothScreen Can't getconnected device : ".concat(JSON.stringify(err)));
                });
              }).catch(err => {
                console.error("SplashBluetoothScreen Can't pair device : ".concat(JSON.stringify(err)));
              });
            });
          });
        }).catch(err => {
          console.error("Can't scan enable : ".concat(JSON.stringify(err)));
        });
      });
    }
    onStatusCB(cbData) {
      console.log("BluetoothScreen cbData:", JSON.stringify(cbData));
      // getStatus response has 'success' property; notification payload does not have that.
      if (cbData !== undefined && (cbData.hasOwnProperty("success") ? cbData.success : true)) {
        if (cbData.status.remoteData.length) {
          console.log("BluetoothScreen rcPairingApis RemoteData Length ", cbData.status.remoteData.length);
          cbData.status.remoteData.map(item => {
            this.tag('Info').text.text = "paired with device ".concat(item.name);
            // Do not clear this.RCTimeout if need to run this in background to reconnect on loss.
            // if (this.RCTimeout) {
            //     console.log("SplashBluetoothScreen clearTimeout(this.RCTimeout)");
            //     Registry.clearTimeout(this.RCTimeout)
            // }
            // To stop the display counter.
            if (Router.getActiveHash() === "splash/bluetooth") {
              if (this.timeInterval) {
                Registry.clearInterval(this.timeInterval);
              }
              Registry.setTimeout(() => {
                Router.navigate('splash/language');
              }, 2000);
            }
          });
        } else {
          switch (cbData.status.pairingState) {
            case "IDLE":
            case "FAILED":
              RCApi.get().startPairing(30);
              break;
          }
        }
      }
    }
    async rcPairingFlow() {
      let activatePlugin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (activatePlugin) {
        await RCApi.get().activate().catch(err => {
          console.error("SplashBluetoothScreen org.rdk.RemoteControl activate error:", err);
          return;
        });
      }
      _thunder.on('org.rdk.RemoteControl', 'onStatus', data => {
        this.onStatusCB(data);
      });
      this.RCTimeout = Registry.setTimeout(() => {
        RCApi.get().getNetStatus().then(result => {
          this.onStatusCB(result);
        });
      }, 5, true);
    }
    _init() {
      appApi$6.getPluginStatus('org.rdk.RemoteControl').then(result => {
        if (result[0].state != "activated") {
          console.log("SplashBluetoothScreen init RemoteControl activate.");
          this.rcPairingFlow(true);
        } else {
          console.log("SplashBluetoothScreen init RemoteControl already activated.");
          this.rcPairingFlow();
        }
      }).catch(err => {
        console.log('SplashBluetoothScreen getPluginStatus org.rdk.RemoteControl error:', JSON.stringify(err));
        appApi$6.getPluginStatusParams('org.rdk.Bluetooth').then(pluginresult => {
          console.log("SplashBluetoothScreen getPluginStatusParams org.rdk.Bluetooth:", pluginresult[1]);
          if (pluginresult[1] === 'deactivated') {
            bluetoothApi.btactivate().then(result => {
              console.log("SplashBluetoothScreen init pairing bluetooth");
              this._PairingApis();
            });
          } else {
            console.log("SplashBluetoothScreen init status not deactivated");
            this._PairingApis();
          }
        });
      });
    }
    _active() {
      this.initTimer();
    }
    pageTransition() {
      return 'left';
    }
    initTimer() {
      this.timeInterval = Registry.setInterval(() => {
        if (this.timeout > 0) {
          --this.timeout;
        } else {
          this.timeout = 30;
        }
        this.tag('Timer').text.text = this.timeout >= 10 ? "0:".concat(this.timeout) : "0:0".concat(this.timeout);
        if (this.timeout === 0) this._setState('StartPairing');
      }, 1000);
    }
    _inactive() {
      if (this.timeInterval) {
        Registry.clearInterval(this.timeInterval);
      }
      if (this.RCTimeout) {
        Registry.clearTimeout(this.RCTimeout);
      }
    }
    static _states() {
      return [class RemotePair extends this {
        $enter() {
          this.tag('Timer').visible = true;
          this.tag('Info').text.text = Language$1.translate('Put the remote control in pairing mode; scan will start in one moment');
        }
        _handleRight() {
          this._setState('Scanning');
        }
        $exit() {
          this.tag('Timer').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class Scanning extends this {
        $enter() {
          this.tag('Loader').visible = true;
          this.tag('Info').text.text = Language$1.translate('Scanning');
        }
        _handleRight() {
          this._setState('PairComplete');
        }
        _handleLeft() {
          this._setState('RemotePair');
        }
        $exit() {
          this.tag('Loader').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class PairComplete extends this {
        $enter() {
          this.tag('Buttons.Continue').visible = true;
          this.tag('Info').text.text = Language$1.translate('Pairing Successful');
        }
        _handleLeft() {
          this._setState('Scanning');
        }
        _handleRight() {
          Router.navigate('splash/language');
        }
        $exit() {
          this.tag('Buttons.Continue').visible = false;
          this.tag('Info').text.text = '';
        }
      }, class StartPairing extends this {
        $enter() {
          this.tag('Buttons.StartPairing').alpha = 1;
          this._focus();
        }
        _focus() {
          this.tag('Buttons.StartPairing').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Buttons.StartPairing.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _handleLeft() {}
        _handleRight() {}
        _handleEnter() {
          console.log('SplashBluetoothScreen states Start Pairing');
          Router.navigate('splash/language');
        }
        $exit() {
          this.tag('Buttons.StartPairing').alpha = 0.5;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$5 = new AppApi();
  const loader$1 = 'Loader';
  class LanguageScreen$1 extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Language: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Language"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Select a language"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          LanguageScreenContents: {
            x: 200 - 1000,
            y: 270,
            Languages: {
              flexItem: {
                margin: 0
              },
              List: {
                type: t.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            Continue: {
              x: 820,
              y: 250,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Continue Setup"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
    }
    pageTransition() {
      return 'left';
    }
    _focus() {
      this._setState('Languages');
    }
    _handleBack() {}
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleDown() {
          if (this._Languages.tag('List').index < availableLanguages.length - 1) {
            this._navigate('down');
          } else {
            this._setState('Continue');
          }
        }
        _handleEnter() {
          if (localStorage.getItem('Language') !== availableLanguages[this._Languages.tag('List').index]) {
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$5.launchResident(notification_url, loader$1).catch(err => {});
            appApi$5.setVisibility(Storage$1.get("selfClientName"), false);
            location.reload();
          }
        }
      }, class Continue extends this {
        $enter() {
          this._focus();
        }
        _focus() {
          this.tag('Continue').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Continue.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Continue').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Continue.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleUp() {
          this._setState('Languages');
        }
        _handleEnter() {
          Router.navigate('splash/network');
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$3 = new Wifi();
  const network = new Network();
  class NetworkScreen extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Network: {
          x: 960,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Network Configuration"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Select a network interface"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          NetworkInterfaceList: {
            x: 200 - 1000,
            y: 270,
            WiFi: {
              y: 0,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate('WiFi'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Ethernet: {
              y: 90,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate('Ethernet'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Skip: {
              x: 820,
              y: 250,
              w: 300,
              mountX: 0.5,
              h: 60,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 150,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Skip"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000,
                  fontStyle: 'bold'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {}
    pageTransition() {
      return 'left';
    }
    _focus() {
      Storage$1.set('setup', true);
      this._setState('WiFi');
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _handleEnter() {
          // this._setState('WiFiScreen')
          wifi$3.setInterface('WIFI', true).then(res => {
            if (res.success) {
              wifi$3.setDefaultInterface('WIFI', true).then(() => {
                Router.navigate('splash/networkList');
              });
            }
          });
          console.log("Wifi");
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          wifi$3.setInterface('ETHERNET', true).then(res => {
            if (res.success) {
              wifi$3.setDefaultInterface('ETHERNET', true).then(() => {
                network.getInterfaces().then(res => {
                  let eth = res.filter(item => item.interface == 'ETHERNET');
                  if (eth[0].interface == 'ETHERNET' && eth[0].enabled == true && eth[0].connected == true) {
                    Router.navigate('menu');
                  } else if (eth[0].interface == 'ETHERNET' && eth[0].connected == false) {
                    Router.navigate('splash/networkPrompt');
                  }
                });
              });
            }
          });
        }
        _handleDown() {
          this._setState('Skip');
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }, class Skip extends this {
        $enter() {
          this._focus();
        }
        _focus() {
          this.tag('Skip').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Skip.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Skip').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Skip.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleEnter() {
          if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
            network.isConnectedToInternet().then(result => {
              if (result) Router.navigate('AlexaLoginScreen');else Router.navigate('menu');
            });
          } else {
            Router.navigate('menu');
          }
        }
        _handleUp() {
          this._setState('Ethernet');
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Reboot Confirmation Screen.
   */
  class NetworkPromptScreen extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        PromptScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Note"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 120,
            InfoTitle: {
              x: 0,
              y: 0,
              mountX: 0.5,
              text: {
                text: Language$1.translate("Ethernet cable is not connected"),
                fontFace: CONFIG.language.font,
                fontSize: 30
              }
            }
          },
          Buttons: {
            x: 200,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            TryAgain: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Try Again"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState('TryAgain');
    }
    _handleBack() {
      Router.navigate('splash/networkPrompt');
    }
    static _states() {
      return [class TryAgain extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          Router.navigate('splash/network');
        }
        _focus() {
          this.tag('TryAgain').patch({
            color: CONFIG.theme.hex
          });
          this.tag('TryAgain.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('TryAgain').patch({
            color: 0xFFFFFFFF
          });
          this.tag('TryAgain.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$2 = new Wifi();
  class NetworkList extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        NetworkList: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Network Configuration"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1600,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Select a wifi network"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Loader: {
            visible: false,
            h: 45,
            w: 45,
            x: 0,
            // x: 320,
            mountX: 1,
            y: 200,
            mountY: 0.5,
            src: Utils.asset('images/settings/Loading.png')
          },
          Networks: {
            x: -800,
            y: 340,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: t.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: t.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            x: -800,
            y: 250,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        }
      };
    }
    pageTransition() {
      return 'left';
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.onError = {
        0: 'SSID_CHANGED - The SSID of the network changed',
        1: 'CONNECTION_LOST - The connection to the network was lost',
        2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
        3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
        4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
        5: 'NO_SSID - The SSID does not exist',
        6: 'UNKNOWN - Any other error.'
      };
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this._wifi = new Wifi();
      this._network = new Network();
      this.wifiStatus = true;
      this._wifiIcon = true;
      this._activateWiFi();
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._setState('JoinAnotherNetwork');
      this._network.activate().then(result => {
        if (result) {
          this._network.registerEvent('onIPAddressStatusChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.status == 'ACQUIRED') ; else if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                this._wifi.setInterface('ETHERNET', true).then(res => {
                  if (res.success) {
                    this._wifi.setDefaultInterface('ETHERNET', true);
                  }
                });
              }
            }
          });
          this._network.registerEvent('onDefaultInterfaceChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.newInterfaceName === 'ETHERNET') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            } else if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              this._wifi.disconnect();
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
              console.log('emplty new old wifi');
              this._wifi.setDefaultInterface('ETHERNET', true);
            }
          });
          this._network.registerEvent('onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              this._wifi.setInterface('ETHERNET', true).then(res => {
                if (res.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
          });
        }
      });
    }

    /**
    * Function to be executed when the Wi-Fi screen is enabled.
    */
    _focus() {
      if (this.wifiStatus) {
        this._wifi.discoverSSIDs();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _unfocus() {
      this._wifi.stopScan();
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      this._wifi.getConnectedSSID().then(result => {
        if (result.ssid != '') {
          this._pairedList = [result];
        } else {
          this._pairedList = [];
        }
        this._availableNetworks.tag('List').rollMax = ssids.length * 90;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.connected = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
        this._otherList = ssids.filter(device => {
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
    }
    static _states() {
      return [class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Loader').visible = false;
            this.wifiLoading.stop();
          }
        }
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log(this._availableNetworks.tag('List').element._item);
          Router.navigate('settings/network/interface/wifi/connect', {
            wifiItem: this._availableNetworks.tag('List').element._item
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          // this._setState('AvailableDevices')
        }
        _handleEnter() {
          if (this.wifiStatus) {
            Router.navigate('settings/network/interface/wifi/another');
          }
        }
        _handleDown() {
          this._setState('AvailableDevices');
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }];
    }

    /**
    * Function to navigate through the lists in the screen.
    * @param {string} listname
    * @param {string} dir
    */

    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          wifi$2.discoverSSIDs();
          this._setState('JoinAnotherNetwork');
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }

    /**
    * Function to turn on and off Wi-Fi.
    */
    switch() {
      if (!this.wifiStatus) {
        this._wifi.disconnect();
        console.log('turning off wifi');
        this._wifi.setInterface('ETHERNET', true).then(result => {
          if (result.success) {
            this._wifi.setDefaultInterface('ETHERNET', true).then(result => {
              if (result.success) {
                this._wifi.disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Loader').visible = false;
                this.wifiLoading.stop();
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        //this.wifiStatus = true
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Loader').visible = true;
        this._wifi.discoverSSIDs();
      }
    }

    /**
    * Function to activate Wi-Fi plugin.
    */
    _activateWiFi() {
      this._wifi.activate().then(() => {
        this.switch();
      });
      this._wifi.registerEvent('onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === 5 && Router.getActiveRoute().includes('splash')) {
          Registry.setTimeout(() => {
            Router.navigate('menu');
          }, 2000);
        }
      });
      this._wifi.registerEvent('onError', notification => {
        this._wifi.discoverSSIDs();
        this._wifi.setInterface('ETHERNET', true).then(res => {
          if (res.success) {
            this._wifi.setDefaultInterface('ETHERNET', true);
          }
        });
      });
      this._wifi.registerEvent('onAvailableSSIDs', notification => {
        this.renderDeviceList(notification.ssids);
        if (!notification.moreData) {
          setTimeout(() => {
            this.tag('Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var splashScreenRoutes = {
    splashScreenRoutes: [{
      path: 'splash',
      component: LogoScreen,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/bluetooth',
      component: BluetoothScreen$1,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/language',
      component: LanguageScreen$1,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/network',
      component: NetworkScreen,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/networkPrompt',
      component: NetworkPromptScreen,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'splash/networkList',
      component: NetworkList,
      widgets: ['Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for rendering items in UI list.
   */
  class Item extends t.Component {
    static _template() {
      return {
        Item: {
          w: 300,
          h: 150,
          rect: true,
          color: 0xFFDBEBFF,
          shader: {
            type: t.shaders.RoundedRectangle,
            radius: 10
          }
        },
        OperatorLogo: {},
        Shadow: {
          alpha: 0,
          zIndex: 2,
          x: -25,
          y: -25,
          color: 0x66000000,
          texture: lng.Tools.getShadowRect(350, 180, 10, 10, 20)
        }
      };
    }

    /**
     * Function to set contents for an item in UI list.
     */
    set item(item) {
      this._item = item;
      this.tag('OperatorLogo').patch({
        Logo: {
          w: 300,
          h: 150,
          zIndex: 3,
          src: Utils.asset(this._item.url)
        }
      });
    }
    _focus() {
      this.tag('Item').zIndex = 3;
      this.tag('Item').scale = 1.2;
      this.tag('Item').color = 0xFFFFFFFF;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 1
        }
      });
    }
    _unfocus() {
      this.tag('Item').zIndex = 1;
      this.tag('Item').scale = 1;
      this.tag('Item').color = 0xFFDBEBFF;
      this.tag('Shadow').patch({
        smooth: {
          alpha: 0
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const homeApi$2 = new HomeApi();
  class UIList extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 1080,
        src: Utils.asset('images/splash/Splash-Background.jpg'),
        UI: {
          x: 200,
          y: 465,
          type: List,
          spacing: 20,
          direction: 'row',
          scroll: {
            after: 4
          }
        }
      };
    }
    pageTransition() {
      return 'right';
    }
    _firstEnable() {
      this.tag('UI').add(homeApi$2.getUIInfo().map((element, idx) => {
        return {
          ref: 'UI' + idx,
          w: 300,
          h: 150,
          type: Item,
          item: element,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    _getFocused() {
      return this.tag('UI');
    }
    _handleEnter() {
      if (this.tag('UI').currentItem._item.title != 'DEFAULT') {
        console.log('Redirect to url');
        return;
      }
      Router.navigate('menu');
    }
  }

  function set(t,e,n,i){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function set(t,e,n,i){var o,r=_superPropBase(t,e);if(r){if((o=Object.getOwnPropertyDescriptor(r,e)).set)return o.set.call(i,n),!0;if(!o.writable)return !1}if(o=Object.getOwnPropertyDescriptor(i,e)){if(!o.writable)return !1;o.value=n,Object.defineProperty(i,e,o);}else _defineProperty$1(i,e,n);return !0},set(t,e,n,i)}function _set(t,e,n,i,o){if(!set(t,e,n,i||t)&&o)throw new TypeError("failed to set property");return n}function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function _get(t,e,n){var i=_superPropBase(t,e);if(i){var o=Object.getOwnPropertyDescriptor(i,e);return o.get?o.get.call(arguments.length<3?t:n):o.value}},_get.apply(this,arguments)}function _superPropBase(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=_getPrototypeOf(t)););return t}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e);}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function _setPrototypeOf(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}function _createSuper(t){var e=function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return !1}}();return function _createSuperInternal(){var n,i=_getPrototypeOf(t);if(e){var o=_getPrototypeOf(this).constructor;n=Reflect.construct(i,arguments,o);}else n=i.apply(this,arguments);return function _possibleConstructorReturn(t,e){if(e&&("object"===_typeof(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function _assertThisInitialized(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(this,n)}}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function _getPrototypeOf(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}function _regeneratorRuntime(){/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function _regeneratorRuntime(){return t};var t={},e=Object.prototype,n=e.hasOwnProperty,i=Object.defineProperty||function(t,e,n){t[e]=n.value;},o="function"==typeof Symbol?Symbol:{},r=o.iterator||"@@iterator",a=o.asyncIterator||"@@asyncIterator",s=o.toStringTag||"@@toStringTag";function define(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"");}catch(t){define=function define(t,e,n){return t[e]=n};}function wrap(t,e,n,o){var r=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(r.prototype),s=new Context(o||[]);return i(a,"_invoke",{value:makeInvokeMethod(t,n,s)}),a}function tryCatch(t,e,n){try{return {type:"normal",arg:t.call(e,n)}}catch(t){return {type:"throw",arg:t}}}t.wrap=wrap;var l={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var c={};define(c,r,(function(){return this}));var u=Object.getPrototypeOf,h=u&&u(u(values([])));h&&h!==e&&n.call(h,r)&&(c=h);var d=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(c);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}));}));}function AsyncIterator(t,e){function invoke(i,o,r,a){var s=tryCatch(t[i],t,o);if("throw"!==s.type){var l=s.arg,c=l.value;return c&&"object"==_typeof(c)&&n.call(c,"__await")?e.resolve(c.__await).then((function(t){invoke("next",t,r,a);}),(function(t){invoke("throw",t,r,a);})):e.resolve(c).then((function(t){l.value=t,r(l);}),(function(t){return invoke("throw",t,r,a)}))}a(s.arg);}var o;i(this,"_invoke",{value:function value(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,i){invoke(t,n,e,i);}))}return o=o?o.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}});}function makeInvokeMethod(t,e,n){var i="suspendedStart";return function(o,r){if("executing"===i)throw new Error("Generator is already running");if("completed"===i){if("throw"===o)throw r;return doneResult()}for(n.method=o,n.arg=r;;){var a=n.delegate;if(a){var s=maybeInvokeDelegate(a,n);if(s){if(s===l)continue;return s}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if("suspendedStart"===i)throw i="completed",n.arg;n.dispatchException(n.arg);}else "return"===n.method&&n.abrupt("return",n.arg);i="executing";var c=tryCatch(t,e,n);if("normal"===c.type){if(i=n.done?"completed":"suspendedYield",c.arg===l)continue;return {value:c.arg,done:n.done}}"throw"===c.type&&(i="completed",n.method="throw",n.arg=c.arg);}}}function maybeInvokeDelegate(t,e){var n=e.method,i=t.iterator[n];if(void 0===i)return e.delegate=null,"throw"===n&&t.iterator.return&&(e.method="return",e.arg=void 0,maybeInvokeDelegate(t,e),"throw"===e.method)||"return"!==n&&(e.method="throw",e.arg=new TypeError("The iterator does not provide a '"+n+"' method")),l;var o=tryCatch(i,t.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,l;var r=o.arg;return r?r.done?(e[t.resultName]=r.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,l):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,l)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e);}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e;}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0);}function values(t){if(t){var e=t[r];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var i=-1,o=function next(){for(;++i<t.length;)if(n.call(t,i))return next.value=t[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return o.next=o}}return {next:doneResult}}function doneResult(){return {value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,i(d,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),i(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,s,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return !!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,s,"GeneratorFunction")),t.prototype=Object.create(d),t},t.awrap=function(t){return {__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,a,(function(){return this})),t.AsyncIterator=AsyncIterator,t.async=function(e,n,i,o,r){void 0===r&&(r=Promise);var a=new AsyncIterator(wrap(e,n,i,o),r);return t.isGeneratorFunction(n)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(d),define(d,s,"Generator"),define(d,r,(function(){return this})),define(d,"toString",(function(){return "[object Generator]"})),t.keys=function(t){var e=Object(t),n=[];for(var i in e)n.push(i);return n.reverse(),function next(){for(;n.length;){var t=n.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},t.values=values,Context.prototype={constructor:Context,reset:function reset(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!t)for(var e in this)"t"===e.charAt(0)&&n.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0);},stop:function stop(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function dispatchException(t){if(this.done)throw t;var e=this;function handle(n,i){return r.type="throw",r.arg=t,e.next=n,i&&(e.method="next",e.arg=void 0),!!i}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],r=o.completion;if("root"===o.tryLoc)return handle("end");if(o.tryLoc<=this.prev){var a=n.call(o,"catchLoc"),s=n.call(o,"finallyLoc");if(a&&s){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0);if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return handle(o.catchLoc,!0)}else {if(!s)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return handle(o.finallyLoc)}}}},abrupt:function abrupt(t,e){for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var r=o;break}}r&&("break"===t||"continue"===t)&&r.tryLoc<=e&&e<=r.finallyLoc&&(r=null);var a=r?r.completion:{};return a.type=t,a.arg=e,r?(this.method="next",this.next=r.finallyLoc,l):this.complete(a)},complete:function complete(t,e){if("throw"===t.type)throw t.arg;return "break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),l},finish:function finish(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),resetTryEntry(n),l}},catch:function _catch(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var i=n.completion;if("throw"===i.type){var o=i.arg;resetTryEntry(n);}return o}}throw new Error("illegal catch attempt")},delegateYield:function delegateYield(t,e,n){return this.delegate={iterator:values(t),resultName:e,nextLoc:n},"next"===this.method&&(this.arg=void 0),l}},t}function asyncGeneratorStep(t,e,n,i,o,r,a){try{var s=t[r](a),l=s.value;}catch(t){return void n(t)}s.done?e(l):Promise.resolve(l).then(i,o);}function _asyncToGenerator(t){return function(){var e=this,n=arguments;return new Promise((function(i,o){var r=t.apply(e,n);function _next(t){asyncGeneratorStep(r,i,o,_next,_throw,"next",t);}function _throw(t){asyncGeneratorStep(r,i,o,_next,_throw,"throw",t);}_next(void 0);}))}}function _toConsumableArray(t){return function _arrayWithoutHoles(t){if(Array.isArray(t))return _arrayLikeToArray(t)}(t)||function _iterableToArray(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||_unsupportedIterableToArray(t)||function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ownKeys(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i);}return n}function _objectSpread(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?ownKeys(Object(n),!0).forEach((function(e){_defineProperty$1(t,e,n[e]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):ownKeys(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e));}));}return t}function _defineProperty$1(t,e,n){return (e=_toPropertyKey$1(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function _slicedToArray(t,e){return function _arrayWithHoles(t){if(Array.isArray(t))return t}(t)||function _iterableToArrayLimit(t,e){var n=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=n){var i,o,r,a,s=[],l=!0,c=!1;try{if(r=(n=n.call(t)).next,0===e){if(Object(n)!==n)return;l=!1;}else for(;!(l=(i=r.call(n)).done)&&(s.push(i.value),s.length!==e);l=!0);}catch(t){c=!0,o=t;}finally{try{if(!l&&null!=n.return&&(a=n.return(),Object(a)!==a))return}finally{if(c)throw o}}return s}}(t,e)||_unsupportedIterableToArray(t,e)||function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _unsupportedIterableToArray(t,e){if(t){if("string"==typeof t)return _arrayLikeToArray(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return "Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(t,e):void 0}}function _arrayLikeToArray(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,i=new Array(e);n<e;n++)i[n]=t[n];return i}function _typeof(t){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},_typeof(t)}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _defineProperties(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,_toPropertyKey$1(i.key),i);}}function _createClass(t,e,n){return e&&_defineProperties(t.prototype,e),n&&_defineProperties(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function _toPropertyKey$1(t){var e=function _toPrimitive(t,e){if("object"!==_typeof(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var i=n.call(t,e||"default");if("object"!==_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return ("string"===e?String:Number)(t)}(t,"string");return "symbol"===_typeof(e)?e:String(e)}var e=new(function(){function Logger(){_classCallCheck(this,Logger),this._logCallback=void 0,this._prefix="LightningUI",this._debug=!1;}return _createClass(Logger,[{key:"debug",get:function get(){return this._debug},set:function set(t){this._debug=Boolean(t);}},{key:"logCallback",get:function get(){return this._logCallback},set:function set(t){"function"==typeof t?this._logCallback=t:this.warn("logCallback value must be a function, instead received ".concat(_typeof(t)));}},{key:"log",value:function log(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var i;(this._logCallback&&this._logCallback({level:"log",payload:e}),this.debug)&&(i=console).log.apply(i,[this._prefix].concat(e));}},{key:"info",value:function info(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var i;(this._logCallback&&this._logCallback({level:"info",payload:e}),this.debug)&&(i=console).info.apply(i,[this._prefix].concat(e));}},{key:"warn",value:function warn(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var i;(this._logCallback&&this._logCallback({level:"warn",payload:e}),this.debug)&&(i=console).warn.apply(i,[this._prefix].concat(e));}},{key:"error",value:function error(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var i;(this._logCallback&&this._logCallback({level:"error",payload:e}),this.debug)&&(i=console).error.apply(i,[this._prefix].concat(e));}}]),Logger}());function getEuclideanDistance(t,e,n,i){var o=t-n,r=e-i;return Math.sqrt(Math.pow(o,2)+Math.sqrt(Math.pow(r,2)))}function isComponentOnScreen(t){if(!t)return !1;var e=t.w,n=t.h,i=t.core,o=void 0===i?{}:i,r=o.renderContext,a=r.px,s=r.py,l=o._scissor,c=void 0===l?[]:l,u=t.stage.h/t.stage.getRenderPrecision(),h=t.stage.w/t.stage.getRenderPrecision();if(!(a>=0&&a+e<=h)||!(s>=0&&s+n<=u))return !1;if(c&&c.length){var d=_slicedToArray(c,4),p=d[0],_=void 0===p?null:p,f=d[1],g=void 0===f?null:f,m=d[2],v=void 0===m?null:m,b=d[3],k=void 0===b?null:b,S=Math.round(a+e)>=Math.round(_),C=Math.round(a)<=Math.round(_+v),T=Math.round(s+n)>=Math.round(g),I=Math.round(s+n)<=Math.round(g+k);return S&&C&&T&&I}return !0}function getWidthByUpCount(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=t.layout.screenW,i=t.layout.columnCount,o=t.layout.marginX,r=t.layout.gutterX;if(!(e<1||e>i))return (n-2*o-(e-1)*r)/e;console.error("Column expects a number between 1 & ".concat(i,". Received ").concat(e));}function getWidthByColumnSpan(t,e){var n=t.layout.columnCount,i=t.layout.gutterX;return getWidthByUpCount(t,n)*e+i*(e-1)}function getDimensions(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=e.w,o=e.h,r=e.ratioX,a=e.ratioY,s=e.upCount,l=n.w||0,c=n.h||0,u={};return u=i&&o?{w:i,h:o}:o&&r&&a?{w:Math.round(o*r/a),h:o}:r&&a&&s?function getItemRatioDimensions(t,e,n,i){var o,r;e&&n&&i?(o=Math.round(getWidthByUpCount(t,i)),r=Math.round(o/e*n)):(o=0,r=0);return {w:o,h:r}}(t,r,a,s):o&&s?{w:Math.round(getWidthByUpCount(t,s)),h:o}:o?{w:l,h:o}:i?{w:i,h:c}:{w:l,h:c},u=_objectSpread(_objectSpread({},u),{},{ratioX:r,ratioY:a,upCount:s})}function getHexColor(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(!t)return 0;"number"==typeof t&&(t=t.toString(16).slice(2)),t=t.replace("#","");var n=Math.round(255*e).toString(16),i="0x".concat(n).concat(t);return Number(i)}function getValidColor(e){if(/^0x[0-9a-fA-F]{8}/g.test(e))return Number(e);if(/^#[0-9a-fA-F]{6}/g.test(e))return getHexColor(e.substr(1,6));if("string"==typeof e&&/^[0-9]{8,10}/g.test(e))return parseInt(e);if("number"==typeof e&&/^[0-9]{8,10}/g.test(e.toString()))return e;if("string"==typeof e&&e.indexOf("rgba")>-1)return rgba2argb(e);if("string"==typeof e&&e.indexOf("rgb")>-1){var n=[].concat(_toConsumableArray(e.replace(/rgb\(|\)/g,"").split(",")),["255"]);return t.StageUtils.getArgbNumber(n)}return null}function reduceFraction(t){return function simplifyFraction(t){for(var e=_slicedToArray(t,2),n=e[0],i=e[1],o=n;o>0;o--)if(!(n%o||i%o))return [n/o,i/o]}(t.split("/").map((function(t){return +t}))).join("/")}var n=function getValFromObjPath(t,e){return "string"==typeof e&&(e=e.split(".").filter((function(t){return t.length}))),e.reduce((function(t,e){return t&&t[e]}),t)};function rgba2argb(e){var n=e.replace(/rgba\(|\)/g,"").split(",");return n[3]=255*n[3],t.StageUtils.getArgbNumber(n)}function capitalizeFirstLetter(t){return t.charAt(0).toUpperCase()+t.slice(1)}var i={getWidth:function getWidth(t){var e=_objectSpread({padding:0,paddingLeft:0,paddingRight:0,strokeWidth:0},arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}),n=e.padding,i=e.paddingLeft,o=e.paddingRight,r=e.strokeWidth;return t?t-(i||n)-(o||n)-r:0},getHeight:function getHeight(t){var e=_objectSpread({padding:0,paddingBottom:0,paddingTop:0,strokeWidth:0},arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}),n=e.padding,i=e.paddingBottom,o=e.paddingTop,r=e.strokeWidth;return t?t-(i||n)-(o||n)-r:0}};function clone(t,e){var n=Object.create(Object.getPrototypeOf(t));if(Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)),!e||t===e)return n;for(var i in e){var o=e[i];t.hasOwnProperty(i)?n[i]=getMergeValue(i,t,e):n[i]=o;}return n}function getMergeValue(t,e,n){var i=e[t],o=n[t],r=_typeof(i),a=_typeof(o);return r!==a||"function"===a||Array.isArray(o)?o:o&&"object"===a?clone(i,o):o}function measureTextWidth(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=document.createElement("canvas").getContext("2d"),n=t.fontStyle,i=t.fontWeight,o=t.fontSize,r=t.fontFamily,a=void 0===r?t.fontFace||"sans-serif":r,s=[n,i,o?"".concat(o,"px"):"0","'".concat(a,"'")].filter(Boolean).join(" ");e.font=s;var l=e.measureText(t.text||"");return Math.round(l.width)}function getDimension(t,e){if(!e)return 0;var n=e.transition(t);return n.isRunning()?n.targetValue:e[t]}var o=getDimension.bind(null,"x"),r=getDimension.bind(null,"y");function flatten(t){return t.reduce((function(t,e){return t.concat(Array.isArray(e)?flatten(e):e)}),[])}function stringifyCompare(t,e){return JSON.stringify(t)===JSON.stringify(e)}function delayForAnimation(t){setTimeout(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:16);}var a=function degreesToRadians(t){return t*(Math.PI/180)},s=/({ICON.*?}|{BADGE:.*?}|{NEWLINE}|{TEXT:.*?})/g;function max(){if(arguments){var t=Array.from(arguments).filter((function(t){return !isNaN(t)&&null!=t}));if(t.length)return Math.max.apply(Math,_toConsumableArray(t))}}function watchForUpdates(t){var n,i=t.element,o=t.watchProps,r=void 0===o?[]:o,a=t.sideEffect,s=void 0===a?function(){}:a;null!=i&&i.isElement||e.error("watchForUpdates: Expected a Lightning Element passed to element parameter, received ".concat(_typeof(i)));var l=null===(n=i.__core)||void 0===n?void 0:n._onAfterUpdate;return i.onAfterUpdate=function(t){var e=!1;r.forEach((function(n){if(!t.transition(n)||!t.transition(n).isRunning()){var i="__watchPrev".concat(n),o=t[n];o!==t[i]&&(t[i]=o,e=!0);}})),e&&s(),l&&l(t);}.bind(this),i}var l={isMarkupString:function isMarkupString(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return "string"==typeof t&&s.test(t)},capitalizeFirstLetter:capitalizeFirstLetter,degreesToRadians:a,downloadFile:function downloadFile(t,e,n){["plain","json"].includes(n)||(n="plain");var i="data:text/".concat(n,";charset=utf-8,")+encodeURIComponent(JSON.stringify(t)),o=document.createElement("a");o.setAttribute("href",i),o.setAttribute("download",e),o.click();},delayForAnimation:delayForAnimation,stringifyCompare:stringifyCompare,objectPropertyOf:function objectPropertyOf(t,e){return e.reduce((function(t,e){return t&&"undefined"!==t[e]?t[e]:void 0}),t)},flatten:flatten,getDimension:getDimension,getFirstNumber:function getFirstNumber(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return e.find(Number.isFinite)},measureTextWidth:measureTextWidth,clone:clone,getMergeValue:getMergeValue,RoundRect:i,rgba2argb:rgba2argb,getValFromObjPath:n,reduceFraction:reduceFraction,getValidColor:getValidColor,getHexColor:getHexColor,getAspectRatioH:function getAspectRatioH(t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:":",n=_slicedToArray((arguments.length>1&&void 0!==arguments[1]?arguments[1]:"16:9").split(e),2);return t/(n[0]/n[1])},getAspectRatioW:function getAspectRatioW(t){var e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:":",n=_slicedToArray((arguments.length>1&&void 0!==arguments[1]?arguments[1]:"16:9").split(e),2);return t*(n[0]/n[1])},getWidthByUpCount:getWidthByUpCount,getDimensions:getDimensions,getWidthByColumnSpan:getWidthByColumnSpan,createConditionalZContext:function createConditionalZContext(t,e){t.zIndex||void 0===e||0===e||(t.forceZIndexContext=!0,t.zIndex=0);},watchForUpdates:watchForUpdates,convertTextAlignToFlexJustify:function convertTextAlignToFlexJustify(t){switch(t){case"left":return "flex-start";case"center":return "center";case"right":return "flex-end";default:return console.warn('Expected "textAlign" values are "left," "center," and "right," but instead, '.concat(t,' was received and will fall back to "left."')),"flex-start"}}},c=new(function(){function Metrics(){_classCallCheck(this,Metrics),this._keyMetricsCallback=void 0;}return _createClass(Metrics,[{key:"keyMetricsCallback",get:function get(){return this._keyMetricsCallback},set:function set(t){-1<["undefined","function"].indexOf(_typeof(t))?this._keyMetricsCallback=t:e.warn("context keyMetricsCallback expected a function. Received ".concat(_typeof(t)));}}]),Metrics}()),u=new t.EventEmitter,h={name:"Base Lightning TV",alpha:{primary:1,secondary:.7,tertiary:.1,inactive:.5,full:1,none:0,alpha1:.1,alpha2:.3,alpha3:.5,alpha4:.7,alpha5:.9},animation:{duration:{none:0,xfast:.1,fast:.25,normal:.5,slow:.75,xslow:.9},delay:{none:0,xfast:.01,fast:.025,normal:.05,slow:.075,xslow:.09},expressive:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},expressiveEntrance:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},expressiveExit:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},standard:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},standardEntrance:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},standardExit:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},utility:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},utilityEntrance:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25},utilityExit:{timingFunction:"cubic-bezier(0, 0, 1, 1)",delay:0,duration:.25}},asset:{arrowLeft:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAi0lEQVRIDWNgGAWjIfD//38JID5Fk5AAGqwKxPeA+D/VLQCaaQLEr0CGgwBVLQCa5wbEn0EGwwDVLAAaGA3Ev2AGw2iqWAA0rBiI/8EMRaYptgBoWDeygehsci1gIlcjWfqArqZdEMFcBLSEdpGMZAntkimSJbTLaEiW0K6oQLKEdoUdzJJRemiHAAD4n+yzPWCs7QAAAABJRU5ErkJggg==",arrowRight:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAg0lEQVRIDWNgGAWjIYArBP7//38KiCVwyVMsDjQcBO4BsSrFhmEzAGw8hHgFpEywqaFIDMkCEPMzELtRZCC6ZjQLQNxfQByNro5sPhYLQEL/gLiYbEORNeKwACbcDVPLBGMMOhrmVDSapkFE00imaTKlaUajaVFB28Ju0CXrUQfhDAEAEgHss6NhpLQAAAAASUVORK5CYII=",backspaceOutline:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC",check:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAOCAYAAAAi2ky3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACtSURBVHgBvdPdDcIgEAfwoy8Nb45QN3AGF2s36Ahu4gpuIDoBfSgfpdoTlCbEWEMh6T8hFzjyg5AAkBHOcQe5UWqspRx435sDpMYj6IYQwwVSEiJ2MKVUBWuzLSLl2HL+uxmNCGFO8yaL7RHxve6qRZoAuS4hxac8735elWVx7jrtMKL1o0Gcat9jhExHSukN/kUIFZ7MpDRtzE1isDRkAUtDvrA8ZI597FUf8gWH9P0b4gko9wAAAABJRU5ErkJggg=="},color:{white:["#ffffff",1],black:["#000000",1],grey:["#929096",1],red:["#e74c3c",1],orange:["#dc7633",1],yellow:["#f7dc6f",1],green:["#2Ecc71",1],blue:["#93a9fd",1],purple:["#663399",1],palette:{"grey-05":["#f8f7fa",1],"grey-40":["#929096",1],"grey-70":["#48474b",1],"grey-90":["#181819",1],"blue-20":["#becffe",1],"blue-40":["#93a9fd",1],"blue-90":["#000033",1]},material:["#181819",1],materialBrand:["#000033",1],overlay:["#181819",.7],textNeutral:["#f8f7fa",1],textNeutralSecondary:["#f8f7fa",.7],textNeutralTertiary:["#f8f7fa",.1],textNeutralDisabled:["#f8f7fa",.5],textInverse:["#181819",1],textInverseSecondary:["#181819",.7],textInverseTertiary:["#181819",.1],textInverseDisabled:["#181819",.5],textBrand:["#93a9fd",1],textBrandSecondary:["#93a9fd",.7],textBrandTertiary:["#93a9fd",.1],textBrandDisabled:["#93a9fd",.5],textPositive:["#2Ecc71",1],textNegative:["#e74c3c",1],textInfo:["#93a9fd",1],textCaution:["#dc7633",1],fillTransparent:["#ffffff",0],fillNeutral:["#f8f7fa",1],fillNeutralSecondary:["#f8f7fa",.7],fillNeutralTertiary:["#f8f7fa",.1],fillNeutralDisabled:["#f8f7fa",.5],fillInverse:["#181819",1],fillInverseSecondary:["#181819",.7],fillInverseTertiary:["#181819",.1],fillInverseDisabled:["#181819",.5],fillBrand:["#93a9fd",1],fillBrandSecondary:["#93a9fd",.7],fillBrandTertiary:["#93a9fd",.1],fillBrandDisabled:["#93a9fd",.5],fillPositive:["#2Ecc71",1],fillNegative:["#e74c3c",1],fillInfo:["#93a9fd",1],fillCaution:["#dc7633",1],strokeNeutral:["#f8f7fa",1],strokeNeutralSecondary:["#f8f7fa",.7],strokeNeutralTertiary:["#f8f7fa",.1],strokeNeutralDisabled:["#f8f7fa",.5],strokeInverse:["#181819",1],strokeInverseSecondary:["#181819",.7],strokeInverseTertiary:["#181819",.1],strokeInverseDisabled:["#181819",.5],strokeBrand:["#93a9fd",1],strokeBrandSecondary:["#93a9fd",.7],strokeBrandTertiary:["#93a9fd",.1],strokeBrandDisabled:["#93a9fd",.5],strokePositive:["#2Ecc71",1],strokeNegative:["#e74c3c",1],strokeInfo:["#93a9fd",1],strokeCaution:["#dc7633",1],interactiveNeutralFocus:["#ffffff",1],interactiveNeutralFocusSoft:["#ffffff",.1],interactiveInverseFocus:["#48474b",1],interactiveInverseFocusSoft:["#48474b",.1],interactiveBrandFocus:["#becffe",1],interactiveBrandFocusSoft:["#becffe",.1],shadowNeutralFocus:["#000000",.7],shadowNeutralFocusSoft:["#000000",.7],shadowInverseFocus:["#000000",.7],shadowInverseFocusSoft:["#000000",.7],shadowBrandFocus:["#000000",.7],shadowBrandFocusSoft:["#000000",.7]},componentConfig:{Keyboard:{style:{keyProps:{delete:{title:null,icon:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC"}}}}},font:[],layout:{screenW:1920,screenH:1080,columnCount:10,marginX:150,marginY:150,safe:50,gutterX:20,gutterY:20,focusScale:1.2},radius:{none:0,xs:2,sm:4,md:8,lg:16,xl:24},spacer:{none:0,xxs:2,xs:4,sm:8,md:10,lg:20,xl:30,xxl:40,xxxl:50},stroke:{none:0,sm:2,md:4,lg:6,xl:8},typography:{display1:{fontFamily:"Arial",fontSize:75,lineHeight:85,fontStyle:"500",verticalAlign:"middle",textBaseline:"bottom"},display2:{fontFamily:"Arial",fontSize:50,lineHeight:60,fontStyle:"500",verticalAlign:"middle",textBaseline:"bottom"},headline1:{fontFamily:"Arial",fontSize:35,fontStyle:"500",lineHeight:48,verticalAlign:"middle",textBaseline:"bottom"},headline2:{fontFamily:"Arial",fontSize:30,fontStyle:"500",lineHeight:40,verticalAlign:"middle",textBaseline:"bottom"},headline3:{fontFamily:"Arial",fontSize:25,fontStyle:"500",lineHeight:36,verticalAlign:"middle",textBaseline:"bottom"},body1:{fontFamily:"Arial",fontSize:25,fontStyle:"300",lineHeight:40,verticalAlign:"middle",textBaseline:"bottom"},body2:{fontFamily:"Arial",fontSize:22,fontStyle:"300",lineHeight:32,verticalAlign:"middle",textBaseline:"bottom"},body3:{fontFamily:"Arial",fontSize:20,fontStyle:"300",lineHeight:32,verticalAlign:"middle",textBaseline:"bottom"},button1:{fontFamily:"Arial",fontSize:25,fontStyle:"500",letterSpacing:-.2,lineHeight:32,verticalAlign:"middle",textBaseline:"bottom"},button2:{fontFamily:"Arial",fontSize:20,fontStyle:"500",lineHeight:32,verticalAlign:"middle",textBaseline:"bottom"},callout1:{fontFamily:"Arial",fontSize:20,fontStyle:"500",letterSpacing:1,lineHeight:32,verticalAlign:"middle",textBaseline:"bottom"},caption1:{fontFamily:"Arial",fontSize:15,fontStyle:"500",lineHeight:24,verticalAlign:"middle",textBaseline:"bottom"},tag1:{fontFamily:"Arial",fontSize:20,fontStyle:"500",letterSpacing:0,lineHeight:24,textBaseline:"bottom"}}},d=[],p=function fontLoader(t){for(var n=[],i=function _loop(){var i=t[o],r=i.family,a=i.src,s=i.descriptors,l=a&&Array.isArray(a)&&a.length?a.map((function(t){return "local"===t.substr(0,5)?t:"url(".concat(t,")")})).join(","):"url("+a+")",c=new FontFace(r,l,s||{});e.info("Loading font",r),document.fonts.add(c),n.push(new Promise((function(t){c.load().then((function(){d.push(c),t(r);})).catch((function(e){t(new Error("".concat(r,": ").concat(e.message)));}));})));},o=0;o<t.length;o++)i();return Promise.all(n).then((function(t){var n=t.filter((function(t){return !(t instanceof Error)})).join(", ");n&&e.log("Fonts loaded: ".concat(n));var i=t.filter((function(t){return t instanceof Error})).map((function(t){return t.message})).join(", ");i&&e.error("Unable to load fonts: ".concat(i));}))},_=function(){var t=_asyncToGenerator(_regeneratorRuntime().mark((function _callee(t){return _regeneratorRuntime().wrap((function _callee$(n){for(;;)switch(n.prev=n.next){case 0:if(!document.fonts||!("delete"in document.fonts)){n.next=6;break}if(d.length){n.next=3;break}return n.abrupt("return");case 3:d=d.filter((function(n){return t.find((function(t){return t.family===n.family}))?n:(e.info("Removing font",n.family),document.fonts.delete(n),!1)})),n.next=7;break;case 6:e.info("Unable to remove manually-added fonts");case 7:case"end":return n.stop()}}),_callee)})));return function cleanupFonts(e){return t.apply(this,arguments)}}(),f={fontFamily:"fontFace"},g=function all(t){for(var e={},n=0;n<t.length;n++)e=clone(e,t[n]);return e},m=[],v=function isSubTheme(t){return "subTheme"===t.slice(0,8)};var b=new(function(){function ThemeManager(){_classCallCheck(this,ThemeManager),this._cache=new Map,"undefined"!=typeof window&&(window.LUI||(window.LUI={}),window.LUI.themeManagerInstances?window.LUI.themeManagerInstances.push({themeManager:this,events:u}):window.LUI.themeManagerInstances=[{themeManager:this,events:u}]);}var t,i,o,r,a;return _createClass(ThemeManager,[{key:"_setCache",value:function _setCache(t,e){"undefined"!=typeof window&&window.LUI.themeManagerInstances.forEach((function(n){var i=n.themeManager;i&&i._cache.set(t,e);}));}},{key:"_deleteCache",value:function _deleteCache(t){"undefined"!=typeof window&&window.LUI.themeManagerInstances.forEach((function(e){var n=e.themeManager;n&&n._cache.delete(t);}));}},{key:"_emit",value:function _emit(t,e){"undefined"!=typeof window&&window.LUI.themeManagerInstances.forEach((function(n){n.events.emit(t,e);}));}},{key:"getTheme",value:function getTheme(){if(this._cache.has("theme"))return this._cache.get("theme");var t=this._processTheme.call(this);return this._setCache("theme",t),t}},{key:"setTheme",value:(a=_asyncToGenerator(_regeneratorRuntime().mark((function _callee2(t){var n,i;return _regeneratorRuntime().wrap((function _callee2$(o){for(;;)switch(o.prev=o.next){case 0:if("object"===_typeof(n=Array.isArray(t)?g(t):t)&&null!==n){o.next=4;break}return e.warn("context theme expected an object. Received ".concat(_typeof(n))),o.abrupt("return");case 4:return this._clearCache(),i=this._processTheme.call(this,[n],n.extensions),this._setCache("theme",i),o.next=9,_(i.font);case 9:if(!i.font||!i.font.length){o.next=12;break}return o.next=12,this._loadFonts(i.font);case 12:return this._refreshSubThemes(),this._emit("themeExtensionsUpdate"),this._emit("themeUpdate"),o.abrupt("return",i);case 16:case"end":return o.stop()}}),_callee2,this)}))),function setTheme(t){return a.apply(this,arguments)})},{key:"getSubTheme",value:function getSubTheme(t){if(this._cache.has("subTheme".concat(t)))return this._cache.get("subTheme".concat(t)).result}},{key:"setSubTheme",value:(r=_asyncToGenerator(_regeneratorRuntime().mark((function _callee3(t,n){var i,o,r,a=arguments;return _regeneratorRuntime().wrap((function _callee3$(s){for(;;)switch(s.prev=s.next){case 0:if(i=!(a.length>2&&void 0!==a[2])||a[2],t){s.next=4;break}return e.warn("Sub theme name not specified"),s.abrupt("return");case 4:if("string"==typeof t){s.next=7;break}return e.warn("Sub theme name must be a string. Received an ".concat(_typeof(t))),s.abrupt("return");case 7:if("object"===_typeof(n)&&Object.keys(n).length){s.next=10;break}return e.warn("Could not set subTheme ".concat(t,", value should be an object with properties. Received an ").concat(_typeof(n))),s.abrupt("return");case 10:if(o=this.getTheme(),!(r=this._processTheme.call(this,[o,n])).font||!r.font.length){s.next=15;break}return s.next=15,this._loadFonts(r.font);case 15:return this._setCache("subTheme".concat(t),{original:n,result:r}),i&&this._emit("themeUpdate".concat(t)),s.abrupt("return",r);case 18:case"end":return s.stop()}}),_callee3,this)}))),function setSubTheme(t,e){return r.apply(this,arguments)})},{key:"_refreshSubThemes",value:function _refreshSubThemes(){var t=this;_toConsumableArray(this._cache.keys()).forEach((function(e){if("string"==typeof e&&v(e)){var n=t._cache.get(e);n.original&&t.updateSubTheme(e.replace(/^subTheme/,""),n.original);}}));}},{key:"_loadFonts",value:(o=_asyncToGenerator(_regeneratorRuntime().mark((function _callee4(t){return _regeneratorRuntime().wrap((function _callee4$(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,n.next=3,p(t);case 3:n.next=8;break;case 5:n.prev=5,n.t0=n.catch(0),e.error("Unable to load font: ".concat(n.t0));case 8:case"end":return n.stop()}}),_callee4,null,[[0,5]])}))),function _loadFonts(t){return o.apply(this,arguments)})},{key:"updateTheme",value:(i=_asyncToGenerator(_regeneratorRuntime().mark((function _callee5(t){var e,n,i;return _regeneratorRuntime().wrap((function _callee5$(o){for(;;)switch(o.prev=o.next){case 0:if(e=Array.isArray(t)?g(t):t,n={},this._cache.has("theme")&&(n=this._cache.get("theme")),this._clearCache(),i=this._processTheme.call(this,[n,e],e.extensions||n.extensions),this._setCache("theme",i),!i.font||!i.font.length){o.next=9;break}return o.next=9,this._loadFonts(i.font);case 9:return this._refreshSubThemes(),e.extensions&&this._emit("themeExtensionsUpdate"),this._emit("themeUpdate"),o.abrupt("return",i);case 13:case"end":return o.stop()}}),_callee5,this)}))),function updateTheme(t){return i.apply(this,arguments)})},{key:"_clearCache",value:function _clearCache(){var t=this;m.filter((function(t){return window.URL&&"function"==typeof window.URL.revokeObjectURL&&URL.revokeObjectURL(t),!1})),this._cache.forEach((function(e,n){"string"==typeof n&&v(n)||t._deleteCache(n);})),this._cache.forEach((function(e,n){"string"==typeof n&&v(n)&&t.setSubTheme(n.replace("subTheme",""),e.original,!1);}));}},{key:"updateSubTheme",value:(t=_asyncToGenerator(_regeneratorRuntime().mark((function _callee6(t,n){var i,o,r,a,s=arguments;return _regeneratorRuntime().wrap((function _callee6$(l){for(;;)switch(l.prev=l.next){case 0:if(i=!(s.length>2&&void 0!==s[2])||s[2],t){l.next=4;break}return e.warn("Sub theme name not specified"),l.abrupt("return");case 4:if("object"===_typeof(n)&&Object.keys(n).length){l.next=7;break}return e.warn("Could not update subTheme ".concat(t," due to invalid value")),l.abrupt("return");case 7:if(o=this.getTheme(),r={},this._cache.has("subTheme".concat(t))&&(r=this._cache.get("subTheme".concat(t)).original),!(a=this._processTheme.call(this,[o,r,n])).font||!a.font.length){l.next=14;break}return l.next=14,this._loadFonts(a.font);case 14:return this._setCache("subTheme".concat(t),{original:clone(r,n),result:a}),i&&this._emit("themeUpdate".concat(t)),l.abrupt("return",a);case 17:case"end":return l.stop()}}),_callee6,this)}))),function updateSubTheme(e,n){return t.apply(this,arguments)})},{key:"removeSubTheme",value:function removeSubTheme(t){this._cache.has("subTheme".concat(t))&&this._deleteCache("subTheme".concat(t)),this._emit("themeUpdate".concat(t));}},{key:"_getComponentUUID",value:function _getComponentUUID(t){return "componentStyle".concat(t)}},{key:"_processTheme",value:function _processTheme(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],i=arguments.length>1?arguments[1]:void 0;if(!Array.isArray(t))throw new Error("context processTheme expected an array. Received ".concat(_typeof(t)));var o=g([h].concat(_toConsumableArray(t))),r={},a=JSON.stringify(o,(function(t,i){var a=i;if(a&&"object"===_typeof(a)){var s=i;for(var l in a)Object.hasOwnProperty.call(a,l)&&f[l]&&(s[l&&f[l]]=a[l],delete s[l]);a=s;}var c=function checkBase64EncodedImage(t){var e=/^data:image\/(jpeg|jpg|png|gif);base64,/,n=e.test(t);return {isImage:n,mimeType:n?function getMimeTypeFromDataUri(t){var e=t.match(/^data:(.*?);base64,/);return e&&2===e.length?e[1]:null}(t.match(e)[0]):null}}(a),u=c.isImage,h=c.mimeType;if(window.URL&&"function"==typeof window.URL.createObjectURL&&u)try{var d=function base64ToBlobURL(t,n){var i=atob(t.substring(t.indexOf(",")+1)),o=[];try{for(var r=0;r<i.length;r+=512){for(var a=i.slice(r,r+512),s=new Array(a.length),l=0;l<a.length;l++)s[l]=a.charCodeAt(l);var c=new Uint8Array(s);o.push(c);}var u=new Blob(o,{type:n});return URL.createObjectURL(u)}catch(t){return e.info("Unable to convert base64 image to URL"),null}}(a,h);return m.push(d),d}catch(t){return a}if(Array.isArray(a)&&2===a.length&&!a[0].targetComponent&&a[0].length&&"#"===a[0].substr(0,1))return getHexColor(a[0],a[1]);if("extensions"!==t&&"function"!=typeof a&&("object"!==_typeof(a)||null===a||"Object"===a.constructor.name||Array.isArray(a))){if("string"==typeof a&&a.includes("theme.")){var p=n({theme:o},a);return p||a}var _=getValidColor(a);return _||a}r[t]=a;}));return _objectSpread(_objectSpread(_objectSpread({},JSON.parse(a)),r),{},{extensions:i})}}]),ThemeManager}()),k$1=new(function(){function Context(){_classCallCheck(this,Context);}return _createClass(Context,[{key:"theme",get:function get(){return b.getTheme()},set:function set(t){e.warn("Context.theme must be set using context.setTheme or context.updateTheme");}},{key:"keyMetricsCallback",get:function get(){return c.keyMetricsCallback},set:function set(t){e.warn("Context.keyMetricsCallback must be set using context.setKeyMetricsCallback");}},{key:"debug",get:function get(){return e.debug},set:function set(t){e.debug=t;}},{key:"on",value:function on(){return u.on.apply(u,arguments)}},{key:"off",value:function off(){return u.off.apply(u,arguments)}},{key:"emit",value:function emit(){return u.emit.apply(u,arguments)}},{key:"log",value:function log(){e.log.apply(e,arguments);}},{key:"info",value:function info(){e.info.apply(e,arguments);}},{key:"warn",value:function warn(){e.warn.apply(e,arguments);}},{key:"error",value:function error(){for(var t=arguments.length,n=new Array(t),i=0;i<t;i++)n[i]=arguments[i];e.error(n);}},{key:"setTheme",value:function setTheme(t){return b.setTheme(t)}},{key:"updateTheme",value:function updateTheme(t){return b.updateTheme(t)}},{key:"getSubTheme",value:function getSubTheme(t){return b.getSubTheme(t)}},{key:"setSubThemes",value:function setSubThemes(t){if("object"===_typeof(t))for(var n in t)b.setSubTheme(n,t[n]);else e.warn("subThemes must be an object");}},{key:"setSubTheme",value:function setSubTheme(t,e){return b.setSubTheme(t,e)}},{key:"updateSubTheme",value:function updateSubTheme(t,e){return b.updateSubTheme(t,e)}},{key:"removeSubTheme",value:function removeSubTheme(t){b.removeSubTheme(t);}},{key:"setLogCallback",value:function setLogCallback(t){e.logCallback=t;}},{key:"setKeyMetricsCallback",value:function setKeyMetricsCallback(t){c.keyMetricsCallback=t;}},{key:"config",value:function config(){for(var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=Object.keys(t),n=0;n<e.length;n++){var i=this["set"+capitalizeFirstLetter(e[n])];i&&i(t[e[n]]);}return this}}]),Context}()),S=new(function(){function GlobalUpdateManager(){_classCallCheck(this,GlobalUpdateManager),this._updateThemeSet=new Set,this._requestUpdateSet=new Set,this._timeout=null,this._runUpdatesTimeoutHandler=this._runUpdatesTimeoutHandler.bind(this);}return _createClass(GlobalUpdateManager,[{key:"_runUpdatesTimeoutHandler",value:function _runUpdatesTimeoutHandler(){this._timeout=null,this._updateThemeSet.forEach((function(t){try{t._updateThemeComponent();}catch(t){k$1.error("Error updating component themes",t);}})),this._updateThemeSet.clear(),this._requestUpdateSet.forEach((function(t){try{t.requestUpdate();}catch(t){k$1.error("Error updating component",t);}})),this._requestUpdateSet.clear();}},{key:"flush",value:function flush(){this._timeout&&(clearTimeout(this._timeout),this._runUpdatesTimeoutHandler());}},{key:"addUpdateTheme",value:function addUpdateTheme(t){this._updateThemeSet.add(t),this._timeout||(this._timeout=setTimeout(this._runUpdatesTimeoutHandler,0));}},{key:"deleteUpdateTheme",value:function deleteUpdateTheme(t){this._updateThemeSet.delete(t);}},{key:"addRequestUpdate",value:function addRequestUpdate(t){this._requestUpdateSet.add(t),this._timeout||(this._timeout=setTimeout(this._runUpdatesTimeoutHandler,0));}},{key:"deleteRequestUpdate",value:function deleteRequestUpdate(t){this._requestUpdateSet.delete(t);}}]),GlobalUpdateManager}());var A=[{pattern:"TV-14",replacer:"Rated TV-14"},{pattern:"CC",replacer:"Closed Captions available"},{pattern:"HD",replacer:"High Definition available"},{pattern:/ENG(?!\+)/,replacer:"English Available"},{pattern:/ENG\+ES/,replacer:"Available in English and Spanish"},{pattern:"AD",replacer:"Audio Description available"},{pattern:"RT",replacer:"Rotten Tomatoes"},{pattern:/(S)+(\d+)+(E)+(\d+)+/,replacer:function replacer(t,e,n,i,o){return "Season ".concat(n," Episode ").concat(o)}}];generateAbbrevConfig(A);function wrapWithBoundary(t){return "\\b".concat(t,"\\b")}function generateAbbrevConfig(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:A,e=(arguments.length>1?arguments[1]:void 0)?[].concat(A,_toConsumableArray(t)):t,n={},i={},o="",r=0;return e.forEach((function(t,e){var a,s=t.pattern,l=t.replacer;s instanceof RegExp?(i[e+r]={pattern:s,replacer:l},a=wrapWithBoundary(s.source),r+=function getNumberOfCaptureGroups(t){return new RegExp(t.toString()+"|").exec("").length-1}(s)):(n[s]={replacer:l},a=wrapWithBoundary(s));o=""===o?"(".concat(a,")"):"".concat(o,"|(").concat(a,")");})),{abbreviationsPattern:o=new RegExp(o,"g"),stringPatternMap:n,regExpPatternMap:i}}function withHandleKey(t){return function(e){_inherits(_class2,e);var n=_createSuper(_class2);function _class2(){return _classCallCheck(this,_class2),n.apply(this,arguments)}return _createClass(_class2,[{key:"_handleKey",value:function _handleKey(t){return this._processEvent(t)}},{key:"_handleKeyRelease",value:function _handleKeyRelease(t){return this._processEvent(t,"Release")}},{key:"_processEvent",value:function _processEvent(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=(this.stage.application.__keymap||{})[t.keyCode];return n||(n=t.key),!(!n||"function"!=typeof this["on".concat(n).concat(e)])&&(this._invokeKeyPayloadCallback(n+e),this["on".concat(n).concat(e)].call(this,this,t))}},{key:"_invokeKeyPayloadCallback",value:function _invokeKeyPayloadCallback(t){this.metricsPayload&&"function"==typeof k$1.keyMetricsCallback&&k$1.keyMetricsCallback(t,this.metricsPayload);}}],[{key:"name",get:function get(){return t.name}}]),_class2}(t)}function withLayout(t){return function(t){_inherits(_class3,t);var e=_createSuper(_class3);function _class3(){return _classCallCheck(this,_class3),e.apply(this,arguments)}return _createClass(_class3,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(_class3.prototype),"_construct",this)&&_get(_getPrototypeOf(_class3.prototype),"_construct",this).call(this),this._previousDimensionData=null;}},{key:"itemLayout",get:function get(){return this._itemLayout},set:function set(t){var e,n=this.constructor._componentName||this.constructor.name;t&&(e=JSON.parse(JSON.stringify(t,(function(t,e){if(!("circle"!==t&&e<0))return "circle"===t?Boolean(e):e;k$1.error("itemLayout for ".concat(n," received an invalid value of ").concat(e," for ").concat(t));})))),stringifyCompare(this._itemLayout,e)||(e&&!e.upCount?(this._originalW=this.w,this._originalH=this.h,this._itemLayout=_objectSpread({w:this._originalW,h:this._originalH},e)):this._itemLayout=e,this._updateItemLayout());}},{key:"_allowUpdate",value:function _allowUpdate(){var t=this._itemLayout||{},e=t.w,n=void 0===e?"":e,i=t.h,o=void 0===i?"":i,r=t.circle,a=void 0===r?"":r,s=t.ratioX,l=void 0===s?"":s,c=t.ratioY,u=void 0===c?"":c,h=t.upCount,d=void 0===h?"":h,p=Object.values(k$1.theme.layout).join("")+"".concat(n).concat(o).concat(a?1:0).concat(l).concat(u).concat(d);return p!==this._previousDimensionData&&(this._previousDimensionData=p,!0)}},{key:"_updateItemLayout",value:function _updateItemLayout(){if(this._allowUpdate()){var t=getDimensions(this.theme,this._itemLayout),e=t.w,n=t.h;if(n||e){var i=k$1.theme.layout.screenW,o=k$1.theme.layout.screenH,r=e||n*(i/o),a=n||e*(o/i);this.w=this._itemLayout&&this._itemLayout.circle?a:r,this.h=a,this._itemLayout&&this._itemLayout.circle&&this.style.radius?(this._circleSet=!0,this._originalRadius=this.style.radius,this.style=_objectSpread(_objectSpread({},this.style),{},{radius:a/2})):this._circleSet&&(this.style=_objectSpread(_objectSpread({},this.style),{},{radius:this._originalRadius}),this._originalRadius=void 0,this._circleSet=!1),this.queueRequestUpdate&&this.queueRequestUpdate(),this.fireAncestors("$itemChanged");}}}}]),_class3}(t)}function withMarqueeSync(t){return function(n){_inherits(_class4,n);var i=_createSuper(_class4);function _class4(){return _classCallCheck(this,_class4),i.apply(this,arguments)}return _createClass(_class4,[{key:"_init",value:function _init(){_get(_getPrototypeOf(_class4.prototype),"_init",this).call(this),this._shouldSync&&this._updateSignals();}},{key:"_update",value:function _update(){_get(_getPrototypeOf(_class4.prototype),"_update",this).call(this),this._shouldSync?this._updateSignals():this._cleanupSyncValues();}},{key:"_cleanupSyncValues",value:function _cleanupSyncValues(){this.syncArray.map((function(t){t.marqueeOverrideLoopX=void 0,t.signals&&t.signals.willMarquee&&delete t.signals.willMarquee;}));}},{key:"_updateSignals",value:function _updateSignals(){this.syncArray&&this.syncArray.map((function(t){t.signals=_objectSpread(_objectSpread({},t.signals),{},{willMarquee:"_willMarquee"});}));}},{key:"_willMarquee",value:function _willMarquee(t){var e=this;this._shouldSync&&(this._longestMarqueeWidth=Math.max(t._textRenderedW||0,this._longestMarqueeWidth||0),this.syncArray.map((function(t){t.marqueeOverrideLoopX=e._longestMarqueeWidth;})));}},{key:"_shouldSync",get:function get(){return !1!==this.style.marqueeSync&&(this.syncArray?Array.isArray(this.syncArray)?!(this.syncArray.length<2)||(e.warn("warning: syncArray must contain at least two component references."),!1):(e.warn("warning: syncArray must be typeof array."),!1):(e.warn("warning: components using MarqueeSync must have a syncArray getter defined."),!1))}}],[{key:"name",get:function get(){return t.name}}]),_class4}(t)}var O=function getCharacterValue(t,e){return t.charCodeAt(0)*(e+1)},W=function getHash(t){return JSON.stringify(t).length+"-"+function getCharacterSum(t){for(var e=JSON.stringify(t),n=0,i=0;i<e.length;i++)n+=O(e[i],i);return n}(t)};function executeWithContext(t,e){return "function"==typeof t?t(e):"object"===_typeof(t)?t:{}}function isPlainObject(t){return !("object"!==_typeof(t)||null===t||Array.isArray(t)||t instanceof Date||t instanceof RegExp||t instanceof Function)}var j=function getSubTheme(t){if(t.subTheme)return t.subTheme;for(var e=t.p;e&&!e.subTheme;)e=e.parent;return e&&e.subTheme},M=function getComponentConfig(t){if(!isPlainObject(t))return {};var e,n=R(t);return n?Array.from(n).reverse().reduce((function(e,n){var i;return clone(e,(null==t||null===(i=t.theme)||void 0===i||null===(i=i.componentConfig)||void 0===i?void 0:i[n])||{})}),{}):(null==t||null===(e=t.theme)||void 0===e||null===(e=e.componentConfig)||void 0===e?void 0:e[t.constructor.__componentName])||{}},R=function getPrototypeChain(t){if(!isPlainObject(t))return [];var e=new Set,n=t;do{null!==(n=Object.getPrototypeOf(n))&&"object"===_typeof(n)&&n.constructor.__componentName&&e.add(n.constructor.__componentName);}while(n);return Array.from(e)};function removeEmptyObjects(t){for(var e in t)t.hasOwnProperty(e)&&"object"===_typeof(t[e])&&null!==t[e]&&(removeEmptyObjects(t[e]),0===Object.keys(t[e]).length&&delete t[e]);if(0!==Object.keys(t).length)return t}var N=function findPropertiesBySubProperty(t,e){var n=new Set;return function traverse(t){for(var i in t)if(t.hasOwnProperty(i)&&"object"===_typeof(t[i])){if(i===e)for(var o in t[i])t[i].hasOwnProperty(o)&&n.add(o);traverse(t[i]);}}(t),Array.from(n)},D=function generateComponentStyleSource(t){var e={},n=t.theme;if(!isPlainObject(t))return {};if(F(t).forEach((function(t){var i=t.style;if("object"!==_typeof(i)||i.base||i.mode||i.tone||i.default){var o=i.base,r=i.mode,a=i.tone;e=clone(e,{base:executeWithContext(o,n)}),e=clone(e,{tone:executeWithContext(a,n)}),e=clone(e,{mode:executeWithContext(r,n)});}else e=clone(e,{base:i});})),t._componentConfig){t._componentConfig.styleConfig&&(k$1.info("style config is deprecated. Please use style = { base: {}, tone: {}, mode: {} }"),e=clone(e,t._componentConfig.styleConfig));var i=t._componentConfig.style;if(null!=i&&i.base&&(e=clone(e,{base:i.base})),i){var o=JSON.parse(JSON.stringify(i));delete o.base,delete o.tone,delete o.mode,e=clone(e,{overwrite:o});}null!=i&&i.tone&&(e=clone(e,{tone:i.tone})),null!=i&&i.mode&&(e=clone(e,{mode:i.mode}));}if(t._componentLevelStyle){t._componentLevelStyle.styleConfig&&(e=clone(e,t._componentLevelStyle.styleConfig));var r=t._componentLevelStyle;if(r){var a=JSON.parse(JSON.stringify(r));delete a.base,delete a.tone,delete a.mode,e=clone(e,{overwrite:a});}null!=r&&r.base&&(e=clone(e,{base:r.base})),null!=r&&r.tone&&(e=clone(e,{tone:r.tone})),null!=r&&r.mode&&(e=clone(e,{mode:r.mode}));}for(var s=e,l=s.base,c=void 0===l?{}:l,u=s.mode,h=void 0===u?{}:u,d=s.tone,p=void 0===d?{}:d,_=s.overwrite,f=void 0===_?{}:_,g={},m=N(h,"tone"),v=N(p,"mode"),b=0,S=_toConsumableArray(new Set(["unfocused"].concat(_toConsumableArray(Object.keys(h)),_toConsumableArray(v))));b<S.length;b++)for(var C=S[b],T=0,I=_toConsumableArray(new Set(["neutral"].concat(_toConsumableArray(Object.keys(p)),_toConsumableArray(m))));T<I.length;T++){var A,P,L=I[T],B=clone(c,f);B=clone(B,p[L]),B=clone(B,h[C]),B=clone(B,(null===(A=p[L])||void 0===A||null===(A=A.mode)||void 0===A?void 0:A[C])||{}),B=clone(B,(null===(P=h[C])||void 0===P||null===(P=P.tone)||void 0===P?void 0:P[L])||{}),g[C+"_"+L]=B;}return U(removeEmptyObjects(z(t,g))||{},t.constructor.aliasStyles)},z=function colorParser(t,e){var i=JSON.stringify(e,(function(e,i){if(!(-1<["tone","mode"].indexOf(e)))return "string"==typeof i&&i.startsWith("theme.")?n(t,i):Array.isArray(i)&&2===i.length?getHexColor(i[0],i[1]):i}));return JSON.parse(i||{})};function generateNameFromPrototypeChain(t){var e,n;if(!Object.getPrototypeOf(t))return (null===(n=t.constructor)||void 0===n?void 0:n.name)||"";var i=(null===(e=t.constructor)||void 0===e?void 0:e.name)||"",o=generateNameFromPrototypeChain(Object.getPrototypeOf(t));return o?"".concat(o,".").concat(i):i}var E={},F=function getStyleChainMemoized(t){var e=generateNameFromPrototypeChain(t);if(E[e])return E[e];var n=H(t);return E[e]=n,n},H=function getStyleChain(t){var e=new Set,n=t;do{(n=Object.getPrototypeOf(n))&&n.constructor&&(n.constructor.__mixinStyle&&!e.has(n.constructor.__mixinStyle)&&("object"===_typeof(n.constructor.__mixinStyle)&&Object.keys(n.constructor.__mixinStyle).length||"function"==typeof n.constructor.__mixinStyle)&&e.add(n.constructor.__mixinStyle),n.constructor.__themeStyle&&!e.has(n.constructor.__themeStyle)&&("object"===_typeof(n.constructor.__themeStyle)&&Object.keys(n.constructor.__themeStyle).length||"function"==typeof n.constructor.__themeStyle)&&e.add(n.constructor.__themeStyle));}while(n);return Array.from(e).map((function(t){return {style:t}})).reverse()},U=function formatStyleObj(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=new Set;return n.add([K,[e]]),Array.from(n).reduce((function(t,e){var n=_slicedToArray(e,2),i=n[0],o=n[1];return i.apply(void 0,[t].concat(_toConsumableArray(o)))}),t)},K=function replaceAliasValues(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=JSON.stringify(t);return [{prev:"height",curr:"h",skipWarn:!0},{prev:"width",curr:"w",skipWarn:!0}].concat(_toConsumableArray(e||[])).forEach((function(t){t&&"string"==typeof t.prev&&"string"==typeof t.curr&&(!t.skipWarn&&n.search('"'.concat(t.prev,'":'))>=0&&console.warn('The style property "'.concat(t.prev,'" is deprecated and will be removed in a future release. Please use "').concat(t.curr,'" instead.')),n=n.replaceAll('"'.concat(t.prev,'":'),'"'.concat(t.curr,'":')));})),JSON.parse(n)},q=new Map;k$1.on("themeUpdate",(function(){q.clear();}));var X=q,V=function(e){_inherits(StyleManager,t.EventEmitter);var n=_createSuper(StyleManager);function StyleManager(){var t,e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).component,i=void 0===e?{}:e;return _classCallCheck(this,StyleManager),(t=n.apply(this,arguments)).init(i),t}return _createClass(StyleManager,[{key:"init",value:function init(t){this.isActive=!0,this.component=t,this.setupListeners(),this._style={},this.update();}},{key:"setupListeners",value:function setupListeners(){this._boundThemeUpdate=this._onThemeUpdate.bind(this),this._hasSubTheme=Boolean(this.component._targetSubTheme),this.component._targetSubTheme?k$1.on("themeUpdate".concat(this.component._targetSubTheme),this._boundThemeUpdate):k$1.on("themeUpdate",this._boundThemeUpdate);}},{key:"clearListeners",value:function clearListeners(){this._boundThemeUpdate&&(this.component._targetSubTheme?k$1.off("themeUpdate".concat(this.component._targetSubTheme),this._boundThemeUpdate):k$1.off("themeUpdate",this._boundThemeUpdate));}},{key:"destroy",value:function destroy(){this.isActive=!1,this._cleanupCache(),this.clearListeners(),this._styleCache=null,this._boundThemeUpdate=null,this.component=null;}},{key:"_onThemeUpdate",value:function _onThemeUpdate(){this.clearSourceCache(),this.clearStyleCache(),this.update();}},{key:"clearSourceCache",value:function clearSourceCache(){if(this.component){var t=this._generateCacheKey("styleSource");this._removeCache(t);}}},{key:"clearStyleCache",value:function clearStyleCache(){if(this.component){var t=this.component,e=t.tone,n=t.mode,i=this._generateCacheKey("style_".concat(n,"_").concat(e));X.delete(i);}}},{key:"_generateCacheKey",value:function _generateCacheKey(t){return [t,this.component.constructor.__componentName,this._customStyleHash].filter(Boolean).join("_")}},{key:"_addCache",value:function _addCache(t,e){var n=this._generateCacheKey(t),i=X.get(n);X.set(n,{ids:_toConsumableArray(new Set([].concat(_toConsumableArray((null==i?void 0:i.ids)||[]),[this.component.__id]))),payload:e});}},{key:"_cleanupCache",value:function _cleanupCache(){var t=this;this.component&&X.forEach((function(e,n){var i=e.ids,o=e.payload,r=i&&i.length&&i.indexOf(t.component.__id);r>-1&&i.length>1?X.set(n,{ids:i.slice(0,r).concat(i.slice(r+1)),payload:o}):r>-1&&X.delete(n);}));}},{key:"_removeCache",value:function _removeCache(t){X.delete(t);}},{key:"_getCache",value:function _getCache(t){var e=this._generateCacheKey(t);return X.get(e)}},{key:"update",value:function update(){if(this.component){var t=this.component,e=t.mode,n=t.tone;try{var i,o,r=null===(i=this._getCache("styleSource"))||void 0===i?void 0:i.payload;r||(r=D(this.component),this._addCache("styleSource",r));var a=null===(o=this._getCache("style_".concat(e,"_").concat(n)))||void 0===o?void 0:o.payload;a||(a=function generateStyle(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isPlainObject(t))return {};var n=t.mode,i=void 0===n?"unfocused":n,o=t.tone,r=void 0===o?"neutral":o,a=e["".concat(i,"_").concat(r)]||e["unfocused_".concat(r)]||e.unfocused_neutral||{},s=t._componentLevelStyle;return s?clone(a,z(t,s)):U(a,t.constructor.aliasStyles)}(this.component,r),this._addCache("style_".concat(e,"_").concat(n),a)),this._style=a,this.emit("styleUpdate",this.style);}catch(t){k$1.error("styleManager: ",t.message);}}}},{key:"style",get:function get(){return this._style},set:function set(t){k$1.warn("styleManager: Cannot mutate style directly");}},{key:"_customStyleHash",get:function get(){if(Boolean(Object.keys(this.component.constructor.__mixinStyle||{}).length)||Boolean(Object.keys(this.component._componentLevelStyle||{}).length))return W(clone(this.component.constructor.__mixinStyle||{},this.component._componentLevelStyle||{}))}}]),StyleManager}();function withThemeStyles(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return function(n){_inherits(_class6,n);var i=_createSuper(_class6);function _class6(){return _classCallCheck(this,_class6),i.apply(this,arguments)}return _createClass(_class6,[{key:"_construct",value:function _construct(){var t=this;this._withThemeStylesSetupComplete?_get(_getPrototypeOf(_class6.prototype),"_construct",this).call(this):(_get(_getPrototypeOf(_class6.prototype),"_construct",this).call(this),this._hSetByUser=!1,this._wSetByUser=!1,this._styleManager=new V({component:this}),this._style=this._styleManager.style,this._styleManager.on("styleUpdate",(function(){t._style=t._styleManager.style,t.queueThemeUpdate();})),this._withThemeStylesSetupComplete=!0);}},{key:"_setup",value:function _setup(){_get(_getPrototypeOf(_class6.prototype),"_setup",this)&&_get(_getPrototypeOf(_class6.prototype),"_setup",this).call(this),this._targetSubTheme=j(this),this._targetSubTheme&&(this._styleManager.clearListeners(),this._styleManager.setupListeners(),this._styleManager.clearStyleCache(),this._styleManager.clearSourceCache(),this._styleManager.update());}},{key:"_attach",value:function _attach(){_get(_getPrototypeOf(_class6.prototype),"_attach",this).call(this),this._styleManager.isActive||this._styleManager.init(this);}},{key:"_detach",value:function _detach(){_get(_getPrototypeOf(_class6.prototype),"_detach",this).call(this),this._styleManager.destroy();}},{key:"_unfocus",value:function _unfocus(){this._isFocusedMode&&(this.mode="unfocused"),_get(_getPrototypeOf(_class6.prototype),"_unfocus",this).call(this);}},{key:"_focus",value:function _focus(){this._isDisabledMode||(this.mode="focused"),_get(_getPrototypeOf(_class6.prototype),"_focus",this).call(this);}},{key:"_checkDimensionUpdates",value:function _checkDimensionUpdates(){var t=!1;!this._wSetByUser&&this.style.w&&this._w!==this.style.w&&(this._w=this.style.w,t=!0),!this._hSetByUser&&this.style.h&&this._h!==this.style.h&&(this._h=this.style.h,t=!0),t&&this._updateDimensions();}},{key:"_updateThemeComponent",value:function _updateThemeComponent(){this.style&&this._isAttached()&&(this._checkDimensionUpdates(),this.queueRequestUpdate?this.queueRequestUpdate():this._update&&this._update(),this._updateItemLayout&&this._updateItemLayout());}},{key:"queueThemeUpdate",value:function queueThemeUpdate(){S.addUpdateTheme(this);}},{key:"theme",get:function get(){return this._targetSubTheme&&k$1.getSubTheme(this._targetSubTheme)||k$1.theme}},{key:"style",get:function get(){return this._style},set:function set(t){"[object Object]"===Object.prototype.toString.call(t)?(this._componentLevelStyle=t,this._styleManager.clearStyleCache(),this._styleManager.update()):k$1.error("style must be an object");}},{key:"_componentStyle",get:function get(){return k$1.info("_componentStyle will soon be deprecated. Please use Component.style"),this._style}},{key:"styleConfig",get:function get(){return this._styleConfig},set:function set(t){k$1.info("style config is deprecated. Please use style = { base: {}, tone: {}, mode: {} }"),this._styleConfig=t,this._styleManager.update();}},{key:"_componentConfig",get:function get(){return M(this)}},{key:"mode",get:function get(){var t;return this._mode||(null===(t=this._componentConfig)||void 0===t?void 0:t.mode)||"unfocused"},set:function set(t){if("string"==typeof t&&this._mode!==t){this._mode=t;var e=this["on".concat(capitalizeFirstLetter(t))];e&&"function"==typeof e&&e.call(this),this._styleManager.update();}}},{key:"tone",get:function get(){return this._tone||this._componentConfig.tone||"neutral"},set:function set(t){"string"==typeof t&&this._tone!==t&&(this._tone=t,this._styleManager.update());}},{key:"w",get:function get(){var t;return this._wSetByUser&&this._w||(null===(t=this.style)||void 0===t?void 0:t.w)||0},set:function set(t){this._w!==t&&(_set(_getPrototypeOf(_class6.prototype),"w",t,this,!0),this._wSetByUser=!0,this._styleManager.clearStyleCache(),this._styleManager.update());}},{key:"h",get:function get(){var t;return this._hSetByUser&&this._h||(null===(t=this.style)||void 0===t?void 0:t.h)||0},set:function set(t){this._h!==t&&(_set(_getPrototypeOf(_class6.prototype),"h",t,this,!0),this._hSetByUser=!0,this._styleManager.clearStyleCache(),this._styleManager.update());}}],[{key:"name",get:function get(){return t.name}},{key:"__componentName",get:function get(){if(!_get(_getPrototypeOf(_class6),"__componentName",this))throw new Error("A valid static __componentName property is required for theming to work properly. Please add this to the ".concat(this.constructor.name," class."));return _get(_getPrototypeOf(_class6),"__componentName",this)}},{key:"__mixinStyle",get:function get(){return e}}]),_class6}(t)}function withTags(t){return function(e){_inherits(_class7,e);var n=_createSuper(_class7);function _class7(){return _classCallCheck(this,_class7),n.apply(this,arguments)}return _createClass(_class7,[{key:"_construct",value:function _construct(){var t=this;(this.constructor.tags||[]).forEach((function(e){if("object"===_typeof(e))var n=e.name,i=e.path;else n=e,i=e;var o="_"+n,r=function getPropertyDescriptor$1(t){return {get:function get(){return this.tag(t)},configurable:!0,enumerable:!0}}(i);Object.defineProperty(Object.getPrototypeOf(t),o,r);})),_get(_getPrototypeOf(_class7.prototype),"_construct",this)&&_get(_getPrototypeOf(_class7.prototype),"_construct",this).call(this);}}],[{key:"name",get:function get(){return t.name}}]),_class7}(t)}function capital(t){return t.charAt(0).toUpperCase()+t.slice(1)}function withUpdates(t){return function(e){_inherits(_class8,e);var n=_createSuper(_class8);function _class8(){return _classCallCheck(this,_class8),n.apply(this,arguments)}return _createClass(_class8,[{key:"_construct",value:function _construct(){var t=this,e=Object.getPrototypeOf(this);e._withUpdatesInitialized||((this.constructor.properties||[]).forEach((function(t){var n=function getPropertyDescriptor(t,e){return {get:function get(){var n=this["_get".concat(capital(t))];if(n&&"function"==typeof n){var i=n.call(this,this[e]);this[e]=i;}return this[e]},set:function set(n){if(n!==this[e]){var i=this["_set".concat(capital(t))];i&&"function"==typeof i&&(n=i.call(this,n)),this[e]="style"===e?clone(this[e],n):n,this.queueRequestUpdate();}},configurable:!0,enumerable:!0}}(t,"_"+t);void 0!==n&&Object.defineProperty(e,t,n);})),(this.constructor.aliasProperties||[]).forEach((function(t){if(t&&"string"==typeof t.prev&&"string"==typeof t.curr){var n=function getAliasPropertyDescriptor(t,e){var n='The property "'.concat(t,'" is deprecated and will be removed in a future release. Please use "').concat(e,'" instead.');return {get:function get(){return console.warn(n),this[e]},set:function set(t){console.warn(n),this[e]=t;}}}(t.prev,t.curr);void 0!==n&&Object.defineProperty(e,t.prev,n);}})),e._withUpdatesInitialized=!0);this._whenEnabled=new Promise((function(e){t._whenEnabledResolver=e;})),_get(_getPrototypeOf(_class8.prototype),"_construct",this)&&_get(_getPrototypeOf(_class8.prototype),"_construct",this).call(this);}},{key:"queueRequestUpdate",value:function queueRequestUpdate(){this._isAttached()&&S.addRequestUpdate(this);}},{key:"_firstEnable",value:function _firstEnable(){this._readyForUpdates=!0,this._whenEnabledResolver(),S.deleteRequestUpdate(this),this.requestUpdate(),_get(_getPrototypeOf(_class8.prototype),"_firstEnable",this)&&_get(_getPrototypeOf(_class8.prototype),"_firstEnable",this).call(this);}},{key:"_detach",value:function _detach(){_get(_getPrototypeOf(_class8.prototype),"_detach",this).call(this),S.deleteRequestUpdate(this);}},{key:"requestUpdate",value:function requestUpdate(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._readyForUpdates||e){var n=this._update();"object"===_typeof(n)&&null!==n&&n.catch&&n.catch((function(e){k$1.error("asyncronous _update() error in '".concat(t.constructor.__componentName,"'"),t,e);}));}}},{key:"logPropTable",value:function logPropTable(){console.table(this._propTable);}},{key:"_propTable",get:function get(){var t=this;return this.constructor.properties.reduce((function(e,n){return e[n]=t[n],e}),{})}}],[{key:"name",get:function get(){return t.name}}]),_class8}(t)}var Y="__original";function withExtensions(t){return t.prototype.constructor._withExtensionsApplied?t:function(e){_inherits(_class10,e);var n=_createSuper(_class10);function _class10(){return _classCallCheck(this,_class10),n.apply(this,arguments)}return _createClass(_class10,[{key:"_prototypeChain",get:function get(){if(this.__prototypeChain)return this.__prototypeChain;var t=new Set,e=this;do{if(null!==(e=Object.getPrototypeOf(e))&&"object"===_typeof(e))try{e.constructor.__componentName&&t.add(e.constructor.__componentName);}catch(t){}}while(e);return this.__prototypeChain=t,t}},{key:"_extensions",get:function get(){var t=k$1&&k$1.theme&&k$1.theme.extensions;return !t||!Array.isArray(t)||Array.isArray(t)&&!t.length?[]:t.filter((function(t){var e=t.targetComponent,n=t.extension;return ("string"==typeof e||Array.isArray(e))&&"function"==typeof n})).slice().reverse()||[]}},{key:"_componentExtensions",get:function get(){var t=this;return this._extensions.filter((function(e){var n=e.targetComponent;return "string"==typeof n?n===t.constructor.__componentName||t._prototypeChain.has(n):!!Array.isArray(n)&&n.find((function(e){if(e.startsWith("/")&&e.endsWith("/")){var n=new RegExp(e.slice(1,-1));return Array.from(t._prototypeChain).some((function(t){return n.test(t)}))}return t._prototypeChain.has(e)}))})).reduce((function(t,e){var n=e.extension;return t.push(n),t}),[])}},{key:"_extensionApplied",get:function get(){return this._currentComponentExtensionLength===this._appliedExtensionLength}},{key:"_construct",value:function _construct(){this._appliedExtensionLength=0,this._extendedList={},this._extensionInstance={},this._setupExtensionBound=this._setupExtension.bind(this),k$1.on("themeUpdate",this._setupExtensionBound),this._currentComponentExtensionLength=this._calculateComponentExtensionLength(),this._createExtension(),_get(_getPrototypeOf(_class10.prototype),"_construct",this).call(this);}},{key:"_detach",value:function _detach(){_get(_getPrototypeOf(_class10.prototype),"_detach",this).call(this),k$1.off("themeUpdate",this._setupExtensionBound);}},{key:"_setupExtension",value:function _setupExtension(){this._currentComponentExtensionLength=this._calculateComponentExtensionLength(),this._createExtension.call(this);}},{key:"_resetComponent",value:function _resetComponent(){var t=this;this._extensionInstance._extensionCleanup&&this._extensionInstance._extensionCleanup.call(this),(Object.keys(this._extendedList)||[]).forEach((function(e){delete t[e],delete t[e+Y];})),this._extensionInstance={},this._extendedList={};}},{key:"_calculateComponentExtensionLength",value:function _calculateComponentExtensionLength(){return this._componentExtensions.reduce((function(t,e){return t+=e.toString().length}),0)}},{key:"_createExtension",value:function _createExtension(){if(!this._extensionApplied){this._resetComponent();var t=new(this._createExtensionClass());this._extendedList=this._createExtensionAliases(t),this._extensionInstance=t,this._setComponentAliases(this._extendedList);}}},{key:"_createExtensionClass",value:function _createExtensionClass(){var t=this._componentExtensions.reduce((function(t,e){return e(t)}),(function ExtensionBase(){}));return this._appliedExtensionLength=this._calculateComponentExtensionLength(),t}},{key:"_createExtensionAliases",value:function _createExtensionAliases(t){for(var e=t,n=0;n<this._componentExtensions.length+1;n++)e=Object.getPrototypeOf(e);var i={},o=this._componentExtensions.reduce((function(t,e){var n=new new e(_createClass((function FakeClass(){_classCallCheck(this,FakeClass);}))),o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(n));return Object.keys(o).forEach((function(e){if(!["constructor"].includes(e)){if(o[e].get||o[e].set)return i[e]={type:"accessor"},void(t[e]={get:function get(){return this[e+Y]},set:function set(t){this[e+Y]=t;}});i[e]={type:"method"},t[e]={value:function value(){this[e+Y]&&this[e+Y]();}};}})),t}),{});return Object.defineProperties(e,o),Object.setPrototypeOf(e,this),i}},{key:"_setComponentAliases",value:function _setComponentAliases(t){var e=this;Object.keys(t).forEach((function(n){e[n+Y]=e[n],"method"===t[n].type?e[n]=e._extensionInstance[n]:"accessor"===t[n].type&&Object.defineProperty(e,n,{configurable:!0,get:function get(){return this._extensionInstance[n]},set:function set(t){this._extensionInstance[n]=t;}});}));}}],[{key:"name",get:function get(){return t.name}},{key:"__componentName",get:function get(){if(!_get(_getPrototypeOf(_class10),"__componentName",this))throw new Error("A valid static __componentName property is required for theming to work properly. Please add this to the ".concat(this.constructor.name," class."));return _get(_getPrototypeOf(_class10),"__componentName",this)}},{key:"_withExtensionsApplied",get:function get(){return !0}}]),_class10}(t)}var G=function withMixins(t){return withExtensions(withLayout(withThemeStyles(withUpdates(withTags(withHandleKey(t))))))}(function(e){_inherits(Base,t.Component);var n=_createSuper(Base);function Base(){return _classCallCheck(this,Base),n.apply(this,arguments)}return _createClass(Base,[{key:"_construct",value:function _construct(){this.skipPlinko=!1,this.centerInParent=!1,this.loaded||(this.loaded=Promise.resolve());}},{key:"_init",value:function _init(){this.queueRequestUpdate();}},{key:"_resetLoadedPromise",value:function _resetLoadedPromise(){var t=this;this.loaded=new Promise((function(e,n){t._resolveLoadedPromise=e,t._rejectLoadedPromise=n;}));}},{key:"_update",value:function _update(){}},{key:"_focus",value:function _focus(){void 0===this.shouldSmooth&&(this.shouldSmooth=!0),this.queueRequestUpdate();}},{key:"_unfocus",value:function _unfocus(){this.queueRequestUpdate();}},{key:"applySmooth",value:function applySmooth(t,e,n){this.shouldSmooth?t.smooth=n||e:t.patch(e);}},{key:"announce",get:function get(){return this._announce},set:function set(t){this._announce=t;}},{key:"announceContext",get:function get(){return this._announceContext},set:function set(t){this._announceContext=t;}},{key:"shouldSmooth",get:function get(){return this._shouldSmooth},set:function set(t){this._shouldSmooth=t;}},{key:"_isDisabledMode",get:function get(){return "disabled"===this.mode}},{key:"_isUnfocusedMode",get:function get(){return "unfocused"===this.mode}},{key:"_isFocusedMode",get:function get(){return "focused"===this.mode}},{key:"isFullyOnScreen",value:function isFullyOnScreen(){return isComponentOnScreen(this)}},{key:"getFocusScale",value:function getFocusScale(){return k$1.theme.layout.focusScale}},{key:"getUnfocusScale",value:function getUnfocusScale(){return 1}}],[{key:"__componentName",get:function get(){return "Base"}}]),Base}()),Q=Object.freeze({__proto__:null,base:function base$R(t){return {gradientTop:t.color.fillTransparent,radius:t.radius.none}},tone:function tone$o(t){return {neutral:{gradientColor:t.color.material},inverse:{gradientColor:t.color.fillNeutral},brand:{gradientColor:t.color.fillBrand}}}}),$=function(e){_inherits(Gradient,G);var n=_createSuper(Gradient);function Gradient(){return _classCallCheck(this,Gradient),n.apply(this,arguments)}return _createClass(Gradient,[{key:"_update",value:function _update(){this.patch({rect:!0,rtt:!0,colorTop:this.style.gradientTop,colorBottom:this.style.gradientColor,texture:t.Tools.getRoundRect(this.w,this.h,this.style.radius)});}}],[{key:"__componentName",get:function get(){return "Gradient"}},{key:"__themeStyle",get:function get(){return Q}}]),Gradient}(),J=Object.freeze({__proto__:null,base:function base$Q(t){return {animationBlurEntrance:t.animation.utilityEntrance,animationBlurExit:t.animation.utilityExit,animationComponentEntrance:t.animation.utilityEntrance,animationGradientEntrance:t.animation.utilityEntrance,animationGradientExit:t.animation.utilityExit,animationImageScaleEntrance:t.animation.standardEntrance,animationImageScaleExit:t.animation.standardEntrance,blur:4,centerImageRadius:t.radius.md,fallbackSrc:void 0,fillColor:t.color.overlay,gradientColor:t.color.material,imageScale:void 0,imageScalePivotX:.5,imageScalePivotY:.5,padding:t.spacer.md,radius:0,zIndexSet:{image:1,blur:2,centerImage:3,fill:4,gradient:5,foreground:6}}}});var Z=function(e){_inherits(CustomImageTexture,t.Texture);var n=_createSuper(CustomImageTexture);function CustomImageTexture(t){var e;return _classCallCheck(this,CustomImageTexture),(e=n.call(this,t))._src=void 0,e._hasAlpha=!1,e}return _createClass(CustomImageTexture,[{key:"src",get:function get(){return this._src},set:function set(t){this._src!==t&&(this._src=t,this._changed());}},{key:"hasAlpha",get:function get(){return this._hasAlpha},set:function set(t){this._hasAlpha!==t&&(this._hasAlpha=t,this._changed());}},{key:"w",get:function get(){return this._w},set:function set(t){this._w=t,this._changed();}},{key:"h",get:function get(){return this._h},set:function set(t){this._h=t,this._changed();}},{key:"_getIsValid",value:function _getIsValid(){return !!this._src}},{key:"_getLookupId",value:function _getLookupId(){return this._src}},{key:"_getSourceLoader",value:function _getSourceLoader(){var e=this,n=this._w,i=this._h,o=this._src,r=this._hasAlpha;if(this.stage.getOption("srcBasePath")){var a=o.charCodeAt(0);-1===o.indexOf("//")&&(a>=65&&a<=90||a>=97&&a<=122||46==a)&&(o=this.stage.getOption("srcBasePath")+o);}return function(a){switch(function checkFileType(t){return t.startsWith("<svg")?"SVG":t.startsWith("blob:")?"Blob":/\.(jpeg|jpg|gif|png|svg)$/i.test(t)?"Image":"Unknown"}(o)){case"SVG":return function createSvg(e,n,i,o,r){var a=n.platform.getDrawingCanvas(),s=a.getContext("2d");s.imageSmoothingEnabled=!0;var l=new Image;l.onload=function(){a.width=o,a.height=r,s.drawImage(l,0,0,a.width,a.height),e(null,{source:a,w:o,h:r});},l.onerror=function(t){e(t);},t.Utils.isPS4||(l.crossOrigin="Anonymous"),l.src=i;}(a,e.stage,"data:image/svg+xml,".concat(encodeURIComponent(o)),n,i);case"Blob":return function imageLoader(e,n){var i=e.src,o=new Image;return "data:"==i.substr(0,5)||t.Utils.isPS4||(o.crossOrigin="Anonymous"),o.onerror=function(){if(o.src)return n("Image load error")},o.onload=function(){n(null,{source:o,renderInfo:{src:i,compressed:!1},hasAlpha:!0});},o.src=i,function(){o.onerror=null,o.onload=null,o.removeAttribute("src");}}({src:o},a);default:return e.stage.platform.loadSrcTexture({src:o,hasAlpha:r},a)}}}},{key:"getNonDefaults",value:function getNonDefaults(){var t=_get(_getPrototypeOf(CustomImageTexture.prototype),"getNonDefaults",this).call(this);return this._src&&(t.src=this._src),t}}]),CustomImageTexture}(),tt=function(e){_inherits(Artwork,G);var n,i,o,r,a=_createSuper(Artwork);function Artwork(){return _classCallCheck(this,Artwork),a.apply(this,arguments)}return _createClass(Artwork,[{key:"_shouldBlur",get:function get(){var t=this._blur||this._hasCenterImage;return this._Image.rtt=t,t}},{key:"_hasCenterImage",get:function get(){return -1<["circle","square"].indexOf(this.format)||"contain"===this.format&&!this._aspectRatioEqual}},{key:"w",get:function get(){return _get(_getPrototypeOf(Artwork.prototype),"w",this)},set:function set(t){_set(_getPrototypeOf(Artwork.prototype),"w",t,this,!0),this._componentSrc=this._generatePromise();}},{key:"h",get:function get(){return _get(_getPrototypeOf(Artwork.prototype),"h",this)},set:function set(t){_set(_getPrototypeOf(Artwork.prototype),"h",t,this,!0),this._componentSrc=this._generatePromise();}},{key:"_actualAspectRatio",get:function get(){return this.w&&this.h?reduceFraction("".concat(this.w,"/").concat(this.h)).replace("/","x"):null}},{key:"_supportedAspectRatioHeights",get:function get(){var t=this;return this.srcCallbackAspectRatios.map((function(e){var n=_slicedToArray(e.split("x").map((function(t){return parseInt(t)})),2),i=n[0],o=n[1];return t.w/i*o}))}},{key:"_closestSupportedAspectRatio",get:function get(){var t=this,e=this._supportedAspectRatioHeights.reduce((function(e,n){return Math.abs(n-t.h)<Math.abs(e-t.h)?n:e}));return this.srcCallbackAspectRatios[this._supportedAspectRatioHeights.indexOf(e)]}},{key:"_processedImageSrc",get:function get(){var t=this.src||this.fallbackSrc;return t!==this.fallbackSrc&&this.srcCallback&&"function"==typeof this.srcCallback&&(t=this.srcCallback({closestAspectRatio:this._closestSupportedAspectRatio,aspectRatio:this._actualAspectRatio,src:this.src,w:this.w,h:this.h})),t&&t.then?t:Promise.resolve(t)}},{key:"_gradientPatch",get:function get(){return {alpha:!this._Gradient&&this.shouldSmooth?.001:1,style:{gradientColor:getValidColor(this.style.gradientColor)},h:this.h+4,type:$,w:this.w+4,x:-2,y:-2,zIndex:this.core.findZContext().zIndex+this.style.zIndexSet.gradient}}},{key:"_construct",value:function _construct(){_get(_getPrototypeOf(Artwork.prototype),"_construct",this).call(this),this._srcCallbackAspectRatios=["16x9","3x4","4x3","2x1","1x1"];}},{key:"_setSrc",value:function _setSrc(t){return this._componentSrc=this._generatePromise(),t}},{key:"_getFallbackSrc",value:function _getFallbackSrc(){return this._fallbackSrc||this.style&&this.style.fallbackSrc}},{key:"_generatePromise",value:function _generatePromise(){var t,e;return {complete:new Promise((function(n,i){t=n,e=i;})),resolve:t,reject:e}}},{key:"_setup",value:function _setup(){this.alpha=.001,this._componentSrc=this._generatePromise(),this._aspectRatioEqual=!1,this._Image.on("txLoaded",this._resolveLoading.bind(this)),this._Image.on("txError",this._rejectLoading.bind(this));}},{key:"_resolveLoading",value:function _resolveLoading(){this._aspectRatioEqual=!!this._Image.texture.source&&parseFloat(this.finalW/this.finalH).toFixed(2)===parseFloat(this._Image.texture.source.w/this._Image.texture.source.h).toFixed(2),this._componentSrc.resolve&&this._componentSrc.resolve(),this.signal("imageLoaded");}},{key:"_rejectLoading",value:function _rejectLoading(t){this._componentSrc.reject&&this._componentSrc.reject(t);}},{key:"_update",value:(r=_asyncToGenerator(_regeneratorRuntime().mark((function _callee9(){return _regeneratorRuntime().wrap((function _callee9$(t){for(;;)switch(t.prev=t.next){case 0:return this._updateRadius(),this._updateGradient(),t.next=4,this._updateImage();case 4:if(this._updateFillColor(),this._updateForegroundImage(),this.src){t.next=9;break}return this._showComponent(),t.abrupt("return");case 9:return t.prev=9,t.next=12,this._componentSrc.complete;case 12:return t.next=14,this._updateCenterImage();case 14:this._updateBlur(),this._showComponent(),this._updateScale(),t.next=22;break;case 19:t.prev=19,t.t0=t.catch(9),this._handleImageLoadError();case 22:void 0===this.shouldSmooth&&(this.shouldSmooth=!0);case 23:case"end":return t.stop()}}),_callee9,this,[[9,19]])}))),function _update(){return r.apply(this,arguments)})},{key:"_updateScale",value:function _updateScale(){if(this.shouldScale){var t;switch(_typeof(this.style.imageScale)){case"function":t=this.style.imageScale(this.w);break;case"number":t=this.style.imageScale;break;default:t=1;}this._Image.smooth={pivotX:this.style.imageScalePivotX,pivotY:this.style.imageScalePivotY,scale:[t,this._Image.scale<t?this.style.animationImageScaleEntrance:this.style.animationImageScaleExit]};}else {this._Image.smooth={scale:[1,this.style.animationImageScaleExit]};}}},{key:"_handleImageLoadError",value:function _handleImageLoadError(){this.src!==this.fallbackSrc&&(k$1.error("Image ".concat(this._src," failed to load")),this.fallbackSrc&&this.fallbackSrc!==this.src&&(this.src=this.fallbackSrc));}},{key:"_showComponent",value:function _showComponent(){this.smooth={alpha:[1,this.style.animationComponentEntrance]};}},{key:"_updateForegroundImage",value:(o=_asyncToGenerator(_regeneratorRuntime().mark((function _callee10(){var t,e=this;return _regeneratorRuntime().wrap((function _callee10$(n){for(;;)switch(n.prev=n.next){case 0:if(this._foregroundSrc){n.next=3;break}return this._ForegroundImage&&this.patch({ForegroundImage:void 0}),n.abrupt("return");case 3:t={mount:.5,x:this.w/2,y:this.h/2,zIndex:this.core.findZContext().zIndex+this.style.zIndexSet.foreground,texture:{type:Z,src:this._foregroundSrc,hasAlpha:!0}},this.foregroundWidth&&this.foregroundHeight?(t.h=this.foregroundHeight,t.w=this.foregroundWidth,this.patch({ForegroundImage:t})):(this.foregroundWidth||this.foregroundHeight)&&(this.patch({ForegroundImage:_objectSpread(_objectSpread({},t),{},{alpha:.001})}),this._ForegroundImage.once("txLoaded",(function(){var t=e._ForegroundImage.texture.getRenderWidth(),n=e._ForegroundImage.texture.getRenderHeight();e._ForegroundImage.patch({alpha:1,w:e.foregroundHeight?e.foregroundHeight*(t/n):e.foregroundWidth,h:e.foregroundWidth?e.foregroundWidth*(n/t):e.foregroundHeight});}))),this.patch({ForegroundImage:t});case 6:case"end":return n.stop()}}),_callee10,this)}))),function _updateForegroundImage(){return o.apply(this,arguments)})},{key:"_updateBlur",value:function _updateBlur(){var e=this;(!this._shouldBlur||this._Image&&this._Image.texture&&this._Image.texture.src===this.fallbackSrc)&&this._Blur?this.shouldSmooth?(this._Blur._getTransition("alpha").once("finish",(function(){e.patch({Blur:void 0});})),this._Blur.smooth={alpha:[0,this.style.animationBlurExit]}):this.patch({Blur:void 0}):!this._srcFailed&&this._shouldBlur&&(this.patch({Blur:{alpha:!this._Blur&&this.shouldSmooth?.001:1,amount:this.style.blur,zIndex:this.core.findZContext().zIndex+this.style.zIndexSet.blur,content:{Image:{h:this.h,texture:this._Image.getTexture(),w:this.w}},h:this.h,rtt:!0,type:t.components.FastBlurComponent,w:this.w}}),this._Blur.alpha<1&&(this._Blur.smooth={alpha:[1,this.style.animationBlurEntrance]}));}},{key:"_updateCenterImage",value:function _updateCenterImage(){"contain"===this.format?this._updateFormatContain():"circle"===this.format||"square"===this.format?this._updateFormatSquareCircle():this._CenterImage&&this.patch({CenterImage:void 0});}},{key:"_updateFormatContain",value:(i=_asyncToGenerator(_regeneratorRuntime().mark((function _callee11(){var t,e,n,i,o;return _regeneratorRuntime().wrap((function _callee11$(r){for(;;)switch(r.prev=r.next){case 0:if(!(this._CenterImage&&this._CenterImage.mode!==this.format||this.src===this.fallbackSrc||this._aspectRatioEqual)){r.next=5;break}if(this.patch({CenterImage:void 0}),this.src!==this.fallbackSrc&&!this._aspectRatioEqual){r.next=5;break}return this._Image.alpha=1,r.abrupt("return");case 5:return n=Math.abs(this._Image.texture.source.w/this._Image.texture.source.h),i=Math.abs(this._Image.texture.source.h/this._Image.texture.source.w),this._Image.texture.source.w<this._Image.texture.source.h?this.h*n<this.w?(t=this.h*n,e=this.h):(t=this.w,e=this.w*i):this._Image.texture.source.w>this._Image.texture.source.h?this.w*i<this.h?(t=this.w,e=this.w*i):(t=this.h*n,e=this.h):(t=Math.min(this.w,this.h),e=t),r.next=10,this._processedImageSrc;case 10:o=r.sent,this.patch({CenterImage:{format:this.format,mount:.5,w:t,h:e,x:this.w/2,y:this.h/2,zIndex:this.core.findZContext().zIndex+this.style.zIndexSet.centerImage,texture:{src:o,resizeMode:{h:e,type:"cover",w:t},type:Z}}});case 12:case"end":return r.stop()}}),_callee11,this)}))),function _updateFormatContain(){return i.apply(this,arguments)})},{key:"_updateFormatSquareCircle",value:function _updateFormatSquareCircle(){if(!(this._CenterImage&&this._CenterImage.mode!==this.format||this.src===this.fallbackSrc)||(this.patch({CenterImage:void 0}),this.src!==this.fallbackSrc)){var e=Math.min(this.w,this.h)-2*this.style.padding;this.patch({CenterImage:{format:this.format,h:e,shader:{radius:"circle"===this.format?e/2:this.style.centerImageRadius,type:t.shaders.RoundedRectangle},w:e,zIndex:this.core.findZContext().zIndex+this.style.zIndexSet.centerImage,Image:{h:e,mount:.5,rtt:!0,w:e,x:this.w/2,y:this.h/2,texture:{src:this._Image.texture.src,resizeMode:{h:e,type:"cover",w:e},type:Z}}}});}}},{key:"_updateGradient",value:function _updateGradient(){var t=this;this.gradient?this._createGradient():this._Gradient&&(this.shouldSmooth?(this._Gradient._getTransition("alpha").once("finish",(function(){var e=t._Gradient&&t._Gradient._getTransition("alpha");!t.gradient&&e&&1===e.p&&t.patch({Gradient:void 0});})),this._Gradient.patch(this._gradientPatch),this._Gradient.smooth={alpha:[0,this.style.animationGradientExit]}):this.patch({Gradient:void 0}));}},{key:"_createGradient",value:function _createGradient(){this.patch({Gradient:this._gradientPatch}),this.shouldSmooth&&this.applySmooth(this._Gradient,{alpha:[1,this.style.animationGradientEntrance]});}},{key:"_updateImage",value:(n=_asyncToGenerator(_regeneratorRuntime().mark((function _callee12(){var t;return _regeneratorRuntime().wrap((function _callee12$(e){for(;;)switch(e.prev=e.next){case 0:if(this._aspectRatioEqual=!1,this._processedImageSrc){e.next=4;break}return this._Image&&(this._Image.texture=void 0),e.abrupt("return");case 4:return e.next=6,this._processedImageSrc;case 6:t=e.sent,this._Image.patch({alpha:this.src!==this.fallbackSrc&&(this._blur||this._hasCenterImage)?.001:1,h:this.h,texture:{type:Z,src:t,resizeMode:{type:"cover",w:this.w,h:this.h}},w:this.w,zIndex:this.core.findZContext().zIndex+this.style.zIndexSet.image});case 8:case"end":return e.stop()}}),_callee12,this)}))),function _updateImage(){return n.apply(this,arguments)})},{key:"_updateFillColor",value:function _updateFillColor(){this.fill?this.patch({FillColor:{rect:!0,w:this.w,h:this.h,color:this.style.fillColor,zIndex:5}}):this.patch({FillColor:void 0});}},{key:"_updateRadius",value:function _updateRadius(){this.patch(this.style.radius?{shader:{type:t.shaders.RoundedRectangle,radius:this.style.radius}}:{shader:void 0});}}],[{key:"__componentName",get:function get(){return "Artwork"}},{key:"__themeStyle",get:function get(){return J}},{key:"properties",get:function get(){return ["blur","fallbackSrc","foregroundHeight","foregroundSrc","foregroundWidth","gradient","format","src","fill","shouldScale","srcCallback","srcCallbackAspectRatios"]}},{key:"tags",get:function get(){return ["Blur","CenterImage","FillColor","ForegroundImage","Gradient","Image","Item"]}},{key:"aliasProperties",get:function get(){return [{prev:"foregroundH",curr:"foregroundHeight"},{prev:"foregroundW",curr:"foregroundWidth"}]}},{key:"_template",value:function _template(){return {rtt:!0,Image:{}}}}]),Artwork}(),et=Object.freeze({__proto__:null,tone:function tone$n(t){return {neutral:{color:t.color.fillNeutral},inverse:{color:t.color.fillInverse},brand:{color:t.color.fillBrand}}}}),nt=function(e){_inherits(Icon,G);var n=_createSuper(Icon);function Icon(){return _classCallCheck(this,Icon),n.apply(this,arguments)}return _createClass(Icon,[{key:"_init",value:function _init(){var t=this;this.on("txLoaded",(function(){t.fixed||t._notify.bind(t)();})),this.on("txError",this._handleTxtError.bind(this));}},{key:"_getColor",value:function _getColor(){return this._color||this.style.color}},{key:"_notify",value:function _notify(){this.w=this.finalW,this.h=this.finalH,this.signal("itemChanged",this),this.fireAncestors("$itemChanged");}},{key:"_handleTxtError",value:function _handleTxtError(){k$1.error("Unable to load icon ".concat(this._icon)),this._icon=null,this.texture=null;}},{key:"_update",value:function _update(){this._icon?this.patch(this._iconPatch):this.texture=null;}},{key:"_iconPatch",get:function get(){var e,n=_slicedToArray([/^<svg.*<\/svg>$/,/\.svg$/].map((function(t){return RegExp.prototype.test.bind(t)})),2),i=n[0],o=n[1],r=i(this.icon),a=o(this.icon);e=r?t.Tools.getSvgTexture("data:image/svg+xml,".concat(encodeURIComponent(this.icon)),this.w,this.h):a?t.Tools.getSvgTexture(this.icon,this.w,this.h):{type:Z,w:this.w,h:this.h,src:this.icon};var s=getValidColor(this._color||this.style.color);return _objectSpread({texture:e,shader:this.radius||this.style.radius?{radius:this.radius||this.style.radius,type:t.shaders.RoundedRectangle}:void 0},s?{colorUl:s,colorUr:s,colorBl:s,colorBr:s}:{})}}],[{key:"__componentName",get:function get(){return "Icon"}},{key:"__themeStyle",get:function get(){return et}},{key:"properties",get:function get(){return ["icon","fixed","color"]}}]),Icon}(),it=Object.freeze({__proto__:null,base:function base$P(t){return {contentSpacing:t.spacer.sm,offsetY:t.spacer.xs,paddingX:t.spacer.md+t.spacer.xxs,paddingY:t.spacer.xs,radius:t.radius.sm,strokeWidth:t.stroke.sm,textStyle:_objectSpread(_objectSpread({},t.typography.tag1),{},{textAlign:"center"})}},tone:function tone$m(t){return {neutral:{backgroundColor:t.color.fillInverseSecondary,iconColor:t.color.textNeutral,textStyle:{textColor:t.color.textNeutral},strokeColor:t.color.strokeNeutral},inverse:{backgroundColor:t.color.fillNeutralSecondary,iconColor:t.color.textInverse,textStyle:{textColor:t.color.textInverse},strokeColor:t.color.strokeInverse},brand:{backgroundColor:t.color.fillBrand,iconColor:t.color.textNeutral,textStyle:{textColor:t.color.textNeutral},strokeColor:t.color.strokeInverse}}}}),ot=function(e){_inherits(Badge,G);var n=_createSuper(Badge);function Badge(){return _classCallCheck(this,Badge),n.apply(this,arguments)}return _createClass(Badge,[{key:"_init",value:function _init(){this._Text.on("txLoaded",this._updateLayout.bind(this)),_get(_getPrototypeOf(Badge.prototype),"_init",this).call(this);}},{key:"_update",value:function _update(){this._updateText(),this._updateIcon(),this._updateLayout(),this._updateVisibility();}},{key:"_updateVisibility",value:function _updateVisibility(){this.alpha=this.title||this.icon?1:0;}},{key:"_updateLayout",value:function _updateLayout(){this._updateWidth(),this._updateBackground(),this._updatePositions(),this.signal("loadedBadge",this);}},{key:"_updateBackground",value:function _updateBackground(){var e=Math.max(this._Text.renderHeight,this._Icon.h)+2*this.style.paddingY;this.patch({h:e,texture:t.Tools.getRoundRect(this.w,e,this.style.radius,this.style.strokeWidth,this.style.strokeColor,!0,this.style.backgroundColor)});}},{key:"_updateText",value:function _updateText(){this._Text&&this._Text.patch({text:_objectSpread(_objectSpread({},this.style.textStyle),{},{text:this.title||""})});}},{key:"_updateIcon",value:function _updateIcon(){this._Icon.patch({icon:this.icon,w:this.iconWidth,h:this.iconHeight,style:{color:getHexColor(this.style.iconColor)}});}},{key:"_updateWidth",value:function _updateWidth(){var t=0;this.title&&this.icon?t=this._Text.renderWidth+this._Icon.finalW+this.style.contentSpacing+2*this.style.paddingX:this.title?t=this._Text.renderWidth+2*this.style.paddingX:this.icon&&(t=this._Icon.finalW+2*this.style.paddingX),this.w=t;}},{key:"_updatePositions",value:function _updatePositions(){this._Icon.y=this.h/2,"left"===this.iconAlign&&this.title&&this.icon?(this._Icon.x=this.style.paddingX,this._Text.x=this._Icon.x+this._Icon.finalW+this.style.contentSpacing):"right"===this.iconAlign&&this.title&&this.icon?(this._Text.x=this.style.paddingX,this._Icon.x=this._Text.x+this._Text.renderWidth+this.style.contentSpacing):(this._Text.x=this.style.paddingX,this._Icon.x=this.style.paddingX),this._Text.y=this._h/2+this.style.offsetY;}},{key:"_getIconHeight",value:function _getIconHeight(){return this.icon?!this._Icon.finalH&&this._Text?this._Text.text.lineHeight:this._Icon.finalH:0}},{key:"announce",get:function get(){return this._announce||this.title},set:function set(t){_set(_getPrototypeOf(Badge.prototype),"announce",t,this,!0);}}],[{key:"_template",value:function _template(){return {Text:{mountY:.5},Icon:{type:nt,mountY:.5,signals:{itemChanged:"_updateLayout"}}}}},{key:"__componentName",get:function get(){return "Badge"}},{key:"__themeStyle",get:function get(){return it}},{key:"properties",get:function get(){return ["title","icon","iconAlign","iconWidth","iconHeight"]}},{key:"tags",get:function get(){return ["Background","Text","Icon"]}}]),Badge}(),rt=Object.freeze({__proto__:null,base:function base$O(t){return {height:10*t.spacer.md,width:0,justify:"center",minWidth:getWidthByColumnSpan(t,3),paddingX:t.spacer.xxxl,paddingXNoTitle:t.spacer.xl,titlePadding:t.spacer.md,itemSpacing:t.spacer.md,textStyle:_objectSpread(_objectSpread({},t.typography.button1),{},{maxLines:1,textColor:t.color.textNeutral}),contentColor:t.color.fillNeutral}},mode:function mode$g(t){return {focused:{textStyle:{textColor:t.color.textInverse},contentColor:t.color.fillInverse,tone:{inverse:{textStyle:{textColor:t.color.textNeutral},contentColor:t.color.fillNeutral},brand:{contentColor:t.color.fillNeutral}}},disabled:{textStyle:{textColor:t.color.textNeutralDisabled},contentColor:t.color.fillNeutralDisabled}}}}),at=function(t){_inherits(FocusManager,G);var e=_createSuper(FocusManager);function FocusManager(){return _classCallCheck(this,FocusManager),e.apply(this,arguments)}return _createClass(FocusManager,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(FocusManager.prototype),"_construct",this).call(this),this._selectedIndex=0,this._itemPosX=0,this._itemPosY=0,this.direction=this.direction||"row";}},{key:"_init",value:function _init(){this._checkSkipFocus();}},{key:"Items",get:function get(){return this.tag("Items")||this.patch({Items:{}}),this._Items}},{key:"_setDirection",value:function _setDirection(t){var e={none:"None",column:"Column",row:"Row"}[t];return e&&this._setState(e),t}},{key:"_getItems",value:function _getItems(){return this._Items.children}},{key:"items",get:function get(){return this.Items.children},set:function set(t){this._resetItems(),this._selectedIndex=0,this.appendItems(t),this._checkSkipFocus();}},{key:"itemPosX",get:function get(){return this._itemPosX},set:function set(t){this.Items.x=this._itemPosX=t;}},{key:"itemPosY",get:function get(){return this._itemPosY},set:function set(t){this.Items.y=this._itemPosY=t;}},{key:"_resetItems",value:function _resetItems(){this.Items.childList.clear(),this.Items.patch({w:0,h:0,x:this.itemPosX,y:this.itemPosY});}},{key:"_appendLazyItem",value:function _appendLazyItem(t){this.appendItems([t]);}},{key:"appendItems",value:function appendItems(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.Items.childList.a(t),this._refocus();}},{key:"appendItemsAt",value:function appendItemsAt(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1?arguments[1]:void 0,i=Number.isInteger(n)?n:this.Items.children.length;this.shouldSmooth=!1,this._lastAppendedIdx=i,e.forEach((function(e,n){t.Items.childList.addAt(_objectSpread(_objectSpread({},e),{},{parentFocus:t.hasFocus()}),i+n);})),this.selectedIndex>=this._lastAppendedIdx&&(this._selectedIndex+=e.length),this.requestUpdate(),this._refocus();}},{key:"prependItems",value:function prependItems(t){this.appendItemsAt(t,0);}},{key:"removeItemAt",value:function removeItemAt(t){this.shouldSmooth=!1,this.Items.childList.removeAt(t),(this.selectedIndex>t||this.selectedIndex===this.Items.children.length)&&this._selectedIndex--,this.requestUpdate(),this._refocus();}},{key:"_checkSkipFocus",value:function _checkSkipFocus(){var t=this.Items.children[this.selectedIndex];t&&t.skipFocus&&this.selectNext();}},{key:"selected",get:function get(){return this.Items.children[this.selectedIndex]}},{key:"selectedIndex",get:function get(){return this._selectedIndex},set:function set(t){this.prevSelected=this.selected,this.Items.children.length&&this.Items.children[t]&&this.Items.children[t].skipFocus||(t!==this._selectedIndex&&(this._selectedIndex=t),this.selected&&this._selectedChange(this.selected,this.prevSelected),this._refocus());}},{key:"_selectedChange",value:function _selectedChange(t,e){this._render(t,e),this.signal("selectedChange",t,e);}},{key:"_render",value:function _render(){}},{key:"_firstFocusableIndex",value:function _firstFocusableIndex(){return this.items.length?this.items.reduce((function(t,e,n){return e.skipFocus||t.push(_objectSpread(_objectSpread({},e),{},{originalIdx:n})),t}),[]).shift().originalIdx:0}},{key:"_lastFocusableIndex",value:function _lastFocusableIndex(){return this.items.length?this.items.reduce((function(t,e,n){return e.skipFocus||t.push(_objectSpread(_objectSpread({},e),{},{originalIdx:n})),t}),[]).pop().originalIdx:0}},{key:"selectPrevious",value:function selectPrevious(){this.shouldSmooth=!0;var t=!!(this.items||[]).filter((function(t){return !t.skipFocus})).length;if(0===this.selectedIndex&&!this.wrapSelected||!t)return !1;var e=this.items.map((function(t){return !!t.skipFocus})).lastIndexOf(!1,this._selectedIndex-1);return e>-1?(this.selectedIndex=e,!0):!!this.wrapSelected&&(this.selectedIndex=this._lastFocusableIndex(),!0)}},{key:"selectNext",value:function selectNext(){var t=this;this.shouldSmooth=!0,this._lazyItems&&this._lazyItems.length&&delayForAnimation((function(){t._appendLazyItem(t._lazyItems.splice(0,1)[0]);}));var e=!!(this.items||[]).filter((function(t){return !t.skipFocus})).length;if(this.selectedIndex===this.Items.children.length-1&&!this.wrapSelected||!e)return !1;var n=this.items.findIndex((function(e,n){return !e.skipFocus&&n>t._selectedIndex}));return n>-1?(this.selectedIndex=n,!0):!!this.wrapSelected&&(this.selectedIndex=this._firstFocusableIndex(),!0)}},{key:"_getIndexOfItemNear",value:function _getIndexOfItemNear(t,e){var n=e.selected;if(!(t&&t.items&&t.items.length&&n))return 0;var i=_slicedToArray(n.core.getAbsoluteCoords(0,0),2),o=i[0],r=i[1],a=[o+n.w/2,r+n.h/2],s=t.items.map((function(t,e){return {index:e,distance:t.skipFocus?null:(n=a,i=t,o=_slicedToArray(n,2),r=o[0],s=o[1],l=_slicedToArray(i.core?i.core.getAbsoluteCoords(0,0):[0,0],2),c=l[0],u=l[1],h=getEuclideanDistance(r,s,c,u),d=getEuclideanDistance(r,s,c+i.w/2,u+i.h/2),p=getEuclideanDistance(r,s,c+i.w,u+i.h),Math.min(h,d,p))};var n,i,o,r,s,l,c,u,h,d,p;})).filter((function(t){return null!==t.distance})).sort((function(t,e){return t.distance-e.distance}));return s[0].index}},{key:"_focus",value:function _focus(){this.items.forEach((function(t){return t.parentFocus=!0}));}},{key:"_unfocus",value:function _unfocus(){this.items.forEach((function(t){return t.parentFocus=!1}));}},{key:"_getFocused",value:function _getFocused(){var t=this.selected;if(t){if(t.focusRef)return t.tag(t.focusRef);if(t.cparent)return t}return this}},{key:"_updateTransitionTarget",value:function _updateTransitionTarget(t,e,n){t&&t.transition(e)&&!t.transition(e).isRunning()&&t.transition(e).targetValue!==n&&t.transition(e).updateTargetValue(n);}},{key:"onScreenItems",get:function get(){var t=this;return this.Items.children.filter((function(e){return t._isOnScreen(e)}))}},{key:"_isOnScreenCompletely",value:function _isOnScreenCompletely(t){return t.isFullyOnScreen?t.isFullyOnScreen():isComponentOnScreen(t)}},{key:"fullyOnScreenItems",get:function get(){var t=this;return this.Items.children.reduce((function(e,n){return n instanceof FocusManager?[].concat(_toConsumableArray(e),_toConsumableArray(n.Items.children.filter(t._isOnScreenCompletely))):t._isOnScreenCompletely(n)?[].concat(_toConsumableArray(e),[n]):e}),[])}},{key:"_isOnScreen",value:function _isOnScreen(){throw new Error("'_isOnScreen' must be implemented by 'row'/'column'")}},{key:"_isComponentHorizontallyVisible",value:function _isComponentHorizontallyVisible(t){var e=o(t);if(!Number.isFinite(e))return !1;var n=this.getTransitionXTargetValue(),i=this.core.renderContext.px+n+e,r=_slicedToArray(this.core._scissor||[],3),a=r[0],s=void 0===a?null:a,l=r[2],c=void 0===l?null:l,u=this.stage.w/this.stage.getRenderPrecision(),h=t.w;if(!(i>=0)||!(i+h<=u))return !1;var d=!0,p=!0;return Number.isFinite(s)&&(d=Math.round(i+h)>=Math.round(s),p=Math.round(i)<=Math.round(s+c)),d&&p}},{key:"_isComponentVerticallyVisible",value:function _isComponentVerticallyVisible(t){var e=r(t);if(!Number.isFinite(e))return !1;var n=this.getTransitionYTargetValue(),i=this.core.renderContext.py,o=_slicedToArray(this.core._scissor||[],4),a=o[1],s=void 0===a?null:a,l=o[3],c=void 0===l?null:l,u=t.h,h=i+n+e,d=this.stage.h/this.stage.getRenderPrecision();if(!(h+u>=0)||!(h<=d))return !1;var p=!0,_=!0;return Number.isFinite(s)&&(p=Math.round(h+u)>Math.round(s),_=Math.round(h)<Math.round(s+c)),p&&_}},{key:"getTransitionXTargetValue",value:function getTransitionXTargetValue(){return this.Items.transition("x").targetValue}},{key:"getTransitionYTargetValue",value:function getTransitionYTargetValue(){return this.Items.transition("y").targetValue}}],[{key:"__componentName",get:function get(){return "FocusManager"}},{key:"tags",get:function get(){return ["Items"]}},{key:"properties",get:function get(){return ["direction","wrapSelected"]}},{key:"_states",value:function _states(){return [function(t){_inherits(None,t);var e=_createSuper(None);function None(){return _classCallCheck(this,None),e.apply(this,arguments)}return _createClass(None)}(this),function(t){_inherits(Row,t);var e=_createSuper(Row);function Row(){return _classCallCheck(this,Row),e.apply(this,arguments)}return _createClass(Row,[{key:"_handleLeft",value:function _handleLeft(){return "function"==typeof this.onLeft?this.onLeft(this):this.selectPrevious()}},{key:"_handleRight",value:function _handleRight(){return "function"==typeof this.onRight?this.onRight(this):this.selectNext()}}]),Row}(this),function(t){_inherits(Column,t);var e=_createSuper(Column);function Column(){return _classCallCheck(this,Column),e.apply(this,arguments)}return _createClass(Column,[{key:"_handleUp",value:function _handleUp(){return "function"==typeof this.onUp?this.onUp(this):this.selectPrevious()}},{key:"_handleDown",value:function _handleDown(){return "function"==typeof this.onDown?this.onDown(this):this.selectNext()}}]),Column}(this)]}}]),FocusManager}(),st=Object.freeze({__proto__:null,base:function base$N(t){return {alwaysScroll:!1,itemSpacing:t.layout.gutterX,itemTransition:t.animation.utility,neverScroll:!1,scrollIndex:0}}}),lt={row:{axis:"x",crossAxis:"y",lengthDimension:"w",crossDimension:"h",innerLengthDimension:"innerW",innerCrossDimension:"innerH"},column:{axis:"y",crossAxis:"x",lengthDimension:"h",crossDimension:"w",innerLengthDimension:"innerH",innerCrossDimension:"innerW"}},ct=function(t){_inherits(NavigationManager,at);var e=_createSuper(NavigationManager);function NavigationManager(){return _classCallCheck(this,NavigationManager),e.apply(this,arguments)}return _createClass(NavigationManager,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(NavigationManager.prototype),"_construct",this).call(this),this.shouldSmooth=!1,this._lazyUpCountBuffer=2;}},{key:"_init",value:function _init(){var t=this._directionPropNames,e=t.lengthDimension,n=t.axis;this[e]||this._initComponentSize(),this.Items.transition(n).on("finish",this._transitionListener.bind(this)),_get(_getPrototypeOf(NavigationManager.prototype),"_init",this).call(this);}},{key:"_initComponentSize",value:function _initComponentSize(){var t=this._directionPropNames.lengthDimension;if((null==this?void 0:this.parent.parent)instanceof NavigationManager&&null!=this&&this.parent.parent[t])this[t]=this.parent.parent[t];else {for(var e=this.parent;e&&!e[t];)e=e.parent;this[t]=e&&e[t]||this.stage.h/this.stage.getRenderPrecision();}}},{key:"_update",value:function _update(){this._updateLayout();}},{key:"_updateLayout",value:function _updateLayout(){for(var t,e=this._directionPropNames,n=e.lengthDimension,i=e.crossDimension,o=e.crossAxis,r=e.innerCrossDimension,a=0,s=0,l=0,c=[],u=0;u<this.Items.children.length;u++){var h=this.Items.children[u];if(s=max(s,this._calcCrossDimensionSize(h)),l=max(l,h[r]||0),this.updatePositionOnAxis(h,a),a+=h[n],u<this.Items.children.length-1){var d=h.extraItemSpacing||0;a+=this.style.itemSpacing+d;}if(h.centerInParent){var p=h.Items&&h.Items[i]||h[i];(p<this[i]||!this.Items[r])&&c.push({childIdx:u,childCrossDimensionSize:p});}else h[o]=0;}var _=this.Items[i]!==s||this.Items[n]!==a;this.Items.patch((_defineProperty$1(t={},i,s),_defineProperty$1(t,r,l||s),_defineProperty$1(t,n,a+(this._totalAddedWidth||0)),t)),this._autoResize(),this._centerItemsInParent(c),this._updateLastScrollIndex(),_&&(this._performRender(),this.fireAncestors("$itemChanged"));}},{key:"_centerItemsInParent",value:function _centerItemsInParent(t){var e=this,n=this._directionPropNames,i=n.crossDimension,o=n.crossAxis,r=n.innerCrossDimension;if(t.length){var a=[this.Items[i],this.Items[r]];1===this.children.length&&a.push(this[i]);var s=Math.max.apply(Math,a);t.forEach((function(t){var n=t.childIdx,i=t.childCrossDimensionSize;e.Items.children[n][o]=(s-i)/2;}));}}},{key:"_autoResize",value:function _autoResize(){this.autoResizeWidth&&(this.w=this.Items.w),this.autoResizeHeight&&(this.h=this.Items.h);}},{key:"_updateLastScrollIndex",value:function _updateLastScrollIndex(){var t=this._directionPropNames,e=t.axis,n=t.lengthDimension;if(this.alwaysScroll)this._lastScrollIndex=this.Items.children.length-1;else {var i=(this.Items.children[this.scrollIndex]||_defineProperty$1({},e,0))[e],o=this.Items.childList.last,r=o?this._calcAxisPosition(o)+o[n]:0;if(r>this[n]){for(var a,s=this.Items.children.length-1;s>=0;s--){if(!(this._calcAxisPosition(this.Items.children[s])+this[n]-i>r))break;a=s;}this._lastScrollIndex=a;}else this._lastScrollIndex>this.items.length&&(this._lastScrollIndex=this.items.length-1);}}},{key:"_calcCrossDimensionSize",value:function _calcCrossDimensionSize(t){return this._isRow?function getH(t){return getDimension("h",t)||t.renderHeight}(t):this._isColumn?function getW(t){return getDimension("w",t)||t.renderWidth}(t):void 0}},{key:"_calcAxisPosition",value:function _calcAxisPosition(t){return this._isRow?o(t):this._isColumn?r(t):void 0}},{key:"_transitionListener",value:function _transitionListener(){this.shouldSmooth=!1,this.transitionDone();}},{key:"_withAfterUpdate",value:function _withAfterUpdate(t){return watchForUpdates({element:t,watchProps:[this._directionPropNames.crossAxis,"w","h","innerW","innerH"],sideEffect:this.queueRequestUpdate.bind(this)})}},{key:"_performRender",value:function _performRender(){}},{key:"_appendItem",value:function _appendItem(t){this.shouldSmooth=!1,t.parentFocus=this.hasFocus(),t=this.Items.childList.a(t);var e=this._directionPropNames.crossDimension;if(!t[e]){var n=this._isRow?this.renderHeight:this.renderWidth;t[e]=t[e]||n;}t=this._withAfterUpdate(t);}},{key:"_appendLazyItem",value:function _appendLazyItem(t){this._appendItem(t),this.queueRequestUpdate(),this._refocus();}},{key:"$itemChanged",value:function $itemChanged(){this.queueRequestUpdate();}},{key:"appendItems",value:function appendItems(){var t,e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];(this.shouldSmooth=!1,this._lazyItems)?(t=this._lazyItems).push.apply(t,_toConsumableArray(n)):(n.length>this.lazyUpCount+this.lazyUpCountBuffer&&(this._lazyItems=n.splice(this.lazyUpCount+this.lazyUpCountBuffer)),n.forEach((function(t){return e._appendItem(t)})),this.queueRequestUpdate(),this._refocus());}},{key:"appendItemsAt",value:function appendItemsAt(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1?arguments[1]:void 0;if(this._lazyItems&&n>this.items.length-1){var i,o=n-this.items.length;(i=this._lazyItems).splice.apply(i,[o,0].concat(_toConsumableArray(e)));}else {var r=this._directionPropNames,a=r.crossDimension,s=r.lengthDimension,l=r.innerLengthDimension,c=Number.isInteger(n)?n:this.Items.children.length;this.shouldSmooth=!1,this._lastAppendedIdx=c,this._totalAddedLength=0,e.forEach((function(e,n){var i=_objectSpread(_objectSpread({},t._withAfterUpdate(e)),{},{parentFocus:t.hasFocus()});e[a]||(i[a]=e[a]||t.Items[a]),t.Items.childList.addAt(i,c+n);var o=e[s]||e[l]||0,r=e.extraItemSpacing||0;t._totalAddedLength+=o+t.style.itemSpacing+r;})),this.selectedIndex>=this._lastAppendedIdx&&(this._selectedPastAdded=!0,this._selectedIndex+=e.length),this.requestUpdate(),this._refocus();}}},{key:"updatePositionOnAxis",value:function updatePositionOnAxis(t,e){var n=this._directionPropNames.axis;this.applySmooth(t,_defineProperty$1({},n,e),_defineProperty$1({},n,[e,this.style.itemTransition])),this.shouldSmooth||this._updateTransitionTarget(t,n,e);}},{key:"scrollTo",value:function scrollTo(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100*this.style.itemTransition.duration;if(null!=t)if(0!==n)for(var i=0;i!==Math.abs(this.selectedIndex-t);i++)setTimeout((function(){e.selectedIndex>t?e.selectPrevious():e.selectNext();}),n*i);else this.selectedIndex=t;}},{key:"transitionDone",value:function transitionDone(){}},{key:"shouldScrollLeft",value:function shouldScrollLeft(){return this._isRow&&this._canScrollBack}},{key:"shouldScrollRight",value:function shouldScrollRight(){return this._isRow&&this._canScrollNext}},{key:"shouldScrollUp",value:function shouldScrollUp(){return this._isColumn&&this._canScrollBack}},{key:"shouldScrollDown",value:function shouldScrollDown(){return this._isColumn&&this._canScrollNext}},{key:"_directionPropNames",get:function get(){return lt[this.direction]}},{key:"_canScrollBack",get:function get(){var t=!1;return this._lastScrollIndex?(t=this.selectedIndex<this._lastScrollIndex,void 0!==this._prevLastScrollIndex&&this._prevLastScrollIndex!==this._lastScrollIndex&&(t=!0)):t=this.selectedIndex>=this.scrollIndex,(this._isRow?this._itemsX:this._itemsY)<0&&t}},{key:"_canScrollNext",get:function get(){var t,e=this._directionPropNames,n=e.axis,i=e.lengthDimension,o=this.Items.childList.last;return this._isRow&&(t=Math.abs(this._itemsX-this.w)),this._isColumn&&(t=Math.abs(this.itemPosY-this.h)),this.selectedIndex>this.scrollIndex&&t<o[n]+o[i]}},{key:"_isColumn",get:function get(){return "column"===this.direction}},{key:"_isRow",get:function get(){return "row"===this.direction}},{key:"_itemsX",get:function get(){return o(this.Items)}},{key:"_getAlwaysScroll",value:function _getAlwaysScroll(){return void 0!==this._alwaysScroll?this._alwaysScroll:this.style.alwaysScroll}},{key:"_getNeverScroll",value:function _getNeverScroll(){return !this.alwaysScroll&&(void 0!==this._neverScroll?this._neverScroll:this.style.neverScroll)}},{key:"_setScrollIndex",value:function _setScrollIndex(t){return t>=0?t:0}},{key:"_getScrollIndex",value:function _getScrollIndex(){return void 0!==this._scrollIndex?this._scrollIndex:this.style.scrollIndex}}],[{key:"__componentName",get:function get(){return "NavigationManager"}},{key:"__themeStyle",get:function get(){return st}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(NavigationManager),"properties",this)),["alwaysScroll","neverScroll","scrollIndex","autoResizeWidth","autoResizeHeight","lazyUpCount","lazyUpCountBuffer"])}}]),NavigationManager}(),ut=Object.freeze({__proto__:null,base:function base$M(t){return {itemSpacing:t.layout.gutterX,scrollIndex:0,alwaysScroll:!1,neverScroll:!1,itemTransition:_objectSpread(_objectSpread({},t.animation.standardEntrance),{},{duration:t.animation.duration.fast})}}}),ht=function(t){_inherits(Row,ct);var e=_createSuper(Row);function Row(){return _classCallCheck(this,Row),e.apply(this,arguments)}return _createClass(Row,[{key:"_isOnScreenForScrolling",value:function _isOnScreenForScrolling(t){if(!t)return !1;var e=o(t);if(!Number.isFinite(e))return !1;var n=this.getTransitionXTargetValue(),i=this.core.renderContext.px,r=i+n+e;return t.transition("x")&&(r-=t.x-t.transition("x").targetValue),r>=i&&r+t.w<=i+this.w}},{key:"_shouldScroll",value:function _shouldScroll(){var t=this.Items.childList.getIndex(this.prevSelected);if(this.lazyScroll&&(this.selectedIndex<this.startLazyScrollIndex||this.selectedIndex>this.stopLazyScrollIndex||t<this.startLazyScrollIndex&&this.selectedIndex===this.startLazyScrollIndex||t>this.stopLazyScrollIndex&&this.selectedIndex===this.stopLazyScrollIndex))return !0;var e=this.alwaysScroll||this._selectedPastAdded;if(!e&&!this.neverScroll){var n=this._isOnScreenForScrolling(this.selected);if(this.lazyScroll)e=!n;else e=this.Items.childList.last&&(this.shouldScrollLeft()||this.shouldScrollRight()||!n);}return e}},{key:"_getPrependedOffset",value:function _getPrependedOffset(){return this._selectedPastAdded=!1,this.Items.x-this._totalAddedWidth}},{key:"_getLazyScrollX",value:function _getLazyScrollX(t){var e=this.Items.childList.getIndex(this.prevSelected);if(this._selectedPastAdded)return this._getPrependedOffset();if(this.selectedIndex<=this.startLazyScrollIndex)return this._getScrollX();if(this.selectedIndex>=this.stopLazyScrollIndex&&this.selectedIndex<e)return this.Items.x+(this.prevSelected.w+this.style.itemSpacing+(this.selected.extraItemSpacing||0));if(t){var n,i=this.Items.childList.getIndex(t),o=this.selected.x;if(-1===i)return;return i>this.selectedIndex?n=-o:i<this.selectedIndex&&(n=this.w-o-this.selected.w),n}return this._getScrollX()}},{key:"_getScrollX",value:function _getScrollX(){if(this._selectedPastAdded)return this._getPrependedOffset();var t,e=this.selectedIndex-this.scrollIndex;return (e=e<0?0:e)===this._firstFocusableIndex()&&(e=0),this.Items.children[e]&&(t=this.Items.children[e].transition("x")?-this.Items.children[e].transition("x").targetValue:-this.Items.children[e].x),t}},{key:"_render",value:function _render(t,e){var n;this.plinko&&e&&e.selected&&(t.selectedIndex=this._getIndexOfItemNear(t,e)),this._prevLastScrollIndex=this._lastScrollIndex,this.Items.children.length?this._shouldScroll()&&(n=this.lazyScroll&&e?this._getLazyScrollX(e):this._getScrollX()):n=this.itemPosX,void 0!==n&&this.updatePositionOnAxis(this.Items,n),this.onScreenEffect(this.onScreenItems);}},{key:"_performRender",value:function _performRender(){this._render(this.selected,this.prevSelected);}},{key:"_isOnScreen",value:function _isOnScreen(t){return !!t&&this._isComponentHorizontallyVisible(t)}},{key:"onScreenEffect",value:function onScreenEffect(){}},{key:"_totalAddedWidth",get:function get(){return this._totalAddedLength}},{key:"_getLazyScroll",value:function _getLazyScroll(){return !this.alwaysScroll&&(void 0!==this._lazyScroll?this._lazyScroll:this.style.lazyScroll)}},{key:"_getNeverScroll",value:function _getNeverScroll(){return !this.alwaysScroll&&!this.lazyScroll&&(void 0!==this._neverScroll?this._neverScroll:this.style.neverScroll)}}],[{key:"__componentName",get:function get(){return "Row"}},{key:"__themeStyle",get:function get(){return ut}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Row),"_template",this).call(this)),{},{direction:"row"})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Row),"properties",this)),["lazyScroll","startLazyScrollIndex","stopLazyScrollIndex"])}}]),Row}(),dt=Object.freeze({__proto__:null,base:function base$L(t){return {backgroundColor:t.color.fillNeutralTertiary,radius:t.radius.md,animation:{}}},mode:function mode$f(t){return {focused:{backgroundColor:t.color.interactiveNeutralFocus,tone:{inverse:{backgroundColor:t.color.interactiveInverseFocus}}},disabled:{backgroundColor:t.color.fillNeutralDisabled}}}}),pt=function(e){_inherits(Surface,G);var n=_createSuper(Surface);function Surface(){return _classCallCheck(this,Surface),n.apply(this,arguments)}return _createClass(Surface,[{key:"innerH",get:function get(){return this.h}},{key:"innerW",get:function get(){return this.w}},{key:"_update",value:function _update(){this._updateLayout(),this._updateScale();}},{key:"_updateLayout",value:function _updateLayout(){this._Background.patch({texture:t.Tools.getRoundRect(this.innerW-2,this.innerH-2,this.style.radius,0,null,!0,this.style.backgroundColor)});}},{key:"_updateScale",value:function _updateScale(){var t=this._isFocusedMode?this.getFocusScale(this.w,this.h):this.getUnfocusScale(this.w,this.h);this.applySmooth(this,{scale:t},{scale:[t,this.style.animation]});}}],[{key:"_template",value:function _template(){return {Background:{}}}},{key:"__componentName",get:function get(){return "Surface"}},{key:"__themeStyle",get:function get(){return dt}},{key:"properties",get:function get(){return []}},{key:"tags",get:function get(){return ["Background"]}}]),Surface}(),_t=Object.freeze({__proto__:null,base:function base$K(t){return {offsetY:t.spacer.xxs,offsetX:0,textStyle:t.typography.body1}},tone:function tone$l(t){return {neutral:{textStyle:{textColor:t.color.fillNeutral}},inverse:{textStyle:{textColor:t.color.fillInverse}},brand:{textStyle:{textColor:t.color.fillBrand}}}}}),yt=Object.freeze({__proto__:null,base:function base$J(t){return {textY:0,iconWidth:t.spacer.xxl+t.spacer.xs,iconHeight:t.spacer.xxl+t.spacer.xs,contentSpacing:t.spacer.md,marginBottom:t.typography.body1.lineHeight/-10,textStyle:_objectSpread(_objectSpread({},t.typography.body1),{},{verticalAlign:"bottom"}),maxLines:1,justify:"flex-start"}}}),ft=function isText(t){return "string"==typeof t||!!t.text},gt=function isIcon(t){return !!t.icon},mt=function(t){_inherits(InlineContent,G);var e=_createSuper(InlineContent);function InlineContent(){return _classCallCheck(this,InlineContent),e.apply(this,arguments)}return _createClass(InlineContent,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(InlineContent.prototype),"_construct",this).call(this),this._maxLinesSuffix="..";}},{key:"_update",value:function _update(){this._updateContent(),this._waitForComponentLoad();}},{key:"_updateContent",value:function _updateContent(){var t=this;this.childList.clear(),this._shouldTruncate&&(this.alpha=.001),this._parsedContent&&this._parsedContent.length&&(this.patch({flex:{direction:"row",wrap:!!this.contentWrap,justifyContent:null!=this.justify?this.justify:this.style.justify}}),this._parsedContent.forEach((function(e,n){var i=n===t._parsedContent.length-1,o={flexItem:_objectSpread(_objectSpread({},t.contentProperties),{},{marginBottom:i?0:t._marginBottom,marginRight:i?0:t.contentProperties.marginRight||t.style.contentSpacing})};ft(e)?("string"==typeof t._parsedContent[n+1]&&(o.flexItem.marginRight=0),t.childList.a(t._createText(o,e))):gt(e)?t.childList.a(t._createIcon(o,e)):!function isBadge(t){return !!t.badge}(e)?e.newline&&t.contentWrap&&t.childList.a({h:0,w:t.w}):t.childList.a(t._createBadge(o,e.badge));})));}},{key:"_waitForComponentLoad",value:function _waitForComponentLoad(){var t=this;this.children.length?Promise.all(this.children.map((function(e){return new Promise((function(n){0===e.h&&e.w===t.w?n():e.on("txLoaded",n);}))}))).finally((function(){return t._contentLoaded()})):(this.h=0,this._contentLoaded());}},{key:"_notifyAncestors",value:function _notifyAncestors(){this.fireAncestors("$loadedInlineContent",this),this.signal("loadedInlineContent",this.finalW,this.multiLineHeight);}},{key:"_contentLoaded",value:function _contentLoaded(){var t=this;this.children.length?setTimeout((function(){t.multiLineHeight=t.finalH,t.flex&&t.flex._layout&&t.flex._layout._lineLayouter&&t.flex._layout._lineLayouter._lines?(t.multiLineHeight=t.style.textStyle.lineHeight*t.flex._layout._lineLayouter._lines.length,t.h=t.multiLineHeight,t._shouldTruncate&&t._renderMaxLines(),t._notifyAncestors()):t._contentLoaded();}),10):this._notifyAncestors();}},{key:"_renderMaxLines",value:function _renderMaxLines(){var t=this,e=this._calcChildrenDimensions();this.childList.clear();var n=!1;e.forEach((function(i,o){if(!n){var r=e[o+1];if(r){var a=i.line===t.maxLines,s=a&&r.line>t.maxLines&&i.hasSpaceForSuffix,l=a&&i.hasSpaceForSuffix&&!r.hasSpaceForSuffix,c=!r||s||l;i.line<=t.maxLines&&(c&&o!==e.length-1?(t.childList.add(t._addSuffix(i)),n=!0):t.childList.add(i.component));}else t.childList.add(i.component);}})),this.alpha=1;}},{key:"_calcChildrenDimensions",value:function _calcChildrenDimensions(){var t=this,e=measureTextWidth(_objectSpread(_objectSpread({},this.style.textStyle),{},{text:this.maxLinesSuffix})),n=0,i=1;return this.children.reduce((function(o,r){var a,s,l,c=r;if(r.w==t.w&&0===r.h){i++,n=0;var u={type:"linebreak",component:c,content:s,line:i,hasSpaceForSuffix:!0};return o.push(u),o}ft(r)?(a="text",s=r.text.text,l=r.texture.getRenderWidth()):gt(r)?(a="icon",l=r.w):"Badge"===r.constructor.__componentName&&(a="badge",l=r.w),n+=l,n+=r.flexItem.marginRight,Math.ceil(n)>=t.w&&(i++,n=l);var h=Math.ceil(n)+e<=t.w,d={type:a,component:c,content:s,line:i,hasSpaceForSuffix:h};return o.push(d),o}),[])}},{key:"_addSuffix",value:function _addSuffix(t){var e,n=t.type,i=t.component,o=t.content,r=-1*i.flexItem.marginRight;return "text"===n?e=this._createText({flexItem:this.contentProperties},"".concat(o.trim()).concat(this.maxLinesSuffix)):(this.childList.add(i),e=this._createText({flexItem:_objectSpread(_objectSpread({},this.contentProperties),{},{marginLeft:r})},this.maxLinesSuffix)),e}},{key:"_createIcon",value:function _createIcon(t,e){var n=(this.textHeight>this.style.textStyle.lineHeight?this.textHeight:this.style.textStyle.lineHeight)-this.style.iconHeight;return _objectSpread(_objectSpread({},t),{},{type:nt,y:n,w:this.style.iconWidth,h:this.style.iconHeight,signals:{itemChanged:"_updateIconPosition"}},e)}},{key:"_createText",value:function _createText(t,e){var n="string"==typeof e.style?this.customStyleMappings[e.style]:e.style;return _objectSpread(_objectSpread({},t),{},{y:void 0!==this.textY?this.textY:this.style.textY,h:this.textHeight,text:_objectSpread(_objectSpread(_objectSpread({},this.style.textStyle),n),{},{text:e.text||e})})}},{key:"_createBadge",value:function _createBadge(t,e){return _objectSpread(_objectSpread(_objectSpread({},t),{},{y:this.badgeY||0},this.badgeProperties),{},{type:ot,title:e,signals:{loadedBadge:"_loadedBadge"}})}},{key:"_updateIconPosition",value:function _updateIconPosition(t){t.y=this.style.textStyle.lineHeight-t.h;}},{key:"_loadedBadge",value:function _loadedBadge(t){void 0===this.badgeY&&(t.y=this.style.textStyle.lineHeight-t.h);}},{key:"_formatSpaces",value:function _formatSpaces(t){var e=/(\s+)/;return flatten((t||[]).reduce((function(t,n){var i=n;if(ft(n)){if("object"===_typeof(n)){var o=n.text.split(e).map((function(t){return _objectSpread(_objectSpread({},n),{},{text:t.trim()})}));return t.push.apply(t,_toConsumableArray(o)),t}i=n.split(e);}return t.push(i),t}),[])).map((function(t,e,n){return " "!==t&&(" "===n[e+1]?t+" ":t)})).filter(Boolean)}},{key:"_setContent",value:function _setContent(t){if(t!==this._content){this._content=t;var e=this._content;t&&!Array.isArray(t)&&(e=function parseInlineContent(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",e=[];if(t&&"string"==typeof t||t.text){var n="string"==typeof t?t:t.text,i=/^{ICON:(.*?)?\|(.*?)?}$/g,o=/^{BADGE:(.*?)}$/g,r=/^{NEWLINE}$/g,a=/^{TEXT:(.*?)?\|(.*?)?}$/g,l=n.split(s);l&&l.length&&l.forEach((function(t){var n=t,s=o.exec(t),l=i.exec(t),c=r.exec(t),u=a.exec(t);s&&s[1]?n={badge:s[1]}:l&&l[1]?n={title:l[1],icon:l[2]||l[1]}:c?n={newline:!0}:u&&u[1]&&(n={text:u[1],style:u[2]}),e.push(n);}));}return e}(t)),this._parsedContent=this._formatSpaces(e);}return t}},{key:"_setBadgeProperties",value:function _setBadgeProperties(t){if("object"===_typeof(t))return t}},{key:"_getBadgeProperties",value:function _getBadgeProperties(){return this._badgeProperties||{}}},{key:"_setContentProperties",value:function _setContentProperties(t){if("object"===_typeof(t))return t}},{key:"_getContentProperties",value:function _getContentProperties(){return this._contentProperties||{}}},{key:"_setCustomStyleMappings",value:function _setCustomStyleMappings(t){if("object"===_typeof(t))return t}},{key:"_getCustomStyleMappings",value:function _getCustomStyleMappings(){return this._customStyleMappings||{}}},{key:"textHeight",get:function get(){return this.style.textStyle.lineHeight||this.style.textStyle.fontSize}},{key:"_marginBottom",get:function get(){return void 0!==this.contentProperties.marginBottom?this.contentProperties.marginBottom:this.style.marginBottom?this.style.marginBottom:0}},{key:"_shouldTruncate",get:function get(){return this.contentWrap&&this.maxLines}},{key:"announce",get:function get(){if(this._announce)return this._announce;var t=this._parsedContent&&this._parsedContent.reduce((function(t,e){return "string"==typeof e?t+=e:e.announce?t+=e.announce:e.text?t+=e.text:e.title?t+=e.title:e.badge&&(t+=e.badge),t+" "}),"");return t?t.replace(/\s+(?=\s)|\s$/g,""):""},set:function set(t){_set(_getPrototypeOf(InlineContent.prototype),"announce",t,this,!0);}}],[{key:"properties",get:function get(){return ["content","contentProperties","badgeY","badgeProperties","justify","contentWrap","customStyleMappings","maxLines","maxLinesSuffix"]}},{key:"__componentName",get:function get(){return "InlineContent"}},{key:"__themeStyle",get:function get(){return yt}},{key:"aliasStyles",get:function get(){return [{prev:"iconH",curr:"iconHeight"},{prev:"iconW",curr:"iconWidth"}]}}]),InlineContent}(),vt=Object.freeze({__proto__:null,base:function base$I(t){return {fadeWidth:100,offset:t.spacer.xxl,shouldSmooth:!1,textStyle:t.typography.body1}}}),xt=function(e){_inherits(FadeShader,t.shaders.WebGLDefaultShader);var n=_createSuper(FadeShader);function FadeShader(t){var e;return _classCallCheck(this,FadeShader),(e=n.call(this,t))._margin={left:0,right:0},e}return _createClass(FadeShader,[{key:"positionLeft",set:function set(t){this._positionLeft=t;}},{key:"positionRight",set:function set(t){this._positionRight=t;}},{key:"setupUniforms",value:function setupUniforms(t){_get(_getPrototypeOf(FadeShader.prototype),"setupUniforms",this).call(this,t);var e=t.shaderOwner;0===this._positionLeft&&(this._positionLeft=.001),0===this._positionRight&&(this._positionRight=.001);var n=this.ctx.stage.getRenderPrecision();this._setUniform("margin",[this._positionLeft*n,this._positionRight*n],this.gl.uniform1fv),this._setUniform("resolution",new Float32Array([e._w*n,e._h*n]),this.gl.uniform2fv);}}]),FadeShader}();xt.fragmentShaderSource="\n  #ifdef GL_ES\n  # ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  # else\n  precision lowp float;\n  # endif\n  #endif\n\n  #define PI 3.14159265359\n\n  varying vec2 vTextureCoord;\n  varying vec4 vColor;\n\n  uniform sampler2D uSampler;\n  uniform vec2 resolution;\n  uniform float margin[2];\n\n  void main() {\n      vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n      vec2 halfRes = 0.5 * resolution.xy;\n      vec2 point = vTextureCoord.xy * resolution;\n\n\n      vec2 pos1 = vec2(point.x, point.y);\n      vec2 pos2 = pos1;\n      pos2.x += margin[0];\n\n      vec2 d = pos2 - pos1;\n      float t = dot(pos1, d) / dot(d, d);\n      t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));\n\n      vec2 pos3 = vec2(vTextureCoord.x * resolution.x, vTextureCoord.y);\n      pos3.x -= resolution.x - margin[1];\n      vec2 pos4 = vec2(vTextureCoord.x + margin[1], vTextureCoord.y);\n\n      vec2 d2 = pos4 - pos3;\n      float t2 = dot(pos3, d2) / dot(d2, d2);\n      t2 = smoothstep(0.0, 1.0, clamp(t2, 0.0, 1.0));\n\n      color = mix(vec4(0.0), color, t);\n      color = mix(color, vec4(0.0), t2);\n\n      gl_FragColor = color;\n  }\n";var bt=function(t){_inherits(Marquee,G);var e=_createSuper(Marquee);function Marquee(){return _classCallCheck(this,Marquee),e.apply(this,arguments)}return _createClass(Marquee,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(Marquee.prototype),"_construct",this).call(this),this._scrolling=!1,this._autoStart=!1,this._centerAlign=!1;}},{key:"_init",value:function _init(){this._Content.on("txLoaded",this._updateContentTexture.bind(this)),_get(_getPrototypeOf(Marquee.prototype),"_init",this).call(this);}},{key:"_updateContentTexture",value:function _updateContentTexture(){var t=this._restartScrolling;this.stopScrolling(),this._currentTexture.h||(this._ContentClipper.h=this._currentTexture.text&&this._currentTexture.text.lineHeight?this._currentTexture.text.lineHeight:this._Content.finalH),this._shouldClip?this._updateShader():(this._ContentClipper.shader=null,this._positionTexture()),t&&this.startScrolling(),this.signal("marqueeContentLoaded");}},{key:"_update",value:function _update(){this._updateColor(),this._updateTexture(),this._updateShader(),this._restartScrolling&&this.startScrolling();}},{key:"_restartScrolling",get:function get(){return this.autoStart||this._scrolling||this._shouldTryScrolling}},{key:"_updateColor",value:function _updateColor(){this.color&&(this._Content.smooth={color:l.getValidColor(this.color)});}},{key:"_currentTexture",get:function get(){return this._Content.text||this._Content.texture||{}}},{key:"_updateTexture",value:function _updateTexture(){var t={rtt:!0};this.contentTexture?t.texture=this.contentTexture:this.title&&(t.text=_objectSpread(_objectSpread(_objectSpread({},this.style.textStyle),this.title),{},{text:this.textContent})),this.patch({ContentClipper:{w:this.w+14,ContentBox:{Content:t,ContentLoopTexture:{}}}}),this.signal("marqueeContentLoaded");}},{key:"_updateShader",value:function _updateShader(){this._ContentClipper.patch({w:this.w>0?this.w+this.style.fadeWidth/2:0,shader:{type:xt,positionLeft:0,positionRight:this.style.fadeWidth},rtt:!0});}},{key:"_updateAnimation",value:function _updateAnimation(){this._scrollAnimation&&this._scrollAnimation.stopNow(),this._scrollAnimation=this.animation({duration:this._loopWidth/50,delay:isNaN(this.delay)?1.5:this.delay,repeat:isNaN(this.repeat)?-1:this.repeat,actions:[{t:"ContentBox",p:"x",v:{sm:0,0:{v:0},.5:{v:-(this._loopWidth+this.style.offset)}}},{t:"ContentClipper",p:"shader.positionLeft",v:{sm:0,0:{v:0},.1:{v:this.style.fadeWidth},.4:{v:this.style.fadeWidth},.5:{v:0}}}]});}},{key:"_positionTexture",value:function _positionTexture(){var t=this._shouldCenter()?(this.w-this._textRenderedW)/2:0;this.style.shouldSmooth?this._ContentBox.smooth={x:t}:this._ContentBox.x=t;}},{key:"startScrolling",value:function startScrolling(){this._Content.off("txLoaded",this.startScrolling.bind(this)),this._shouldTryScrolling=!0,0===this._textRenderedW&&this._Content.on("txLoaded",this.startScrolling.bind(this)),this._shouldClip?(this._scrolling=!0,this._ContentLoopTexture.x=this._loopWidth+this.style.offset,this._ContentLoopTexture.texture=this._Content.getTexture(),this._updateAnimation(),this._scrollAnimation.start()):this._scrolling=!1;}},{key:"stopScrolling",value:function stopScrolling(){this._shouldTryScrolling=!1,this._scrolling=!1,this._scrollAnimation&&(this._scrollAnimation.stopNow(),this._ContentLoopTexture.texture=null);}},{key:"_shouldClip",get:function get(){return this._textRenderedW>this.w-this.style.fadeWidth/4}},{key:"_shouldCenter",value:function _shouldCenter(){return this._centerAlign||this._Content.text&&"center"===this._Content.text.textAlign}},{key:"_setAutoStart",value:function _setAutoStart(t){return this.autoStart&&!t&&this._updateContentTexture(),t}},{key:"_setCenterAlign",value:function _setCenterAlign(t){return this._centerAlign=t,this._updateContentTexture(),t}},{key:"textContent",get:function get(){var t,e,n;return null!==(t=null!==(e=null===(n=this.title)||void 0===n?void 0:n.text)&&void 0!==e?e:this.title)&&void 0!==t?t:""}},{key:"_loopWidth",get:function get(){return this.overrideLoopX||this._textRenderedW}},{key:"_textRenderedW",get:function get(){return this._Content.renderWidth}},{key:"announce",get:function get(){return this._announce||this.title&&this.title.text},set:function set(t){_set(_getPrototypeOf(Marquee.prototype),"announce",t,this,!0);}}],[{key:"_template",value:function _template(){return {ContentClipper:{boundsMargin:[],ContentBox:{Content:{},ContentLoopTexture:{}}}}}},{key:"__componentName",get:function get(){return "Marquee"}},{key:"__themeStyle",get:function get(){return vt}},{key:"tags",get:function get(){return ["ContentClipper",{name:"ContentBox",path:"ContentClipper.ContentBox"},{name:"Content",path:"ContentClipper.ContentBox.Content"},{name:"ContentLoopTexture",path:"ContentClipper.ContentBox.ContentLoopTexture"}]}},{key:"properties",get:function get(){return ["autoStart","title","contentTexture","color","centerAlign","delay","repeat","overrideLoopX"]}},{key:"aliasStyles",get:function get(){return [{prev:"fadeW",curr:"fadeWidth"}]}}]),Marquee}(),kt=Object.entries(Object.getOwnPropertyDescriptors(t.textures.TextTexture.prototype)).reduce((function(e,n){var i=_slicedToArray(n,1)[0],o=t.textures.TextTexture.prototype[i];return i.startsWith("_")||["undefined","function"].includes(_typeof(o))?e:_objectSpread(_defineProperty$1({},i,o),e)}),{}),St=function(t){_inherits(TextBox,G);var e=_createSuper(TextBox);function TextBox(){return _classCallCheck(this,TextBox),e.apply(this,arguments)}return _createClass(TextBox,[{key:"_setDimensions",value:function _setDimensions(t,e){var n=t,i=e;this._isInlineContent||(n=this._Text.texture.getRenderWidth(),i=this._Text.texture.getRenderHeight());var o=this.w!==n||this.h!==i;n&&i&&o&&(this.h=i,this.fixed||(this.w=n),!this.hideOnLoad&&this.alpha<1&&(this.alpha=1),this._notifyAncestors());}},{key:"_setContent",value:function _setContent(t){return this._isInlineContent=!1,(Array.isArray(t)||l.isMarkupString(t))&&(this._isInlineContent=!0),"string"==typeof t||this._isInlineContent?t:""}},{key:"title",get:function get(){return this._content}},{key:"_notifyAncestors",value:function _notifyAncestors(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.w,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.h;this.fireAncestors("$itemChanged"),this.signal("textBoxChanged",{w:t,h:e});}},{key:"_construct",value:function _construct(){_get(_getPrototypeOf(TextBox.prototype),"_construct",this).call(this),this._marqueeContentListenerAttached=!1,this._marqueeOverrideLoopX=void 0,this._resetMarqueePromise();}},{key:"_update",value:function _update(){this.content?(this._isInlineContent?this._updateInlineContent():this._updateText(),this._updateMarquee()):(this._Text||this._InlineContent)&&(this.w=this.h=0,this._notifyAncestors(),this._updateMarquee(),this.patch({Text:void 0,InlineContent:void 0}));}},{key:"_updateInlineContent",value:function _updateInlineContent(){var t=this;this.patch({Text:void 0});var e=mt.properties.reduce((function(e,n){return null!=t[n]&&(e[n]=t[n]),e}),{});this._textStyleSet.wordWrapWidth&&(e.w=this._textStyleSet.wordWrapWidth,e.rtt=!0),this._textStyleSet.maxLines&&(e.maxLines=this._textStyleSet.maxLines),this._textStyleSet.maxLinesSuffix&&(e.maxLinesSuffix=this._textStyleSet.maxLinesSuffix),this.patch({alpha:1,InlineContent:_objectSpread(_objectSpread({type:mt,w:this.w},e),{},{signals:{loadedInlineContent:"_setDimensions"}})});}},{key:"_updateText",value:function _updateText(){this.patch({InlineContent:void 0}),this._Text||(this.patch({Text:{}}),this._Text.on("txLoaded",this._setDimensions.bind(this)));var t=this._textStyleSet;this._Text&&this._Text.patch({y:this.style.offsetY,x:this.style.offsetX,text:_objectSpread(_objectSpread({},kt),t)});}},{key:"marqueeOverrideLoopX",get:function get(){return this._marqueeOverrideLoopX},set:function set(t){this._marqueeOverrideLoopX=t,this._Marquee&&(this._Marquee.overrideLoopX=this._marqueeOverrideLoopX),this._resolveAwaitMarqueeOverrideX();}},{key:"_resetMarqueePromise",value:function _resetMarqueePromise(){var t=this;this._awaitMarqueeOverrideX=new Promise((function(e,n){t._resolveAwaitMarqueeOverrideX=e,t._rejectAwaitMarqueeOverrideX=n;}));}},{key:"_loadedMarqueeContent",value:function _loadedMarqueeContent(){this.signal("willMarquee",this._Marquee);}},{key:"_updateMarquee",value:function _updateMarquee(){var t=this,e=this._isInlineContent?this._InlineContent:this._Text;if(this._Marquee&&!this.marquee&&this._toggleMarquee(e),this.marquee){this._resetMarqueePromise();var n=_objectSpread(_objectSpread({},this.marqueeProps),{},{w:this._textStyleSet.wordWrapWidth||this.w,h:this.h,y:this.style.offsetY,x:this.style.offsetX,signals:{marqueeContentLoaded:"_loadedMarqueeContent"}});this._Marquee||(n.type=bt),this._isInlineContent?(this._InlineContent.w=0,n.contentTexture=e.getTexture(),n.w=this._textStyleSet.wordWrapWidth||this.w):n.title=_objectSpread(_objectSpread({text:e.text.text},this._textStyleSet),{},{wordWrapWidth:0,maxLines:1}),this.patch({Marquee:n}),this._marqueeContentListenerAttached||(this._marqueeContentListenerAttached=!0),void 0!==this._marqueeOverrideLoopX?this._awaitMarqueeOverrideX.then((function(){t._toggleMarquee(e);})):this._toggleMarquee(e);}}},{key:"_getMarqueeProps",value:function _getMarqueeProps(){var t;return null!==(t=this._marqueeProps)&&void 0!==t?t:{}}},{key:"_textStyleSet",get:function get(){var t=this,e=_objectSpread(_objectSpread({},this.theme.typography.body1),null!==this.style.textStyle&&"object"===_typeof(this.style.textStyle)&&Object.keys(this.style.textStyle)?this.style.textStyle:this.theme.typography[this.style.textStyle]);return this.constructor.properties.forEach((function(n){"fontStyle"!==n&&void 0!==t["_".concat(n)]&&(e["content"===n?"text":n]=t["_".concat(n)]);})),this.w&&!this._isInlineContent&&!this.style.textStyle.wordWrapWidth&&this.fixed&&(e.wordWrapWidth=this.w),e}},{key:"_toggleMarquee",value:function _toggleMarquee(t){this.marquee?(t.alpha=.001,this._Marquee.alpha=1,this._Marquee.startScrolling()):(t.alpha=1,this._Marquee.alpha=.001,this._Marquee.stopScrolling());}},{key:"toggleMarquee",value:function toggleMarquee(){var t=this._isInlineContent?this._InlineContent:this._Text;this._toggleMarquee(t);}},{key:"announce",get:function get(){return this._announce||(this._isInlineContent&&this._InlineContent?this._InlineContent.announce:this.content)},set:function set(t){_set(_getPrototypeOf(TextBox.prototype),"announce",t,this,!0);}},{key:"smooth",set:function set(t){k$1.warn("warning: value smoothing is known to cause bugs with the TextBox - patch updated values instead."),_set(_getPrototypeOf(TextBox.prototype),"smooth",t,this,!0);}}],[{key:"_template",value:function _template(){return {alpha:.001}}},{key:"__componentName",get:function get(){return "TextBox"}},{key:"__themeStyle",get:function get(){return _t}},{key:"tags",get:function get(){return ["InlineContent","Marquee","Text"]}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(mt.properties),["content","fixed","marquee","marqueeProps","hideOnLoad"])}}]),TextBox}(),Ct=function(t){_inherits(Button,pt);var e=_createSuper(Button);function Button(){return _classCallCheck(this,Button),e.apply(this,arguments)}return _createClass(Button,[{key:"_update",value:function _update(){this._updatePrefix(),this._updateTitle(),this._updateSuffix(),this._updateAllPositioning(),this._updateTruncation();}},{key:"_updateAllPositioning",value:function _updateAllPositioning(){this._updatePositions(),this._updateContentDimensions(),this._updateSurfaceDimensions(),this._updateContentPosition(),_get(_getPrototypeOf(Button.prototype),"_update",this).call(this);}},{key:"$itemChanged",value:function $itemChanged(){this._updateAllPositioning(),this._updateTruncation();}},{key:"_onTitleTextBoxChanged",value:function _onTitleTextBoxChanged(){this._updateAllPositioning();}},{key:"_updatePositions",value:function _updatePositions(){this._hasPrefix&&(this._Prefix.x=this._prefixX),this._hasTitle&&(this._TextWrapper.x=this._titleX),this._hasSuffix&&(this._Suffix.x=this._suffixX);}},{key:"_updatePrefix",value:function _updatePrefix(){if(this.prefix){var t={style:{itemSpacing:this.style.itemSpacing}};this._Prefix||(t=_objectSpread(_objectSpread({},this._rowProps),t)),this._Content.patch({Prefix:t}),this._Prefix.items=this._addButtonProps(this.prefix);}else this._Content.patch({Prefix:void 0});}},{key:"_updateTitle",value:function _updateTitle(){if(this._hasTitle){var t={content:this.title,style:{textStyle:this.style.textStyle}};this._Title||(t=_objectSpread({type:St,mountY:.5,y:function y(t){return t/2},signals:{textBoxChanged:"_onTitleTextBoxChanged"}},t)),this._Content.patch({TextWrapper:{mountY:.5,Title:t}});}else this._Content.patch({TextWrapper:{Title:void 0}});}},{key:"_updateSuffix",value:function _updateSuffix(){if(this.suffix){var t={style:{itemSpacing:this.style.itemSpacing}};this._Suffix||(t=_objectSpread(_objectSpread({},this._rowProps),t)),this._Content.patch({Suffix:t}),this._Suffix.items=this._addButtonProps(this.suffix);}else this._Content.patch({Suffix:void 0});}},{key:"_updateTruncation",value:function _updateTruncation(){this._Title&&this._Title.patch({style:{textStyle:_objectSpread(_objectSpread({},this.style.textStyle),{},{wordWrap:this.fixed,wordWrapWidth:this.fixed?this._fixedWordWrapWidth:0})}});}},{key:"_updateContentDimensions",value:function _updateContentDimensions(){var t={},e=this.h/2;this._Content.transition("w").targetValue!==this._contentW&&(this._Content.w=this._contentW),this._Content.y!==e&&(t.y=e),Object.keys(t).length>0&&this.applySmooth(this._Content,t);}},{key:"_updateContentPosition",value:function _updateContentPosition(){this._Content.patch(this._contentProps);}},{key:"_updateSurfaceDimensions",value:function _updateSurfaceDimensions(){var t=this.w;(t=this.fixed?this._w:!this._hasTitle&&(this._hasPrefix||this._hasSuffix)||this._Title&&!this._Title.visible&&(this._hasPrefix||this._hasSuffix)?this._contentW+this._paddingX:Math.max(this._contentW+this._paddingX,this.style.minWidth))!==this.w&&(this.w=t),this.fireAncestors("$itemChanged");}},{key:"_addButtonProps",value:function _addButtonProps(t){var e=this;return (Array.isArray(t)?t:[t]).map((function(t){return _objectSpread(_objectSpread(_objectSpread({},e._buttonProps),t),{},{style:_objectSpread({color:e.style.contentColor},t.style)})}))}},{key:"_getJustify",value:function _getJustify(){return this._justify?this._justify:this.style.justify}},{key:"_contentProps",get:function get(){var t,e;switch(this.justify){case"left":t=0,e=this._paddingLeft;break;case"right":t=1,e=this.w-this._paddingRight;break;default:t=.5,e=this.w/2;}return {mountX:t,x:e}}},{key:"_buttonProps",get:function get(){return {centerInParent:!0,mode:this.mode}}},{key:"_hasPrefix",get:function get(){return !(!this.prefix||!Object.keys(this.prefix).length)}},{key:"_prefixW",get:function get(){return this._hasPrefix?this._Prefix.w:0}},{key:"_prefixX",get:function get(){return 0}},{key:"_hasTitle",get:function get(){return !!this.title}},{key:"_titleW",get:function get(){return this._hasTitle&&this._Title&&this._Title._Text&&this._Title.visible?this._Title.w:0}},{key:"_titleX",get:function get(){return this._hasPrefix?this._prefixW+this.style.titlePadding:0}},{key:"_hasSuffix",get:function get(){return !(!this.suffix||!Object.keys(this.suffix).length)}},{key:"_suffixW",get:function get(){return this._hasSuffix?this._Suffix.w:0}},{key:"_suffixX",get:function get(){return this._hasTitle?this._titleW+this._TextWrapper.x+this.style.titlePadding:this._hasPrefix?this._prefixW+this.style.itemSpacing:0}},{key:"_contentW",get:function get(){return this._hasSuffix?this._suffixX+this._suffixW:this._hasTitle&&this._Title&&this._Title.visible?this._titleX+this._titleW:this._hasPrefix?this._prefixX+this._prefixW:0}},{key:"_rowProps",get:function get(){return {type:ht,mountY:.5,autoResizeHeight:!0,autoResizeWidth:!0}}},{key:"_totalTitlePaddingX",get:function get(){var t=0;return this._hasPrefix&&(t+=this.style.titlePadding),this._hasSuffix&&(t+=this.style.titlePadding),t}},{key:"_fixedWordWrapWidth",get:function get(){var t=this.w,e=this._paddingX+this._prefixW+this._suffixW+this._totalTitlePaddingX;return Math.max(1,t-e)}},{key:"announce",get:function get(){if(this._announce)return this._announce;var t=[];return this.title&&t.push(this.title),t.push(this._announceComponentName),this._hasPrefix&&this._Prefix.items.length&&t.push.apply(t,_toConsumableArray(this._Prefix.items.map((function(t){return t.announce})))),this._hasSuffix&&this._Suffix.items.length&&t.push.apply(t,_toConsumableArray(this._Suffix.items.map((function(t){return t.announce})))),t},set:function set(t){_set(_getPrototypeOf(Button.prototype),"announce",t,this,!0);}},{key:"_announceComponentName",get:function get(){return Button.__componentName}},{key:"_paddingX",get:function get(){return this._paddingLeft+this._paddingRight}},{key:"_paddingLeft",get:function get(){return this._hasTitle?this.style.paddingX:this.style.paddingXNoTitle}},{key:"_paddingRight",get:function get(){return this._hasTitle?this.style.paddingX:this.style.paddingXNoTitle}}],[{key:"__componentName",get:function get(){return "Button"}},{key:"__themeStyle",get:function get(){return rt}},{key:"properties",get:function get(){return ["fixed","justify","prefix","suffix","title"]}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Button),"tags",this)),["Content",{name:"TextWrapper",path:"Content.TextWrapper"},{name:"Title",path:"Content.TextWrapper.Title"},{name:"Prefix",path:"Content.Prefix"},{name:"Suffix",path:"Content.Suffix"}])}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Button),"_template",this).call(this)),{},{Content:{mount:.5,x:function x(t){return t/2},y:function y(t){return t/2},zIndex:2}})}}]),Button}(),wt=Object.freeze({__proto__:null,base:function base$H(t){return {height:8*t.spacer.md,minWidth:getWidthByColumnSpan(t,1),paddingX:t.spacer.xxl,textStyle:t.typography.button2}}}),Tt=function(t){_inherits(ButtonSmall,Ct);var e=_createSuper(ButtonSmall);function ButtonSmall(){return _classCallCheck(this,ButtonSmall),e.apply(this,arguments)}return _createClass(ButtonSmall,null,[{key:"__componentName",get:function get(){return "ButtonSmall"}},{key:"__themeStyle",get:function get(){return wt}}]),ButtonSmall}(),It=Object.freeze({__proto__:null,base:function base$G(t){return {height:12*t.spacer.xxl,paddingHorizontal:t.spacer.xl,paddingVertical:t.spacer.xl,radius:t.radius.md,titleTextStyle:_objectSpread(_objectSpread({},t.typography.headline1),{},{wordWrap:!0,maxLines:2,textColor:t.color.textNeutral}),width:l.getWidthByUpCount(t,6)}},mode:function mode$e(t){return {focused:{tone:{neutral:{backgroundColor:t.color.interactiveNeutralFocusSoft},inverse:{backgroundColor:t.color.interactiveInverseFocusSoft},brand:{backgroundColor:t.color.interactiveBrandFocusSoft}}},disabled:{titleTextStyle:{textColor:t.color.textNeutralDisabled}}}}}),At=function(t){_inherits(Card,pt);var e=_createSuper(Card);function Card(){return _classCallCheck(this,Card),e.apply(this,arguments)}return _createClass(Card,[{key:"_update",value:function _update(){_get(_getPrototypeOf(Card.prototype),"_update",this).call(this),this._updateTitle(),this._updatePositions();}},{key:"_updatePositions",value:function _updatePositions(){this._updateTitlePosition();}},{key:"_updateTitle",value:function _updateTitle(){this._Title.patch({content:this.title,style:{textStyle:_objectSpread(_objectSpread({},this.style.titleTextStyle),{},{wordWrapWidth:this._calculateTextWidth()})}});}},{key:"_calculateTextWidth",value:function _calculateTextWidth(){return this.w-2*this.style.paddingHorizontal}},{key:"_updateTitlePosition",value:function _updateTitlePosition(){this._Title.x=this.style.paddingHorizontal,this._Title.y=this.style.paddingVertical;}},{key:"announce",get:function get(){return this._announce||this._Title&&this._Title.announce},set:function set(t){_set(_getPrototypeOf(Card.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Card"}},{key:"__themeStyle",get:function get(){return It}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Card),"properties",this)),["title"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Card),"tags",this)),["Title"])}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Card),"_template",this).call(this)),{},{Title:{type:St,signals:{textBoxChanged:"_updatePositions"}}})}}]),Card}(),Pt=Object.freeze({__proto__:null,base:function base$F(t){return {descriptionTextStyle:_objectSpread(_objectSpread({},t.typography.body2),{},{textColor:t.color.textNeutralSecondary,wordWrap:!0,maxLines:3}),detailsTextStyle:_objectSpread(_objectSpread({},t.typography.body3),{},{textColor:t.color.textNeutral,wordWrap:!0,maxLines:1})}},mode:function mode$d(t){return {disabled:{descriptionTextStyle:{textColor:t.color.textNeutralDisabled},detailsTextStyle:{textColor:t.color.textNeutralDisabled}}}}}),Lt=function(t){_inherits(CardTitle,At);var e=_createSuper(CardTitle);function CardTitle(){return _classCallCheck(this,CardTitle),e.apply(this,arguments)}return _createClass(CardTitle,[{key:"_update",value:function _update(){_get(_getPrototypeOf(CardTitle.prototype),"_update",this).call(this),this._updateDescription(),this._updateDetails(),this._updatePositions();}},{key:"_updatePositions",value:function _updatePositions(){_get(_getPrototypeOf(CardTitle.prototype),"_updatePositions",this).call(this),this._updateDescriptionPosition(),this._updateDetailsPosition();}},{key:"_updateDescription",value:function _updateDescription(){this._Description.patch({content:this.description,style:{textStyle:_objectSpread(_objectSpread({},this.style.descriptionTextStyle),{},{wordWrapWidth:this._calculateTextWidth()})}});}},{key:"_updateDescriptionPosition",value:function _updateDescriptionPosition(){this._Description.x=this.style.paddingHorizontal,this._Description.y=this.style.paddingVertical+this._Title.h;}},{key:"_updateDetails",value:function _updateDetails(){this._Details.patch({content:this.details,style:{textStyle:_objectSpread(_objectSpread({},this.style.detailsTextStyle),{},{wordWrapWidth:this._calculateTextWidth()})}});}},{key:"_updateDetailsPosition",value:function _updateDetailsPosition(){this._Details.x=this.style.paddingHorizontal,this._Details.y=this.h-this.style.paddingVertical;}},{key:"announce",get:function get(){return this._announce||[this._Title&&this._Title.announce,this._Description&&this._Description.announce,this._Details&&this._Details.announce]},set:function set(t){_set(_getPrototypeOf(CardTitle.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "CardTitle"}},{key:"__themeStyle",get:function get(){return Pt}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardTitle),"tags",this)),["Description","Details"])}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardTitle),"properties",this)),["description","details"])}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(CardTitle),"_template",this).call(this)),{},{Description:{type:St,signals:{textBoxChanged:"_updatePositions"}},Details:{type:St,mountY:1}})}}]),CardTitle}(),Bt=Object.freeze({__proto__:null,base:function base$E(t){return {descriptionTextStyle:_objectSpread(_objectSpread({},t.typography.body2),{},{textColor:t.color.textNeutralSecondary,wordWrap:!0,maxLines:8}),height:15*t.spacer.xxxl,subtitleTextStyle:_objectSpread(_objectSpread({},t.typography.body3),{},{maxLines:2,textColor:t.color.textNeutral,wordWrap:!0}),width:l.getWidthByColumnSpan(t,4)}},mode:function mode$c(t){return {disabled:{descriptionTextStyle:{textColor:t.color.textNeutralDisabled},subtitleTextStyle:{textColor:t.color.textNeutralDisabled}}}}}),Ot=Object.freeze({__proto__:null,base:function base$D(t){var e=t.spacer.xxl;return {alpha:t.alpha.primary,width:e,height:e,knobHeight:e/2,knobWidth:e/2,radius:e/2,strokeWidth:t.stroke.sm}},mode:function mode$b(t){return {disabled:{alpha:t.alpha.inactive}}},tone:function tone$k(t){return {neutral:{backgroundColor:t.color.fillNeutralDisabled,backgroundColorChecked:t.color.fillNeutral,knobColor:t.color.fillInverse,strokeColor:t.color.strokeInverse},inverse:{backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillInverse,knobColor:t.color.fillNeutral,strokeColor:t.color.strokeNeutral},brand:{backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillBrand,knobColor:t.color.fillNeutral,strokeColor:t.color.strokeNeutral}}}}),Wt=function(e){_inherits(Radio,G);var n=_createSuper(Radio);function Radio(){return _classCallCheck(this,Radio),n.apply(this,arguments)}return _createClass(Radio,[{key:"_update",value:function _update(){this._updateBody(),this._updateStroke(),this._updateKnob(),this._checkedChanged&&(this.fireAncestors("$announce",this.announce),this._checkedChanged=!1),this._updateOpacity();}},{key:"_updateBody",value:function _updateBody(){var e=this.checked?this.style.backgroundColorChecked:this.style.backgroundColor,n=this.style.radius>=this.w/2?(this.w-this.style.strokeWidth)/2:0;this._Body.patch({texture:t.Tools.getRoundRect(this.w-this.style.strokeWidth,this.h-this.style.strokeWidth,n,null,null,!0,e)});}},{key:"_updateStroke",value:function _updateStroke(){this._Stroke.patch({texture:t.Tools.getRoundRect(this.w,this.h,this.style.radius,this.style.strokeWidth,this.style.strokeColor,!1)});}},{key:"_updateKnob",value:function _updateKnob(){this._Knob.patch({texture:t.Tools.getRoundRect(this.style.knobWidth,this.style.knobHeight,this.style.knobWidth/2,null,null,!0,this.style.knobColor)}),this.applySmooth(this._Knob,{alpha:this.checked?1:0});}},{key:"_updateOpacity",value:function _updateOpacity(){this.applySmooth(this,{alpha:this.style.alpha});}},{key:"_setChecked",value:function _setChecked(t){return this._checkedChanged=t!==this._checked,t}},{key:"toggle",value:function toggle(){return this._isDisabledMode||(this.checked=!this.checked),this}},{key:"_handleEnter",value:function _handleEnter(){return "function"==typeof this.onEnter?this.onEnter(this):(this.toggle(),!1)}},{key:"announce",get:function get(){return this._announce||(this.checked?"Checked":"Unchecked")},set:function set(t){_set(_getPrototypeOf(Radio.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Radio"}},{key:"__themeStyle",get:function get(){return Ot}},{key:"_template",value:function _template(){var t={mount:.5,x:function x(t){return t/2},y:function y(t){return t/2}};return {Body:_objectSpread(_objectSpread({rtt:!0},t),{},{Knob:_objectSpread(_objectSpread({},t),{},{alpha:0})}),Stroke:t}}},{key:"tags",get:function get(){return ["Knob","Body","Stroke"]}},{key:"properties",get:function get(){return ["checked"]}}]),Radio}(),jt=Object.freeze({__proto__:null,base:function base$C(t){var e=t.spacer.xl;return {width:e,height:e,knobHeight:e/2,knobWidth:e/2,radius:e/2}}});(function(t){_inherits(RadioSmall,Wt);var e=_createSuper(RadioSmall);function RadioSmall(){return _classCallCheck(this,RadioSmall),e.apply(this,arguments)}return _createClass(RadioSmall,null,[{key:"__componentName",get:function get(){return "RadioSmall"}},{key:"__themeStyle",get:function get(){return jt}}]),RadioSmall})();(function(t){_inherits(CardRadio,Lt);var e=_createSuper(CardRadio);function CardRadio(){return _classCallCheck(this,CardRadio),e.apply(this,arguments)}return _createClass(CardRadio,[{key:"_update",value:function _update(){_get(_getPrototypeOf(CardRadio.prototype),"_update",this).call(this),this._updateRadio(),this._updateSubtitle(),this._updatePositions();}},{key:"_updatePositions",value:function _updatePositions(){_get(_getPrototypeOf(CardRadio.prototype),"_updatePositions",this).call(this),this._updateSubtitlePosition();}},{key:"_updateSubtitle",value:function _updateSubtitle(){this._Subtitle.patch({content:this.subtitle,style:{textStyle:_objectSpread(_objectSpread({},this.style.subtitleTextStyle),{},{wordWrapWidth:this._calculateTextWidth()})}});}},{key:"_updateRadio",value:function _updateRadio(){var t=_objectSpread(_objectSpread({},this.radio),{},{mode:this.mode,mountX:1,x:this.w-this.style.paddingHorizontal,y:this.style.paddingVertical});this._Radio||(t.type=Wt),this.patch({Radio:t});}},{key:"_updateSubtitlePosition",value:function _updateSubtitlePosition(){this._Subtitle.x=this.style.paddingHorizontal,this._Subtitle.y=this.style.paddingVertical+this._Title.h;}},{key:"_updateDescriptionPosition",value:function _updateDescriptionPosition(){this._Description.x=this.style.paddingHorizontal,this._Description.y=2*this.style.paddingVertical+this._Title.h+this._Subtitle.h;}},{key:"announce",get:function get(){return this._announce||[this._Title&&this._Title.announce,this._Subtitle&&this._Subtitle.announce,this._Description&&this._Description.announce,this._Details&&this._Details.announce]},set:function set(t){_set(_getPrototypeOf(CardRadio.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "CardRadio"}},{key:"__themeStyle",get:function get(){return Bt}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardRadio),"properties",this)),["radio","subtitle"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardRadio),"tags",this)),["Radio","Subtitle"])}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(CardRadio),"_template",this).call(this)),{},{Subtitle:{type:St,signals:{textBoxChanged:"_updatePositions"}}})}}]),CardRadio})();var Nt=Object.freeze({__proto__:null,base:function base$B(t){return {height:5*t.spacer.xxl,iconWidth:t.spacer.xxl,iconHeight:t.spacer.xxl,width:l.getWidthByColumnSpan(t,3)}}});(function(t){_inherits(CardSection,At);var e=_createSuper(CardSection);function CardSection(){return _classCallCheck(this,CardSection),e.apply(this,arguments)}return _createClass(CardSection,[{key:"_update",value:function _update(){_get(_getPrototypeOf(CardSection.prototype),"_update",this).call(this),this._updateIcon();}},{key:"_updateIcon",value:function _updateIcon(){var t=this.style,e=t.iconWidth,n=t.iconHeight,i={w:e,h:n,icon:this.iconSrc,x:this.w-e-this.style.paddingHorizontal,y:(this._Title.style.textStyle.lineHeight-n)/2+this.style.paddingVertical};this._Icon||(i.type=nt),this.patch({Icon:i});}},{key:"_calculateTextWidth",value:function _calculateTextWidth(){var t=this.w-2*this.style.paddingHorizontal;return this.iconSrc?t-this.iconWidth:t}}],[{key:"__componentName",get:function get(){return "CardSection"}},{key:"__themeStyle",get:function get(){return Nt}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardSection),"tags",this)),["Icon"])}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardSection),"properties",this)),["iconWidth","iconHeight","iconSrc"])}}]),CardSection})();var zt=Object.freeze({__proto__:null,base:function base$A(t){var e=t.stroke.sm,n=t.spacer.xxl-2*e;return {alpha:t.alpha.primary,width:n,height:n,checkWidth:t.spacer.lg,checkHeight:t.spacer.md+t.spacer.xs,checkSrc:t.asset.check,radius:n/2,strokeWidth:e}},mode:function mode$a(t){return {disabled:{alpha:t.alpha.inactive}}},tone:function tone$j(t){return {neutral:{strokeColor:t.color.strokeInverse,checkColor:t.color.textInverse,backgroundColor:t.color.fillNeutralDisabled,backgroundColorChecked:t.color.fillNeutral},inverse:{strokeColor:t.color.strokeNeutral,checkColor:t.color.textNeutral,backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillInverse},brand:{strokeColor:t.color.strokeNeutral,checkColor:t.color.textNeutral,backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillBrand}}}}),Et=function(e){_inherits(Checkbox,G);var n=_createSuper(Checkbox);function Checkbox(){return _classCallCheck(this,Checkbox),n.apply(this,arguments)}return _createClass(Checkbox,[{key:"_update",value:function _update(){this._updateBody(),this._updateStroke(),this._updateCheck(),this._checkedChanged&&(this.fireAncestors("$announce",this.announce),this._checkedChanged=!1),this._updateOpacity();}},{key:"_updateCheck",value:function _updateCheck(){this._Check.patch({w:this.style.checkWidth,h:this.style.checkHeight,icon:this.style.checkSrc,style:{color:this.style.checkColor}});var t={alpha:this.checked?1:0};this.applySmooth(this._Check,t);}},{key:"_updateBody",value:function _updateBody(){var e=this.checked?this.style.backgroundColorChecked:this.style.backgroundColor,n=this.style.radius>=this.w/2?(this.w-this.style.strokeWidth)/2:0;this._Body.patch({texture:t.Tools.getRoundRect(this.w-this.style.strokeWidth,this.h-this.style.strokeWidth,n,0,null,!0,e)});}},{key:"_updateStroke",value:function _updateStroke(){this._Stroke.patch({texture:t.Tools.getRoundRect(this.w,this.h,this.style.radius,this.style.strokeWidth,this.style.strokeColor,!1)});}},{key:"_updateOpacity",value:function _updateOpacity(){this.applySmooth(this,{alpha:this.style.alpha});}},{key:"_setChecked",value:function _setChecked(t){return this._checkedChanged=t!==this._checked,t}},{key:"toggle",value:function toggle(){return this._isDisabledMode||(this.checked=!this.checked),this}},{key:"_handleEnter",value:function _handleEnter(){return "function"==typeof this.onEnter?this.onEnter(this):(this.toggle(),!1)}},{key:"announce",get:function get(){return this._announce||(this.checked?"Checked":"Unchecked")},set:function set(t){_set(_getPrototypeOf(Checkbox.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Checkbox"}},{key:"__themeStyle",get:function get(){return zt}},{key:"_template",value:function _template(){var t={mount:.5,x:function x(t){return t/2},y:function y(t){return t/2}};return {Body:_objectSpread(_objectSpread({rtt:!0},t),{},{Check:_objectSpread(_objectSpread({type:nt},t),{},{alpha:0})}),Stroke:t}}},{key:"tags",get:function get(){return ["Check","Body","Stroke"]}},{key:"properties",get:function get(){return ["checked"]}},{key:"aliasStyles",get:function get(){return [{prev:"checkH",curr:"checkHeight"},{prev:"checkW",curr:"checkWidth"}]}}]),Checkbox}(),Ft=Object.freeze({__proto__:null,base:function base$z(t){return {radius:[t.radius.md,t.radius.md,t.radius.md,t.radius.none],paddingX:t.spacer.lg,paddingY:t.spacer.md,offsetY:t.spacer.xxs,textStyle:t.typography.caption1}},tone:function tone$i(t){return {neutral:{textStyle:{textColor:t.color.textInverse},backgroundColor:t.color.fillNeutral},inverse:{textStyle:{textColor:t.color.textNeutral},backgroundColor:t.color.fillInverse},brand:{textStyle:{textColor:t.color.textNeutral},backgroundColor:t.color.fillBrand}}}}),Ht=function(e){_inherits(Label,G);var n=_createSuper(Label);function Label(){return _classCallCheck(this,Label),n.apply(this,arguments)}return _createClass(Label,[{key:"_init",value:function _init(){this._Text.on("txLoaded",this._updateBackground.bind(this)),_get(_getPrototypeOf(Label.prototype),"_init",this).call(this);}},{key:"_update",value:function _update(){this._updateBackground(),this._updateText();}},{key:"_updateText",value:function _updateText(){this._Text&&this._Text.patch({text:_objectSpread(_objectSpread({},this.style.textStyle),{},{text:this.title})});}},{key:"_updateBackground",value:function _updateBackground(){this._Text.x=this.w/2,this._Text.y=this.h/2+this.style.offsetY,this.h=this.title?this._Text.renderHeight+2*this.style.paddingY:0,this.w=this.title?this._Text.renderWidth+2*this.style.paddingX:0,this._Background.patch({texture:t.Tools.getRoundRect(this.w-2,this.h-2,this.style.radius,0,null,!0,this.style.backgroundColor)}),this.signal("loadedLabel",this);}},{key:"announce",get:function get(){return this._announce||this._Text&&this._Text.text.text},set:function set(t){_set(_getPrototypeOf(Label.prototype),"announce",t,this,!0);}}],[{key:"_template",value:function _template(){return {Background:{},Text:{mountY:.5,mountX:.5,text:{}}}}},{key:"__componentName",get:function get(){return "Label"}},{key:"__themeStyle",get:function get(){return Ft}},{key:"properties",get:function get(){return ["title"]}},{key:"tags",get:function get(){return ["Background","Text"]}}]),Label}(),Ut=Object.freeze({__proto__:null,base:function base$y(t){return {descriptionTextStyle:_objectSpread(_objectSpread({},t.typography.body2),{},{maxLines:1}),fadeWidth:100,logoWidth:t.typography.body3.lineHeight,logoHeight:t.typography.body3.lineHeight,logoPadding:t.spacer.lg,subtitleTextStyle:t.typography.body3,titleTextStyle:_objectSpread(_objectSpread({},t.typography.headline1),{},{maxLines:1}),marqueeSync:!0,alpha:t.alpha.primary}},mode:function mode$9(t){return {disabled:{subtitleTextStyle:{textColor:t.color.textNeutralDisabled},alpha:t.alpha.inactive}}},tone:function tone$h(t){return {neutral:{titleTextStyle:{textColor:t.color.textNeutral},subtitleTextStyle:{textColor:t.color.textNeutral},descriptionTextStyle:{textColor:t.color.textNeutralSecondary},mode:{disabled:{titleTextStyle:{textColor:t.color.textNeutralDisabled},subtitleTextStyle:{textColor:t.color.textNeutralDisabled},descriptionTextStyle:{textColor:t.color.textNeutralDisabled}}}},inverse:{titleTextStyle:{textColor:t.color.textInverse},subtitleTextStyle:{textColor:t.color.textInverse},descriptionTextStyle:{textColor:t.color.textInverseSecondary},mode:{disabled:{titleTextStyle:{textColor:t.color.textNeutralDisabled},subtitleTextStyle:{textColor:t.color.textNeutralDisabled},descriptionTextStyle:{textColor:t.color.textNeutralDisabled}}}},brand:{titleTextStyle:{textColor:t.color.textNeutral},subtitleTextStyle:{textColor:t.color.textNeutral},descriptionTextStyle:{textColor:t.color.textNeutralSecondary},mode:{disabled:{titleTextStyle:{textColor:t.color.textNeutralDisabled},subtitleTextStyle:{textColor:t.color.textNeutralDisabled},descriptionTextStyle:{textColor:t.color.textNeutralDisabled}}}}}}}),Kt=withMarqueeSync(function(t){_inherits(MetadataBase,G);var e=_createSuper(MetadataBase);function MetadataBase(){return _classCallCheck(this,MetadataBase),e.apply(this,arguments)}return _createClass(MetadataBase,[{key:"_init",value:function _init(){this.requestUpdate(!0);}},{key:"_titleLoaded",value:function _titleLoaded(){this._updateLayout();}},{key:"_subtitleLoaded",value:function _subtitleLoaded(t){var e=t.w,n=t.h;this._updateSubtitleLayout({w:e,h:n}),this._updateLayout();}},{key:"_descriptionLoaded",value:function _descriptionLoaded(){this._updateLayout();}},{key:"_updateSubtitleLayout",value:function _updateSubtitleLayout(t){var e=t.w,n=t.h;this._SubtitleWrapper.alpha=this.style.alpha,this._SubtitleWrapper.w=e,this._SubtitleWrapper.h=n;}},{key:"_update",value:function _update(){this._updateLines(),this._updateLayout();}},{key:"_updateLines",value:function _updateLines(){this._Text.w=this._textW(),this._updateTitle(),this._updateSubtitle(),this._updateDescription();}},{key:"_updateLayout",value:function _updateLayout(){this._updatePositions(),this._updateMetadataHeight(),this._updateLogo();}},{key:"_updatePositions",value:function _updatePositions(){this._Text.h=this._textH(),this._Text.x=this.logo&&"left"===this.logoPosition?this.logoWidth+this.style.logoPadding:0,this._Text.y=(this.h-this._Text.h)/2;}},{key:"_updateMetadataHeight",value:function _updateMetadataHeight(){var t=Math.max(this.logoHeight,this._Text.h);this.h!==t&&(this.h=t,this.signal("updateComponentDimensions"));}},{key:"_updateTitle",value:function _updateTitle(){this._Title.patch({content:this.title,marquee:this.marquee,style:{textStyle:_objectSpread(_objectSpread({},this.style.titleTextStyle),{},{maxLines:1,wordWrap:!0,wordWrapWidth:this._Text.w})}});}},{key:"resetMarquee",value:function resetMarquee(){this.marquee&&(this.title&&this._Title.toggleMarquee(),this.description&&this._Description.toggleMarquee());}},{key:"_updateSubtitle",value:function _updateSubtitle(){this._Subtitle.patch({content:this.subtitle,style:{textStyle:this.style.subtitleTextStyle}}),this._Subtitle.finalW>this._textW()?this._SubtitleWrapper.patch({w:this._textW()+this.style.fadeWidth/2,shader:{type:xt,positionLeft:0,positionRight:this.style.fadeWidth},rtt:!0}):this._SubtitleWrapper.shader=void 0,this._SubtitleWrapper.visible=!!this.subtitle,this._SubtitleWrapper.alpha=this.style.alpha;}},{key:"_updateDescription",value:function _updateDescription(){this._Description.patch({content:this.description,marquee:this.marquee,style:{textStyle:_objectSpread(_objectSpread({},this.style.descriptionTextStyle),{},{maxLines:1,wordWrap:!0,wordWrapWidth:this._Text.w})}});}},{key:"_updateLogo",value:function _updateLogo(){this.logoPosition=this.logoPosition||"right",this._Logo.patch({type:nt,w:this.logoWidth,h:this.logoHeight,icon:this.logo,alpha:this.style.alpha}),this._Logo.x="left"===this.logoPosition?0:this.w-this._Logo.w,this._Logo.y=(this.h-this.logoHeight)/2;}},{key:"_textW",value:function _textW(){return this.w-(this.logo?this.logoWidth+this.style.logoPadding:0)}},{key:"_textH",value:function _textH(){return (this.title&&this._Title&&this._Title.h||0)+(this.subtitle&&this._SubtitleWrapper&&this._SubtitleWrapper.h||0)+(this.description&&this._Description&&this._Description.h||0)}},{key:"_getLogoWidth",value:function _getLogoWidth(){return void 0!==this._logoWidth?this._logoWidth:this.style.logoWidth}},{key:"_setLogoWidth",value:function _setLogoWidth(t){return void 0!==t?t:this.logoWidth}},{key:"_getLogoHeight",value:function _getLogoHeight(){return void 0!==this._logoHeight?this._logoHeight:this.style.logoHeight}},{key:"_setLogoHeight",value:function _setLogoHeight(t){return void 0!==t?t:this.logoHeight}},{key:"syncArray",get:function get(){return [].concat(_toConsumableArray(this.title?[this._Title]:[]),_toConsumableArray(this.description?[this._Description]:[]),_toConsumableArray(this.subtitle?[this._Subtitle]:[]))}},{key:"announce",get:function get(){return this._announce||[this._Title&&this._Title.announce,this._Subtitle&&this._Subtitle.announce,this._Description&&this._Description.announce,this.logoTitle]},set:function set(t){_set(_getPrototypeOf(MetadataBase.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "MetadataBase"}},{key:"__themeStyle",get:function get(){return Ut}},{key:"_template",value:function _template(){return {Text:{flex:{direction:"column",justifyContent:"flex-start"},Title:{type:St,signals:{textBoxChanged:"_titleLoaded"}},SubtitleWrapper:{Subtitle:{type:St,signals:{textBoxChanged:"_subtitleLoaded"}}},Description:{type:St,signals:{textBoxChanged:"_descriptionLoaded"}}},Logo:{flexItem:!1,type:nt}}}},{key:"properties",get:function get(){return ["description","logo","logoHeight","logoPosition","logoTitle","logoWidth","subtitle","title","marquee"]}},{key:"tags",get:function get(){return ["Text",{name:"Title",path:"Text.Title"},{name:"SubtitleWrapper",path:"Text.SubtitleWrapper"},{name:"Subtitle",path:"Text.SubtitleWrapper.Subtitle"},{name:"Description",path:"Text.Description"},"Logo"]}}]),MetadataBase}()),qt=Object.freeze({__proto__:null,base:function base$x(t){return {titleTextStyle:t.typography.headline3,descriptionTextStyle:t.typography.body3}},tone:function tone$g(t){return {neutral:{subtitleTextStyle:{textColor:t.color.textNeutralSecondary},descriptionTextStyle:{textColor:t.color.textNeutral},mode:{disabled:{subtitleTextStyle:{textColor:t.color.textNeutralDisabled},descriptionTextStyle:{textColor:t.color.textNeutralDisabled}}}},inverse:{subtitleTextStyle:{textColor:t.color.textInverseSecondary},descriptionTextStyle:{textColor:t.color.textInverse},mode:{disabled:{subtitleTextStyle:{textColor:t.color.textNeutralDisabled},descriptionTextStyle:{textColor:t.color.textNeutralDisabled}}}},brand:{subtitleTextStyle:{textColor:t.color.textNeutralSecondary},descriptionTextStyle:{textColor:t.color.textNeutral},mode:{disabled:{subtitleTextStyle:{textColor:t.color.textNeutralDisabled},descriptionTextStyle:{textColor:t.color.textNeutralDisabled}}}}}}}),Xt=function(t){_inherits(MetadataTile,Kt);var e=_createSuper(MetadataTile);function MetadataTile(){return _classCallCheck(this,MetadataTile),e.apply(this,arguments)}return _createClass(MetadataTile,[{key:"_updateSubtitle",value:function _updateSubtitle(){this.description?(this._Subtitle.patch({content:""}),this._Subtitle.alpha=0,this._Subtitle.visible=!1):(this._Subtitle.alpha=1,this._Subtitle.visible=!0,_get(_getPrototypeOf(MetadataTile.prototype),"_updateSubtitle",this).call(this));}},{key:"_updateSubtitleLayout",value:function _updateSubtitleLayout(t){var e=t.h;this.subtitle&&!this.description?(this._SubtitleWrapper.h=e,this._SubtitleWrapper.alpha=this.style.alpha):this._SubtitleWrapper.h=0;}},{key:"announce",get:function get(){return this._announce||[this._Title&&this._Title.announce,this._Subtitle&&this._Subtitle.announce||this._Description&&this._Description.announce,this.logoTitle]},set:function set(t){_set(_getPrototypeOf(MetadataTile.prototype),"announce",t,this,!0);}},{key:"_textH",value:function _textH(){return (this.title&&this._Title&&this._Title.h||0)+(this.subtitle&&this._Subtitle&&this._Subtitle.visible&&this._SubtitleWrapper.h||0)+(this.description&&this._Description&&this._Description.h||0)}}],[{key:"__componentName",get:function get(){return "MetadataTile"}},{key:"__themeStyle",get:function get(){return qt}}]),MetadataTile}(),Vt=Object.freeze({__proto__:null,base:function base$w(t){return {height:t.spacer.md,animation:t.animation.utility,radius:t.radius.xs}},tone:function tone$f(t){return {neutral:{barColor:t.color.fillNeutralTertiary,progressColor:t.color.fillNeutral},inverse:{barColor:t.color.fillInverseTertiary,progressColor:t.color.fillInverse},brand:{barColor:t.color.fillNeutralTertiary,progressColor:t.color.fillBrand}}}}),Yt=function(e){_inherits(ProgressBar,G);var n=_createSuper(ProgressBar);function ProgressBar(){return _classCallCheck(this,ProgressBar),n.apply(this,arguments)}return _createClass(ProgressBar,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(ProgressBar.prototype),"_construct",this)&&_get(_getPrototypeOf(ProgressBar.prototype),"_construct",this).call(this),this._progress=0;}},{key:"_update",value:function _update(){this._updateTextures(),this._updateProgress(),this._progressChanged&&(this.fireAncestors("$announce",this.announce),this._progressChanged=!1);}},{key:"_updateTextures",value:function _updateTextures(){var e=this._getProgressWidth();this._Bar.texture=t.Tools.getRoundRect(this.w-2,this.h,this.style.radius,0,0,!0,this.style.barColor),this._Progress.texture=t.Tools.getRoundRect(e+1,this.h,this.style.radius,0,0,!0,this.style.progressColor);}},{key:"_updateProgress",value:function _updateProgress(){var t=this._getProgressWidth();this._Progress.smooth={w:[t,this.style.animation],alpha:Number(t>0)};}},{key:"_setProgress",value:function _setProgress(t){return this._progressChanged=t!==this._progress,t}},{key:"announce",get:function get(){if(void 0!==this._announce&&null!==this._announce)return this._announce;var t=this.progress;return t>1?t=1:t<0&&(t=0),"".concat(Math.round(100*t),"%")},set:function set(t){_set(_getPrototypeOf(ProgressBar.prototype),"announce",t,this,!0);}},{key:"_getProgressWidth",value:function _getProgressWidth(){var t=this.w*this._progress;return t<=0?0:Math.min(t,this.w)}}],[{key:"_template",value:function _template(){return {Bar:{zIndex:1},Progress:{alpha:0,zIndex:2}}}},{key:"__themeStyle",get:function get(){return Vt}},{key:"__componentName",get:function get(){return "ProgressBar"}},{key:"properties",get:function get(){return ["progress"]}},{key:"tags",get:function get(){return ["Bar","Progress"]}}]),ProgressBar}(),Gt=Object.freeze({__proto__:null,base:function base$v(t){return {animationEntrance:t.animation.standardEntrance,animationExit:t.animation.standardExit,metadataLocation:"standard",paddingX:t.spacer.xl,paddingY:t.spacer.lg,paddingYProgress:t.spacer.xl,paddingYBetweenContent:t.spacer.md,radius:t.radius.md,alpha:t.alpha.primary}},mode:function mode$8(t){return {disabled:{alpha:t.alpha.inactive}}},tone:function tone$e(t){return {neutral:{mode:{focused:{backgroundColor:t.color.interactiveNeutralFocusSoft}}},inverse:{mode:{focused:{backgroundColor:t.color.interactiveInverseFocusSoft}}},brand:{mode:{focused:{backgroundColor:t.color.interactiveBrandFocusSoft}}}}}}),Qt=function(t){_inherits(Tile,pt);var e=_createSuper(Tile);function Tile(){return _classCallCheck(this,Tile),e.apply(this,arguments)}return _createClass(Tile,[{key:"announce",get:function get(){return this._announce||[this._Metadata&&this._Metadata.announce,this._Badge&&this._Badge.announce,this._Label&&this._Label.announce,this._ProgressBar&&this._ProgressBar.announce]},set:function set(t){_set(_getPrototypeOf(Tile.prototype),"announce",t,this,!0);}},{key:"_update",value:function _update(){_get(_getPrototypeOf(Tile.prototype),"_update",this).call(this),this._updateTileColor(),this._updateContent(),this._updateArtwork(),this._updateBadge(),this._updateLabel(),this._updateCheckbox(),this._updateProgressBar(),this._updateMetadata();}},{key:"h",get:function get(){return this._isInsetMetadata?_get(_getPrototypeOf(Tile.prototype),"h",this):_get(_getPrototypeOf(Tile.prototype),"h",this)+(this._Metadata&&this._Metadata.h||0)},set:function set(t){_set(_getPrototypeOf(Tile.prototype),"h",t,this,!0);}},{key:"innerH",get:function get(){return this._h}},{key:"_gradient",get:function get(){return !this._isCircleLayout&&Boolean(this._isInsetMetadata&&this._hasMetadata&&this._shouldShowMetadata)}},{key:"_isCircleLayout",get:function get(){return Boolean(this._itemLayout&&this._itemLayout.circle)}},{key:"_foregroundDefaultWidth",get:function get(){return parseFloat(this._w/this._h).toFixed(2)===parseFloat(16/9).toFixed(2)?.5*this.innerW:.75*this.innerW}},{key:"_updateTileColor",value:function _updateTileColor(){this._Tile.alpha=this.style.alpha;}},{key:"_updateContent",value:function _updateContent(){var t=this,e={h:this._h,w:this._w,x:this._w/2,y:this._h/2};this.applySmooth(this._Content,e,Object.keys(e).reduce((function(n,i){return n[i]=[e[i],t._isFocusedMode?t.style.animationEntrance:t.style.animationExit],n}),{}));}},{key:"_updateArtwork",value:function _updateArtwork(){var t,e;this._Artwork.patch(_objectSpread(_objectSpread({mode:this.mode,h:this._h,w:this._w,x:this._w/2,y:this._h/2,src:this.src},this.artwork||{}),{},{style:_objectSpread({radius:null===(t=this.style)||void 0===t?void 0:t.radius},null===(e=this.artwork)||void 0===e?void 0:e.style),gradient:this._gradient,shouldScale:this._isFocusedMode}));}},{key:"_getSrc",value:function _getSrc(){return this.artwork&&this.artwork.src||this._src}},{key:"_imageLoaded",value:function _imageLoaded(){this._Background.alpha=0;}},{key:"_updateBadge",value:function _updateBadge(){var t;if(null!==(t=this.badge)&&void 0!==t&&t.title&&!this._isCircleLayout){var e=_objectSpread(_objectSpread({},this.badge),{},{mode:this.mode,x:this.style.paddingX,y:this.style.paddingY,alpha:this._shouldShowBadgeLabel?1:.001});this._Badge?(this._Badge.patch(e),this.applySmooth(this._Badge,e,_objectSpread(_objectSpread({},e),this._badgeLabelTransitions))):this._Content.patch({Badge:_objectSpread(_objectSpread({type:ot},e),{},{signals:{loadedBadge:"_updateBadge"}})});}else this._Badge&&this._Content.patch({Badge:void 0});}},{key:"_updateLabel",value:function _updateLabel(){var t;if(null!==(t=this.label)&&void 0!==t&&t.title&&!this._isCircleLayout){var e=_objectSpread(_objectSpread({},this.label),{},{mode:this.mode,x:this._w-this.style.paddingX,y:this.style.paddingY,alpha:this._shouldShowBadgeLabel?1:.001});this._Label?(this._Label.patch(e),this.applySmooth(this._Label,e,_objectSpread(_objectSpread({},e),{},{x:[e.x,this._shouldShowBadgeLabel?this.style.animationEntrance:this.style.animationExit]},this._badgeLabelTransitions))):this._Content.patch({Label:_objectSpread(_objectSpread({type:Ht,mountX:1},e),{},{signals:{loadedLabel:"_updateLabel"}})});}else this._Label&&this._Content.patch({Label:void 0});}},{key:"_shouldShowBadgeLabel",get:function get(){return this.persistentMetadata||this._isFocusedMode&&!this._isCircleLayout}},{key:"_badgeLabelTransitions",get:function get(){return {y:[this._shouldShowBadgeLabel?this.style.paddingY:0,this._shouldShowBadgeLabel?this.style.animationEntrance:this.style.animationExit],alpha:[this._shouldShowBadgeLabel?1:.001,this._shouldShowBadgeLabel?this.style.animationEntrance:this.style.animationExit]}}},{key:"_updateCheckbox",value:function _updateCheckbox(){var t;if("boolean"==typeof(null===(t=this.checkbox)||void 0===t?void 0:t.checked)&&this.checkbox.checked&&!this._isCircleLayout){var e=_objectSpread(_objectSpread({},this.checkbox),{},{mode:this.mode,x:this._w-this.style.paddingX,y:this._h-this.style.paddingY});this._Checkbox?this.applySmooth(this._Checkbox,e):this._Content.patch({Checkbox:_objectSpread(_objectSpread({},e),{},{type:Et,mount:1})});}else this._Checkbox&&this._Content.patch({Checkbox:void 0});}},{key:"_progressBarY",get:function get(){return (this._ProgressBar&&0!==this._ProgressBar._getTransition("alpha")._targetValue?this._ProgressBar._getTransition("y")._targetValue||this._ProgressBar.y:0)||0}},{key:"_updateProgressBar",value:function _updateProgressBar(){var t,e=this;if("number"==typeof(null===(t=this.progressBar)||void 0===t?void 0:t.progress)&&this.progressBar.progress&&!this._isCircleLayout){if(this.progressBar.progress>0){var n=_objectSpread(_objectSpread({},this.progressBar),{},{mode:this.mode,w:this._w-2*this.style.paddingX,x:this._w/2,y:this._h-this.style.paddingYProgress});if(!this._ProgressBar)return this._Content.patch({ProgressBar:_objectSpread(_objectSpread({},n),{},{type:Yt,mountX:.5,mountY:1,alpha:this._hasMetadata&&this.shouldSmooth?.001:1})}),void(this.shouldSmooth&&(this._ProgressBar.smooth={alpha:[1,{delay:this.style.animationEntrance.duration}]}));this.applySmooth(this._ProgressBar,n,Object.keys(n).reduce((function(t,i){return t[i]=[n[i],e._isFocusedMode?e.style.animationEntrance:e.style.animationExit],t}),{}));}}else this._ProgressBar&&(this.shouldSmooth?(this._ProgressBar._getTransition("alpha").once("finish",(function(){e._removeProgressBar();})),this._ProgressBar.smooth={alpha:0}):this._removeProgressBar());}},{key:"_removeProgressBar",value:function _removeProgressBar(){this._Content.patch({ProgressBar:void 0}),this._updateMetadata();}},{key:"_shouldShowMetadata",get:function get(){return this._hasMetadata&&(this.persistentMetadata&&!this._isInsetMetadata||this._isFocusedMode&&!this._isInsetMetadata||(this.persistentMetadata||this._isFocusedMode)&&this._isInsetMetadata&&!this._isCircleLayout)}},{key:"_isInsetMetadata",get:function get(){return "inset"===this.metadataLocation}},{key:"_metadataTransitions",get:function get(){return {y:[this._shouldShowMetadata?this._metadataY:this._h+this.style.paddingY,this._shouldShowMetadata?this.style.animationEntrance:this.style.animationExit],alpha:[this._metadataAlpha,this._shouldShowMetadata?this.style.animationEntrance:this.style.animationExit]}}},{key:"_hasMetadata",get:function get(){var t=this;return Xt.properties.some((function(e){return t.metadata&&t.metadata[e]}))}},{key:"_metadataY",get:function get(){return this._isInsetMetadata?this._progressBarY?this._progressBarY-this.style.paddingYBetweenContent:this._h-this.style.paddingY:this._h+this.style.paddingY}},{key:"_metadataAlpha",get:function get(){return this._shouldShowMetadata?1:.001}},{key:"_metadataPatch",get:function get(){return _objectSpread({mode:this.mode,alpha:this._metadataAlpha,mountX:.5,mountY:this._isInsetMetadata?1:0,marquee:this._isFocusedMode,w:this._w-2*this.style.paddingX,x:this._w/2,y:!this.persistentMetadata&&this._isInsetMetadata&&this._isFocusedMode?this._h+this.style.paddingY:this._metadataY},this.metadata||{})}},{key:"_getMetadataLocation",value:function _getMetadataLocation(){var t;return null!==(t=this.style.metadataLocation)&&void 0!==t?t:this._metadataLocation}},{key:"_setMetadataLocation",value:function _setMetadataLocation(t){return t&&(this.style={metadataLocation:t}),t}},{key:"_updateMetadata",value:function _updateMetadata(){this._hasMetadata?this._Metadata||!this._hasMetadata?(this._Metadata.patch(this._metadataPatch),this._animateMetadata()):this._Content.patch({Metadata:_objectSpread({type:Xt,signals:{updateComponentDimensions:"_metadataLoaded"}},this._metadataPatch)}):this._Content.patch({Metadata:void 0});}},{key:"_animateMetadata",value:function _animateMetadata(){this._Metadata&&(this.applySmooth(this._Metadata,this._metadataPatch,this._metadataTransitions),this._isFocusedMode||this._resetMarqueeAnimation());}},{key:"_metadataLoaded",value:function _metadataLoaded(){this._animateMetadata(),this._isInsetMetadata||this.fireAncestors("$itemChanged");}},{key:"_resetMarqueeAnimation",value:function _resetMarqueeAnimation(){var t=this,e=this._Metadata._getTransition("alpha");e?e.on("finish",(function(){t._Metadata&&t._Metadata.resetMarquee();})):this._Metadata.resetMarquee();}}],[{key:"__componentName",get:function get(){return "Tile"}},{key:"__themeStyle",get:function get(){return Gt}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Tile),"_template",this).call(this)),{},{Tile:{Artwork:{type:tt,signals:{imageLoaded:"_imageLoaded"},mount:.5},Content:{mount:.5}}})}},{key:"properties",get:function get(){return ["artwork","badge","checkbox","circle","label","metadata","metadataLocation","persistentMetadata","progressBar","src"]}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Tile),"tags",this)),["Artwork","Content","Tile",{name:"Badge",path:"Content.Badge"},{name:"Checkbox",path:"Content.Checkbox"},{name:"Metadata",path:"Content.Metadata"},{name:"ProgressBar",path:"Content.ProgressBar"},{name:"Label",path:"Content.Label"}])}}]),Tile}();var $t=Object.freeze({__proto__:null,base:function base$u(t){return {alpha:t.alpha.primary,counterTextStyle:t.typography.headline3,itemSize:2*t.layout.gutterX,itemSpacing:t.spacer.md,radius:t.radius.sm}},mode:function mode$7(t){return {disabled:{alpha:t.alpha.inactive}}},tone:function tone$d(t){return {neutral:{counterBackgroundColor:t.color.fillInverseSecondary},inverse:{counterBackgroundColor:t.color.fillNeutralSecondary},brand:{counterBackgroundColor:t.color.fillInverseSecondary}}}}),Jt=function(e){_inherits(Provider,G);var n=_createSuper(Provider);function Provider(){return _classCallCheck(this,Provider),n.apply(this,arguments)}return _createClass(Provider,[{key:"providersHidden",get:function get(){return this.providers.length-this._visibleCount}},{key:"_construct",value:function _construct(){this._providers=[],_get(_getPrototypeOf(Provider.prototype),"_construct",this).call(this);}},{key:"_update",value:function _update(){this._updateProviders(),this._updateCounter();}},{key:"_updateProviders",value:function _updateProviders(){var t=this,e=[];this.providers.slice(0,this.visibleCount).forEach((function(n){var i={centerInParent:!0,radius:t.disableRadius?0:t.style.radius,alpha:t.style.alpha,style:n.style||{}};if(n.type===nt&&n.icon&&n.w&&n.h){var o=n.w/n.h;i=_objectSpread(_objectSpread({type:nt,icon:n.icon},n),{},{w:t.style.itemSize*o,h:t.style.itemSize},i);}else i=_objectSpread({type:nt,w:t.style.itemSize,h:t.style.itemSize},i),"object"===_typeof(n)?i=_objectSpread(_objectSpread({},i),n):i.icon=n;e.push(i);})),this._Row.patch({style:{itemSpacing:this.style.itemSpacing},items:e,h:this.style.itemSize});}},{key:"_updateCounter",value:function _updateCounter(){if(this.providers.length>this.visibleCount){var e=this.providersHidden,n={announce:"+".concat(e),alpha:this.style.alpha,w:this.style.itemSize,h:this.style.itemSize,centerInParent:!0,Background:{w:this.style.itemSize,h:this.style.itemSize,texture:t.Tools.getRoundRect(this.style.itemSize,this.style.itemSize,this.style.radius,0,null,!0,this.style.counterBackgroundColor)},Text:{type:St,mountX:.5,mountY:.5,x:this.style.itemSize/2,y:this.style.itemSize/2,content:this.counterText||"+".concat(e),style:{textStyle:this.style.counterTextStyle}}};this._Row.appendItems([n]);}}},{key:"$itemChanged",value:function $itemChanged(){this.signal("providerChanged");}},{key:"_getVisibleCount",value:function _getVisibleCount(){var t=this.providers.length,e=Math.min(Math.max(1,this._visibleCount),t);return this._visibleCount<1&&console.warn("Warning: The specified visible count (".concat(this._visibleCount,") is less than the minimum value (").concat(1,"). Setting it to ").concat(1,".")),this._visibleCount>t&&console.warn("Warning: The specified visible count (".concat(this._visibleCount,") is greater than the maximum value (").concat(t,"). Setting it to ").concat(t,".")),e}},{key:"w",get:function get(){return this._Row.w}},{key:"announce",get:function get(){return this._announce||this._Row.items&&this._Row.items.length&&this._Row.items.map((function(t){return t.announce}))},set:function set(t){_set(_getPrototypeOf(Provider.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Provider"}},{key:"__themeStyle",get:function get(){return $t}},{key:"_template",value:function _template(){return {Row:{type:ht,autoResizeWidth:!0}}}},{key:"properties",get:function get(){return ["disableRadius","counterText","providers","visibleCount"]}},{key:"tags",get:function get(){return ["Row"]}}]),Provider}(),Zt=Object.freeze({__proto__:null,base:function base$t(t){return {detailsTextStyle:t.typography.body3,descriptionTextStyle:{maxLines:3},fadeWidth:t.spacer.md*t.spacer.md,provider:{itemSize:t.spacer.xxxl+t.spacer.md}}},tone:function tone$c(t){return {neutral:{detailsTextStyle:{textColor:t.color.textNeutral},mode:{disabled:{detailsTextStyle:{textColor:t.color.textNeutralDisabled}}}},inverse:{detailsTextStyle:{textColor:t.color.textInverse},mode:{disabled:{detailsTextStyle:{textColor:t.color.textNeutralDisabled}}}},brand:{detailsTextStyle:{textColor:t.color.textNeutral},mode:{disabled:{detailsTextStyle:{textColor:t.color.textNeutralDisabled}}}}}}}),te=function(t){_inherits(MetadataCardContent,Kt);var e,n=_createSuper(MetadataCardContent);function MetadataCardContent(){return _classCallCheck(this,MetadataCardContent),n.apply(this,arguments)}return _createClass(MetadataCardContent,[{key:"_setDetails",value:function _setDetails(t){var e=this;return this._detailsPromise=t?new Promise((function(t){e._detailsPromiseResolver=t;})):void 0,t}},{key:"_setProvider",value:function _setProvider(t){var e=this;return this._providerPromise=t?new Promise((function(t){e._providerPromiseResolver=t;})):void 0,t}},{key:"_update",value:(e=_asyncToGenerator(_regeneratorRuntime().mark((function _callee13(){return _regeneratorRuntime().wrap((function _callee13$(t){for(;;)switch(t.prev=t.next){case 0:return this._updateLines(),this._updateProvider(),t.next=4,Promise.all([this._detailsPromise,this._providerPromise].filter(Boolean));case 4:this._updatePositions();case 5:case"end":return t.stop()}}),_callee13,this)}))),function _update(){return e.apply(this,arguments)})},{key:"_updateLines",value:function _updateLines(){this._Text.w=this.w,this._updateTitle(),this._updateDescription(),this._updateDetails();}},{key:"_updateDescription",value:function _updateDescription(){this._Description.patch({content:this.description,style:{textStyle:_objectSpread(_objectSpread({},this.style.descriptionTextStyle),{},{wordWrap:!0,wordWrapWidth:this._Text.w})}});}},{key:"_updateDetails",value:function _updateDetails(){var t=this._detailsMaxW;this._Details.patch({content:this.details,style:{textStyle:_objectSpread(_objectSpread({},this.style.detailsTextStyle),{},{wordWrap:!0,maxLines:1,wordWrapWidth:t+this.style.fadeWidth/2})}}),this._Details.finalW>t?this._DetailsFader.patch({w:t+this.style.fadeWidth/2,shader:{type:xt,positionLeft:0,positionRight:this.style.fadeWidth}}):this._DetailsFader.shader=void 0;}},{key:"_resolveDetails",value:function _resolveDetails(){this._detailsPromiseResolver&&this._detailsPromiseResolver(),this._updatePositions();}},{key:"_updateProvider",value:function _updateProvider(){this.provider&&this._Provider.patch(_objectSpread(_objectSpread({mode:this.mode},this.provider),{},{style:this.style.provider}));}},{key:"_resolveProvider",value:function _resolveProvider(){this._providerPromiseResolver&&this._providerPromiseResolver(),this._updatePositions();}},{key:"_updatePositions",value:function _updatePositions(){this._Text.h=this._textH,this._Text.w=this._textW,this._DetailsWrapper.w=this._textW,this._DetailsWrapper.h=Math.max(this._providerH,this._Details.h),this._DetailsWrapper.y=this.h-this._DetailsWrapper.h,this._Details.y=this._DetailsWrapper.h/2,this._Provider.x=this._DetailsWrapper.w-this._providerW,this._Provider.y=this._DetailsWrapper.h-this._providerH;}},{key:"_textW",get:function get(){return this.w}},{key:"_textH",get:function get(){return this.h-this._providerH}},{key:"_providerW",get:function get(){return this._Provider.w}},{key:"_providerH",get:function get(){return this._Provider._Row._Items.h}},{key:"_detailsMaxW",get:function get(){return this.w-this._providerW-this.style.fadeWidth/2}},{key:"announce",get:function get(){return this._announce||[this._Title&&this._Title.announce,this._Description&&this._Description.announce,this._Details&&this._Details.announce,this._Provider&&this._Provider.announce]},set:function set(t){_set(_getPrototypeOf(MetadataCardContent.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "MetadataCardContent"}},{key:"__themeStyle",get:function get(){return Zt}},{key:"_template",value:function _template(){return {Text:{flex:{direction:"column",justifyContent:"flex-start"},Title:{type:St},Description:{type:St}},DetailsWrapper:{DetailsFader:{Details:{mountY:.5,type:St,signals:{textBoxChanged:"_resolveDetails"}}},Provider:{mount:1,type:Jt,signals:{providerChanged:"_resolveProvider"}}}}}},{key:"properties",get:function get(){return ["description","details","provider","title"]}},{key:"tags",get:function get(){return ["Text",{name:"Title",path:"Text.Title"},{name:"Description",path:"Text.Description"},"DetailsWrapper",{name:"DetailsFader",path:"DetailsWrapper.DetailsFader"},{name:"Details",path:"DetailsWrapper.DetailsFader.Details"},{name:"Provider",path:"DetailsWrapper.Provider"}]}}]),MetadataCardContent}(),ee=Object.freeze({__proto__:null,base:function base$s(t){return {expandedWidth:l.getWidthByUpCount(t,2),expandedHeight:l.getDimensions(t,{ratioX:16,ratioY:9,upCount:4}).h,imageSize:{width:l.getDimensions(t,{ratioX:16,ratioY:9,upCount:4}).w,height:l.getDimensions(t,{ratioX:16,ratioY:9,upCount:4}).h},metadata:{descriptionTextStyle:{maxLines:2}},paddingVertical:1.5*t.spacer.md}}}),ne=function(t){_inherits(CardContent,At);var e=_createSuper(CardContent);function CardContent(){return _classCallCheck(this,CardContent),e.apply(this,arguments)}return _createClass(CardContent,[{key:"_update",value:function _update(){this._updateSize(),this._updateTile(),this._updateRadius(),this._updateMetadata(),_get(_getPrototypeOf(CardContent.prototype),"_update",this).call(this);}},{key:"_updateTitle",value:function _updateTitle(){}},{key:"_updateTitlePosition",value:function _updateTitlePosition(){}},{key:"_updateTile",value:function _updateTile(){var t=this.style.imageSize.w,e=this.style.expandedHeight;"horizontal"!==this._orientation&&(t=this.style.expandedWidth,e=this.style.imageSize.h);var n=this.tile;this.src&&(n=l.clone({src:this.src},this.tile)),this._Tile.patch(_objectSpread(_objectSpread({w:t,h:e},n),{},{persistentMetadata:!0,alpha:this._shouldShowTile?1:0}));}},{key:"_updateMetadata",value:function _updateMetadata(){var t=_objectSpread(_objectSpread(_objectSpread(_objectSpread({},this.metadata),this._metadataPosition),this._metadataDimensions),{},{mode:this.mode,alpha:this._shouldShowMetadata?1:0,style:this.style.metadata});this._Metadata||(t.type=te),this.patch({Metadata:t});}},{key:"_updateSize",value:function _updateSize(){var t=this.style.expandedWidth,e=this.style.expandedHeight;this._collapse&&("horizontal"===this._orientation?t=this._collapseW:e=this._collapseH),this.w=t,this.h=e;}},{key:"_updateRadius",value:function _updateRadius(){var t=Array.isArray(this.style.radius)&&4===this.style.radius.length?this.style.radius:Array(4).fill(this.style.radius),e=t;this._collapse||(e="horizontal"===this._orientation?[t[0],0,0,t[3]]:[t[0],t[1],0,0]),this._Tile.patch({style:{radius:e}});}},{key:"_getSrc",value:function _getSrc(){return this.tile&&(this.tile.artwork&&this.tile.artwork.src||this.tile.src)||this._src}},{key:"_metadataDimensions",get:function get(){var t=2*this.style.paddingHorizontal,e=2*this.style.paddingVertical,n=this.style.expandedWidth-this.style.imageSize.w-t,i=this.style.expandedHeight-e;return "horizontal"!==this.orientation&&(n=this.style.expandedWidth-t,i=this.style.expandedHeight-this.style.imageSize.h-e),{w:n,h:i}}},{key:"_metadataPosition",get:function get(){var t=this.style.paddingHorizontal,e=this.style.paddingVertical,n=t+(this._collapse?0:this.style.imageSize.w),i=e;return "horizontal"!==this.orientation&&(n=t,i=e+(this._collapse?0:this.style.imageSize.h)),{x:n,y:i}}},{key:"_shouldShowMetadata",get:function get(){return !this._collapse||this.collapseToMetadata}},{key:"_shouldShowTile",get:function get(){return !this._collapse||this._collapse&&!this.collapseToMetadata}},{key:"_collapse",get:function get(){return this.shouldCollapse&&!this._isFocusedMode}},{key:"_collapseW",get:function get(){return this.collapseToMetadata?this.style.expandedWidth-this.style.imageSize.w:this.style.imageSize.w}},{key:"_collapseH",get:function get(){return this.collapseToMetadata?this.style.expandedHeight-this.style.imageSize.h:this.style.imageSize.h}},{key:"announce",get:function get(){return this._announce||[this._Metadata&&this._Metadata.announce,this._Tile&&this._Tile.announce]},set:function set(t){_set(_getPrototypeOf(CardContent.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "CardContent"}},{key:"__themeStyle",get:function get(){return ee}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(CardContent),"_template",this).call(this)),{},{Tile:{type:Qt}})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardContent),"properties",this)),["tile","metadata","orientation","collapseToMetadata","shouldCollapse","src"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(CardContent),"tags",this)),["Metadata","Tile"])}},{key:"aliasStyles",get:function get(){return [{prev:"expandedW",curr:"expandedWidth"},{prev:"expandedH",curr:"expandedHeight"}]}}]),CardContent}(),ie=function(t){_inherits(CardContentHorizontal,ne);var e=_createSuper(CardContentHorizontal);function CardContentHorizontal(){return _classCallCheck(this,CardContentHorizontal),e.apply(this,arguments)}return _createClass(CardContentHorizontal,[{key:"_init",value:function _init(){this._orientation="horizontal",_get(_getPrototypeOf(CardContentHorizontal.prototype),"_init",this).call(this);}}],[{key:"__componentName",get:function get(){return "CardContentHorizontal"}},{key:"__themeStyle",get:function get(){return ee}}]),CardContentHorizontal}(),oe=Object.freeze({__proto__:null,base:function base$r(t){var e=l.getDimensions(t,{ratioX:16,ratioY:9,upCount:3}),n=e.w,i=e.h;return {expandedWidth:l.getWidthByColumnSpan(t,8),expandedHeight:i,imageSize:{width:n,height:i},metadata:{descriptionTextStyle:{maxLines:3}}}}});(function(t){_inherits(CardContentHorizontalLarge,ie);var e=_createSuper(CardContentHorizontalLarge);function CardContentHorizontalLarge(){return _classCallCheck(this,CardContentHorizontalLarge),e.apply(this,arguments)}return _createClass(CardContentHorizontalLarge,null,[{key:"__componentName",get:function get(){return "CardContentHorizontalLarge"}},{key:"__themeStyle",get:function get(){return oe}}]),CardContentHorizontalLarge})();var ae=Object.freeze({__proto__:null,base:function base$q(t){return {expandedWidth:l.getWidthByUpCount(t,4),expandedHeight:l.getDimensions(t,{ratioX:16,ratioY:9,upCount:4}).h+7*t.spacer.xxxl+t.spacer.lg+t.spacer.xxs,metadata:{descriptionTextStyle:{maxLines:3}}}}}),se=function(t){_inherits(CardContentVertical,ne);var e=_createSuper(CardContentVertical);function CardContentVertical(){return _classCallCheck(this,CardContentVertical),e.apply(this,arguments)}return _createClass(CardContentVertical,[{key:"_init",value:function _init(){this._orientation="vertical",_get(_getPrototypeOf(CardContentVertical.prototype),"_init",this).call(this);}}],[{key:"__componentName",get:function get(){return "CardContentVertical"}},{key:"__themeStyle",get:function get(){return ae}}]),CardContentVertical}(),le=Object.freeze({__proto__:null,base:function base$p(t){return {expandedHeight:l.getDimensions(t,{ratioX:16,ratioY:9,upCount:4}).h+14*t.spacer.md,metadata:{descriptionTextStyle:{maxLines:1}}}}});(function(t){_inherits(CardContentVerticalSmall,se);var e=_createSuper(CardContentVerticalSmall);function CardContentVerticalSmall(){return _classCallCheck(this,CardContentVerticalSmall),e.apply(this,arguments)}return _createClass(CardContentVerticalSmall,[{key:"_setMetadata",value:function _setMetadata(t){return _objectSpread(_objectSpread({},t),{},{details:void 0,provider:void 0})}}],[{key:"__componentName",get:function get(){return "CardContentVerticalSmall"}},{key:"__themeStyle",get:function get(){return le}}]),CardContentVerticalSmall})();var ue=Object.freeze({__proto__:null,base:function base$o(t){var e=t.stroke.sm,n=t.spacer.xl-2*e;return {width:n,height:n,checkWidth:t.spacer.md,checkHeight:t.spacer.md+t.spacer.xxs,radius:n/2,strokeWidth:e}}});(function(t){_inherits(CheckboxSmall,Et);var e=_createSuper(CheckboxSmall);function CheckboxSmall(){return _classCallCheck(this,CheckboxSmall),e.apply(this,arguments)}return _createClass(CheckboxSmall,null,[{key:"__themeStyle",get:function get(){return ue}}]),CheckboxSmall})();var de=Object.freeze({__proto__:null,base:function base$n(t){return {itemSpacing:t.layout.gutterY,scrollIndex:0,itemTransition:_objectSpread(_objectSpread({},t.animation.standardEntrance),{},{duration:t.animation.duration.fast})}}}),pe=function(t){_inherits(Column,ct);var e=_createSuper(Column);function Column(){return _classCallCheck(this,Column),e.apply(this,arguments)}return _createClass(Column,[{key:"_shouldScroll",value:function _shouldScroll(){var t=this.alwaysScroll;t||this.neverScroll||(t=this.Items.childList.last&&(this.shouldScrollUp()||this.shouldScrollDown()));return this.selectedIndex<this.scrollIndex&&(t=!1),t}},{key:"_render",value:function _render(t,e){if(this._prevLastScrollIndex=this._lastScrollIndex,this.plinko&&e&&e.selected&&(0!==this.items.indexOf(e)||!e.skipPlinko)){var n=this.checkSkipPlinko(e,t);t.selectedIndex=this._getIndexOfItemNear(t,n||e);}else t&&!t.selectedIndex&&(t.selectedIndex=0);if(this.Items.children.length){if(this._shouldScroll()){var i=this.selectedIndex>this._lastScrollIndex?this.Items.children[this._lastScrollIndex-this.scrollIndex]:this.selected;this.Items.children[this._firstFocusableIndex()]===i&&(i=this.Items.children[0]);var o=(this.Items.children[this.scrollIndex]||{y:0}).y,r=[-(i||this.Items.childList.first).transition("y").targetValue+(i===this.selected?o:0),this.style.itemTransition],a=-i.y+(i===this.selected?o:0);this.applySmooth(this.Items,{y:a},{y:r}),this.shouldSmooth||this._updateTransitionTarget(this.Items,"y",a);}}else this.applySmooth(this.Items,{y:this.itemPosY}),this.shouldSmooth||this._updateTransitionTarget(this.Items,"y",this.itemPosY);this.onScreenEffect(this.onScreenItems);}},{key:"_performRender",value:function _performRender(){this._render(this.selected,this.prevSelected);}},{key:"checkSkipPlinko",value:function checkSkipPlinko(t,e){var n=this;if(!t||!t.skipPlinko||[0,this.items.length-1].includes(this.items.indexOf(t)))return null;var i=this.items.indexOf(t),o=i-this.items.indexOf(e),r=(o>0?this.items.slice(i).map((function(t){return {skipPlinko:t.skipPlinko,index:n.items.indexOf(t)}})):this.items.slice(0,i+1).map((function(t){return {skipPlinko:t.skipPlinko,index:n.items.indexOf(t)}})).reverse()).find((function(t){return t.skipPlinko&&!n.items[t.index+o].skipPlinko})),a=r?r.index+o:i+o;return this.items[a]}},{key:"_itemsY",get:function get(){return r(this.Items)}},{key:"$removeItem",value:function $removeItem(t){if(t){var e=t===this.selected;this.Items.childList.remove(t),this.queueRequestUpdate(),(e||this.selectedIndex>=this.items.length)&&(this.selectedIndex=this._selectedIndex),this.items.length||this.fireAncestors("$columnEmpty");}}},{key:"$columnChanged",value:function $columnChanged(){this.queueRequestUpdate();}},{key:"_isOnScreen",value:function _isOnScreen(t){return !!t&&this._isComponentVerticallyVisible(t)}},{key:"onScreenEffect",value:function onScreenEffect(){}}],[{key:"__componentName",get:function get(){return "Column"}},{key:"__themeStyle",get:function get(){return de}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Column),"_template",this).call(this)),{},{direction:"column"})}}]),Column}(),_e=function base$m(t){var e=t.spacer.lg,n=t.radius.xl,i=Math.max(n-e/2,0);return {height:8*t.spacer.md,iconStyle:{radius:n,width:t.spacer.xxxl,height:t.spacer.xxxl},logoStyle:{radius:i,width:7*t.spacer.md,height:6*t.spacer.md},minWidth:9*t.spacer.md,paddingX:e,paddingXNoTitle:t.spacer.md,prefixPadding:t.spacer.md,radius:n,titlePadding:t.spacer.md}},ye=Object.freeze({__proto__:null,base:_e}),fe=function(t){_inherits(Control,Tt);var e=_createSuper(Control);function Control(){return _classCallCheck(this,Control),e.apply(this,arguments)}return _createClass(Control,[{key:"_update",value:function _update(){this._updatePrefixStyle(),_get(_getPrototypeOf(Control.prototype),"_update",this).call(this),this._updateCollapseStatus();}},{key:"_updateCollapseStatus",value:function _updateCollapseStatus(){this._Title&&(this._Title.visible=!this._collapse);}},{key:"_updatePrefixStyle",value:function _updatePrefixStyle(){this._prefix&&(this.logo?this._updatePrefixObj(this.logo,{style:_objectSpread({color:void 0},this.style.logoStyle)}):this.icon&&this._updatePrefixObj(this.icon,{style:this.style.iconStyle}));}},{key:"_patchTitle",value:function _patchTitle(t,e){this._Title.patch({x:t,mountX:e});}},{key:"_updateContentPosition",value:function _updateContentPosition(){if(this._prefix&&this._Title)switch(this._Content.patch({mountX:0,x:this._paddingLeft}),this._justify){case"left":this._patchTitle(0,0);break;case"right":if(this.w<this._Prefix.w+this._Title.w)this._patchTitle(0,0);else {var t=this.w-(this._paddingLeft+this._paddingRight+this._Prefix.w+this.style.titlePadding);this._patchTitle(t,1);}break;default:if(this.fixed)if(this.w<this._Prefix.w+this._Title.w)this._patchTitle(0,0);else {var e=(this.w-(this._paddingLeft+this._Prefix.w+this._paddingRight))/2;this._patchTitle(e,.5);}else {var n=(this.w-(this._paddingLeft+this._Prefix.w+this.style.titlePadding+this._paddingRight))/2;this._patchTitle(n,.5);}}else _get(_getPrototypeOf(Control.prototype),"_updateContentPosition",this).call(this),this._Title&&this._patchTitle(0,0);}},{key:"_setPrefix",value:function _setPrefix(){}},{key:"_setSuffix",value:function _setSuffix(){}},{key:"_updatePrefixObj",value:function _updatePrefixObj(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._prefix=_objectSpread({type:nt,icon:t},e);}},{key:"_setIcon",value:function _setIcon(t){return this.logo||(t?this._updatePrefixObj(t,{style:this.style.iconStyle}):this._prefix=t),t}},{key:"_setLogo",value:function _setLogo(t){return t?this._updatePrefixObj(t,{style:_objectSpread({color:void 0},this.style.logoStyle)}):this.icon?this._updatePrefixObj(this.icon,{style:this.style.iconStyle}):this._prefix=t,t}},{key:"_paddingLeft",get:function get(){return this.logo?this.style.paddingXNoTitle:this.style.paddingX}},{key:"_paddingRight",get:function get(){return !this.logo||this._hasTitle&&!this._collapse?this.style.paddingX:this.style.paddingXNoTitle}},{key:"_collapse",get:function get(){return this.shouldCollapse&&!this._isFocusedMode}},{key:"_announceComponentName",get:function get(){return Control.__componentName}}],[{key:"__componentName",get:function get(){return "Control"}},{key:"__themeStyle",get:function get(){return ye}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Control),"properties",this)),["icon","logo","shouldCollapse"])}}]),Control}(),ge=Object.freeze({__proto__:null,base:function base$l(t){var e=_e(t),n=7*t.spacer.md,i=(e.height-n)/2,o=Math.max(e.radius-i,0);return {height:n,logoStyle:{radius:Math.max(o-e.paddingX/2,0),height:5*t.spacer.md,width:6*t.spacer.md},radius:o,minWidth:8*t.spacer.md,textStyle:t.typography.button2}}});(function(t){_inherits(ControlSmall,fe);var e=_createSuper(ControlSmall);function ControlSmall(){return _classCallCheck(this,ControlSmall),e.apply(this,arguments)}return _createClass(ControlSmall,null,[{key:"__componentName",get:function get(){return "ControlSmall"}},{key:"__themeStyle",get:function get(){return ge}}]),ControlSmall})();var ve=Object.freeze({__proto__:null,base:function base$k(t){return {width:getWidthByUpCount(t,1),titleMarginLeft:t.layout.gutterX,titleTextStyle:_objectSpread(_objectSpread({},t.typography.headline1),{},{textColor:t.color.textNeutral}),rowMarginTop:t.spacer.lg}},tone:function tone$b(t){return {neutral:{titleTextStyle:{textColor:t.color.textNeutral}},inverse:{titleTextStyle:{textColor:t.color.textInverse}},brand:{titleTextStyle:{textColor:t.color.textNeutral}}}}}),xe=function(t){_inherits(TitleRow,ht);var e=_createSuper(TitleRow);function TitleRow(){return _classCallCheck(this,TitleRow),e.apply(this,arguments)}return _createClass(TitleRow,[{key:"_titleLoaded",value:function _titleLoaded(){this._updateRow();}},{key:"_update",value:function _update(){_get(_getPrototypeOf(TitleRow.prototype),"_update",this).call(this),this._updateTitle(),this._updateRow();}},{key:"_updateTitle",value:function _updateTitle(){this.title?this._Title.patch({x:this.style.titleMarginLeft,content:this.title,style:{textStyle:this.style.titleTextStyle}}):this._Title&&this._Title.patch({h:0,content:""});}},{key:"_updateRow",value:function _updateRow(){this.Items.patch({y:this._Title.finalH+this.style.rowMarginTop}),this.patch({w:this.w||this.style.w,h:this.Items.y+this.Items.h});}},{key:"announce",get:function get(){return this._announce||this._Title&&this._Title.announce},set:function set(t){_set(_getPrototypeOf(TitleRow.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "TitleRow"}},{key:"__themeStyle",get:function get(){return ve}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({Title:{type:St,signals:{textBoxChanged:"_titleLoaded"}}},_get(_getPrototypeOf(TitleRow),"_template",this).call(this)),{},{autoResizeHeight:!1})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(TitleRow),"properties",this)),["title"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(TitleRow),"tags",this)),["Title"])}}]),TitleRow}(),be=Object.freeze({__proto__:null,base:function base$j(t){return {extraItemSpacing:t.spacer.lg}}});(function(t){_inherits(ControlRow,xe);var e=_createSuper(ControlRow);function ControlRow(){return _classCallCheck(this,ControlRow),e.apply(this,arguments)}return _createClass(ControlRow,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(ControlRow.prototype),"_construct",this).call(this),this._leftControls=[],this._contentItems=[],this._rightControls=[],this._lastLeftControlIndex=-1,this._lastItemIndex=-1,this._lazyLoadBuffer=0;}},{key:"_updateContent",value:function _updateContent(){var t=[];this.leftControls.length&&t.push.apply(t,_toConsumableArray(this._withExtraSpacing(this.leftControls,!0))),this.contentItems.length&&t.push.apply(t,_toConsumableArray(this._withExtraSpacing(this.contentItems))),this.rightControls.length&&t.push.apply(t,_toConsumableArray(this.rightControls)),t.length&&this.patch({alpha:1,items:t,selectedIndex:this.leftControls.length,startLazyScrollIndex:this.leftControls.length,stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}},{key:"_withExtraSpacing",value:function _withExtraSpacing(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=_toConsumableArray(t),i=e?this._prevLeftControls:this._prevItems;return i&&i.length&&n[i.length-1]&&(n[i.length-1].extraItemSpacing=0),n[n.length-1].extraItemSpacing=null==this.extraItemSpacing?this.style.extraItemSpacing:this.extraItemSpacing,e?this._prevLeftControls=n:this._prevItems=n,n}},{key:"_getMoreItems",value:function _getMoreItems(){if(this.lazyLoadBuffer){var t=this.contentItems.length-1-this.lazyLoadBuffer;this.selectedIndex-this.leftControls.length>=t&&this.selectedIndex<this.leftControls.length+this.contentItems.length&&this.loadMoreItems();}}},{key:"loadMoreItems",value:function loadMoreItems(){this.signal("loadMoreItems");}},{key:"_selectedChange",value:function _selectedChange(t,e){_get(_getPrototypeOf(ControlRow.prototype),"_selectedChange",this).call(this,t,e),this._getMoreItems();}},{key:"_appendItemsAt",value:function _appendItemsAt(t,e,n){var i=_toConsumableArray(t);null!=n&&(this.items[n].extraItemSpacing=void 0,i[i.length-1].extraItemSpacing=null==this.extraItemSpacing?this.style.extraItemSpacing:this.extraItemSpacing),this.appendItemsAt(i,e);}},{key:"addContentItems",value:function addContentItems(t){var e=this._createContentItems(t),n=this._lastItemIndex+1;this._appendItemsAt(e,n,this._lastItemIndex),this._lastItemIndex+=e.length,this._contentItems&&(this._contentItems=[].concat(_toConsumableArray(this.contentItems),_toConsumableArray(e))),this.patch({stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}},{key:"addContentItemsAt",value:function addContentItemsAt(t,e){var n=this._createContentItems(t),i=this._lastLeftControlIndex+1+e;if(i===this._lastItemIndex+1)this.addContentItems(n);else {var o;if(this._appendItemsAt(n,i),this._contentItems)(o=this._contentItems).splice.apply(o,[i,0].concat(_toConsumableArray(n))),this._lastItemIndex=this.contentItems.length-1;this.patch({stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}}},{key:"removeContentItemAt",value:function removeContentItemAt(t){var e=this._lastLeftControlIndex+1+t;this.removeItemAt(e),this._lastItemIndex--,this._contentItems&&this._contentItems.splice(t,1),this.patch({startLazyScrollIndex:this.leftControls.length,stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}},{key:"addLeftControls",value:function addLeftControls(t){var e=this._createControls(t),n=this._lastLeftControlIndex+1;this._appendItemsAt(e,n,this._lastLeftControlIndex),this._leftControls&&(this._leftControls=[].concat(_toConsumableArray(this._leftControls),_toConsumableArray(t)),this._lastLeftControlIndex=this._leftControls.length-1,this._lastItemIndex+=t.length),this.patch({startLazyScrollIndex:this.leftControls.length,stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}},{key:"addLeftControlsAt",value:function addLeftControlsAt(t,e){var n=this._createControls(t);if(e===this._lastLeftControlIndex+1)this.addLeftControls(t);else {var i;if(this._appendItemsAt(n,e),this.leftControls)(i=this._leftControls).splice.apply(i,[e,0].concat(_toConsumableArray(t))),this._lastLeftControlIndex=this._leftControls.length-1,this._lastItemIndex+=t.length;this.patch({startLazyScrollIndex:this.leftControls.length,stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}}},{key:"removeLeftControlAt",value:function removeLeftControlAt(t){this.removeItemAt(t),this._lastLeftControlIndex--,this._lastItemIndex--,this.leftControls&&this._leftControls.splice(t,1),this.patch({startLazyScrollIndex:this.leftControls.length,stopLazyScrollIndex:this.leftControls.length+this.contentItems.length-1});}},{key:"addRightControls",value:function addRightControls(t){var e;(e=this._rightControls).push.apply(e,_toConsumableArray(t)),this._appendItemsAt(this._createControls(t),this.items.length);}},{key:"addRightControlsAt",value:function addRightControlsAt(t,e){var n,i=this._leftControls.length+this._contentItems.length+e;(n=this._rightControls).splice.apply(n,[e,0].concat(_toConsumableArray(t))),this._appendItemsAt(this._createControls(t),i);}},{key:"removeRightControlAt",value:function removeRightControlAt(t){var e=this.leftControls.length+this.contentItems.length+t;this.removeItemAt(e),this.rightControls&&this._rightControls.splice(t,1);}},{key:"_createControls",value:function _createControls(t){return t.map((function(t){return _objectSpread({backgroundType:"fill",centerInParent:!0},t)}))}},{key:"_createContentItems",value:function _createContentItems(t){return t.map((function(t){return _objectSpread(_objectSpread({},t),{},{centerInParent:!0})}))}},{key:"_setLeftControls",value:function _setLeftControls(t){this._leftControls=this._createControls(t),this._lastLeftControlIndex=t.length-1,this._updateContent();}},{key:"_getLeftControls",value:function _getLeftControls(){return this._leftControls}},{key:"_setRightControls",value:function _setRightControls(t){this._rightControls=this._createControls(t),this._updateContent();}},{key:"_getRightControls",value:function _getRightControls(){return this._rightControls}},{key:"_getContentItems",value:function _getContentItems(){return this._contentItems}},{key:"_setContentItems",value:function _setContentItems(t){this._contentItems=this._createContentItems(t),this._lastItemIndex=this._lastLeftControlIndex+t.length,this._updateContent();}},{key:"_getLeftControlItems",value:function _getLeftControlItems(){return this.leftControls.length?this.items.slice(0,this._lastLeftControlIndex+1):[]}},{key:"_getContentItemItems",value:function _getContentItemItems(){return this.contentItems.length?this.items.slice(this._lastLeftControlIndex+1,this._lastItemIndex+1):[]}},{key:"_getRightControlItems",value:function _getRightControlItems(){if(this.rightControls.length){var t=this._lastItemIndex||this._lastLeftControlIndex;return t?this.items.slice(t+1):this.items}return []}},{key:"leftControls",get:function get(){return this._getLeftControls()},set:function set(t){this._setLeftControls(t);}},{key:"rightControls",get:function get(){return this._getRightControls()},set:function set(t){this._setRightControls(t);}},{key:"contentItems",get:function get(){return this._getContentItems()},set:function set(t){this._setContentItems(t);}},{key:"lazyLoadBuffer",get:function get(){return this._lazyLoadBuffer},set:function set(t){this._lazyLoadBuffer=t,this._getMoreItems();}}],[{key:"__componentName",get:function get(){return "ControlRow"}},{key:"__themeStyles",get:function get(){return be}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(ControlRow),"_template",this).call(this)),{},{alpha:0,lazyScroll:!0,signals:{selectedChange:"_getMoreItems"}})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ControlRow),"properties",this)),["extraItemSpacing"])}}]),ControlRow})();var Se=Object.freeze({__proto__:null,base:function base$i(t){return {propertyTextStyle:_objectSpread(_objectSpread({},t.typography.headline1),{},{textColor:t.color.textNeutral}),valueTextStyle:_objectSpread(_objectSpread({},t.typography.body1),{},{textColor:t.color.textNeutral})}}}),Ce=function(t){_inherits(Spacer,G);var e=_createSuper(Spacer);function Spacer(){return _classCallCheck(this,Spacer),e.apply(this,arguments)}return _createClass(Spacer,[{key:"_update",value:function _update(){this._Line.w=this.w,this._TickRight.x=this._Line.w,this.lineColor&&(this._Line.color=this._TickLeft.color=this._TickRight.color=this.lineColor),this.rotation=this.vertical?Math.PI/2:0,this.signal("spacerLoaded");}}],[{key:"__componentName",get:function get(){return "Spacer"}},{key:"_template",value:function _template(){return {Line:{h:Spacer._lineThickness,rect:!0,mountY:.5,TickLeft:_objectSpread(_objectSpread({},Spacer._tick),{},{x:-1*Spacer._lineThickness}),TickRight:Spacer._tick}}}},{key:"properties",get:function get(){return ["lineColor"]}},{key:"tags",get:function get(){return ["Line","TickLeft","TickRight"]}},{key:"_lineThickness",get:function get(){return 3}},{key:"_tickLength",get:function get(){return 25}},{key:"_tick",get:function get(){return {rect:!0,mountY:.5,w:Spacer._lineThickness,h:Spacer._tickLength,y:Spacer._lineThickness/2}}}]),Spacer}();(function(t){_inherits(GridOverlay,G);var e=_createSuper(GridOverlay);function GridOverlay(){return _classCallCheck(this,GridOverlay),e.apply(this,arguments)}return _createClass(GridOverlay,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(GridOverlay.prototype),"_construct",this).call(this),this._showColumns=this._showMargins=this._showSafe=this._showGutters=this._showText=!0;}},{key:"_update",value:function _update(){this._updateGlobalThemeProps(),this._updateMargins(),this._updateSafe(),this._updateColumns(),this._updateGutters(),this._updateText(),this._updateVisibility();}},{key:"_updateVisibility",value:function _updateVisibility(){this._Columns.smooth={alpha:Number(this.showColumns)},this._Margins.smooth={alpha:Number(this.showMargins)},this._Safe.smooth={alpha:Number(this.showSafe)},this._Gutters.smooth={alpha:Number(this.showGutters)},this._TextPanel.smooth={alpha:Number(this.showText)};}},{key:"_updateGlobalThemeProps",value:function _updateGlobalThemeProps(){var t=k$1.theme,e=t.layout,n=t.color,i=e.screenW,o=e.screenH,r=e.columnCount,a=e.marginX,s=e.marginY,l=e.gutterX,c=e.gutterY,u=e.safe;this._screenW=i,this._screenH=o,this._columnCount=r,this._marginX=a,this._marginY=s,this._safe=u,this._gutterX=l,this._gutterY=c,this._columnColor=n.interactiveNeutralFocusSoft,this._marginColor=n.green,this._safeColor=n.red,this._gutterColor=n.blue;}},{key:"_updateMargins",value:function _updateMargins(){var t={lineColor:this._marginColor},e=_objectSpread(_objectSpread({},t),{},{w:this._marginX});this._MarginHorizontal.y=this._screenH/2,this._MarginLeft.patch(e),this._MarginRight.patch(e),this._MarginRight.x=this._screenW-this._marginX;var n=_objectSpread(_objectSpread({},t),{},{w:this._marginY});this._MarginVertical.x=this._marginX-n.w/2,this._MarginTop.patch(n),this._MarginTop.patch(n),this._MarginTop.y=n.w/2;}},{key:"_updateSafe",value:function _updateSafe(){var t={lineColor:this._safeColor,w:this._safe};this._SafeHorizontal.y=this._screenH/4,this._SafeLeft.patch(t),this._SafeRight.patch(t),this._SafeRight.x=this._screenW-this._safe,this._SafeVertical.x=(this._screenW-t.w)/2,this._SafeVertical.y=t.w/2,this._SafeTop.patch(t),this._SafeBottom.patch(t),this._SafeBottom.y=this._screenH-this._safe;}},{key:"_updateColumns",value:function _updateColumns(){this._Columns.patch({w:this._screenW,h:this._screenH,x:this._marginX,style:{itemSpacing:this._gutterX},items:this._columnRects});}},{key:"_columnRects",get:function get(){var t=this;return Array.apply(null,{length:this._columnCount}).map((function(){return {rect:!0,w:getWidthByColumnSpan(t.theme,1),h:t._screenH,color:t._columnColor}}))}},{key:"_updateGutters",value:function _updateGutters(){var t={lineColor:this._gutterColor,w:this._gutterY};this._GutterHorizontal.patch(_objectSpread(_objectSpread({},t),{},{x:(this._screenW-t.w)/2,y:this._screenH/4}));}},{key:"_updatePropertyTextStyle",value:function _updatePropertyTextStyle(t,e){var n={textStyle:_objectSpread({},this.style.propertyTextStyle)};e&&(n.textStyle.textColor=e),t.Items.tag("Property").style=n;}},{key:"_updateValueTextStyle",value:function _updateValueTextStyle(t){t.Items.tag("Value").style={textStyle:this.style.valueTextStyle};}},{key:"_updateText",value:function _updateText(){var t="Property",e="Value";this._TextPanel.x=this._screenW-this._marginX-getWidthByColumnSpan(this.theme,3),this._TextPanel.y=this._safe,this._TextScreenW.Items.tag(t).content="Screen Width",this._TextScreenW.Items.tag(e).content="".concat(this._screenW,"px"),this._updatePropertyTextStyle(this._TextScreenW),this._updateValueTextStyle(this._TextScreenW),this._TextScreenH.Items.tag(t).content="Screen Height",this._TextScreenH.Items.tag(e).content="".concat(this._screenH,"px"),this._updatePropertyTextStyle(this._TextScreenH),this._updateValueTextStyle(this._TextScreenH),this._TextColumnCount.Items.tag(t).content="Columns",this._TextColumnCount.Items.tag(e).content="".concat(this._columnCount,", ").concat(Math.round(getWidthByColumnSpan(this.theme,1)),"px each"),this._updatePropertyTextStyle(this._TextColumnCount),this._updateValueTextStyle(this._TextColumnCount),this._TextMarginX.Items.tag(t).content="Margin-X",this._TextMarginX.Items.tag(e).content="".concat(this._marginX,"px"),this._updatePropertyTextStyle(this._TextMarginX,this._marginColor),this._updateValueTextStyle(this._TextMarginX),this._TextMarginY.Items.tag(t).content="Margin-Y",this._TextMarginY.Items.tag(e).content="".concat(this._marginY,"px"),this._updatePropertyTextStyle(this._TextMarginY,this._marginColor),this._updateValueTextStyle(this._TextMarginY),this._TextGutterX.Items.tag(t).content="Gutter-X",this._TextGutterX.Items.tag(e).content="".concat(this._gutterX,"px"),this._updatePropertyTextStyle(this._TextGutterX,this._gutterColor),this._updateValueTextStyle(this._TextGutterX),this._TextGutterY.Items.tag(t).content="Gutter-Y",this._TextGutterY.Items.tag(e).content="".concat(this._gutterY,"px"),this._updatePropertyTextStyle(this._TextGutterY,this._gutterColor),this._updateValueTextStyle(this._TextGutterY),this._TextSafe.Items.tag(t).content="Safe",this._TextSafe.Items.tag(e).content="".concat(this._safe,"px"),this._updatePropertyTextStyle(this._TextSafe,this._safeColor),this._updateValueTextStyle(this._TextSafe);}}],[{key:"__componentName",get:function get(){return "GridOverlay"}},{key:"__themeStyle",get:function get(){return Se}},{key:"_template",value:function _template(){var t={type:ht,autoResizeHeight:!0,Items:{Property:{type:St,signals:{textBoxChanged:"_update"}},Value:{type:St,signals:{textBoxChanged:"_update"},centerInParent:!0}}};return {Columns:{alpha:.001,type:ht},Margins:{alpha:.001,Horizontal:{Left:{type:Ce,signals:{spacerLoaded:"_update"}},Right:{type:Ce,signals:{spacerLoaded:"_update"}}},Vertical:{Top:{type:Ce,vertical:!0}}},Safe:{alpha:.001,Horizontal:{Left:{type:Ce,signals:{spacerLoaded:"_update"}},Right:{type:Ce,signals:{spacerLoaded:"_update"}}},Vertical:{Top:{type:Ce,vertical:!0},Bottom:{type:Ce,vertical:!0}}},Gutters:{alpha:.001,Horizontal:{type:Ce,signals:{spacerLoaded:"_update"}}},TextPanel:{alpha:.001,type:pe,autoResizeHeight:!0,Items:{ScreenW:t,ScreenH:t,ColumnCount:t,MarginX:t,MarginY:t,GutterX:t,GutterY:t,Safe:t}}}}},{key:"properties",get:function get(){return ["showColumns","showMargins","showSafe","showGutters","showText"]}},{key:"tags",get:function get(){return ["Columns","Margins",{name:"MarginHorizontal",path:"Margins.Horizontal"},{name:"MarginLeft",path:"Margins.Horizontal.Left"},{name:"MarginRight",path:"Margins.Horizontal.Right"},{name:"MarginVertical",path:"Margins.Vertical"},{name:"MarginTop",path:"Margins.Vertical.Top"},"Safe",{name:"SafeHorizontal",path:"Safe.Horizontal"},{name:"SafeLeft",path:"Safe.Horizontal.Left"},{name:"SafeRight",path:"Safe.Horizontal.Right"},{name:"SafeVertical",path:"Safe.Vertical"},{name:"SafeTop",path:"Safe.Vertical.Top"},{name:"SafeBottom",path:"Safe.Vertical.Bottom"},"Gutters",{name:"GutterHorizontal",path:"Gutters.Horizontal"},"TextPanel",{name:"TextScreenW",path:"TextPanel.Items.ScreenW"},{name:"TextScreenH",path:"TextPanel.Items.ScreenH"},{name:"TextColumnCount",path:"TextPanel.Items.ColumnCount"},{name:"TextMarginX",path:"TextPanel.Items.MarginX"},{name:"TextMarginY",path:"TextPanel.Items.MarginY"},{name:"TextGutterX",path:"TextPanel.Items.GutterX"},{name:"TextGutterY",path:"TextPanel.Items.GutterY"},{name:"TextSafe",path:"TextPanel.Items.Safe"}]}}]),GridOverlay})();var Te=Object.freeze({__proto__:null,base:function base$h(t){return {cursorStyle:{textColor:t.color.textNeutral,blink:!0,width:t.spacer.xs,height:t.spacer.xxl},eyebrowTextStyle:_objectSpread(_objectSpread({},t.typography.caption1),{},{maxLines:1,textColor:t.color.textNeutral}),helpTextStyle:_objectSpread(_objectSpread({},t.typography.caption1),{},{maxLines:1,textColor:t.color.textNeutralSecondary}),minWidth:getWidthByUpCount(t,4),paddingX:t.spacer.xl,paddingY:t.spacer.xl}},mode:function mode$6(t){return {disabled:{eyebrowTextStyle:{textColor:t.color.textNeutralDisabled},helpTextStyle:{textColor:t.color.textNeutralDisabled}},focused:{cursorStyle:{textColor:t.color.textInverse},eyebrowTextStyle:{textColor:t.color.textNeutral},helpTextStyle:{textColor:t.color.textNeutralSecondary}}}},tone:function tone$a(t){return {inverse:{mode:{focused:{eyebrowTextStyle:{textColor:t.color.textNeutral},helpTextStyle:{textColor:t.color.textNeutral}}}}}}}),Ie=function(t){_inherits(Input,Ct);var e=_createSuper(Input);function Input(){return _classCallCheck(this,Input),e.apply(this,arguments)}return _createClass(Input,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(Input.prototype),"_construct",this).call(this),this._title="",this.actualTitle="",this.position=this.title?this.title.length:0,this._justify="left",this._fixed=!0,this.w=this.style.minWidth;}},{key:"$itemChanged",value:function $itemChanged(){_get(_getPrototypeOf(Input.prototype),"$itemChanged",this).call(this),this._updateTextWrapper(),this._updateHiddenContent(),this._updateCursorPosition(),this._updateTitleScrollPosition();}},{key:"_onTitleTextBoxChanged",value:function _onTitleTextBoxChanged(){this._updateHiddenContent();}},{key:"_onHiddenTextBoxChanged",value:function _onHiddenTextBoxChanged(){this._updateCursorPosition();}},{key:"_update",value:function _update(){this._updatePassword(),_get(_getPrototypeOf(Input.prototype),"_update",this).call(this),this._updateEyebrow(),this._updateHelpText(),this._updateTextWrapper(),this._updateHiddenContent(),this._updateCursor(),this._updateCursorListening(),this._updateCursorBlink(),this._updateCursorPosition(),this._updateTitleScrollPosition();}},{key:"_updatePassword",value:function _updatePassword(){this.title=this.password?this.mask.repeat(this.actualTitle.length):this.actualTitle;}},{key:"_updateTruncation",value:function _updateTruncation(){this._Title&&this._Title.patch({style:{textStyle:_objectSpread(_objectSpread({},this.style.textStyle),{},{wordWrap:!1})}});}},{key:"_updateEyebrow",value:function _updateEyebrow(){this._Eyebrow.patch({content:this.eyebrow,style:{textStyle:this.style.eyebrowTextStyle},mountY:1,x:this.style.paddingX,y:this.y-this.style.paddingY});}},{key:"_updateHelpText",value:function _updateHelpText(){this._HelpText.patch({content:this.helpText,style:{textStyle:this.style.helpTextStyle},x:this.style.paddingX,y:this.y+this.innerH+this.style.paddingY});}},{key:"_updateTextWrapper",value:function _updateTextWrapper(){this._TextWrapper.clipping=!0,this._TextWrapper.w=this._visibleContentWidth,this._Title&&(this._TextWrapper.h=this._Title.h);}},{key:"_updateHiddenContent",value:function _updateHiddenContent(){this._HiddenContent||this._Content.patch({HiddenContent:{type:St,mountY:.5,y:function y(t){return t/2},signals:{textBoxChanged:"_onHiddenTextBoxChanged"}}});var t=this.title,e=void 0===t?"":t,n=this.position,i=this.password,o=this.mask,r=i?o.repeat(e.length).substring(0,n):e.substring(0,n);this._HiddenContent.patch({style:{textStyle:this.style.textStyle},content:r}),this._HiddenContent._Text&&this._HiddenContent._Text.patch({alpha:.001});}},{key:"_updateCursor",value:function _updateCursor(){this.style.cursorStyle&&this.style.cursorStyle.blink&&(this._Cursor||(this._Content.patch({Cursor:{rect:!0,mountY:.5}}),this.cursorBlink=this._Cursor.animation({duration:1.5,repeat:-1,actions:[{p:"alpha",v:{0:0,.5:1,1:0}}]})),this._Cursor.patch(this.style.cursorStyle));}},{key:"_updateCursorListening",value:function _updateCursorListening(){this._isDisabledMode?this.cursorBlink&&(this.isCursorActive?this.cursorBlink.start():this.cursorBlink.stop()):this.cursorBlink&&!this.cursorBlink.isPlaying()&&this.cursorBlink.start(),this._Cursor.smooth={color:this.style.cursorStyle.textColor};}},{key:"_updateCursorBlink",value:function _updateCursorBlink(){this.cursorBlink&&(this.isCursorActive?this.cursorBlink.start():(this.cursorBlink.stop(),this._Cursor.patch({alpha:.001})));}},{key:"_updateCursorPosition",value:function _updateCursorPosition(){this._Cursor.x=this._titleX+(this._isOverflow?this._TextWrapper.w:this._HiddenContent.w);}},{key:"_updateTitleScrollPosition",value:function _updateTitleScrollPosition(){this._Title&&(this._Title.x=this._isOverflow?this._visibleContentWidth-this._HiddenContent.w:0,this._HiddenContent&&this._TextWrapper&&(this._HiddenContent.x=this._TextWrapper.x+this._Title.x));}},{key:"_suffixX",get:function get(){var t=this._hasPrefix?this.w-this._paddingLeft-this._paddingRight-this._prefixW:this.w-this._paddingLeft-this._paddingRight-this.style.paddingX;return t>0?t:0}},{key:"isCursorActive",get:function get(){return this.listening&&(this._isFocusedMode||this._isUnfocusedMode)}},{key:"_isOverflow",get:function get(){return this._HiddenContent.w>this._visibleContentWidth}},{key:"_visibleContentWidth",get:function get(){return this._fixedWordWrapWidth}},{key:"value",get:function get(){return this.actualTitle},set:function set(t){this.title=this.actualTitle=t,this.position=0,this._updatePassword();}},{key:"clear",value:function clear(){this.isCursorActive&&(this.title=this.actualTitle="",this.position=0);}},{key:"insert",value:function insert(t){this.isCursorActive&&(this.actualTitle=this.actualTitle.slice(0,this.position)+t+this.actualTitle.slice(this.position),this._updatePassword(),this.position+=t.length);}},{key:"backspace",value:function backspace(){this.isCursorActive&&this.position>0&&(this.actualTitle=this.actualTitle.slice(0,this.position-1)+this.actualTitle.slice(this.position),this._updatePassword(),this.position--);}},{key:"_handleLeft",value:function _handleLeft(){return !this._isDisabledMode&&(this.moveLeft(),"function"!=typeof this.onLeft||this.onLeft(this))}},{key:"_handleRight",value:function _handleRight(){return !this._isDisabledMode&&(this.moveRight(),"function"!=typeof this.onRight||this.onRight(this))}},{key:"moveLeft",value:function moveLeft(){return this.position>=0&&(this.position--,!0)}},{key:"moveRight",value:function moveRight(){return this.position<this.title.length&&(this.position++,!0)}},{key:"announce",get:function get(){return this._announce?this._announce:this.password?[this.eyebrow,this.helpText]:[this.eyebrow,"Input: "+this.title,this.helpText]},set:function set(t){_set(_getPrototypeOf(Input.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Input"}},{key:"__themeStyle",get:function get(){return Te}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Input),"_template",this).call(this)),{},{Eyebrow:{type:St},HelpText:{type:St}})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Input),"properties",this)),["actualTitle","cursor","eyebrow","helpText","listening","mask","password","position"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Input),"tags",this)),["Eyebrow","HelpText",{name:"Cursor",path:"Content.Cursor"},{name:"HiddenContent",path:"Content.HiddenContent"}])}}]),Input}(),Ae=Object.freeze({__proto__:null,base:function base$g(t){var e=t.typography.headline2;return {height:9*t.spacer.md,minWidth:7*t.spacer.md,paddingX:t.spacer.md,textStyle:e,sizes:{sm:7*t.spacer.md,md:15*t.spacer.md,lg:23*t.spacer.md,xl:47*t.spacer.md,xxl:95*t.spacer.md},iconWidth:e.lineHeight,iconHeight:e.lineHeight}}}),Pe={a:"alpha",b:"bravo",c:"charlie",d:"delta",e:"echo",f:"foxtrot",g:"golf",h:"hotel",i:"india",j:"juliett",k:"kilo",l:"lima",m:"mike",n:"november",o:"oscar",p:"papa",q:"quebec",r:"romeo",s:"sierra",t:"tango",u:"uniform",v:"victor",w:"whiskey",x:"x-ray",y:"yankee",z:"zulu"};function getNato(t){return function isAlphaChar(t){return /^[A-Za-z]$/.test(t)}(t)?"".concat(t,", ").concat(Pe[t.toLowerCase()]):t}var Le=function(t){_inherits(Key,Ct);var e=_createSuper(Key);function Key(){return _classCallCheck(this,Key),e.apply(this,arguments)}return _createClass(Key,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(Key.prototype),"_construct",this).call(this),this._size="sm",this._fixed=!0;}},{key:"_update",value:function _update(){this.w=this.style.sizes[this.size]||this.style.sizes.sm,this._updatePrefixStyle(),_get(_getPrototypeOf(Key.prototype),"_update",this).call(this);}},{key:"_updatePrefixStyle",value:function _updatePrefixStyle(){this._prefix&&this.icon&&this._updatePrefixObj(this.icon,{style:this.style.iconStyle});}},{key:"_updatePrefixObj",value:function _updatePrefixObj(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._prefix=_objectSpread({type:nt,icon:t,w:this.style.iconWidth,h:this.style.iconHeight},e);}},{key:"_setIcon",value:function _setIcon(t){return t?this._updatePrefixObj(t,{style:this.style.iconStyle}):this._prefix=t,t}},{key:"announce",get:function get(){return this._announce?this._announce:function isUpperCase(t){return /^[A-Z]$/.test(t)}(this.title)?"Capital ".concat(getNato(this.title),", button"):getNato(this.title)+", button"},set:function set(t){_set(_getPrototypeOf(Key.prototype),"announce",t,this,!0);}},{key:"_handleEnter",value:function _handleEnter(){return "function"==typeof this.onEnter?this.onEnter(this):(this.toggle&&this.fireAncestors("$toggleKeyboard",this.toggle),this.fireAncestors("$onSoftKey",{key:this.keyId||this.title,toggle:this.toggle}),!1)}}],[{key:"__componentName",get:function get(){return "Key"}},{key:"__themeStyle",get:function get(){return Ae}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Key),"properties",this)),["icon","size","toggle"])}},{key:"aliasStyles",get:function get(){return [{prev:"iconH",curr:"iconHeight"},{prev:"iconW",curr:"iconWidth"}]}}]),Key}(),Be=Object.freeze({__proto__:null,base:function base$f(t){return {keySpacing:t.spacer.md,screenW:t.layout.screenW,marginX:t.layout.marginX,inputSpacing:10*t.spacer.md+t.spacer.md,inputStyle:{radius:t.radius.md}}}}),Oe=function capitalize(t){return t.charAt(0).toUpperCase()+t.slice(1)},We=function(t){_inherits(Keyboard,G);var e=_createSuper(Keyboard);function Keyboard(){return _classCallCheck(this,Keyboard),e.apply(this,arguments)}return _createClass(Keyboard,[{key:"_init",value:function _init(){this._setShouldUpdateThemeBound=this._setShouldUpdateTheme.bind(this),k$1.on("themeUpdate",this._setShouldUpdateThemeBound),_get(_getPrototypeOf(Keyboard.prototype),"_init",this).call(this);}},{key:"_setShouldUpdateTheme",value:function _setShouldUpdateTheme(){this.shouldUpdateTheme=!0;}},{key:"_detach",value:function _detach(){_get(_getPrototypeOf(Keyboard.prototype),"_detach",this).call(this),k$1.off("themeUpdate",this._setShouldUpdateThemeBound);}},{key:"_focus",value:function _focus(){_get(_getPrototypeOf(Keyboard.prototype),"_focus",this).call(this),this.fireAncestors("$keyboardFocused",!0);}},{key:"_getFocused",value:function _getFocused(){return this._currentKeyboard||this}},{key:"_update",value:function _update(){this._currentFormat||(this._currentFormat=this.defaultFormat),this.centerKeyboard?this.x=(this.style.screenW-this.w)/2-this.style.marginX:this.x=0,this._formatsChanged||this.shouldUpdateTheme?(this._createFormat(this._currentFormat),this._refocus(),this._formatsChanged=!1,this.shouldUpdateTheme=!1):this._formatKeys();}},{key:"_createFormat",value:function _createFormat(t){var e=this.formats[t];if(e){var n=this._formatKeyboardData(e);this._createKeyboard(t,this._createRows(n,t));}}},{key:"_createKeyboard",value:function _createKeyboard(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t=Oe(t),1===e.length?this.patch(_defineProperty$1({},t,e[0])):this.patch(_defineProperty$1({},t,{type:pe,plinko:!0,items:e,style:{itemSpacing:this.style.keySpacing},autoResizeWidth:!0,autoResizeHeight:!0,neverScroll:!0}));}},{key:"_createRows",value:function _createRows(){var t=this,e=arguments.length>1?arguments[1]:void 0;return (arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).map((function(n){return {type:ht,autoResizeHeight:!0,autoResizeWidth:!0,centerInParent:t.centerKeyboard,neverScroll:!0,wrapSelected:void 0===t.rowWrap||t.rowWrap,style:{itemSpacing:t.style.keySpacing},items:t._createKeys(n,e)}}))}},{key:"_createKeys",value:function _createKeys(){var t=this,e=arguments.length>1?arguments[1]:void 0;return (arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).map((function(n){if(!n)return {skipFocus:!0};var i={type:t.keyComponent||Le};if("object"===_typeof(n)){var o,r,a,s=n.keyId||n.title,l=(null===(o=t.style.keyProps)||void 0===o||null===(o=o[e])||void 0===o?void 0:o[s])||(null===(r=t.style.keyProps)||void 0===r?void 0:r[s]);return l&&l.icon?_objectSpread(_objectSpread(_objectSpread({type:t.keyComponent||Le},n),null===(a=t.style.keyProps)||void 0===a?void 0:a[s]),{},{style:{iconStyle:_objectSpread({},l.iconStyle)},size:l.size||n.size}):_objectSpread(_objectSpread({},i),n)}return _objectSpread(_objectSpread({},i),{},{title:n})}))}},{key:"_formatKeyboardData",value:function _formatKeyboardData(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];if(Array.isArray(t)&&t.length){if(!Array.isArray(t[0])&&!this.inline){var e,n,i=[];for(e=0,n=-1;e<t.length;e++)e%this.columnCount==0&&(i[++n]=[]),i[n].push(t[e]);return i}return this.inline?[t]:t}}},{key:"_formatKeys",value:function _formatKeys(){var t=this;Object.keys(this.formats).forEach((function(e){var n=t.tag(Oe(e));n&&(n.patch({style:{itemSpacing:t.style.keySpacing}}),n.items.forEach((function(e){e.patch({style:{itemSpacing:t.style.keySpacing},centerInParent:t.centerKeys,wrapSelected:void 0===t.rowWrap||t.rowWrap});})),n.queueRequestUpdate());}));}},{key:"$toggleKeyboard",value:function $toggleKeyboard(t){var e=Oe(t);if(t!==this._currentFormat){this._createFormat(t);var n=this.tag(e);this.selectKeyOn(n),this._currentKeyboard.alpha=0,n.alpha=1,this._currentFormat=t;}}},{key:"selectKeyOn",value:function selectKeyOn(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getSelectedKey(),n=e.row,i=e.column;t&&t.constructor&&("Row"===t.constructor.name?t.selectedIndex=i:(t.selectedIndex=n,t.selected.selectedIndex=i));}},{key:"getSelectedKey",value:function getSelectedKey(){var t,e,n=this._currentKeyboard;return "Row"===n.constructor.name?(t=0,e=n.selectedIndex):(t=n.selectedIndex,e=n.selected.selectedIndex),{row:t,column:e}}},{key:"$itemChanged",value:function $itemChanged(){this.w=this._currentKeyboard.w,this.fireAncestors("$itemChanged"),this.signal("keyboardWidthChanged");}},{key:"_setFormats",value:function _setFormats(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this._formatsChanged=!0,t}},{key:"defaultFormat",get:function get(){return this._defaultFormat||Object.keys(this.formats)[0]},set:function set(t){this._defaultFormat=t;}},{key:"_currentKeyboard",get:function get(){return this.tag(Oe(this._currentFormat))}},{key:"columnCount",get:function get(){return this._columnCount?this._columnCount:this.rowCount?this.formats[this.defaultFormat.toLowerCase()].length/this.rowCount:this.inline?this.formats[this.defaultFormat.toLowerCase()].length:11},set:function set(t){this._columnCount=t;}},{key:"announce",get:function get(){return this._announce?this._announce:"Keyboard"+(this.title?", ".concat(this.title):"")},set:function set(t){_set(_getPrototypeOf(Keyboard.prototype),"announce",t,this,!0);}},{key:"announceContext",get:function get(){return this._announceContext||["PAUSE-2","Use arrow keys to choose characters, press center to select"]},set:function set(t){_set(_getPrototypeOf(Keyboard.prototype),"announceContext",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Keyboard"}},{key:"__themeStyle",get:function get(){return Be}},{key:"properties",get:function get(){return ["formats","centerKeyboard","rowWrap","centerKeys","keyComponent"]}}]),Keyboard}();(function(t){_inherits(KeyboardEmail,We);var e=_createSuper(KeyboardEmail);function KeyboardEmail(){return _classCallCheck(this,KeyboardEmail),e.apply(this,arguments)}return _createClass(KeyboardEmail,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(KeyboardEmail.prototype),"_construct",this).call(this),this.formats=this.emailFormat;}},{key:"emailFormat",get:function get(){return {uppercase:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["Q","W","E","R","T","Y","U","I","O","P",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["A","S","D","F","G","H","J","K","L","@",{title:"",size:"md",toggle:"accents",announce:"accents, button",keyId:"accents"}],["Z","X","C","V","B","N","M",{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"_",announce:"underscore, button"},{title:"shift",size:"md",toggle:"lowercase",announce:"shift off, button",keyId:"shift"}],[{title:".com",announce:"dot, com",size:"md"},{title:".net",announce:"dot, net",size:"md"},{title:".edu",announce:"dot, edu",size:"md"},{title:".org",announce:"dot, org",size:"md"},{title:".co",announce:"dot, co",size:"md"},{title:".uk",announce:"dot, uk",size:"md"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],lowercase:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["q","w","e","r","t","y","u","i","o","p",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["a","s","d","f","g","h","j","k","l","@",{title:"",size:"md",toggle:"accents",announce:"accents, button",keyId:"accents"}],["z","x","c","v","b","n","m",{title:"_",announce:"underscore, button"},{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"shift",size:"md",toggle:"uppercase",announce:"shift on, button",keyId:"shift"}],[{title:".com",announce:"dot, com",size:"md"},{title:".net",announce:"dot, net",size:"md"},{title:".edu",announce:"dot, edu",size:"md"},{title:".org",announce:"dot, org",size:"md"},{title:".co",announce:"dot, co",size:"md"},{title:".uk",announce:"dot, uk",size:"md"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],accents:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["","","","","","","","","","",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["","","","","","","","","","@",{title:"abc",size:"md",toggle:"lowercase",announce:"alpha mode, button"}],["","","","","","","","","","","","","","","","","","","","","",{title:"_",announce:"underscore, button"},{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"shift",size:"md",toggle:"accentsUpper",announce:"shift off, button",keyId:"shift"}],[{title:".com",announce:"dot, com",size:"md"},{title:".net",announce:"dot, net",size:"md"},{title:".edu",announce:"dot, edu",size:"md"},{title:".org",announce:"dot, org",size:"md"},{title:".co",announce:"dot, co",size:"md"},{title:".uk",announce:"dot, uk",size:"md"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],accentsUpper:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["","","","","","","","","","",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["","","","","","","","","","@",{title:"abc",size:"md",toggle:"lowercase",announce:"alpha mode, button"}],["","","","","","","","","","","","","","","","","","","","","",{title:"_",announce:"underscore, button"},{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"shift",size:"md",toggle:"accents",announce:"shift off, button",keyId:"shift"}],[{title:".com",announce:"dot, com",size:"md"},{title:".net",announce:"dot, net",size:"md"},{title:".edu",announce:"dot, edu",size:"md"},{title:".org",announce:"dot, org",size:"md"},{title:".co",announce:"dot, co",size:"md"},{title:".uk",announce:"dot, uk",size:"md"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],symbols:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],[{title:"!",announce:"exclamation, button"},"@","#","$","%",{title:"^",announce:"caret circumflex, button"},"&","*",{title:"(",announce:"open parenthesis, button"},{title:")",announce:"close parenthesis, button"},{title:"abc",size:"md",toggle:"lowercase",announce:"alpha mode, button"}],[{title:"{",announce:"open brace, button"},{title:"}",announce:"close brace, button"},{title:"[",announce:"open bracket, button"},{title:"]",announce:"close bracket, button"},{title:";",announce:"semicolon, button"},{title:'"',announce:"doublequote, button"},{title:",",announce:"comma, button"},{title:"|",announce:"vertical bar, button"},{title:"\\",announce:"backslash, button"},{title:"/",announce:"forwardslash, button"},{title:"",size:"md",toggle:"accents",announce:"accents, button",keyId:"accents"}],[{title:"<",announce:"less than, button"},{title:">",announce:"greater than, button"},{title:"?",announce:"question mark, button"},{title:"=",announce:"equal sign, button"},{title:"`",announce:"grave accent, button"},{title:"~",announce:"tilde, button"},{title:"_",announce:"underscore, button"},{title:":",announce:"colon, button"},{title:"-",announce:"dash, button"},{title:"+",announce:"plus sign, button"}],[{title:".com",announce:"dot, com",size:"md"},{title:".net",announce:"dot, net",size:"md"},{title:".edu",announce:"dot, edu",size:"md"},{title:".org",announce:"dot, org",size:"md"},{title:".co",announce:"dot, co",size:"md"},{title:".uk",announce:"dot, uk",size:"md"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]]}}}],[{key:"__componentName",get:function get(){return "KeyboardEmail"}},{key:"__themeStyle",get:function get(){return Be}}]),KeyboardEmail})();(function(t){_inherits(KeyboardFullScreen,We);var e=_createSuper(KeyboardFullScreen);function KeyboardFullScreen(){return _classCallCheck(this,KeyboardFullScreen),e.apply(this,arguments)}return _createClass(KeyboardFullScreen,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(KeyboardFullScreen.prototype),"_construct",this).call(this),this.formats=this.fullscreenFormat;}},{key:"fullscreenFormat",get:function get(){return {letters:[["","","","","","","","","",{title:"#@!",size:"lg",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"},{title:"Space",size:"lg",keyId:"space",announce:"space, button"},{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"},"","","","","","","","",""],["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"]],symbols:[["","","","","","","","","",{title:"ABC",size:"lg",toggle:"letters",announce:"caps on, button"},{title:"Space",size:"lg",keyId:"space",announce:"space, button"},{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"},"","","","","","","","",""],["1","2","3","4","5","6","7","8","9","0",{title:"!",announce:"exclamation, button"},"@","#","$","%",{title:"^",announce:"caret circumflex, button"},"&","*",{title:"(",announce:"open parenthesis, button"},{title:")",announce:"close parenthesis, button"},{title:"`",announce:"grave accent, button"},"~","_",".","-","+"]]}}}],[{key:"__componentName",get:function get(){return "KeyboardFullScreen"}},{key:"__themeStyle",get:function get(){return Be}}]),KeyboardFullScreen})();(function(t){_inherits(KeyboardNumbers,We);var e=_createSuper(KeyboardNumbers);function KeyboardNumbers(){return _classCallCheck(this,KeyboardNumbers),e.apply(this,arguments)}return _createClass(KeyboardNumbers,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(KeyboardNumbers.prototype),"_construct",this).call(this),this.formats=this.numbersFormat;}},{key:"numbersFormat",get:function get(){return {numbers:["1","2","3","4","5","6","7","8","9","0"],dialpad:[["1","2","3"],["4","5","6"],["7","8","9"],["0"]],dialpadExtended:[["1","2","3"],["4","5","6"],["7","8","9"],["0"],[{title:"Delete",size:"lg",keyId:"delete",announce:"delete, button"}]]}}}],[{key:"__componentName",get:function get(){return "KeyboardNumbers"}},{key:"__themeStyle",get:function get(){return Be}}]),KeyboardNumbers})();(function(t){_inherits(KeyboardQwerty,We);var e=_createSuper(KeyboardQwerty);function KeyboardQwerty(){return _classCallCheck(this,KeyboardQwerty),e.apply(this,arguments)}return _createClass(KeyboardQwerty,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(KeyboardQwerty.prototype),"_construct",this).call(this),this.formats=this.qwertyFormat;}},{key:"qwertyFormat",get:function get(){return {uppercase:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["Q","W","E","R","T","Y","U","I","O","P",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["A","S","D","F","G","H","J","K","L","@",{title:"",size:"md",toggle:"accents",announce:"accents, button",keyId:"accents"}],["Z","X","C","V","B","N","M",{title:"_",announce:"underscore, button"},{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"shift",size:"md",toggle:"lowercase",announce:"shift off, button",keyId:"shift"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],lowercase:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["q","w","e","r","t","y","u","i","o","p",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["a","s","d","f","g","h","j","k","l","@",{title:"",size:"md",toggle:"accents",announce:"accents, button",keyId:"accents"}],["z","x","c","v","b","n","m",{title:"_",announce:"underscore, button"},{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"shift",size:"md",toggle:"uppercase",announce:"shift on, button",keyId:"shift"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],accents:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["","","","","","","","","","",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["","","","","","","","","","@",{title:"abc",size:"md",toggle:"lowercase",announce:"alpha mode, button"}],["","","","","","","","","","","","","","","","","","","","","",{title:"_",announce:"underscore, button"},{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"shift",size:"md",toggle:"accentsUpper",announce:"shift off, button",keyId:"shift"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],accentsUpper:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],["","","","","","","","","","",{title:"#@!",size:"md",toggle:"symbols",announce:"symbol mode, button",keyId:"symbols"}],["","","","","","","","","","@",{title:"abc",size:"md",toggle:"lowercase",announce:"alpha mode, button"}],["","","","","","","","","","","","","","","","","","","","","",{title:".",announce:"period, button"},{title:"-",announce:"dash, button"},{title:"_",announce:"underscore, button"},{title:"shift",size:"md",toggle:"accents",announce:"shift off, button",keyId:"shift"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]],symbols:[["1","2","3","4","5","6","7","8","9","0",{title:"Delete",size:"md",keyId:"delete",announce:"delete, button"}],[{title:"!",announce:"exclamation, button"},"@","#","$","%",{title:"^",announce:"caret circumflex, button"},"&","*",{title:"(",announce:"open parenthesis, button"},{title:")",announce:"close parenthesis, button"},{title:"abc",size:"md",toggle:"lowercase",announce:"alpha mode, button"}],[{title:"{",announce:"open brace, button"},{title:"}",announce:"close brace, button"},{title:"[",announce:"open bracket, button"},{title:"]",announce:"close bracket, button"},{title:";",announce:"semicolon, button"},{title:'"',announce:"doublequote, button"},{title:",",announce:"comma, button"},{title:"|",announce:"vertical bar, button"},{title:"\\",announce:"backslash, button"},{title:"/",announce:"forwardslash, button"},{title:"",size:"md",toggle:"accents",announce:"accents, button",keyId:"accents"}],[{title:"<",announce:"less than, button"},{title:">",announce:"greater than, button"},{title:"?",announce:"question mark, button"},{title:"=",announce:"equal sign, button"},{title:"`",announce:"grave accent, button"},{title:"~",announce:"tilde, button"},{title:"_",announce:"underscore, button"},{title:":",announce:"colon, button"},{title:"-",announce:"dash, button"},{title:"+",announce:"plus sign, button"}],[{title:"Clear",size:"lg",keyId:"clear",announce:"clear, button"},{title:"Space",size:"xl",keyId:"space",announce:"space, button"},{title:"Done",size:"lg",keyId:"done",announce:"done, button"}]]}}}],[{key:"__componentName",get:function get(){return "KeyboardQwerty"}},{key:"__themeStyle",get:function get(){return Be}}]),KeyboardQwerty})();(function(t){_inherits(KeyboardInput,G);var e=_createSuper(KeyboardInput);function KeyboardInput(){return _classCallCheck(this,KeyboardInput),e.apply(this,arguments)}return _createClass(KeyboardInput,[{key:"_update",value:function _update(){this._Wrapper.style.itemSpacing=this.style.inputSpacing,this._updateKeyboardType(),this._updateInput(),this._updateKeyboard(),this._updateCenterKeyboard();}},{key:"_updateKeyboardType",value:function _updateKeyboardType(){this._Keyboard.constructor!==this.keyboardType&&(this._Wrapper._resetItems(),this._Wrapper.items=[{type:Ie,ref:"Input"},{type:this.keyboardType,ref:"Keyboard",passSignals:{keyboardWidthChanged:!0}}]);}},{key:"_updateInput",value:function _updateInput(){this._Input.patch(_objectSpread(_objectSpread({},this.input),{},{centerInParent:this.centerKeyboard,w:this._Keyboard.w,style:_objectSpread({},this.style.inputStyle),listening:this._isFocusedMode}));}},{key:"_updateKeyboard",value:function _updateKeyboard(){this._Keyboard.patch({defaultFormat:this.defaultFormat||"lowercase",centerKeyboard:this.centerKeyboard});}},{key:"_updateWidth",value:function _updateWidth(){this._Input.w=this.w=this._Keyboard.w,this.fireAncestors("$itemChanged");}},{key:"_updateCenterKeyboard",value:function _updateCenterKeyboard(){this.centerKeyboard?this.x=(this.style.screenW-this.w)/2-this.style.marginX:this.x=0;}},{key:"$onSoftKey",value:function $onSoftKey(t){var e=t.key,n=void 0===e?"":e;if(!t.toggle)switch(n.toLowerCase()){case"delete":this._Input.backspace();break;case"done":break;case"space":this._Input.insert(" ");break;case"clear":this._Input.clear();break;default:this._Input.insert(n);}}},{key:"$keyboardFocused",value:function $keyboardFocused(t){this._Input.listening=!!t;}},{key:"_getFocused",value:function _getFocused(){return this._Wrapper||this}}],[{key:"__componentName",get:function get(){return "KeyboardInput"}},{key:"properties",get:function get(){return ["centerKeyboard","defaultFormat","input","keyboardType"]}},{key:"__themeStyle",get:function get(){return Be}},{key:"_template",value:function _template(){return {Wrapper:{type:pe,neverScroll:!0,w:this.w,items:[{type:Ie,ref:"Input"},{type:We,ref:"Keyboard",passSignals:{keyboardWidthChanged:!0}}],selectedIndex:1,signals:{keyboardWidthChanged:"_updateWidth"}}}}},{key:"tags",get:function get(){return ["Wrapper",{name:"Input",path:"Wrapper.Input"},{name:"Keyboard",path:"Wrapper.Keyboard"}]}}]),KeyboardInput})();var ze=Object.freeze({__proto__:null,base:function base$e(t){var e=t.spacer.lg;return {width:e,height:e,radius:e/2}},tone:function tone$9(t){return {neutral:{circleColor:t.color.interactiveNeutralFocus,mode:{disabled:{circleColor:t.color.fillNeutralDisabled}}},inverse:{circleColor:t.color.interactiveInverseFocus,mode:{disabled:{circleColor:t.color.fillInverseDisabled}}},brand:{circleColor:t.color.interactiveBrandFocus,mode:{disabled:{circleColor:t.color.fillInverseDisabled}}}}}}),Ee=function(e){_inherits(Knob,G);var n=_createSuper(Knob);function Knob(){return _classCallCheck(this,Knob),n.apply(this,arguments)}return _createClass(Knob,[{key:"_update",value:function _update(){this._updateCircleLayout();}},{key:"_updateCircleLayout",value:function _updateCircleLayout(){this.patch({texture:t.Tools.getRoundRect(this.w,this.h,this.style.radius,null,null,!0,this.style.circleColor)});}}],[{key:"__componentName",get:function get(){return "Knob"}},{key:"__themeStyle",get:function get(){return ze}},{key:"_template",value:function _template(){return {mount:.5}}}]),Knob}(),Fe=Object.freeze({__proto__:null,base:function base$d(t){return {alpha:t.alpha.primary,descriptionTextStyle:_objectSpread(_objectSpread({},t.typography.body3),{},{maxLines:1,textColor:t.color.textNeutralSecondary}),height:3*t.spacer.xxl,logoStyle:{width:2*t.spacer.xxl,height:2*t.spacer.xxl,radius:t.radius.sm},paddingX:t.spacer.xl,titlePadding:t.spacer.lg,titleTextStyle:_objectSpread(_objectSpread({},t.typography.headline3),{},{maxLines:1,textColor:t.color.textNeutral}),width:l.getWidthByColumnSpan(t,3)}},mode:function mode$5(t){return {disabled:{alpha:t.alpha.inactive,descriptionTextStyle:{textColor:t.color.textNeutralDisabled},titleTextStyle:{textColor:t.color.textNeutralDisabled}},focused:{descriptionTextStyle:{textColor:t.color.textInverseSecondary},titleTextStyle:{textColor:t.color.textInverse}}}},tone:function tone$8(t){return {inverse:{mode:{focused:{descriptionTextStyle:{textColor:t.color.textNeutral},titleTextStyle:{textColor:t.color.textNeutral}}}}}}}),He=function(t){_inherits(ListItem,Ct);var e=_createSuper(ListItem);function ListItem(){return _classCallCheck(this,ListItem),e.apply(this,arguments)}return _createClass(ListItem,[{key:"_onTextBoxChanged",value:function _onTextBoxChanged(){this._updateTitle(),this._updateDescription(),this._updateTruncation();}},{key:"_update",value:function _update(){this._updatePrefixLogo(),this._updateSuffixLogo(),_get(_getPrototypeOf(ListItem.prototype),"_update",this).call(this),this._updateDescription();}},{key:"_updateTitle",value:function _updateTitle(){this._TextWrapper.patch({Title:{content:this.title,style:{textStyle:this.style.titleTextStyle}}});}},{key:"_updateDescription",value:function _updateDescription(){if(this._hasDescription){var t={content:this.description,style:{textStyle:_objectSpread(_objectSpread({},this.style.descriptionTextStyle),{},{wordWrap:!0,wordWrapWidth:this._fixedWordWrapWidth})},visible:!this._collapse};this._Description||(t=_objectSpread({type:St,signals:{textBoxChanged:"_onTextBoxChanged"}},t)),this._TextWrapper.patch({Description:t});}else this._TextWrapper.patch({Description:void 0});}},{key:"_updateTruncation",value:function _updateTruncation(){this._Title&&this._Title.patch({style:{textStyle:_objectSpread(_objectSpread({},this.style.titleTextStyle),{},{wordWrap:this.fixed,wordWrapWidth:this.fixed?this._fixedWordWrapWidth:0})}});}},{key:"_updatePrefixLogo",value:function _updatePrefixLogo(){this._hasPrefixLogo&&(this._prefix=this._addLogoProps(this._prefixLogo));}},{key:"_updateSuffixLogo",value:function _updateSuffixLogo(){this._hasSuffixLogo&&(this._suffix=this._addLogoProps(this._suffixLogo));}},{key:"_addLogoProps",value:function _addLogoProps(t){return {type:nt,icon:t,style:_objectSpread({color:void 0},this.style.logoStyle)}}},{key:"_hasPrefixLogo",get:function get(){return this.prefixLogo}},{key:"_hasSuffixLogo",get:function get(){return this.suffixLogo}},{key:"_rowProps",get:function get(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(ListItem.prototype),"_rowProps",this)),{},{autoResizeHeight:!0})}},{key:"_buttonProps",get:function get(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(ListItem.prototype),"_buttonProps",this)),{},{alpha:this.style.alpha})}},{key:"_hasDescription",get:function get(){return !!this.description}},{key:"_suffixX",get:function get(){return this.w-this._paddingRight-this._suffixW-this.style.paddingX}},{key:"_collapse",get:function get(){return this.shouldCollapse&&!this._isFocusedMode}},{key:"announce",get:function get(){return this._announce?this._announce:this.title+this.description+", List Item"},set:function set(t){_set(_getPrototypeOf(ListItem.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "ListItem"}},{key:"__themeStyle",get:function get(){return Fe}},{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(ListItem),"_template",this).call(this)),{},{justify:"left",fixed:!0,Content:_objectSpread(_objectSpread({},_get(_getPrototypeOf(ListItem),"_template",this).call(this).Content),{},{TextWrapper:{mountY:.5,flex:{direction:"column"},Title:{type:St,signals:{textBoxChanged:"_onTextBoxChanged"}}}})})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ListItem),"properties",this)),["description","prefixLogo","suffixLogo","shouldCollapse"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ListItem),"tags",this)),[{name:"Description",path:"Content.TextWrapper.Description"}])}}]),ListItem}(),Ue=Object.freeze({__proto__:null,base:function base$c(){return {showArrows:!1,showKnob:!1}},mode:function mode$4(){return {focused:{showArrows:!0}}},tone:function tone$7(t){return {neutral:{mode:{focused:{arrowColor:t.color.fillInverse,progressBar:{barColor:t.color.fillInverseTertiary,progressColor:t.color.fillInverse}}}},inverse:{mode:{focused:{arrowColor:t.color.fillNeutral,progressBar:{barColor:t.color.fillNeutralTertiary,progressColor:t.color.fillNeutral}}}},brand:{mode:{focused:{arrowColor:t.color.fillInverse,progressBar:{barColor:t.color.fillBrandTertiary,progressColor:t.color.fillBrand}}}}}}}),Ke=Object.freeze({__proto__:null,base:function base$b(t){var e=t.spacer.lg;return {arrowAlphaValue:t.alpha.primary,arrowAlphaValueLimit:t.alpha.secondary,arrowHeight:t.spacer.xxl,arrowSpacing:t.spacer.md,arrowWidth:t.spacer.xxl,arrowColor:t.color.fillNeutral,containerHeight:t.spacer.lg+t.spacer.xs,iconLeftSrc:t.asset.arrowLeft,iconRightSrc:t.asset.arrowRight,minWidth:getWidthByColumnSpan(t,2),progressBar:{},width:e,height:e,radius:e/2,showArrows:!0,showKnob:!0,circleAnimation:{}}},mode:function mode$3(){return {disabled:{arrowAlphaValue:0}}},tone:function tone$6(t){return {neutral:{arrowColor:t.color.fillNeutral,circleColor:t.color.interactiveNeutralFocus},inverse:{arrowColor:t.color.fillInverse,circleColor:t.color.interactiveInverseFocus},brand:{arrowColor:t.color.fillNeutral,circleColor:t.color.interactiveNeutralFocus}}}}),qe=function(t){_inherits(Slider,G);var e=_createSuper(Slider);function Slider(){return _classCallCheck(this,Slider),e.apply(this,arguments)}return _createClass(Slider,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(Slider.prototype),"_construct",this).call(this),this._min=0,this._max=100,this._step=1,this._value=0,this._vertical=!1;}},{key:"_update",value:function _update(){this._updateDirection(),this._updateSliderLayout(),this._updatePositions(),this._updateArrowAlpha(),this._updateArrows(),this.signal("onChange",this.value,this),this._valueChanged&&(this.fireAncestors("$announce",this.announce),this._valueChanged=!1);}},{key:"_handleLeft",value:function _handleLeft(){return !this._isDisabledMode&&(this._decrementValue(),"function"!=typeof this.onLeft||this.onLeft(this))}},{key:"_handleRight",value:function _handleRight(){return !this._isDisabledMode&&(this._incrementValue(),"function"!=typeof this.onRight||this.onRight(this))}},{key:"_updateDirection",value:function _updateDirection(){this.patch({pivotX:0,rotation:this.vertical?a(90):0,mountY:this.vertical?.5:0});}},{key:"_updateSliderLayout",value:function _updateSliderLayout(){var t=this.w||this.style.minWidth;this._Container.patch({h:this.style.containerHeight,w:t,Bar:{x:this._calculatedSliderX,SliderBar:{y:this.style.containerHeight/2,w:this._calculatedSliderWidth,style:_objectSpread({duration:0},this.style.progressBar)}}}),this.h=Math.max(this.style.containerHeight,this.style.arrowHeight);}},{key:"_updatePositions",value:function _updatePositions(){this._updateSliderProgress(),this._updateCirclePosition();}},{key:"_updateSliderProgress",value:function _updateSliderProgress(){var t=this.value<this.min?this.min/this.max:this.value/this.max;this.value>this.max||this.value-this.step>this.max?t=this._calculatedSliderWidth:(this.min<0||this.max<0)&&(t=(this.value-this.min)/(this.max-this.min)),this._SliderBar.progress=t;}},{key:"_updateCirclePosition",value:function _updateCirclePosition(){var t;t=this.value<this.min||this.value+this.step<this.min?this.min/this.max*this._calculatedSliderWidth:this.value>this.max||this.value-this.step>this.max?this._calculatedSliderWidth:this.min<0||this.max<0?(this.value-this.min)/(this.max-this.min)*this._calculatedSliderWidth:this.value/this.max*this._calculatedSliderWidth,this._Circle&&(this._Circle.patch({mode:this.mode,style:{radius:this.style.radius,w:this.style.w,h:this.style.h,circleColor:this.style.circleColor},y:this._SliderBar.y+1,alpha:this._isFocusedMode&&this.style.showKnob?1:0}),this.style.circleAnimation&&Object.keys(this.style.circleAnimation).length?this._Circle.smooth={x:[t,this.style.circleAnimation]}:this._Circle.x=t);}},{key:"_updateArrowAlpha",value:function _updateArrowAlpha(){var t,e,n=this.style.showArrows?this.style.arrowAlphaValue:.001,i=this.style.showArrows?this.style.arrowAlphaValueLimit:.001;t=e=n,!this._isDisabledMode&&this.value<=this.min?(t=i,e=n):!this._isDisabledMode&&this.value>=this.max&&(t=n,e=i),this._LeftArrow.smooth={alpha:t},this._RightArrow.smooth={alpha:e};}},{key:"_updateArrows",value:function _updateArrows(){var t={w:this.style.arrowWidth,h:this.style.arrowHeight,style:{color:this.style.arrowColor}};this._LeftArrow.patch(_objectSpread(_objectSpread({},t),{},{icon:this.style.iconLeftSrc})),this._RightArrow.patch(_objectSpread(_objectSpread({},t),{},{icon:this.style.iconRightSrc})),this._RightArrow.smooth={x:this.style.arrowSpacing+this._calculatedSliderWidth+this._Bar.x};}},{key:"_decrementValue",value:function _decrementValue(){var t=this.value-this.step;this.value=t>=this.min?t:this.min,this._updatePositions();}},{key:"_incrementValue",value:function _incrementValue(){var t=this.value+this.step;this.value=t<=this.max?t:this.max,this._updatePositions();}},{key:"_handleUp",value:function _handleUp(){return !1}},{key:"_handleDown",value:function _handleDown(){return !1}},{key:"_calculatedSliderX",get:function get(){return this.style.showArrows?this.style.arrowSpacing+this.style.arrowWidth:0}},{key:"_calculatedSliderWidth",get:function get(){var t=this.style.showArrows?2*this.style.arrowSpacing+2*this.style.arrowWidth:0;return this.w<t+this._circleW?this.style.minWidth-t:this.w-t}},{key:"_circleW",get:function get(){return this._Circle?this._Circle.w:0}},{key:"_setVertical",value:function _setVertical(t){return this._setState(t?"VerticalSlider":""),t}},{key:"_setValue",value:function _setValue(t){return this._valueChanged=t!==this._value,t}},{key:"announce",get:function get(){return void 0!==this._announce&&null!==this._announce?this._announce:this.value.toString()},set:function set(t){_set(_getPrototypeOf(Slider.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Slider"}},{key:"__themeStyle",get:function get(){return Ke}},{key:"_template",value:function _template(){return {Container:{mountY:.5,y:function y(t){return t/2},Bar:{mountY:.5,SliderBar:{type:Yt,progress:.5,mountY:.5,announce:""},Circle:{type:Ee,zIndex:5}},LeftArrow:{type:nt,mountY:.5,y:function y(t){return t/2}},RightArrow:{type:nt,mountY:.5,y:function y(t){return t/2}}}}}},{key:"properties",get:function get(){return ["max","min","step","value","vertical"]}},{key:"tags",get:function get(){return ["Container",{name:"Bar",path:"Container.Bar"},{name:"SliderBar",path:"Container.Bar.SliderBar"},{name:"Circle",path:"Container.Bar.Circle"},{name:"LeftArrow",path:"Container.LeftArrow"},{name:"RightArrow",path:"Container.RightArrow"}]}},{key:"_states",value:function _states(){return [function(t){_inherits(VerticalSlider,t);var e=_createSuper(VerticalSlider);function VerticalSlider(){return _classCallCheck(this,VerticalSlider),e.apply(this,arguments)}return _createClass(VerticalSlider,[{key:"_handleLeft",value:function _handleLeft(){return !1}},{key:"_handleRight",value:function _handleRight(){return !1}},{key:"_handleUp",value:function _handleUp(){return !this._isDisabledMode&&(this._decrementValue(),"function"!=typeof this.onUp||this.onUp(this))}},{key:"_handleDown",value:function _handleDown(){return !this._isDisabledMode&&(this._incrementValue(),"function"!=typeof this.onDown||this.onDown(this))}}]),VerticalSlider}(this)]}}]),Slider}(),Xe=function(t){_inherits(NestedSlider,qe);var e=_createSuper(NestedSlider);function NestedSlider(){return _classCallCheck(this,NestedSlider),e.apply(this,arguments)}return _createClass(NestedSlider,null,[{key:"__componentName",get:function get(){return "NestedSlider"}},{key:"__themeStyle",get:function get(){return Ue}}]),NestedSlider}(),Ve=Object.freeze({__proto__:null,base:function base$a(t){return {paddingY:t.spacer.md+t.spacer.xs,valueTextStyle:_objectSpread(_objectSpread({},t.typography.headline3),{},{maxLines:1,textColor:t.color.textNeutralSecondary})}},mode:function mode$2(t){return {disabled:{valueTextStyle:{textColor:t.color.textNeutralDisabled}},focused:{valueTextStyle:{textColor:t.color.textInverseSecondary}}}},tone:function tone$5(t){return {neutral:{mode:{focused:{valueTextStyle:{textColor:t.color.textInverseSecondary}}}},inverse:{mode:{focused:{valueTextStyle:{textColor:t.color.textNeutralSecondary}}}},brand:{mode:{focused:{valueTextStyle:{textColor:t.color.textInverseSecondary}}}}}}});(function(t){_inherits(ListItemSlider,He);var e=_createSuper(ListItemSlider);function ListItemSlider(){return _classCallCheck(this,ListItemSlider),e.apply(this,arguments)}return _createClass(ListItemSlider,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(ListItemSlider.prototype),"_construct",this).call(this),this.value=50;}},{key:"_update",value:function _update(){_get(_getPrototypeOf(ListItemSlider.prototype),"_update",this).call(this),this._updateSliderPosition(),this._updateValue();}},{key:"_onTextBoxChanged",value:function _onTextBoxChanged(){_get(_getPrototypeOf(ListItemSlider.prototype),"_onTextBoxChanged",this).call(this),this._TextWrapper.h=Math.max(this._Title?this._Title.h:0,this._Value?this._Value.h:0);}},{key:"_updateValue",value:function _updateValue(){if(this._hasValue){var t={content:this.value.toString(),style:{textStyle:_objectSpread({},this.style.valueTextStyle)},mountX:1,x:this.w-this._paddingX};this._Value||(t=_objectSpread({type:St,signals:{textBoxChanged:"_onTextBoxChanged"}},t)),this._TextWrapper.patch({Value:t});}else this._TextWrapper.patch({Value:void 0});}},{key:"_updateSliderPosition",value:function _updateSliderPosition(){var t=this.w-this._paddingLeft-this._paddingRight,e=_objectSpread(_objectSpread({mode:this.mode,tone:this.tone,w:t,x:t/2,visible:!this._collapse,alpha:this.style.alpha},this.slider),{},{value:this.value});this._Slider.patch(e);}},{key:"_hasValue",get:function get(){return null!=this.value||null!=this.value}},{key:"_fixedWordWrapWidth",get:function get(){return this.w-this._paddingLeft-this._paddingRight-this._paddingX}},{key:"_onSliderChanged",value:function _onSliderChanged(t,e){t>=e.max?this.value=e.max:t<=e.min?this.value=e.min:this.value=e.value;}},{key:"_handleLeft",value:function _handleLeft(){return "function"==typeof this.onLeft?this.onLeft(this):!(!this._Slider||this._isDisabledMode)&&this._Slider._handleLeft()}},{key:"_handleRight",value:function _handleRight(){return "function"==typeof this.onRight?this.onRight(this):!(!this._Slider||this._isDisabledMode)&&this._Slider._handleRight()}},{key:"announce",get:function get(){return this._announce?this._announce:this.title+this.value+", List Item Slider"},set:function set(t){_set(_getPrototypeOf(ListItemSlider.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "ListItemSlider"}},{key:"__themeStyle",get:function get(){return Ve}},{key:"_template",value:function _template(){var t=_get(_getPrototypeOf(ListItemSlider),"_template",this);return _objectSpread(_objectSpread({},t()),{},{Content:_objectSpread(_objectSpread({},t().Content),{},{flex:{direction:"column"},TextWrapper:_objectSpread(_objectSpread({},t().Content.TextWrapper),{},{mountY:0,flex:void 0}),Slider:{type:Xe,mountX:.5,signals:{onChange:"_onSliderChanged"}}})})}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ListItemSlider),"properties",this)),["slider","value"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ListItemSlider),"tags",this)),[{name:"Slider",path:"Content.Slider"},{name:"Value",path:"Content.TextWrapper.Value"}])}}]),ListItemSlider})();var Ge=Object.freeze({__proto__:null,base:function base$9(t){return {arrowAlphaValue:t.alpha.primary,arrowAlphaValueLimit:t.alpha.secondary,arrowWidth:t.spacer.xxl,arrowHeight:t.spacer.xxl,iconLeftSrc:t.asset.arrowLeft,iconRightSrc:t.asset.arrowRight}},tone:function tone$4(t){return {neutral:{mode:{focused:{arrowColor:t.color.fillInverse}}},inverse:{mode:{focused:{arrowColor:t.color.fillNeutral}}},brand:{mode:{focused:{arrowColor:t.color.fillInverse}}}}}});(function(t){_inherits(ListItemPicker,He);var e=_createSuper(ListItemPicker);function ListItemPicker(){return _classCallCheck(this,ListItemPicker),e.apply(this,arguments)}return _createClass(ListItemPicker,[{key:"_onTextBoxChanged",value:function _onTextBoxChanged(){_get(_getPrototypeOf(ListItemPicker.prototype),"_onTextBoxChanged",this).call(this),this._alignPicker();}},{key:"_construct",value:function _construct(){_get(_getPrototypeOf(ListItemPicker.prototype),"_construct",this).call(this),this._options=[],this._selectedIndex=0;}},{key:"_update",value:function _update(){_get(_getPrototypeOf(ListItemPicker.prototype),"_update",this).call(this),this._updatePicker(),this._updateArrows(),this._updateArrowsAlpha(),this._updateAlignment();}},{key:"_updateAlignment",value:function _updateAlignment(){this._isFocusedMode?this.patch({justify:"center"}):this.patch({justify:"left"});}},{key:"_updateArrows",value:function _updateArrows(){if(!this._isFocusedMode){return this._LeftArrow&&(this._LeftArrow.alpha=.001),void(this._RightArrow&&(this._RightArrow.alpha=.001))}var t={w:this.style.arrowWidth,h:this.style.arrowHeight,style:{color:this.style.arrowColor},alpha:this.style.arrowAlphaValue};this._LeftArrow||this.patch({LeftArrow:{type:nt,mountY:.5,y:function y(t){return t/2}}}),this._LeftArrow.patch(_objectSpread(_objectSpread({},t),{},{icon:this.style.iconLeftSrc})),this._LeftArrow.smooth={x:this.style.paddingX},this._RightArrow||this.patch({RightArrow:{type:nt,mountY:.5,mountX:1,y:function y(t){return t/2}}}),this._RightArrow.patch(_objectSpread(_objectSpread({},t),{},{icon:this.style.iconRightSrc})),this._RightArrow.smooth={x:this.w-this.style.paddingX};}},{key:"_updatePicker",value:function _updatePicker(){var t=this,e=this.w-this._paddingX-2*this.style.arrowWidth;this._Picker||this._TextWrapper.patch({Picker:{type:ht,clipping:!0,alwaysScroll:!0,signals:{selectedChange:"_updateArrowsAlpha"}}}),this._Picker.patch({visible:!this._collapse,h:this.style.descriptionTextStyle.lineHeight,w:e,items:this.options.map((function(n){return {type:bt,h:t.style.descriptionTextStyle.lineHeight,w:e,centerAlign:t._isFocusedMode,title:_objectSpread(_objectSpread({},t.style.descriptionTextStyle),{},{text:n})}})),selectedIndex:this.selectedIndex}),this._alignPicker();}},{key:"_alignPicker",value:function _alignPicker(){this._Picker.patch({mountX:this._isFocusedMode?.5:0,x:this._isFocusedMode?this._Title.w/2:0});}},{key:"_updateArrowsAlpha",value:function _updateArrowsAlpha(){this._Picker&&(this._selectedIndex=this._Picker.selectedIndex);var t=this._isFocusedMode?this.style.arrowAlphaValue:0;this._RightArrow&&(this._RightArrow.alpha=this.selectedIndex===this.options.length-1&&this._isFocusedMode?this.style.arrowAlphaValueLimit:t),this._LeftArrow&&(this._LeftArrow.alpha=0===this.selectedIndex&&this._isFocusedMode?this.style.arrowAlphaValueLimit:t),this.fireAncestors("$announce",this.announce);}},{key:"_fixedWordWrapWidth",get:function get(){var t=this.w-this._paddingX-2*this.style.arrowWidth-2*this.style.titlePadding,e=this.w-this._paddingLeft-this._paddingRight;return this._isFocusedMode?t:e}},{key:"_collapse",get:function get(){return this.shouldCollapse&&!this._isFocusedMode}},{key:"selectedOption",get:function get(){return this._Picker.selected}},{key:"_handleLeft",value:function _handleLeft(){return "function"==typeof this.onLeft?this.onLeft(this):(this._Picker.selectPrevious(),!0)}},{key:"_handleRight",value:function _handleRight(){return "function"==typeof this.onRight?this.onRight(this):(this._Picker.selectNext(),!0)}},{key:"announce",get:function get(){return this._announce?this._announce:this.title+this.options[this.selectedIndex]+", List Item"},set:function set(t){_set(_getPrototypeOf(ListItemPicker.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "ListItemPicker"}},{key:"__themeStyle",get:function get(){return Ge}},{key:"properties",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ListItemPicker),"properties",this)),["options","selectedIndex"])}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(ListItemPicker),"tags",this)),["LeftArrow","RightArrow",{name:"Picker",path:"Content.TextWrapper.Picker"}])}}]),ListItemPicker})();(function(t){_inherits(MetadataCard,Kt);var e=_createSuper(MetadataCard);function MetadataCard(){return _classCallCheck(this,MetadataCard),e.apply(this,arguments)}return _createClass(MetadataCard,null,[{key:"__componentName",get:function get(){return "MetadataCard"}}]),MetadataCard})();var Je=function base$8(t){return {textStyle:t.typography.body2,fadeHeight:100,scroll:{timingFunction:"linear",duration:t.animation.duration.xfast},contentMarginTop:t.spacer.md,contentMarginLeft:t.spacer.xl,sliderMarginLeft:t.spacer.lg+t.spacer.xxs}},Ze=Object.freeze({__proto__:null,base:Je}),tn=Object.freeze({__proto__:null,base:function base$7(t){var e=Je(t).scroll;return {progressBar:{animation:e},circleAnimation:e}}}),en=function(t){_inherits(ScrollSlider,qe);var e=_createSuper(ScrollSlider);function ScrollSlider(){return _classCallCheck(this,ScrollSlider),e.apply(this,arguments)}return _createClass(ScrollSlider,null,[{key:"__componentName",get:function get(){return "ScrollSlider"}},{key:"__themeStyle",get:function get(){return tn}}]),ScrollSlider}();(function(e){_inherits(ScrollWrapper,G);var n=_createSuper(ScrollWrapper);function ScrollWrapper(){return _classCallCheck(this,ScrollWrapper),n.apply(this,arguments)}return _createClass(ScrollWrapper,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(ScrollWrapper.prototype),"_construct",this).call(this),this._scrollStep=10,this._shouldWrap=!1,this._flexDirection="column",this._fadeContent=!0,this._sliderWidth=0;}},{key:"_afterTextBoxUpdate",value:function _afterTextBoxUpdate(t){this._prevW===t.finalW&&this._prevH===t.finalH||(this._prevW=t.finalW,this._prevH=t.finalH,this._updateScrollWrapperLayout(),this._updateAlpha());}},{key:"_resetFlexContainer",value:function _resetFlexContainer(){this._FadeContainer.patch({ScrollContainer:void 0}),this._FadeContainer.patch({ScrollContainer:{w:function w(t){return t},wordWrap:!0}});}},{key:"_update",value:function _update(){this._contentChanged&&(this._resetFlexContainer(),this._updateAutoScroll()),this._updateScrollContainer(),this._updateScrollWrapperLayout(),this._updateAlpha();}},{key:"_updateAutoScroll",value:function _updateAutoScroll(){this.resetScroll(),this._setupAutoScroll(),this._contentChanged=!1;}},{key:"_updateScrollWrapperLayout",value:function _updateScrollWrapperLayout(){this._ScrollContainer.patch({w:this._contentWidth}),this._updateFadeContainer(),this._updateSlider();}},{key:"_updateAlpha",value:function _updateAlpha(){this._Slider.smooth={alpha:this.showScrollBar&&this._isFocusedMode?1:0};}},{key:"_updateFadeContainer",value:function _updateFadeContainer(){var e=this._ScrollContainer.finalH>this.h,n=this.fadeContent&&e&&!this._isEndContentVisible;this._FadeContainer.patch({h:this.h,w:this._contentWidth,y:this.style.contentMarginTop,x:this.style.contentMarginLeft,rtt:!0,shader:n?{type:t.shaders.FadeOut,bottom:this.style.fadeHeight}:void 0});}},{key:"_scrollContainerLoaded",value:function _scrollContainerLoaded(t){var e=t.h;this._ScrollContainer.h=e,this._updateScrollWrapperLayout();}},{key:"_updateScrollContainer",value:function _updateScrollContainer(){var t=this;if(this.content)if("string"==typeof this.content)this._ScrollContainer.patch({flex:{direction:"column"},ScrollableText:{h:0,w:this._contentWidth,type:St,content:this.content,style:{textStyle:_objectSpread(_objectSpread({},this.style.textStyle),{},{wordWrap:!0,wordWrapWidth:this._contentWidth})},signals:{textBoxChanged:"_scrollContainerLoaded"},onAfterUpdate:this._afterTextBoxUpdate.bind(this)}});else if(Array.isArray(this.content)){var e={};this.content.forEach((function(n,i){var o="ScrollText".concat(i);e[o]=_objectSpread({w:t._contentWidth},n),n.text&&(e[o]={type:St,content:n.text,style:{textStyle:_objectSpread(_objectSpread(_objectSpread({},t.style.textStyle),n.style),{},{wordWrap:!0,wordWrapWidth:t._contentWidth})},onAfterUpdate:t._afterTextBoxUpdate.bind(t)});})),this._ScrollContainer.patch(_objectSpread({flex:{direction:this.flexDirection,wrap:this.shouldWrap}},e));}}},{key:"_scrollDown",value:function _scrollDown(){if(this._scrollContainerY+this._ScrollContainer.finalH>this.renderHeight){var t=this._scrollContainerY-this.scrollStep,e=t+this._ScrollContainer.finalH>this.renderHeight,n=this.renderHeight-this._ScrollContainer.finalH-this.style.contentMarginTop;this._ScrollContainer.patch({smooth:{y:[e?t:n,this._scrollAnimation]}}),this._scrollContainerY+this._ScrollContainer.finalH<=this.h&&(this._isEndContentVisible=!0,this._autoScrollComplete=!0,this.fireAncestors("$scrollChanged","endDown",this),this._updateFadeContainer());}}},{key:"_scrollUp",value:function _scrollUp(){if(this._scrollContainerY<0){var t=this._scrollContainerY+this.scrollStep,e=t<0;this._ScrollContainer.patch({smooth:{y:[e?t:0,this._scrollAnimation]}}),this._scrollContainerY+this._ScrollContainer.finalH>this.renderHeight&&(this._autoScrollComplete=!1),this._scrollContainerY>=0&&this.fireAncestors("$scrollChanged","endUp",this),this._isEndContentVisible&&(this._isEndContentVisible=!1,this._updateFadeContainer());}}},{key:"resetScroll",value:function resetScroll(){this._ScrollContainer.y=0,this._Slider.value=0,this._ScrollContainer.transition("y").finish(),delete this._ScrollContainer._transitions,this._autoScrollComplete=!1;}},{key:"_setAutoScroll",value:function _setAutoScroll(t){return this._autoScroll!==t&&(this._autoScroll=t),this._setupAutoScroll(),t}},{key:"_setupAutoScroll",value:function _setupAutoScroll(){var t=this;clearTimeout(this._startAutoScroll),clearTimeout(this._performAutoScrollTimer),this.autoScroll&&(this._startAutoScroll=setTimeout((function(){return t._performAutoScroll()}),isNaN(this.autoScrollDelay)?2e3:this.autoScrollDelay));}},{key:"_performAutoScroll",value:function _performAutoScroll(){var t=this;this.autoScroll&&!this._autoScrollComplete&&(this._Slider._handleDown(),this._performAutoScrollTimer=setTimeout((function(){return t._performAutoScroll()}),isNaN(this.autoScrollSpeed)?200:this.autoScrollSpeed));}},{key:"_setContent",value:function _setContent(t){return t!==this._content&&this.enabled&&(this._contentChanged=!0),t}},{key:"_updateScrollContainerSize",value:function _updateScrollContainerSize(t,e){this._sliderWidth!==e._Container.h&&(this._sliderWidth=e._Container.h,this._updateScrollContainer());}},{key:"_updateSlider",value:function _updateSlider(){var t=this._ScrollContainer.finalH-this.renderHeight,e=Math.ceil(t/this.scrollStep),n=this.renderHeight,i=n/e;this._Slider.patch({x:this.w-this._sliderWidth,w:n,min:0,max:n,step:i,onUp:this._scrollUp.bind(this),onDown:this._scrollDown.bind(this)});}},{key:"_contentWidth",get:function get(){return this.w-this.style.contentMarginLeft-this.style.sliderMarginLeft-this._sliderWidth}},{key:"_scrollContainerY",get:function get(){return this._ScrollContainer.transition("y").targetValue}},{key:"_scrollAnimation",get:function get(){var t=isNaN(this.scrollDuration)?this.style.scroll.duration:this.scrollDuration;return _objectSpread(_objectSpread({},this.style.scroll),{},{duration:t})}},{key:"_getFocused",value:function _getFocused(){return this._Slider}},{key:"announce",get:function get(){return this._announce?this._announce:Array.isArray(this.content)?this._ScrollContainer&&this._ScrollContainer.children&&this._ScrollContainer.children.length?this._ScrollContainer.children.map((function(t){return t.announce})):this.content.map((function(t){return t.announce||t.text})):this.content},set:function set(t){_set(_getPrototypeOf(ScrollWrapper.prototype),"announce",t,this,!0);}}],[{key:"__themeStyle",get:function get(){return Ze}},{key:"_template",value:function _template(){return {clipping:!0,FadeContainer:{ScrollContainer:{w:function w(t){return t},wordWrap:!0}},Slider:{type:en,vertical:!0,signals:{onChange:"_updateScrollContainerSize"},announce:" "}}}},{key:"__componentName",get:function get(){return "ScrollWrapper"}},{key:"properties",get:function get(){return ["autoScroll","autoScrollDelay","autoScrollSpeed","content","fadeContent","scrollDuration","scrollStep","showScrollBar","shouldWrap","flexDirection"]}},{key:"tags",get:function get(){return ["FadeContainer","Slider",{name:"ScrollContainer",path:"FadeContainer.ScrollContainer"},{name:"ScrollableText",path:"ScrollContainer.ScrollableText"}]}}]),ScrollWrapper})();var rn=Object.freeze({__proto__:null,base:function base$6(t){return {alpha:t.alpha.none,animation:t.animation.standardEntrance,blur:t.spacer.xxl,color:t.color.shadowNeutralFocus,offsetX:0,offsetY:t.spacer.lg,radius:t.radius.md,spread:-1*t.spacer.md,maxOffsetY:t.spacer.xxl,maxOffsetX:0}},mode:function mode$1(t){return {focused:{alpha:t.alpha.secondary,offsetY:t.spacer.xxl}}},tone:function tone$3(t){return {neutral:{color:t.color.shadowNeutralFocus},inverse:{color:t.color.shadowInverseFocus},brand:{color:t.color.shadowBrandFocus}}}});(function(e){_inherits(Shadow,G);var n=_createSuper(Shadow);function Shadow(){return _classCallCheck(this,Shadow),n.apply(this,arguments)}return _createClass(Shadow,[{key:"_updateFocusStyle",value:function _updateFocusStyle(){this._Shadow&&this.applySmooth(this._Shadow,{alpha:this.style.alpha,y:this.style.offsetY,x:this.style.offsetX},{alpha:[this.style.alpha,this.style.animation],y:[this.style.offsetY,this.style.animation],x:[this.style.offsetX,this.style.animation]});}},{key:"_update",value:function _update(){var e=this.style.spread+2*this.style.blur,n=this.style.maxOffsetY,i=this.style.maxOffsetX;this.patch({Frame:{w:this.w+2*e+i,h:this.h+2*e+n,x:(this.w+i)/2,y:(this.h+n)/2,mount:.5,rtt:this.maskShadow,shader:this.maskShadow?{type:t.shaders.Hole,w:this.w-4,h:this.h-4,x:e+2,y:e+2,radius:this.style.radius}:void 0,Shadow:{color:this.style.color,texture:t.Tools.getShadowRect(this.w+2*this.style.spread,this.h+2*this.style.spread,this.style.radius,this.style.blur)}}}),void 0===this.shouldSmooth&&(this.shouldSmooth=!0),this._updateFocusStyle();}}],[{key:"__componentName",get:function get(){return "Shadow"}},{key:"__themeStyle",get:function get(){return rn}},{key:"properties",get:function get(){return ["maskShadow"]}},{key:"tags",get:function get(){return ["Frame",{name:"Shadow",path:"Frame.Shadow"}]}}]),Shadow})();var sn=Object.freeze({__proto__:null,base:function base$5(t){var e=t.spacer.xxl;return {width:e,height:e,radius:e/2}}});(function(t){_inherits(SliderLarge,qe);var e=_createSuper(SliderLarge);function SliderLarge(){return _classCallCheck(this,SliderLarge),e.apply(this,arguments)}return _createClass(SliderLarge,null,[{key:"__componentName",get:function get(){return "SliderLarge"}},{key:"__themeStyle",get:function get(){return sn}}]),SliderLarge})();var cn=function(t){_inherits(ContentSwitcher,G);var e=_createSuper(ContentSwitcher);function ContentSwitcher(){return _classCallCheck(this,ContentSwitcher),e.apply(this,arguments)}return _createClass(ContentSwitcher,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(ContentSwitcher.prototype),"_construct",this).call(this),this._selectedIndex=0,this._contentItems=[];}},{key:"_update",value:function _update(){_get(_getPrototypeOf(ContentSwitcher.prototype),"_update",this).call(this),this._updateSelected();}},{key:"_updateSelected",value:function _updateSelected(){var t=this;if(this._preveSelectedIndex!==this.selectedIndex){if(void 0!==this._preveSelectedIndex){var e=this.tag("Content".concat(this._preveSelectedIndex));e.smooth={alpha:0},this._hasContent?e._getTransition("alpha").once("finish",(function(){t._fadeInContent();})):void 0!==this.selectedIndex&&this._fadeInContent();}else this._hasContent&&this._fadeInContent();this._preveSelectedIndex=this.selectedIndex;}}},{key:"_fadeInContent",value:function _fadeInContent(){var t=this;this._selectedContent.smooth={alpha:1},this._selectedContent._getTransition("alpha").once("finish",(function(){t.h=t._selectedContent.h,t.signal("contentHeightChange",t.h);}));}},{key:"_updateContent",value:function _updateContent(){var t=this,e=this.contentItems.reduce((function(e,n,i){var o,r="Content".concat(i);if("function"==typeof n){var a=n();a.then?t._loadAsyncComponent(a,i):o=a;}else o=n;return o&&(e[r]=_objectSpread(_objectSpread({},o),{},{alpha:0})),e}),{});this.patch(e);}},{key:"_loadAsyncComponent",value:function _loadAsyncComponent(t,e){var n=this;t.then((function(t){var i="Content".concat(e);n.patch(_defineProperty$1({},i,_objectSpread(_objectSpread({},t),{},{alpha:0})));}));}},{key:"contentItems",get:function get(){return this._contentItems},set:function set(t){stringifyCompare(t,this._contentItems)||(this._contentItems=t,this._updateContent());}},{key:"_hasContent",get:function get(){return this._selectedContent&&this._selectedContent.children.length>0}},{key:"_selectedContent",get:function get(){return this.tag("Content".concat(this.selectedIndex))}},{key:"_getFocused",value:function _getFocused(){if(this._hasContent)return this._selectedContent}}],[{key:"__componentName",get:function get(){return "ContentSwitcher"}},{key:"properties",get:function get(){return ["selectedIndex"]}}]),ContentSwitcher}(),un=Object.freeze({__proto__:null,base:function base$4(t){return {tabSpacing:t.spacer.lg,tabsMarginBottom:t.spacer.xxl}}});(function(t){_inherits(TabBar,G);var e=_createSuper(TabBar);function TabBar(){return _classCallCheck(this,TabBar),e.apply(this,arguments)}return _createClass(TabBar,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(TabBar.prototype),"_construct",this).call(this),this._tabContent=[],this._isTabsFocused=!0;}},{key:"_selectedTabChange",value:function _selectedTabChange(){return "object"===_typeof(this._tabContent)&&"function"==typeof this._tabContent.then?this._tabContent.then(this.queueRequestUpdate):this.queueRequestUpdate()}},{key:"_update",value:function _update(){this._updateTabsLayout(),this._updateTabs(),this._updateTabContent(),this._updateTabBarHeight();}},{key:"_updateTabsLayout",value:function _updateTabsLayout(){var t=this,e={style:{itemSpacing:this.style.tabSpacing}},n=ht.properties.reduce((function(e,n){return null!=t[n]&&(e[n]=t[n]),e}),e);this._Tabs.patch(n);}},{key:"_updateTabs",value:function _updateTabs(){var t=this;this._Tabs.wrapSelected=this.wrapSelected,this._Tabs.items.forEach((function(e){var n=e===t._Tabs.selected;t._isUnfocusedMode?e.mode="unfocused":t._isFocusedMode&&(t._isTabsFocused?e.mode=n?"focused":"unfocused":e.mode=n?"selected":"unfocused");})),this.alphaSelectedTab&&this._updateTabAlphas();}},{key:"_updateTabAlphas",value:function _updateTabAlphas(){var t=this;this._isTabsFocused?this._Tabs.items.forEach((function(t){t.patch({alpha:1});})):this._Tabs.items.forEach((function(e){e.patch({alpha:e===t._Tabs.selected?1:.3});}));}},{key:"_updateTabContent",value:function _updateTabContent(){var t=this.style.tabsMarginBottom;this._TabContent.patch({y:this._Tabs.h+t,contentItems:this._tabContent,selectedIndex:this._isFocusedMode?this._Tabs.selectedIndex:void 0});}},{key:"_updateTabBarHeight",value:function _updateTabBarHeight(){var t;t=this.collapse?this._isFocusedMode&&this._tabContent.filter((function(t){return Object.keys(t).length})).length?this._expandedHeight:this._collapsedHeight:this._expandedHeight,this._TabContent.smooth={alpha:!this.collapse||this._isFocusedMode?1:.001},this.h!==t&&(this.h=t,this.fireAncestors("$itemChanged"));}},{key:"selectTabs",value:function selectTabs(){this._isTabsFocused||(this._isTabsFocused=!0,this._updateTabs(),this._updateTabBarHeight());}},{key:"resetTabs",value:function resetTabs(){this._Tabs.selectedIndex=0;}},{key:"_handleDown",value:function _handleDown(){this._isTabsFocused&&this._TabContent._hasContent&&(this._isTabsFocused=!1,this._updateTabs(),this._updateTabBarHeight());}},{key:"_handleUp",value:function _handleUp(){this.selectTabs();}},{key:"_setTabs",value:function _setTabs(t){return this._tabContent=[],this._tabContent=t.map((function(t){return t.tabContent||{}})),this._Tabs.items=t,t}},{key:"_collapsedHeight",get:function get(){return this._Tabs.h}},{key:"_expandedHeight",get:function get(){return this._Tabs.h+this.style.tabsMarginBottom+this._TabContent.h}},{key:"_getFocused",value:function _getFocused(){return this._isTabsFocused?this._Tabs:this._TabContent}},{key:"_unfocus",value:function _unfocus(){_get(_getPrototypeOf(TabBar.prototype),"_unfocus",this).call(this),this.reset&&this.resetTabs();}}],[{key:"_template",value:function _template(){return {Tabs:{type:ht,autoResizeHeight:!0,signals:{selectedChange:"_selectedTabChange"}},TabContent:{type:cn,signals:{contentHeightChange:"_updateTabBarHeight"}}}}},{key:"__themeStyle",get:function get(){return un}},{key:"__componentName",get:function get(){return "TabBar"}},{key:"properties",get:function get(){return ["alphaSelectedTab","collapse","reset","tabs","wrapSelected"].concat(_toConsumableArray(ht.properties))}},{key:"tags",get:function get(){return ["Tabs","TabContent"]}}]),TabBar})();var dn=Object.freeze({__proto__:null,base:function base$3(t){return {radius:t.radius.xl,paddingX:t.spacer.xxxl+t.spacer.xxs,paddingY:t.spacer.md+t.spacer.xs,noTitlePaddingX:t.spacer.xl,iconSize:t.spacer.xxxl,iconMarginRight:t.spacer.md,textStyle:_objectSpread(_objectSpread({},t.typography.headline3),{},{textColor:t.color.textNeutral}),backgroundColor:t.color.fillTransparent,contentColor:t.color.fillNeutral}},mode:function mode(t){return {focused:{backgroundColor:t.color.interactiveNeutralFocus,contentColor:t.color.fillInverse,textStyle:{textColor:t.color.textInverse}},selected:{backgroundColor:t.color.interactiveNeutralFocusSoft,contentColor:t.color.fillNeutral,textStyle:{textColor:t.color.textNeutral}},disabled:{backgroundColor:t.color.fillTransparent,contentColor:t.color.fillNeutralDisabled,textStyle:{textColor:t.color.textNeutralDisabled}}}},tone:function tone$2(t){return {neutral:{},inverse:{mode:{focused:{contentColor:t.color.fillNeutral,textStyle:{textColor:t.color.textNeutral}}}},brand:{mode:{focused:{contentColor:t.color.fillNeutral,textStyle:{textColor:t.color.textNeutral}}}}}}});(function(t){_inherits(Tab,pt);var e=_createSuper(Tab);function Tab(){return _classCallCheck(this,Tab),e.apply(this,arguments)}return _createClass(Tab,[{key:"_onTextBoxChanged",value:function _onTextBoxChanged(){this._updateContent(),this._updateTabSize();}},{key:"_update",value:function _update(){_get(_getPrototypeOf(Tab.prototype),"_update",this).call(this),this._updateIcon(),this._updateText(),this._updateContent(),this._updateTabSize();}},{key:"_updateIcon",value:function _updateIcon(){if(this.icon){var t={icon:this.icon,w:this.style.iconSize,h:this.style.iconSize,y:this._Content.h/2,style:{color:this.style.contentColor}};this.title?(t.x=0,t.mountX=0):(t.x=this._Content.w/2,t.mountX=.5),this._Icon?this._Icon.patch(t):this._Content.patch({Icon:_objectSpread({type:nt,mountY:.5},t)});}else this._Content.patch({Icon:void 0});}},{key:"_updateText",value:function _updateText(){var t={content:this.title,style:{textStyle:this.style.textStyle},y:this._Content.h/2};this.icon?(t.x=this._iconW+this.style.iconMarginRight,t.mountX=0):(t.x=this._Content.w/2,t.mountX=.5),this._Text.patch(t);}},{key:"_updateContent",value:function _updateContent(){this._Content.patch({w:this._iconW+(this.title?this.style.iconMarginRight:0)+this._textW,h:Math.max(this._iconH,this._Text.h)});}},{key:"_updateTabSize",value:function _updateTabSize(){this.title||this.icon?this.patch({w:2*this._paddingX+this._Content.w,h:2*this.style.paddingY+this._Content.h}):this.patch({w:0,h:0});}},{key:"_textW",get:function get(){return this.title?this._Text.w:0}},{key:"_iconW",get:function get(){return this.icon?this._Icon.w:0}},{key:"_iconH",get:function get(){return this.icon?this._Icon.h:0}},{key:"_paddingX",get:function get(){return this.title?this.style.paddingX:this.style.noTitlePaddingX}},{key:"announce",get:function get(){return this._announce||this._Text&&this._Text.announce},set:function set(t){_set(_getPrototypeOf(Tab.prototype),"announce",t,this,!0);}}],[{key:"_template",value:function _template(){return _objectSpread(_objectSpread({},_get(_getPrototypeOf(Tab),"_template",this).call(this)),{},{Content:{mount:.5,x:function x(t){return t/2},y:function y(t){return t/2},Text:{type:St,mountY:.5,signals:{textBoxChanged:"_onTextBoxChanged"}}}})}},{key:"__themeStyle",get:function get(){return dn}},{key:"__componentName",get:function get(){return "Tab"}},{key:"properties",get:function get(){return ["icon","title"]}},{key:"tags",get:function get(){return [].concat(_toConsumableArray(_get(_getPrototypeOf(Tab),"tags",this)),["Content",{name:"Icon",path:"Content.Icon"},{name:"Text",path:"Content.Text"}])}}]),Tab})();var _n=Object.freeze({__proto__:null,base:function base$2(t){return {height:t.spacer.xxl,knobWidth:t.spacer.xl,knobHeight:t.spacer.xl,knobRadius:t.radius.sm+t.radius.xs,knobPadding:t.spacer.xxs,knobX:t.spacer.xs,knobXChecked:t.spacer.xxl+t.spacer.xs,strokeRadius:t.radius.md,strokeWeight:t.stroke.sm,width:2*t.spacer.xxl}},tone:function tone$1(t){return {neutral:{strokeColor:t.color.fillInverse,backgroundColor:t.color.fillNeutralDisabled,backgroundColorChecked:t.color.fillNeutral,knobColor:t.color.fillInverse,knobColorChecked:t.color.fillInverse,mode:{disabled:{strokeColor:t.color.fillInverseDisabled,backgroundColor:t.color.fillNeutralDisabled,backgroundColorChecked:t.color.fillNeutralDisabled,knobColor:t.color.fillInverseDisabled,knobColorChecked:t.color.fillInverseDisabled}}},inverse:{strokeColor:t.color.fillNeutral,backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillInverse,knobColor:t.color.fillNeutral,knobColorChecked:t.color.fillNeutral,mode:{disabled:{strokeColor:t.color.fillInverseDisabled,backgroundColor:t.color.fillNeutralDisabled,backgroundColorChecked:t.color.fillNeutralDisabled,knobColor:t.color.fillInverseDisabled,knobColorChecked:t.color.fillInverseDisabled}}},brand:{strokeColor:t.color.fillNeutral,backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillBrand,knobColor:t.color.fillNeutral,knobColorChecked:t.color.fillNeutral,mode:{disabled:{strokeColor:t.color.fillNeutralDisabled,backgroundColor:t.color.fillInverseDisabled,backgroundColorChecked:t.color.fillInverseDisabled,knobColor:t.color.fillNeutralDisabled,knobColorChecked:t.color.fillNeutralDisabled}}}}}}),yn=function(e){_inherits(Toggle,G);var n=_createSuper(Toggle);function Toggle(){return _classCallCheck(this,Toggle),n.apply(this,arguments)}return _createClass(Toggle,[{key:"_construct",value:function _construct(){_get(_getPrototypeOf(Toggle.prototype),"_construct",this)&&_get(_getPrototypeOf(Toggle.prototype),"_construct",this).call(this),this._checked=!1;}},{key:"_update",value:function _update(){this._updateKnobPosition(),this._updateColors(),this._updateContainer(),this._updateStroke(),this._updateKnob(),this._checkedChanged&&(this.fireAncestors("$announce",this.announce),this._checkedChanged=!1);}},{key:"_updateKnobPosition",value:function _updateKnobPosition(){var t=this.style,e=t.knobXChecked,n=t.knobX,i=t.knobPadding,o=t.knobWidth,r=t.strokeWeight;this._knobX=n||r+i,this._knobXChecked=e||this.w-r-i-o;var a=this.checked?this._knobXChecked:this._knobX;this.applySmooth(this._Knob,{x:a});}},{key:"_updateColors",value:function _updateColors(){var t=this.style,e=t.backgroundColor,n=t.backgroundColorChecked,i=t.knobColor,o=t.knobColorChecked,r=this.checked?o:i,a=this.checked?n:e;this.applySmooth(this._Knob,{color:r}),this.applySmooth(this._Container,{color:a});}},{key:"_updateContainer",value:function _updateContainer(){var e,n=this.style,i=n.knobRadius,o=n.knobPadding,r=n.strokeRadius,a=n.strokeWeight;e=void 0!==r?0===r?0:Math.max(0,r-a):Math.max(0,i+o+a),this._Container.patch({w:this.w,h:this.h,texture:t.Tools.getRoundRect(this.w-2*a,this.h-2*a,e,a,0,!0,!1)});}},{key:"_updateStroke",value:function _updateStroke(){var e=this.style,n=e.knobRadius,i=e.knobPadding,o=e.strokeColor,r=e.strokeRadius,a=e.strokeWeight;this._Stroke.patch({w:this.w,h:this.h,texture:t.Tools.getRoundRect(this.w,this.h,void 0!==r?r:n+i+a,a,o,!1,!1)});}},{key:"_updateKnob",value:function _updateKnob(){var e=this.style,n=e.knobHeight,i=e.knobWidth,o=e.knobRadius;this._Knob.patch({zIndex:2,y:(this.h-n)/2,texture:t.Tools.getRoundRect(i-2,n-2,o,0,0,!0,!1)});}},{key:"_setChecked",value:function _setChecked(t){return this._checkedChanged=t!==this._checked,t}},{key:"toggle",value:function toggle(){return this._isDisabledMode||(this.checked=!this.checked),this}},{key:"_handleEnter",value:function _handleEnter(){return "function"==typeof this.onEnter?this.onEnter(this):(this.toggle(),!1)}},{key:"announce",get:function get(){return this._announce||(this.checked?"Checked":"Unchecked")},set:function set(t){_set(_getPrototypeOf(Toggle.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Toggle"}},{key:"__themeStyle",get:function get(){return _n}},{key:"_template",value:function _template(){return {Container:{Stroke:{},Knob:{}}}}},{key:"tags",get:function get(){return ["Container",{name:"Knob",path:"Container.Knob"},{name:"Stroke",path:"Container.Stroke"}]}},{key:"properties",get:function get(){return ["checked"]}}]),Toggle}(),fn=Object.freeze({__proto__:null,base:function base$1(t){return {height:3*t.spacer.md,strokeRadius:.75*t.radius.md,strokeWeight:t.stroke.sm,knobWidth:t.spacer.lg,knobHeight:t.spacer.lg,knobRadius:t.radius.sm,knobPadding:t.spacer.xs,knobXChecked:t.spacer.xl+t.spacer.xs,width:6*t.spacer.md}}});(function(t){_inherits(ToggleSmall,yn);var e=_createSuper(ToggleSmall);function ToggleSmall(){return _classCallCheck(this,ToggleSmall),e.apply(this,arguments)}return _createClass(ToggleSmall,null,[{key:"__componentName",get:function get(){return "ToggleSmall"}},{key:"__themeStyle",get:function get(){return fn}}]),ToggleSmall})();(function(e){_inherits(Circle,t.Texture);var n=_createSuper(Circle);function Circle(t){var e;return _classCallCheck(this,Circle),(e=n.call(this,t))._color="rgb(0,0,0)",e._fill=!0,e._radius=100,e._stroke=!1,e._strokeColor="rgb(0,0,0)",e._strokeWidth=1,e}return _createClass(Circle,[{key:"fill",get:function get(){return this._fill},set:function set(t){this._fill=t,this._changed();}},{key:"radius",get:function get(){return this._radius},set:function set(t){this._radius=t,this._changed();}},{key:"color",get:function get(){return this._color},set:function set(t){this._color=t,this._changed();}},{key:"stroke",get:function get(){return this._stroke},set:function set(t){this._stroke=t,this._changed();}},{key:"strokeWidth",get:function get(){return this._strokeWidth},set:function set(t){this._strokeWidth=t,this._changed();}},{key:"strokeColor",get:function get(){return this._strokeColor},set:function set(t){this._strokeColor=t,this._changed();}},{key:"_getLookupId",value:function _getLookupId(){return "__circle_".concat(this._radius)}},{key:"_getSourceLoader",value:function _getSourceLoader(){var t=this._color,e=this._fill,n=this._radius,i=this._stroke,o=this._strokeColor,r=this._strokeWidth,a=this.stage.platform.getDrawingCanvas(),s=n;return i&&(s=n+2*r),a.width=2*s,a.height=2*s,function(l){var c=a.getContext("2d");c.lineWidth=r,c.strokeStyle=o,c.fillStyle=t,c.beginPath(),c.arc(s,s,n,0,2*Math.PI),e&&c.fill(),i&&c.stroke(),l(null,{source:a,radius:n});}}}]),Circle})();(function(e){_inherits(Arrow,t.Texture);var n=_createSuper(Arrow);function Arrow(t){var e;return _classCallCheck(this,Arrow),(e=n.call(this,t))._color="rgb(13, 13, 15)",e._w=0,e._h=0,e._direction="right",e}return _createClass(Arrow,[{key:"w",get:function get(){return this._w},set:function set(t){this._w=t,this._changed();}},{key:"h",get:function get(){return this._h},set:function set(t){this._h=t,this._changed();}},{key:"direction",get:function get(){return this._direction},set:function set(t){this._direction=t,this._changed();}},{key:"color",get:function get(){return this._color},set:function set(t){this._color=t,this._changed();}},{key:"_getLookupId",value:function _getLookupId(){return "__triangle_".concat(this._direction,"_").concat(this._w,"x").concat(this._h)}},{key:"_getSourceLoader",value:function _getSourceLoader(){var t=this._color,e=this._w,n=this._h,i=this._direction,o=this.stage.platform.getDrawingCanvas();return function(r){var a=o.getContext("2d");o.width=e,o.height=n,a.fillStyle=t,a.strokeStyle=a.fillStyle,a.lineWidth=2,a.lineCap="round",a.lineJoin="round";var s=a.lineWidth/2;a.beginPath(),"right"===i?(a.moveTo(s,s),a.lineTo(s,n-s),a.lineTo(e-s,n/2)):"down"===i?(a.moveTo(s,s),a.lineTo(e-s,s),a.lineTo(e/2,n-s)):(a.moveTo(s,n/2),a.lineTo(e-s,s),a.lineTo(e-s,n-s)),a.closePath(),a.stroke(),a.fill(),r(null,{source:o,w:e,h:n,direction:i});}}}]),Arrow})();(function(e){_inherits(Line,t.Texture);var n=_createSuper(Line);function Line(t){var e;return _classCallCheck(this,Line),(e=n.call(this,t))._w=0,e._h=0,e._rounded=!1,e}return _createClass(Line,[{key:"w",get:function get(){return this._w},set:function set(t){this._w=t,this._changed();}},{key:"h",get:function get(){return this._h},set:function set(t){this._h=t,this._changed();}},{key:"rounded",get:function get(){return this._rounded},set:function set(t){this._rounded=t,this._changed();}},{key:"_getLookupId",value:function _getLookupId(){return "__line_".concat(this._w,"x").concat(this._h).concat(this._rounded?"_rounded":"")}},{key:"_getSourceLoader",value:function _getSourceLoader(){var t=this._w,e=this._h,n=this._rounded,i=this.stage.platform.getDrawingCanvas();return function(o){var r=i.getContext("2d");i.width=t,i.height=e,r.lineWidth=e,n&&(r.lineCap="round"),r.strokeStyle="white",r.beginPath(),r.moveTo(n?2:0,e/2),r.lineTo(n?t-2:t,e/2),r.stroke(),o(null,{source:i,w:t,h:e,rounded:n});}}}]),Line})();var bn=function(e){_inherits(Bubble,t.Texture);var n=_createSuper(Bubble);function Bubble(t){var e;return _classCallCheck(this,Bubble),(e=n.call(this,t))._w=0,e._h=0,e._radius=0,e._pointerW=0,e._pointerH=0,e._strokeWidth=0,e._color="white",e}return _createClass(Bubble,[{key:"w",get:function get(){return this._w},set:function set(t){this._w=t,this._changed();}},{key:"h",get:function get(){return this._h},set:function set(t){this._h=t,this._changed();}},{key:"radius",get:function get(){return this._radius},set:function set(t){Array.isArray(t)?this._radius=new Array(4).fill().map((function(e,n){return t[n]||0})):this._radius=t,this._changed();}},{key:"pointerW",get:function get(){return this._pointerW},set:function set(t){this._pointerW=t,this._changed();}},{key:"pointerH",get:function get(){return this._pointerH},set:function set(t){this._pointerH=t,this._changed();}},{key:"strokeWidth",get:function get(){return this._strokeWidth},set:function set(t){this._strokeWidth=t,this._changed();}},{key:"color",get:function get(){return this._color},set:function set(e){this._color=t.StageUtils.getRgbaString(e),this._changed();}},{key:"createBubble",value:function createBubble(t){var e=t.stage,n=t.w,i=void 0===n?0:n,o=t.h,r=void 0===o?0:o,a=t.radius,s=void 0===a?0:a,l=t.pointerW,c=void 0===l?0:l,u=t.pointerH,h=void 0===u?0:u,d=t.strokeWidth,p=void 0===d?1:d,_=t.color,f=void 0===_?"white":_,g=e.platform.getDrawingCanvas(),m=g.getContext("2d");g.width=i+p+4,g.height=r+p+4,m.imageSmoothingEnabled=!0,m.fillStyle=f,m.strokeStyle=f,m.lineWidth=p,m.lineCap="round",m.lineJoin="round";var v=.5*p+1,b=v,k=b+i,S=v,C=S+r,T=C-h,I=Array.isArray(s);return m.beginPath(),m.moveTo(b+(I?s[0]:s),S),m.lineTo(k-(I?s[0]:s),S),m.arcTo(k,S,k,S+(I?s[1]:s),I?s[1]:s),m.lineTo(k,T-(I?s[2]:s)),m.arcTo(k,T,k-(I?s[2]:s),T,I?s[2]:s),m.lineTo(i/2+c/2,T),m.arcTo(i/2,C,i/2-c/2,T,2),m.lineTo(i/2-c/2,T),m.lineTo(b+(I?s[3]:s),T),m.arcTo(b,T,b,T-(I?s[3]:s),I?s[3]:s),m.lineTo(b,S+(I?s[0]:s)),m.arcTo(b,S,b+(I?s[0]:s),S,I?s[0]:s),m.stroke(),m.fill(),g}},{key:"_getLookupId",value:function _getLookupId(){var t=this.w,e=this.h,n=this.radius,i=this.pointerW,o=this.pointerH,r=this.color;return "__bubble_".concat(t,"x").concat(e,"_radius-").concat(n,"_pointer-").concat(i,"x").concat(o,"_fill-").concat(r)}},{key:"_getSourceLoader",value:function _getSourceLoader(){var t=this;return function(e){e(null,{source:t.createBubble(t)});}}}]),Bubble}(),kn=Object.freeze({__proto__:null,base:function base(t){return {marginBottom:t.spacer.xxxl,paddingX:t.spacer.lg,paddingY:t.spacer.md,pointerWidth:t.spacer.xl,pointerHeight:t.spacer.md+t.spacer.xs,radius:t.radius.md,textStyle:_objectSpread(_objectSpread({},t.typography.caption1),{},{textColor:t.color.textInverse}),transition:t.animation.utility}},tone:function tone(t){return {neutral:{backgroundColor:t.color.fillNeutral,textStyle:{textColor:t.color.textInverse}},inverse:{backgroundColor:t.color.fillInverse,textStyle:{textColor:t.color.textNeutral}},brand:{backgroundColor:t.color.fillBrand,textStyle:{textColor:t.color.textNeutral}}}}});(function(t){_inherits(Tooltip,G);var e=_createSuper(Tooltip);function Tooltip(){return _classCallCheck(this,Tooltip),e.apply(this,arguments)}return _createClass(Tooltip,[{key:"_update",value:function _update(){this._updateText();}},{key:"_updateText",value:function _updateText(){this._Text&&this._Text.patch({content:this.title,style:{textStyle:this.style.textStyle}});}},{key:"_textLoaded",value:function _textLoaded(){this._updateBackground(),this._updateTextPosition();}},{key:"_updateBackground",value:function _updateBackground(){var t=this._Text.finalH+2*this.style.paddingY+this.style.pointerHeight,e=this._Text.finalW+2*this.style.paddingX;this.patch({w:e,h:t,mountY:1,y:-this.style.marginBottom,Background:{w:e,h:t,texture:{type:bn,w:e,h:t,radius:this.style.radius,pointerWidth:this.style.pointerWidth,pointerHeight:this.style.pointerHeight,color:this.style.backgroundColor}}});}},{key:"_updateTextPosition",value:function _updateTextPosition(){this._Text&&this._Text.patch({mount:.5,x:this._Background.w/2,y:(this._Background.h-this.style.pointerHeight)/2});}},{key:"_clearTimers",value:function _clearTimers(){clearTimeout(this._hideTimer),clearTimeout(this._showTimer);}},{key:"_transitionIn",value:function _transitionIn(){var t=this,e={smooth:{alpha:[1,this.style.transition],scale:[1,this.style.transition]}};this.delayVisible?this._showTimer=setTimeout((function(){t.patch({smooth:e});}),this.delayVisible):(this._showTimer=void 0,this.patch({smooth:e})),this._hideTimer=this.timeVisible?setTimeout((function(){t._unfocus();}),this.timeVisible+(this.delayVisible||0)):void 0;}},{key:"_transitionOut",value:function _transitionOut(){this.patch({smooth:{alpha:[0,this.style.transition],scale:[.5,this.style.transition]}});}},{key:"_focus",value:function _focus(){this._clearTimers(),this._transitionIn();}},{key:"_unfocus",value:function _unfocus(){this._clearTimers(),this._transitionOut();}},{key:"announce",get:function get(){return this._announce||this._Text&&this._Text.announce},set:function set(t){_set(_getPrototypeOf(Tooltip.prototype),"announce",t,this,!0);}}],[{key:"__componentName",get:function get(){return "Tooltip"}},{key:"__themeStyle",get:function get(){return kn}},{key:"_template",value:function _template(){return {alpha:0,scale:.5,mountX:.5,x:function x(t){return t/2},Background:{Text:{type:St,signals:{textBoxChanged:"_textLoaded"}}}}}},{key:"properties",get:function get(){return ["title","delayVisible","timeVisible"]}},{key:"tags",get:function get(){return ["Background",{name:"Text",path:"Background.Text"}]}},{key:"aliasStyles",get:function get(){return [{prev:"pointerH",curr:"pointerHeight"},{prev:"pointerW",curr:"pointerWidth"}]}}]),Tooltip})();

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let platform = null;
  let thunder$c = null;
  function thunderJS() {
    if (thunder$c) return thunder$c;
    thunder$c = thunderJS$1({
      host: window.location.hostname,
      port: '9998'
    });
    return thunder$c;
  }
  async function registerListener(plugin, eventname, cb) {
    return await thunderJS().on(plugin, eventname, notification => {
      console.log("DACApi Received event " + plugin + ":" + eventname, notification);
      if (cb != null) {
        cb(notification, eventname, plugin);
      }
    });
  }
  async function addEventHandler(eventHandlers, pluginname, eventname, cb) {
    eventHandlers.push(await registerListener(pluginname, eventname, cb));
  }
  function translateLisaProgressEvent(evtname) {
    if (evtname === "DOWNLOADING") {
      return "Downloading";
    } else if (evtname === "UNTARING") {
      return "Extracting";
    } else if (evtname === "UPDATING_DATABASE") {
      return "Installing";
    } else if (evtname === "FINISHED") {
      return "Finished";
    } else {
      return evtname;
    }
  }
  async function registerLISAEvents(id, progress) {
    let eventHandlers = [];
    if (progress === undefined) {
      console.log("DACApi progress undefined, return");
      return;
    }
    progress.reset();
    let handleProgress = (notification, eventname, plugin) => {
      console.log('DACApi handleProgress: ' + plugin + ' ' + eventname);
      if (plugin !== 'LISA') {
        return;
      }
      if (notification.status === 'Progress') {
        let parts = notification.details.split(" ");
        if (parts.length >= 2) {
          let pc = parseFloat(parts[1]) / 100.0;
          progress.setProgress(pc, translateLisaProgressEvent(parts[0]));
        }
      } else if (notification.status === 'Success') {
        progress.fireAncestors('$fireDACOperationFinished', true);
        eventHandlers.map(h => {
          h.dispose();
        });
        eventHandlers = [];
      } else if (notification.status === 'Failed') {
        progress.fireAncestors('$fireDACOperationFinished', false, 'Failed');
        eventHandlers.map(h => {
          h.dispose();
        });
        eventHandlers = [];
      }
    };
    addEventHandler(eventHandlers, 'LISA', 'operationStatus', handleProgress);
  }
  const installDACApp = async (app, progress) => {
    let platName = await getPlatformNameForDAC();
    let url = app.url;
    if (!Storage$1.get("CloudAppStore")) {
      url = app.url.replace(/ah212/g, platName);
    }
    registerLISAEvents(app.id, progress);
    let result = null;
    let param = {
      id: app.id,
      type: 'application/dac.native',
      appName: app.name,
      category: app.category,
      versionAsParameter: app.version,
      url: url
    };
    try {
      console.info("installDACApp LISA.install with param:", JSON.stringify(param));
      result = await thunderJS()['LISA'].install(param);
    } catch (error) {
      console.error('DACApi Error on installDACApp: ' + error.code + ' ' + error.message);
      return false;
    }
    return true;
  };
  const uninstallDACApp = async (app, progress) => {
    // Could be same app is running; lets end it if so.
    await thunderJS()['org.rdk.RDKShell'].getClients().then(response => {
      if (Array.isArray(response.clients) && response.clients.includes(app.id.toLowerCase())) {
        console.log("DACApi killing " + app.id + " as we got a match in getClients response.");
        thunderJS()['org.rdk.RDKShell'].kill({
          client: app.id
        });
      }
    });
    registerLISAEvents(app.id, progress);
    let result = null;
    let param = {
      id: app.id,
      type: 'application/dac.native',
      versionAsParameter: app.version,
      uninstallType: 'full'
    };
    try {
      console.info("uninstallDACApp LISA.uninstall with params:", JSON.stringify(param));
      result = await thunderJS()['LISA'].uninstall(param);
    } catch (error) {
      console.error('DACApi Error on LISA uninstall: ' + error.code + ' ' + error.message);
      return false;
    }
    return true;
  };
  const getInstalledDACApps = async () => {
    let result = null;
    try {
      result = await thunderJS()['LISA'].getList();
    } catch (error) {
      console.error('DACApi Error on LISA getList: ', error);
    }
    return result == null ? [] : result.apps ? result.apps : [];
  };
  const getPlatformNameForDAC = async () => {
    if (platform == null) {
      platform = await getDeviceName();
      platform = platform.split('-')[0];
      console.info("getPlatformNameForDAC platform after split: ", JSON.stringify(platform));
    }
    if (platform.startsWith('raspberrypi4')) {
      return 'rpi4';
    } else if (platform.startsWith('raspberrypi')) {
      return 'rpi3';
    } else if (platform === 'brcm972180hbc') {
      return '7218c';
    } else if (platform === 'brcm972127ott') {
      return '72127ott';
    } else if (platform === 'vip7802') {
      return '7218c';
    } else if (platform === 'm393') {
      return '7218c';
    } else if (platform.toLowerCase().includes('hp44h')) {
      return 'ah212';
    } else if (platform.toLowerCase().includes('amlogic')) {
      return 'ah212';
    } else if (platform.toLowerCase().includes('mediaclient')) {
      return 'rtd1319';
    } else if (platform.toLowerCase().includes('blade')) {
      return 'rtd1319';
    } else {
      // default
      return 'rpi3';
    }
  };
  const getDeviceName = async () => {
    let result = null;
    try {
      result = await thunderJS().DeviceInfo.systeminfo();
    } catch (error) {
      console.error('DAC Api Error on systeminfo: ', error);
    }
    return result == null ? "unknown" : result.devicename;
  };
  const startDACApp = async app => {
    console.log('DACApi startDACApp invoked with data:' + app);
    let result = null;
    try {
      if (app.type === 'application/dac.native') {
        result = await thunderJS()['org.rdk.RDKShell'].launchApplication({
          client: app.id,
          mimeType: app.type,
          uri: app.id + ';' + app.version + ';' + app.type,
          topmost: true,
          focus: true
        });
      } else if (app.type === 'application/html') {
        result = await thunderJS()['org.rdk.RDKShell'].launch({
          callsign: app.id,
          uri: app.url,
          type: 'HtmlApp'
        });
      } else if (app.type === 'application/lightning') {
        result = await thunderJS()['org.rdk.RDKShell'].launch({
          callsign: app.id,
          uri: app.url,
          type: 'LightningApp'
        });
      } else {
        console.warn('DACApi Unsupported app type: ' + app.type);
        return false;
      }
    } catch (error) {
      console.error('DACApi Error on launchApplication: ', error);
      return false;
    }
    if (result == null) {
      console.error('DACApi launch error returned result: ', result);
      return false;
    } else if (!result.success) {
      // Could be same app is in suspended mode.
      await thunderJS()['org.rdk.RDKShell'].getClients().then(response => {
        if (Array.isArray(response.clients) && response.clients.includes(app.id.toLowerCase())) {
          console.log("DACApi " + app.id + " got a match in getClients response; could be in suspended mode, resume it.");
          thunderJS()['org.rdk.RDKShell'].resumeApplication({
            client: app.id
          }).then(result => {
            if (!result.success) {
              return false;
            } else if (result.success) {
              if (Storage$1.get("applicationType") === "") {
                thunder$c.call('org.rdk.RDKShell', 'setVisibility', {
                  "client": "ResidentApp",
                  "visible": false
                });
              }
            }
          });
        }
      });
    } else if (result.success) {
      if (Storage$1.get("applicationType") === "") {
        thunder$c.call('org.rdk.RDKShell', 'setVisibility', {
          "client": "ResidentApp",
          "visible": false
        });
      }
    } else ;
    try {
      result = await thunderJS()['org.rdk.RDKShell'].moveToFront({
        client: app.id
      });
    } catch (error) {
      console.log('DACApi Error on moveToFront: ', error);
    }
    try {
      result = await thunderJS()['org.rdk.RDKShell'].setFocus({
        client: app.id
      });
      Storage$1.set("applicationType", app.id + ';' + app.version + ';' + app.type);
    } catch (error) {
      console.log('DACApi Error on setFocus: ', error);
      return false;
    }
    return result == null ? false : result.success;
  };

  /* WorkAround until proper cloud based App Catalog support */
  const getAppCatalogInfo = async () => {
    Storage$1.set("CloudAppStore", true);
    let appListArray = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("app-catalog-path")) {
          Storage$1.set("CloudAppStore", false);
          console.log("Fetching apps from local server");
          let url = data["app-catalog-path"];
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("DACApi fetch result: ", result);
            if (result.hasOwnProperty("applications")) {
              appListArray = result["applications"];
            } else {
              console.error("DACApi result does not have applications");
              Storage$1.set("CloudAppStore", true);
            }
          }).catch(error => {
            console.error("DACApi fetch error from local server", error);
            Storage$1.set("CloudAppStore", true);
          });
        } else if (Storage$1.get("CloudAppStore") && data.hasOwnProperty("app-catalog-cloud")) {
          console.log("Fetching apps from cloud server");
          let cloud_data = data["app-catalog-cloud"];
          let url = cloud_data["url"] + "?platform=arm:v7:linux&category=application";
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("DACApi fetch result: ", result);
            if (result.hasOwnProperty("applications")) {
              appListArray = result["applications"];
            } else {
              console.error("DACApi result does not have applications");
            }
          }).catch(error => console.log("DACApi fetch error from cloud", error));
        }
      } else {
        console.error("DACApi Appstore info not available; DAC features won't work.");
      }
    } catch (error) {
      console.log("DACApi Appstore info Error: ", error);
    }
    return appListArray == null ? undefined : appListArray;
  };
  const getFirmwareVersion = async () => {
    let firmwareVerList = null,
      firmwareVer = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("app-catalog-cloud")) {
          let cloud_data = data["app-catalog-cloud"];
          if (cloud_data.hasOwnProperty("firmwareVersions")) {
            firmwareVerList = cloud_data['firmwareVersions'];
            let i = 0;
            while (i < firmwareVerList.length) {
              if ((await getPlatformNameForDAC()) === firmwareVerList[i].platform) {
                firmwareVer = firmwareVerList[i].ver;
                break;
              }
              i += 1;
            }
            if (firmwareVer === null) console.error("Platform not supported");
          } else {
            console.error("Firmware version not available");
          }
        }
      } else {
        console.error("DACApi Appstore info not available; DAC features won't work.");
      }
    } catch (error) {
      console.log("DACApi Appstore info Error: ", error);
    }
    return firmwareVer;
  };
  const fetchAppIcon = async (id, version) => {
    let appIcon = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("app-catalog-cloud")) {
          let cloud_data = data["app-catalog-cloud"];
          let url = cloud_data["url"] + "/" + id + ":" + version + "?platformName=" + (await getPlatformNameForDAC()) + "&firmwareVer=" + (await getFirmwareVersion());
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("App fetch result: ", result);
            if (result.hasOwnProperty("header")) {
              appIcon = result.header.icon;
            } else {
              console.error("App does not have URL");
            }
          }).catch(error => console.log("App Icon fetch error", error));
        }
      } else {
        console.error("DACApi Appstore info not available; DAC features won't work.");
      }
    } catch (error) {
      console.log("DACApi Appstore info Error: ", error);
    }
    return appIcon == null ? undefined : appIcon;
  };
  const fetchLocalAppIcon = async id => {
    let appIcon = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("app-catalog-path")) {
          let url = data["app-catalog-path"];
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            if (result.hasOwnProperty("applications")) {
              let appListArray = result["applications"];
              for (let i = 0; i < appListArray.length; i++) {
                if (appListArray[i].id === id) {
                  appIcon = appListArray[i]["icon"];
                  break;
                }
              }
            } else {
              console.error("DACApi result does not have applications");
              Storage$1.set("CloudAppStore", true);
            }
          }).catch(error => console.log("App Icon fetch error", error));
        }
      } else {
        console.error("DACApi Appstore info not available; DAC features won't work.");
      }
    } catch (error) {
      console.log("DACApi Appstore info Error: ", error);
    }
    return appIcon == null ? undefined : appIcon;
  };
  const fetchAppUrl = async (id, version) => {
    let appUrl = null;
    try {
      let data = new HomeApi().getPartnerAppsInfo();
      if (data) {
        data = await JSON.parse(data);
        if (data != null && data.hasOwnProperty("app-catalog-cloud")) {
          let cloud_data = data["app-catalog-cloud"];
          let url = cloud_data["url"] + "/" + id + ":" + version + "?platformName=" + (await getPlatformNameForDAC()) + "&firmwareVer=" + (await getFirmwareVersion());
          await fetch(url, {
            method: 'GET',
            cache: "no-store"
          }).then(response => response.text()).then(result => {
            result = JSON.parse(result);
            console.log("App fetch result: ", result);
            if (result.hasOwnProperty("header")) {
              appUrl = result.header.url;
            } else {
              console.error("App does not have URL");
            }
          }).catch(error => console.log("App URL fetch error", error));
        }
      } else {
        console.error("DACApi Appstore info not available; DAC features won't work.");
      }
    } catch (error) {
      console.log("DACApi Appstore info Error: ", error);
    }
    return appUrl == null ? undefined : appUrl;
  };

  class AppStoreItem extends t.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xAA000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language$1.translate('Installing'),
              fontFace: CONFIG.language.font,
              fontSize: 20
            },
            ProgressBar: {
              y: 30,
              x: -50,
              type: Yt,
              w: 200,
              progress: 1,
              barColor: 4284637804,
              progressColor: 4127195135,
              animationDuration: 5
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        }
      };
    }
    set info(data) {
      this.data = data;
      if (!data.hasOwnProperty('icon')) data.icon = "/images/apps/DACApp_455_255.png";
      if (data.icon.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.icon)
        });
      } else {
        this.tag('Image').patch({
          src: data.icon
        });
      }
      this.tag('Text').text.text = data.installed[0].appName;
    }
    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    async _init() {
      this._app = {};
      this._app.isRunning = false;
      this._app.isInstalled = false;
      this._app.isInstalling = false;
      this._app.isUnInstalling = false;
      this._buttonIndex = 0;
      if (Storage$1.get("CloudAppStore")) {
        let icon = await fetchAppIcon(this.data.id, this.data.installed[0].version);
        this.tag('Image').patch({
          src: icon
        });
      } else {
        let icon = await fetchLocalAppIcon(this.data.id);
        if (icon !== undefined) {
          this.tag('Image').patch({
            src: Utils.asset(icon)
          });
        }
      }
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
    async _handleEnter() {
      this._app.url = this.data.installed[0].url;
      this._app.id = this.data.id;
      this._app.name = this.data.installed[0].appName;
      this._app.version = this.data.installed[0].version;
      this._app.type = this.data.type;
      this._app.isRunning = await startDACApp(this._app);
    }
  }

  class OptionsItem extends t.Component {
    static _template() {
      return {
        Wrapper: {
          Text: {
            text: {
              text: '',
              fontFace: CONFIG.language.font,
              fontSize: 35,
              wordWrap: false,
              wordWrapWidth: 230,
              fontStyle: "normal",
              textOverflow: "ellipsis"
            }
          },
          Bar: {
            y: 50,
            texture: t.Tools.getRoundRect(0, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex)
          }
        }
      };
    }
    _focus() {
      this.tag('Bar').texture = t.Tools.getRoundRect(this.tag('Text').finalW, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex);
      this.tag('Text').text.fontStyle = 'bold';
    }
    _unfocus() {
      this.tag('Bar').texture = t.Tools.getRoundRect(0, 5, 0, 0, CONFIG.theme.hex, true, CONFIG.theme.hex);
      this.tag('Text').text.fontStyle = '';
    }
    static get width() {
      return 250;
    }
    _handleEnter() {
      this.fireAncestors('$selectOption', this.idx, this);
      this._focus();
    }
    _handleDown() {
      this._handleEnter();
    }
    set element(item) {
      this.tag('Text').text.text = Language$1.translate(item);
      if (this.tag('Text').text.text.length > 11) {
        this.tag('Text').text.fontSize = 25;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Progress extends lng.Component {
    static _template() {
      let RR = lng.shaders.RoundedRectangle;
      return {
        BackgroundOverlay: {
          rect: true,
          color: 0xFF000000,
          alpha: 0,
          w: 300,
          h: 168,
          x: -50,
          y: -80
        },
        Label: {
          x: 10,
          y: -28,
          text: {
            fontSize: 18,
            textColor: 0xFFFFFFFF
          }
        },
        ProgressBar: {
          Background: {
            x: -2,
            y: 0,
            w: 4,
            h: 12,
            rtt: true,
            rect: true,
            color: 0xFF666666,
            shader: {
              radius: 3,
              type: RR
            }
          },
          Progress: {
            x: 0,
            y: 0,
            w: 0,
            h: 10,
            rtt: true,
            rect: true,
            color: CONFIG.theme.hex,
            shader: {
              radius: 3,
              type: RR
            }
          }
        }
      };
    }
    getProgress() {
      return this.value;
    }
    reset() {
      this.value = 0;
      this.tag("Progress").w = 0;
      this.tag("ProgressBar").alpha = 0.0;
      this.tag("Label").text.text = "";
      this.tag("Label").alpha = 1.0;
    }
    setProgress(pc, state) {
      this.percent = pc * 100;
      this.value = pc;
      var ww = (this.w - 4) * pc;
      if (pc != 1.0) {
        this.tag("BackgroundOverlay").alpha = 0.6;
        this.tag("ProgressBar").setSmooth('alpha', 0.7, {
          duration: .1
        });
        this.tag("Progress").setSmooth('w', ww, {
          duration: 1
        });
      }
      if (state !== "") {
        this.tag("Label").text.text = state + " " + Math.floor(this.percent) + "%";
      }
      if (pc == 1.0) {
        this.tag("ProgressBar").setSmooth('alpha', 0, {
          duration: 2.3
        });
        this.tag("Label").setSmooth('alpha', 0, {
          duration: 2.3
        });
        this.tag("BackgroundOverlay").setSmooth('alpha', 0, {
          duration: 1.5
        });
      }
    }
    _init() {
      this.tag("Background").w = this.w;
      this.reset();
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AppCatalogItem extends t.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xFF000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language$1.translate('Already installed') + "!",
              fontFace: CONFIG.language.font,
              fontSize: 20
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        StatusProgress: {
          type: Progress,
          x: 50,
          y: 80,
          w: 200
        }
      };
    }
    set info(data) {
      this.data = data;
      if (!data.hasOwnProperty('icon')) data.icon = "/images/apps/DACApp_455_255.png";
      if (data.icon.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.icon)
        });
      } else {
        this.tag('Image').patch({
          src: data.icon
        });
      }
      this.tag('Text').text.text = data.name;
    }
    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    async $fireDACOperationFinished(success, msg) {
      if (this._app.isInstalling) {
        this._app.isInstalled = success;
        this._app.isInstalling = false;
        this.updateStatus();
        if (!success) {
          this.tag('StatusProgress').setProgress(1.0, 'Error: ' + msg);
        }
      } else if (this._app.isUnInstalling) {
        this._app.isInstalled = !success;
        this._app.isUnInstalling = false;
        this.updateStatus();
        if (!success) {
          this.tag('StatusProgress').setProgress(1.0, 'Error: ' + msg);
        }
      }
    }
    updateStatus() {
      if (this._app.isRunning) {
        this.tag('StatusProgress').setProgress(1.0, Language$1.translate('Running') + "!");
      } else {
        if (this._app.isInstalled) {
          console.log("App is installed");
          this.tag('StatusProgress').setProgress(1.0, Language$1.translate('Installed') + '!');
        } else {
          this.tag('StatusProgress').reset();
        }
      }
    }
    async myfireINSTALL() {
      if (this._app.isInstalled) {
        console.log("App is already installed");
        this.tag("Overlay").alpha = 0.7;
        this.tag("OverlayText").alpha = 1;
        this.tag("Overlay").setSmooth('alpha', 0, {
          duration: 5
        });
        return;
      }
      this._app.isInstalling = await installDACApp(this._app, this.tag('StatusProgress'));
      this.updateStatus();
    }
    _init() {
      this._app = {};
      this._app.isRunning = false;
      this._app.isInstalled = false;
      this._app.isInstalling = false;
      this._app.isUnInstalling = false;
      this._buttonIndex = 0;
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
    async _handleEnter() {
      this._app.id = this.data.id;
      this._app.name = this.data.name;
      this._app.version = this.data.version;
      this._app.type = this.data.type;
      if (Storage$1.get("CloudAppStore")) {
        this._app.description = this.data.description;
        this._app.size = this.data.size;
        this._app.category = this.data.category;
        this._app.url = await fetchAppUrl(this._app.id, this._app.version);
        console.log("fetchAppUrl:", this._app.url);
      } else {
        this._app.url = this.data.uri;
      }
      let installedApps = await getInstalledDACApps();
      this._app.isInstalled = installedApps.find(a => {
        return a.id === this._app.id;
      });
      if (this._app.isInstalled === undefined) this._app.isInstalled = false;
      if (this._app.url !== undefined) {
        this.myfireINSTALL();
      } else console.error("App url undefined");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ManageAppItem extends t.Component {
    static _template() {
      return {
        Shadow: {
          y: -10,
          alpha: 0,
          rect: true,
          color: CONFIG.theme.hex,
          h: this.height + 20,
          w: this.width
        },
        Image: {
          h: this.height,
          w: this.width
        },
        Overlay: {
          alpha: 0,
          rect: true,
          color: 0xFF000000,
          h: this.height,
          w: this.width,
          OverlayText: {
            alpha: 0,
            mount: 0.5,
            x: this.width / 2,
            y: this.height / 2,
            text: {
              text: Language$1.translate("Uninstalling App") + "..",
              fontFace: CONFIG.language.font,
              fontSize: 30
            }
          }
        },
        Text: {
          alpha: 0,
          y: this.height + 10,
          text: {
            text: '',
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        StatusProgress: {
          type: Progress,
          x: 50,
          y: 80,
          w: 200
        }
      };
    }
    set info(data) {
      this.data = data;
      if (!data.hasOwnProperty('icon')) data.icon = "/images/apps/DACApp_455_255.png";
      if (data.icon.startsWith('/images')) {
        this.tag('Image').patch({
          src: Utils.asset(data.icon)
        });
      } else {
        this.tag('Image').patch({
          src: data.icon
        });
      }
      this.tag('Text').text.text = data.installed[0].appName;
    }
    static get width() {
      return 300;
    }
    static get height() {
      return 168;
    }
    async $fireDACOperationFinished(success, msg) {
      if (this._app.isUnInstalling) {
        this._app.isInstalled = !success;
        this._app.isUnInstalling = false;
        await this.displayLabel().then(res => {
          setTimeout(() => {
            this.fireAncestors('$refreshManagedApps');
          }, 500);
        });
        if (!success) {
          this.tag('StatusProgress').setProgress(1.0, 'Error: ' + msg);
        }
      }
    }
    displayLabel() {
      return new Promise((resolve, reject) => {
        this.tag("OverlayText").text.text = Language$1.translate("App Uninstalled");
        this.tag("Overlay").alpha = 0.7;
        this.tag("OverlayText").alpha = 1;
        this.tag("Overlay").setSmooth('alpha', 0, {
          duration: 5
        });
        resolve();
      });
    }
    async myfireUNINSTALL() {
      this._app.isUnInstalling = await uninstallDACApp(this._app, this.tag('StatusProgress'));
    }
    async _init() {
      this._app = {};
      this._app.isRunning = false;
      this._app.isInstalled = false;
      this._app.isInstalling = false;
      this._app.isUnInstalling = false;
      this._buttonIndex = 0;
      if (Storage$1.get("CloudAppStore")) {
        let icon = await fetchAppIcon(this.data.id, this.data.installed[0].version);
        this.tag('Image').patch({
          src: icon
        });
      } else {
        let icon = await fetchLocalAppIcon(this.data.id);
        if (icon !== undefined) {
          this.tag('Image').patch({
            src: Utils.asset(icon)
          });
        }
      }
    }
    _focus() {
      this.scale = 1.15;
      this.zIndex = 2;
      this.tag("Shadow").alpha = 1;
      this.tag("Text").alpha = 1;
    }
    _unfocus() {
      this.scale = 1;
      this.zIndex = 1;
      this.tag("Shadow").alpha = 0;
      this.tag("Text").alpha = 0;
    }
    _handleEnter() {
      this._app.url = this.data.installed[0].url;
      this._app.id = this.data.id;
      this._app.name = this.data.installed[0].appName;
      this._app.version = this.data.installed[0].version;
      this._app.type = this.data.type;
      this.myfireUNINSTALL();
    }
  }

  class AppStore extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Apps'));
    }
    static _template() {
      return {
        rect: true,
        h: 1080,
        w: 1920,
        color: CONFIG.theme.background,
        Container: {
          x: 200,
          y: 270,
          Options: {
            // x: 10,
            type: List,
            direction: 'row',
            spacing: 30
          },
          Apps: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: AppStoreItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          Catalog: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: AppCatalogItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          },
          ManagedApps: {
            x: 20,
            y: 120,
            type: Grid,
            columns: 5,
            itemType: ManageAppItem,
            w: 1920,
            h: (AppStore.height + 90) * 2 + 2 * 20 - 10,
            scroll: {
              after: 2
            },
            spacing: 20
          }
        }
      };
    }
    async _firstEnable() {
      const Catalog = await getAppCatalogInfo();
      const options = ['My Apps', 'App Catalog', 'Manage Apps'];
      this.tag('Options').add(options.map((element, idx) => {
        return {
          type: OptionsItem,
          element: element,
          w: OptionsItem.width,
          idx
        };
      }));
      this.options = {
        0: async () => {
          const installedApplications = await getInstalledDACApps();
          this.tag('Apps').add(installedApplications.map(element => {
            return {
              h: AppStoreItem.height + 90,
              w: AppStoreItem.width,
              info: element
            };
          }));
        },
        1: async () => {
          this.tag('Catalog').add(Catalog.map(element => {
            return {
              h: AppCatalogItem.height + 90,
              w: AppCatalogItem.width,
              info: element
            };
          }));
        },
        2: async () => {
          const installedApplications = await getInstalledDACApps();
          this.tag('ManagedApps').add(installedApplications.map(element => {
            return {
              h: ManageAppItem.height + 90,
              w: ManageAppItem.width,
              info: element
            };
          }));
        }
      };
      const installedApps = await getInstalledDACApps();
      if (Object.keys(installedApps).length === 0) {
        this.tag('Options').setIndex(1);
        this.options[1]();
        this._setState('Catalog');
      } else {
        this.options[0]();
        this._setState('Apps');
      }
    }
    $selectOption(option, obj) {
      this.tag('Apps').clear();
      this.tag('Catalog').clear();
      this.tag('ManagedApps').clear();
      obj._focus();
      this.options[option]();
      switch (option) {
        case 0:
          this._setState('Apps');
          break;
        case 1:
          this._setState('Catalog');
          break;
        case 2:
          this._setState('ManagedApps');
          break;
      }
    }
    $refreshManagedApps() {
      this.tag('ManagedApps').clear();
      this.options[2]();
      this._setState('ManagedApps');
    }
    _handleLeft() {
      Router.focusWidget('Menu');
    }
    _handleBack() {
      Router.focusWidget('Menu');
    }
    pageTransition() {
      return 'up';
    }
    _handleUp() {
      this.widgets.menu.notify('TopPanel');
    }
    _focus() {
      this._setState('Options');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('Options');
        }
        _handleDown() {
          this._setState('Apps');
        }
      }, class Apps extends this {
        _getFocused() {
          return this.tag('Apps');
        }
        _handleUp() {
          this._setState('Options');
        }
      }, class Catalog extends this {
        _getFocused() {
          return this.tag('Catalog');
        }
        _handleUp() {
          this._setState('Options');
        }
      }, class ManagedApps extends this {
        _getFocused() {
          return this.tag('ManagedApps');
        }
        _handleUp() {
          this._setState('Options');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class to render items in Subscription in details screen .
   */
  let index$1 = 0;
  class SubscriptionItem extends t.Component {
    static _template() {
      return {
        SubscriptionItem: {
          Title: {
            y: 40,
            mountY: 0.5,
            text: {
              text: "YouTube",
              fontFace: CONFIG.language.font,
              fontSize: 25,
              // maxLines: 1,
              wordWrap: false,
              wordWrapWidth: 175,
              fontStyle: 'normal',
              textOverflow: 'ellipsis'
            }
          },
          SubscriptionBox: {
            x: 183,
            y: 0,
            Lines: {
              TopLine: {
                y: 0,
                mountY: 0.5,
                w: 484,
                h: 3,
                rect: true,
                color: 0xFFFFFFFF
              },
              BottomLine: {
                y: 77,
                mountY: 0.5,
                w: 484,
                h: 3,
                rect: true,
                color: 0xFFFFFFFF
              }
            },
            Arrows: {
              ArrowBackward: {
                h: 30,
                w: 45,
                x: 0,
                scaleX: -1,
                y: 38,
                mountY: 0.5,
                src: Utils.asset('images/settings/Arrow.png')
              },
              ArrowForward: {
                h: 30,
                w: 45,
                y: 38,
                x: 484,
                mountY: 0.5,
                mountX: 1,
                src: Utils.asset('images/settings/Arrow.png')
              }
            }
          },
          SubscriptionValues: {
            x: 433,
            y: 40,
            mount: 0.5,
            zIndex: 2,
            text: {
              text: 'Youtube',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 400,
              maxLines: 1,
              textOverflow: 'ellipsis',
              textAlign: 'center'
            }
          }
        }
      };
    }
    set item(item) {
      this._item = item;
      this.tag('Title').text.text = this._item.host["_@attribute"];
      if (Array.isArray(this._item.viewingOptions.viewingOption)) {
        this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[0]);
        this.tag('Arrows').visible = true;
      } else if (this._item.viewingOptions.viewingOption !== null && typeof this._item.viewingOptions.viewingOption === 'object') {
        this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption);
        this._item.viewingOptions.viewingOption = [this._item.viewingOptions.viewingOption];
        this.tag('Arrows').visible = false;
      }
      // this.tag('SubscriptionValues').text.text=`${this._item.viewingOptions.viewingOption[0].price["_@attribute"]}-${this._item.viewingOptions.viewingOption[0].license}-${this._item.viewingOptions.viewingOption[0].quality}`;
    }

    convertPricing(option) {
      let res = '';
      if (option.license !== undefined) {
        let license = option.license.toLowerCase();
        res = res + license.substr(0, 1).toUpperCase() + license.substr(1) + " ";
      }
      if (option.price !== undefined) {
        res = res + "$" + option.price["_@attribute"] + " ";
      }
      if (option.quality !== undefined) {
        res = res + option.quality;
      }
      return res;
    }
    _focus() {
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("TopLine").h = 5;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").h = 5;
      this.tag("TopLine").zIndex = 10;
      this.tag("BottomLine").zIndex = 10;
      this.tag('Title').text.fontStyle = 'bold';
      this.tag('SubscriptionValues').text.fontStyle = 'bold';
      // console.log(this._item)
    }

    _handleLeft() {
      // index = (3 + (--index)) % 3;
      index$1 = index$1 - 1;
      if (index$1 < 0) {
        index$1 = this._item.viewingOptions.viewingOption.length - 1;
      }
      this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[index$1]);
    }
    _handleEnter() {
      // this.handleDone()
      if (this._item.host["_@attribute"].toLowerCase() === "youtube") {
        let appApi = new AppApi();
        console.log(this._item.url);
        let params = {
          url: this._item.url,
          launchLocation: "gracenote",
          appIdentifier: 'n:3'
        };
        appApi.launchApp("YouTube", params).catch(err => {});
      }
    }
    _handleRight() {
      // index = (3 + (++index)) % 3;
      index$1 = index$1 + 1;
      if (index$1 > this._item.viewingOptions.viewingOption.length - 1) {
        index$1 = 0;
      }
      this.tag('SubscriptionValues').text.text = this.convertPricing(this._item.viewingOptions.viewingOption[index$1]);
    }
    _unfocus() {
      this.tag("TopLine").color = 0xFFFFFFFF;
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").color = 0xFFFFFFFF;
      this.tag("BottomLine").h = 3;
      this.tag("TopLine").zIndex = 0;
      this.tag("BottomLine").zIndex = 0;
      this.tag('Title').text.fontStyle = 'normal';
      this.tag('SubscriptionValues').text.fontStyle = 'normal';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var homeApi$1 = new HomeApi();
  class DetailsScreen extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(this.name);
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        w: 1920,
        h: 1080,
        rect: true,
        color: 0xff000000,
        Details: {
          x: 200,
          y: 270,
          Image: {
            x: 0,
            y: 0,
            h: 493,
            w: 878
          },
          Cast: {
            Title: {
              x: 10,
              y: 520,
              text: {
                text: "",
                fontStyle: "bold",
                fontSize: 22
              }
            }
          },
          Description: {
            Title: {
              x: 10,
              y: 550,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 22,
                wordWrapWidth: 900,
                wordWrap: true
              }
            }
          },
          Subscriptions: {
            x: 950,
            y: 50,
            w: 670,
            h: 395,
            visible: false,
            clipping: true,
            List: {
              type: t.components.ListComponent,
              w: 670,
              h: 390,
              y: 5,
              itemSize: 77,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          },
          Time: {
            y: 520,
            x: 1000,
            Title: {
              // mountX: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Rating: {
            y: 550,
            x: 1000,
            Title: {
              // mountX: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 25,
                wordWrap: true,
                wordWrapWidth: 500
              }
            }
          },
          GracenoteLogo: {
            x: 925,
            y: 510,
            w: 300,
            h: 168,
            src: Utils.asset("images/powered_by_gracenote.png")
          }
        }
      };
    }
    set params(args) {
      this.rootId = args.gracenoteItem.program.tmsid;
      this.name = args.gracenoteItem.program.title;
      let imgUrl = "http://developer.tmsimg.com/" + args.gracenoteItem.program.preferredImage.uri.replace("w=1280&", "w=878&").replace("&h=720", "&h=493") + "&api_key=" + args.key;
      this.tag("Image").src = Utils.proxyUrl(imgUrl);
      this.tag("Cast.Title").text.text = "".concat(args.gracenoteItem.program.topCast[0], " \t ").concat(args.gracenoteItem.program.topCast[1], " \t ").concat(args.gracenoteItem.program.topCast[2]);
      this.tag("Description.Title").text.text = args.gracenoteItem.program.longDescription;
      this.tag("Time.Title").text.text = "".concat(args.gracenoteItem.duration, " Minutes");
      if (args.gracenoteItem.ratings) {
        this.tag("Rating.Title").text.text = "".concat(args.gracenoteItem.ratings[0].body, " \n").concat(args.gracenoteItem.ratings[0].subRating);
      } else {
        this.tag("Rating.Title").text.text = "";
      }
      homeApi$1.getMovieSubscriptions(args.gracenoteItem.program.tmsId).then(response => {
        let options = response.ovd.movie.videos.video;
        if (options) {
          this.tag("Subscriptions.List").items = options.map((item, index) => {
            return {
              w: 670,
              h: 77,
              type: SubscriptionItem,
              item: item
            };
          });
          this.tag("Subscriptions").visible = true;
        } else {
          this.tag("Subscriptions").visible = false;
        }
        this._setState("Subscriptions");
        this.tag("Subscriptions.List").setIndex(0);
      }).catch(error => console.log(error));
    }
    _init() {}
    _focus() {
      this._setState("DetailsScreen");
      this.tag("Subscriptions.List").setIndex(0);
    }
    _unfocus() {
      this.tag("Subscriptions").visible = false;
    }
    _handleBack() {
      Router.navigate("menu");
    }
    static _states() {
      return [class DetailsScreen extends this {
        _handleDown() {
          this._setState("Subscriptions");
        }
        _handleUp() {
          this._setState("Subscriptions");
        }
        _handleLeft() {
          this._setState("Subscriptions");
        }
        _handleRight() {
          this._setState("Subscriptions");
        }
        _handleEnter() {
          this._setState("Subscriptions");
        }
      }, class Subscriptions extends this {
        _getFocused() {
          return this.tag("Subscriptions.List").element;
        }
        _handleDown() {
          this.tag("Subscriptions.List").setNext();
        }
        _handleUp() {
          this.tag("Subscriptions.List").setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var detailsScreenRoutes = {
    detailsScreenRoutes: [{
      path: 'menu/details',
      component: DetailsScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }]
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class to render items with tick Icon.
   */
  class TickMarkItem extends t.Component {
    /**
     * Function to render Tick mark Icon elements in the settings.
     */

    _construct() {
      this.Tick = Utils.asset("/images/settings/Tick.png");
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    set isTicked(isTicked) {
      this.tag("Item").patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          color: 0xffffffff,
          visible: isTicked
        }
      });
    }
    _init() {
      this.tag("Item").patch({
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.itemName,
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
      this.tag("Item.Tick").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png";
        this.tag("Item.Tick").src = url;
      });
    }
    _handleEnter() {
      this.onHandleEnter(this.uniqID); //expecting a function that gets executed on handleEnter
    }

    _focus() {
      this.tag("Item").color = COLORS.hightlightColor;
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Satellite extends t.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: t.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setSatellite", selected);
      this.tag("List").items = this.fireAncestors("$getSatelliteList").map((item, index) => {
        return {
          ref: "Satellite" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected.name === item.name,
          //boolean
          itemName: item.name,
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedSatellite"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Polarity extends t.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: t.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setPolarity", selected);
      this.tag("List").items = this.fireAncestors("$getPolarityList").map((item, index) => {
        return {
          ref: "Polarity" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: Language.translate(item.charAt(0).toUpperCase() + item.slice(1)),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedPolarity"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class FEC extends t.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: t.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setFEC", selected);
      this.tag("List").items = this.fireAncestors("$getFECList").map((item, index) => {
        return {
          ref: "FEC" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.replace("fec", "").replace("_", "/").toUpperCase(),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedFEC"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Modulation extends t.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: t.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setModulation", selected);
      this.tag("List").items = this.fireAncestors("$getModulationList").map((item, index) => {
        return {
          ref: "Modulation" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.toUpperCase(),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedModulation"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SearchType extends t.Component {
    static _template() {
      return {
        Contents: {
          x: 200,
          y: 270,
          w: 1620,
          h: 730,
          clipping: true,
          List: {
            type: t.components.ListComponent,
            w: 1620,
            h: 730,
            y: 5,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -7
          }
        }
      };
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.tag("List").setNext();
    }
    _handleUp() {
      this.tag("List").setPrevious();
    }
    refreshItems(selected) {
      this.fireAncestors("$setSearchType", selected);
      this.tag("List").items = this.fireAncestors("$getSearchTypeList").map((item, index) => {
        return {
          ref: "SearchType" + index,
          w: 1620,
          h: 90,
          type: TickMarkItem,
          isTicked: selected === item,
          //boolean
          itemName: item.charAt(0).toUpperCase() + item.slice(1),
          //pass the formated item name
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _focus() {
      this.refreshItems(this.fireAncestors("$getSelectedSearchType"));
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  const keyMap = {
    "0": 48,
    "1": 49,
    "2": 50,
    "3": 51,
    "4": 52,
    "5": 53,
    "6": 54,
    "7": 55,
    "8": 56,
    "9": 57,
    "q": 81,
    "w": 87,
    "e": 69,
    "r": 82,
    "t": 84,
    "y": 89,
    "u": 85,
    "i": 73,
    "o": 79,
    "p": 80,
    "a": 65,
    "s": 83,
    "d": 68,
    "f": 70,
    "g": 71,
    "h": 72,
    "j": 74,
    "k": 75,
    "l": 76,
    "z": 90,
    "x": 88,
    "c": 67,
    "v": 86,
    "b": 66,
    "n": 78,
    "m": 77,
    "Q": 81,
    "W": 87,
    "E": 69,
    "R": 82,
    "T": 84,
    "Y": 89,
    "U": 85,
    "I": 73,
    "O": 79,
    "P": 80,
    "A": 65,
    "S": 83,
    "D": 68,
    "F": 70,
    "G": 71,
    "H": 72,
    "J": 74,
    "K": 75,
    "L": 76,
    "Z": 90,
    "X": 88,
    "C": 67,
    "V": 86,
    "B": 66,
    "N": 78,
    "M": 77,
    "Backspace": 8,
    "Enter": 13,
    "Space": 32,
    "PageUp": 33,
    "PageDown": 34,
    "Home": 36,
    "ArrowLeft": 37,
    "ArrowUp": 38,
    "ArrowRight": 39,
    "ArrowDown": 40,
    "AudioVolumeDown": 174,
    "AudioVolumeUp": 175,
    "AudioVolumeMute": 173,
    "MediaStop": 178,
    "MediaTrackPrevious": 177,
    "MediaPlay": 179,
    "MediaTrackNext": 176,
    "Escape": 27,
    "Pause": 179,
    "MediaRewind": 227,
    "MediaFastForward": 228,
    "F1": 112,
    "Inputs_Shortcut": 113,
    //F2
    "Picture_Setting_Shortcut": 114,
    //F3
    "Youtube": 115,
    //F4
    "Power": 116,
    // F5
    "Amazon": 117,
    //F6
    "Netflix": 118,
    //F7, F8 Voice RCU Key
    "Settings_Shortcut": 121,
    // F10
    "Guide_Shortcut": 120,
    // F9
    "AppCarousel": 122,
    // F11
    "F12": 123
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class IntegerInput extends t.Component {
    static _template() {
      return {
        x: 200,
        y: 275,
        InputBox: {
          Border: {
            texture: t.Tools.getRoundRect(1600, 90, 0, 3, 0xffffffff, false)
          },
          Arrows: {
            y: 50,
            visible: false,
            RightArrow: {
              h: 50,
              w: 50,
              x: 1600,
              mountX: 1,
              mountY: 0.5,
              color: 0xffffffff,
              src: Utils.asset("images/settings/Arrow.png")
            },
            LeftArrow: {
              h: 50,
              w: 50,
              x: 0,
              mountX: 0,
              mountY: 0.5,
              scaleX: -1,
              color: 0xffffffff,
              src: Utils.asset("images/settings/Arrow.png")
            }
          },
          Content: {
            x: 50,
            y: 50,
            mountY: 0.5,
            text: {
              text: Language$1.translate("Enter the value and click Done"),
              textColor: COLORS.titleColor,
              fontFace: CONFIG.language.font,
              fontSize: 25,
              wordWrap: false,
              wordWrapWidth: 1500,
              textOverflow: "ellipsis"
            }
          }
        },
        Keyboard: {
          x: 660,
          y: 200,
          type: Keyboard$1,
          visible: true,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.numbers
        }
      };
    }
    _init() {
      this.numKeyCodes = [keyMap["0"], keyMap["1"], keyMap["2"], keyMap["3"], keyMap["4"], keyMap["5"], keyMap["6"], keyMap["7"], keyMap["8"], keyMap["9"]];
      //console.log(this.numKeyCodes) // above array order is importent as index is used as numeric value
    }

    _focus() {
      this._setState("InputBox");
      this.tag("Content").text.text = this.prevVal === "" ? Language$1.translate("Enter the value and click Done") : this.prevVal;
      this.inputValue = this.prevVal;
      console.log("presetValues: ", this.presetValues);
      this.presetValuesLength = 0;
      this.presetIdx = -1; //to accomodate previous value of the input field
      if (Array.isArray(this.presetValues)) {
        this.presetValuesLength = this.presetValues.length;
        console.log(this.presetValues, this.presetValuesLength);
        this.tag("Arrows").visible = true;
      } else {
        this.tag("Arrows").visible = false;
      }
    }
    handleDone() {
      // console.log(this.inputValue);
      this.onHandleDone(this.inputValue);
    }
    _handleKey(key) {
      let keyValue = this.numKeyCodes.indexOf(key.keyCode); //index is used as value for numeric keys
      if (keyValue >= 0) {
        this.inputValue += String(keyValue);
        this.tag("Content").text.text = this.inputValue;
      } else {
        return false; //to pass on other keys such as handleBack
      }
    }

    static _states() {
      return [class InputBox extends this {
        $enter() {
          this.tag("InputBox.Border").texture = t.Tools.getRoundRect(1600, 90, 0, 3, CONFIG.theme.hex, false);
          this.tag("RightArrow").color = CONFIG.theme.hex;
          this.tag("LeftArrow").color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag("InputBox.Border").texture = t.Tools.getRoundRect(1600, 90, 0, 3, 0xffffffff, false);
          this.tag("RightArrow").color = 0xffffffff;
          this.tag("LeftArrow").color = 0xffffffff;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleEnter() {
          this._setState("Keyboard");
        }
        _handleLeft() {
          if (this.presetValuesLength > 0) {
            if (this.presetIdx <= 0) {
              this.presetIdx = this.presetValuesLength - 1;
            } else {
              this.presetIdx -= 1;
            }
            this.inputValue = this.presetValues[this.presetIdx];
            this.tag("Content").text.text = this.inputValue;
          }
        }
        _handleRight() {
          if (this.presetValuesLength > 0) {
            if (this.presetIdx === this.presetValuesLength - 1 || this.presetIdx < 0) {
              this.presetIdx = 0;
            } else {
              this.presetIdx += 1;
            }
            this.inputValue = this.presetValues[this.presetIdx];
            this.tag("Content").text.text = this.inputValue;
          }
        }
        _handleUp() {
          // do nothing
        }
      }, class Keyboard extends this {
        _handleDown() {
          // do nothing
        }
        _handleUp() {
          this._setState("InputBox");
        }
        _getFocused() {
          return this.tag("Keyboard");
        }
        _handleBack() {
          this._setState("InputBox");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === "Done") {
            this.handleDone();
          } else if (key === "Clear") {
            this.inputValue = this.inputValue.substring(0, this.inputValue.length - 1);
          } else if (key === "Delete") {
            this.inputValue = "";
          } else {
            this.inputValue += key;
          }
          this.tag("Content").text.text = this.inputValue;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const dtvApi$4 = new DTVApi();
  const config$a = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  const thunder$b = thunderJS$1(config$a);
  const systemcCallsign = "DTV";

  /**
   * Class for DVB Scan screen.
   */
  class DvbSScan$1 extends t.Component {
    _onChanged() {
      this.tag("Scroller").y = 2; //to reset the position when this route is hit
      this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        DvbSScanScreenContents: {
          x: 200,
          y: 275,
          Wrapper: {
            y: -3,
            h: 635,
            w: 1700,
            clipping: true,
            Scroller: {
              y: 2,
              Satellite: {
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Satellite"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Frequency: {
                y: 90,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Frequency"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Polarity: {
                y: 180,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Polarity"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SymbolRate: {
                y: 270,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Symbol Rate"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              FEC: {
                y: 360,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("FEC"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              DVBS2: {
                y: 450,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("DVB-S2"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              },
              Modulation: {
                y: 540,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Modulation"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SearchType: {
                y: 630,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Search Mode"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Retune: {
                y: 720,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Clear existing service list"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              }
            }
          },
          StartScan: {
            zIndex: 3,
            x: 10,
            y: 670,
            h: 50,
            w: 200,
            rect: true,
            color: 0xffffffff,
            Title: {
              x: 100,
              y: 27,
              mount: 0.5,
              text: {
                text: Language$1.translate("Start Scan"),
                textColor: 0xff000000,
                fontFace: CONFIG.language.font,
                fontSize: 24
              }
            }
          },
          ErrorNotification: {
            x: 250,
            y: 670,
            h: 50,
            visible: false,
            Content: {
              x: 10,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Error!"),
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            }
          },
          ScanProgress: {
            x: 270,
            y: 670,
            h: 50,
            visible: false,
            Title: {
              visible: false,
              x: 40,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Please wait scan in progress") + "...",
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 10,
              mountX: 1,
              y: 25,
              mountY: 0.5,
              src: Utils.asset("images/settings/Loading.png")
            }
          }
        },
        SelectSatellite: {
          type: Satellite,
          visible: false
        },
        SelectFrequency: {
          type: IntegerInput,
          visible: false
        },
        SelectPolarity: {
          type: Polarity,
          visible: false
        },
        SelectSymbolRate: {
          type: IntegerInput,
          visible: false
        },
        SelectFEC: {
          type: FEC,
          visible: false
        },
        SelectModulation: {
          type: Modulation,
          visible: false
        },
        SelectSearchType: {
          type: SearchType,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Satellite");
      this.preventExit = false;
      this.selectedSatellite = {};
      this.selectedFrequency = "";
      this.selectedPolarity = "";
      this.selectedSymbolRate = "";
      this.selectedFEC = "";
      this.selectedDVBS2 = false; //default value is false
      this.selectedModulation = "";
      this.selectedSearchType = "";
      this.selectedRetune = false; //default value is set to false

      this.loadingAnimation = this.tag("ScanProgress.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.inProgressAnimation = this.tag("ScanProgress.Title").animation({
        duration: 0.6,
        repeat: 0,
        stopMethod: "immediate",
        actions: [{
          p: "text.text",
          v: {
            0: Language$1.translate("Please wait scan in progress"),
            0.3: Language$1.translate("Please wait scan in progress") + ".",
            0.6: Language$1.translate("Please wait scan in progress") + "..",
            0.9: Language$1.translate("Please wait scan in progress") + "..."
          }
        }]
      });
    }
    setScanInProgress() {
      this.preventExit = true;
      this.loadingAnimation.start();
      this.inProgressAnimation.start();
      this.tag("ScanProgress").visible = true;
    }
    setScanFinished() {
      this.preventExit = false;
      this.loadingAnimation.stop();
      this.inProgressAnimation.stop();
      this.tag("ScanProgress").visible = false;
      this.tag("ScanProgress.Title").visible = false;
    }
    _captureKey() {
      if (this.preventExit) {
        this.tag("ScanProgress.Title").visible = true;
        this.inProgressAnimation.start();
      } else {
        return false;
      }
    }
    consoleLog() {
      //log it everywhere
      console.log("selectedSatellite: ", JSON.stringify(this.selectedSatellite), " selectedFrequency: ", this.selectedFrequency, " selectedPolarity: ", this.selectedPolarity, " selectedSymbolRate: ", this.selectedSymbolRate, " selectedFEC: ", this.selectedFEC, " selectedDVBS2: ", this.selectedDVBS2, " selectedModulation: ", this.selectedModulation, " selectedSearchType: ", this.selectedSearchType, " selectedRetune: ", this.selectedRetune);
    }
    _focus() {
      // console.log("dvbscan screen in focus");
      this.resetForm();
      this._setState("Satellite");
      this.consoleLog();
      // console.log(this.satelliteList);
      // console.log(this.polarityList);
      // console.log(this.fecList);
      // console.log(this.modulationList);
      // console.log(this.searchtypeList);
    }

    _firstActive() {
      thunder$b.on(systemcCallsign, "searchstatus", notification => {
        console.log("SearchStatus Notification: ", JSON.stringify(notification));
        if (notification.finished) {
          console.log("notification.finished: ", notification.finished);
          this.setScanFinished();
          dtvApi$4.noOfServices().then(res => {
            this.tag("ErrorNotification.Content").text.text = Language$1.translate("Found ") + res + Language$1.translate(" services.");
            this.tag("ErrorNotification").visible = true;
          });
        }
      });

      ///////////////satellite

      this.satelliteList = [];
      dtvApi$4.satelliteList().then(res => {
        this.satelliteList = res;
      });

      ///////////////////polarity

      this.polarityList = [];
      dtvApi$4.polarityList().then(res => {
        this.polarityList = res;
      });

      ///////////////////symbolRate
      //symbol rate has some predefined values additional to custom imput
      this.symbolRateList = [];
      dtvApi$4.symbolRateList().then(res => {
        this.symbolRateList = res;
      });

      ////////////////////FEC

      this.fecList = [];
      dtvApi$4.fecList().then(res => {
        this.fecList = res;
      });

      ///////////////////modulation

      this.modulationList = [];
      dtvApi$4.modulationList().then(res => {
        this.modulationList = res;
      });

      ///////////////////searchtype

      this.searchtypeList = [];
      dtvApi$4.searchtypeList().then(res => {
        this.searchtypeList = res;
      });
    }
    _handleBack() {
      this.resetForm();
      Router.navigate("settings/livetv/scan");
    }
    $getSatelliteList() {
      return this.satelliteList;
    }
    $setSatellite(satellite) {
      this.selectedSatellite = satellite;
      //this.consoleLog();
    }

    $getSelectedSatellite() {
      return this.selectedSatellite;
    }
    $getPolarityList() {
      return this.polarityList;
    }
    $setPolarity(polarity) {
      this.selectedPolarity = polarity;
      //this.consoleLog();
    }

    $getSelectedPolarity() {
      return this.selectedPolarity;
    }
    $getFECList() {
      return this.fecList;
    }
    $setFEC(fec) {
      this.selectedFEC = fec;
      //this.consoleLog();
    }

    $getSelectedFEC() {
      return this.selectedFEC;
    }
    $getModulationList() {
      return this.modulationList;
    }
    $setModulation(modulation) {
      this.selectedModulation = modulation;
      //this.consoleLog();
    }

    $getSelectedModulation() {
      return this.selectedModulation;
    }
    $getSearchTypeList() {
      return this.searchtypeList;
    }
    $setSearchType(searchtype) {
      this.selectedSearchType = searchtype;
      //this.consoleLog();
    }

    $getSelectedSearchType() {
      return this.selectedSearchType;
    }
    setFrequency(frequency) {
      this._setState("Frequency");
      this.selectedFrequency = frequency;
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency") + ": " + (this.selectedFrequency !== "" ? this.selectedFrequency : Language$1.translate("Select a") + " " + Language$1.translate("Frequency"));
    }
    setSymbolRate(symbolrate) {
      this._setState("SymbolRate");
      this.selectedSymbolRate = symbolrate;
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate") + ": " + (this.selectedSymbolRate !== "" ? this.selectedSymbolRate : Language$1.translate("Select a") + " " + Language$1.translate("Symbol Rate"));
    }
    resetForm() {
      this.setScanFinished();
      //reset the form variables to initial state on exit from this form
      this.selectedSatellite = {};
      this.tag("Satellite.Title").text.text = Language$1.translate("Satellite");
      this.selectedFrequency = "";
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency");
      this.selectedPolarity = "";
      this.tag("Polarity.Title").text.text = Language$1.translate("Polarity");
      this.selectedSymbolRate = "";
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate");
      this.selectedFEC = "";
      this.tag("FEC.Title").text.text = Language$1.translate("FEC");
      this.selectedDVBS2 = false;
      this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.selectedModulation = "";
      this.tag("Modulation.Title").text.text = Language$1.translate("Modulation");
      this.selectedSearchType = "";
      this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode");
      this.selectedRetune = false;
      this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.tag("ErrorNotification").visible = false;
    }
    verifyInputs() {
      let errorString = "";
      if (Object.keys(this.selectedSatellite).length === 0) {
        errorString += "| " + Language$1.translate("Satellite") + " ";
      }
      if (this.selectedFrequency === "") {
        errorString += "| " + Language$1.translate("Frequency") + " ";
      }
      if (this.selectedPolarity === "") {
        errorString += "| " + Language$1.translate("Polarity") + " ";
      }
      if (this.selectedSymbolRate === "") {
        errorString += "| " + Language$1.translate("Symbol Rate") + " ";
      }
      if (this.selectedFEC === "") {
        errorString += "| " + Language$1.translate("FEC") + " ";
      }
      if (this.selectedModulation === "") {
        errorString += "| " + Language$1.translate("Modulation") + " ";
      }
      if (this.selectedSearchType === "") {
        errorString += "| " + Language$1.translate("Search Mode") + " ";
      }
      return errorString;
    }
    static _states() {
      return [class Satellite extends this {
        $enter() {
          this.tag("Satellite")._focus();
        }
        $exit() {
          this.tag("Satellite")._unfocus();
        }
        _handleDown() {
          this._setState("Frequency");
        }
        _handleEnter() {
          if (this.satelliteList.length > 0) {
            this._setState("Satellite.SelectSatellite");
          } else {
            dtvApi$4.satelliteList().then(res => {
              this.satelliteList = res;
            });
          }
        }
        static _states() {
          return [class SelectSatellite extends Satellite {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSatellite").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Satellite"));
            }
            $exit() {
              this.tag("SelectSatellite").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Satellite.Title").text.text = Language$1.translate("Satellite") + ": " + (Object.keys(this.selectedSatellite).length !== 0 ? this.selectedSatellite.name : Language$1.translate("Select a") + " " + Language$1.translate("Satellite"));
            }
            _getFocused() {
              return this.tag("SelectSatellite");
            }
            _handleBack() {
              this._setState("Satellite");
            }
          }];
        }
      }, class Frequency extends this {
        $enter() {
          this.tag("Frequency")._focus();
        }
        $exit() {
          this.tag("Frequency")._unfocus();
        }
        _handleUp() {
          this._setState("Satellite");
        }
        _handleDown() {
          this._setState("Polarity");
        }
        _handleEnter() {
          this.tag("SelectFrequency").patch({
            prevVal: this.selectedFrequency,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setFrequency.bind(this) //pass a function that will be executed when done is clicked on the keyboard
          });

          this._setState("Frequency.SelectFrequency");
        }
        static _states() {
          return [class SelectFrequency extends Frequency {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFrequency").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Frequency"));
            }
            $exit() {
              this.tag("SelectFrequency").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
            }
            _getFocused() {
              return this.tag("SelectFrequency");
            }
            _handleBack() {
              this.setFrequency(this.selectedFrequency);
            }
          }];
        }
      }, class Polarity extends this {
        $enter() {
          this.tag("Polarity")._focus();
        }
        $exit() {
          this.tag("Polarity")._unfocus();
        }
        _handleUp() {
          this._setState("Frequency");
        }
        _handleDown() {
          this._setState("SymbolRate");
        }
        _handleEnter() {
          this._setState("Polarity.SelectPolarity");
        }
        static _states() {
          return [class SelectPolarity extends Polarity {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectPolarity").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Polarity"));
            }
            $exit() {
              this.tag("SelectPolarity").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Polarity.Title").text.text = Language$1.translate("Polarity") + ": " + (this.selectedPolarity !== "" ? this.selectedPolarity.charAt(0).toUpperCase() + this.selectedPolarity.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Polarity"));
            }
            _getFocused() {
              return this.tag("SelectPolarity");
            }
            _handleBack() {
              this._setState("Polarity");
            }
          }];
        }
      }, class SymbolRate extends this {
        $enter() {
          this.tag("SymbolRate")._focus();
        }
        $exit() {
          this.tag("SymbolRate")._unfocus();
        }
        _handleUp() {
          this._setState("Polarity");
        }
        _handleDown() {
          this._setState("FEC");
        }
        _handleEnter() {
          this.tag("SelectSymbolRate").patch({
            prevVal: this.selectedSymbolRate,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setSymbolRate.bind(this),
            //pass a function that will be executed when done is clicked on the keyboard
            presetValues: this.symbolRateList //can handle a list of predefined values that can be selected using arrow keys
          });

          this._setState("SymbolRate.SelectSymbolRate");
        }
        static _states() {
          return [class SelectSymbolRate extends SymbolRate {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSymbolRate").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Symbol Rate"));
            }
            $exit() {
              this.tag("SelectSymbolRate").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
            }
            _getFocused() {
              return this.tag("SelectSymbolRate");
            }
            _handleBack() {
              this.setSymbolRate(this.selectedSymbolRate);
            }
          }];
        }
      }, class FEC extends this {
        $enter() {
          this.tag("FEC")._focus();
        }
        $exit() {
          this.tag("FEC")._unfocus();
        }
        _handleUp() {
          this._setState("SymbolRate");
        }
        _handleDown() {
          this._setState("DVBS2");
        }
        _handleEnter() {
          this._setState("FEC.SelectFEC");
        }
        static _states() {
          return [class SelectFEC extends FEC {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFEC").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("FEC"));
            }
            $exit() {
              this.tag("SelectFEC").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("FEC.Title").text.text = Language$1.translate("FEC") + ": " + (this.selectedFEC !== "" ? this.selectedFEC.replace("fec", "").replace("_", "/").toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("FEC"));
            }
            _getFocused() {
              return this.tag("SelectFEC");
            }
            _handleBack() {
              this._setState("FEC");
            }
          }];
        }
      }, class DVBS2 extends this {
        $enter() {
          this.tag("DVBS2")._focus();
        }
        $exit() {
          this.tag("DVBS2")._unfocus();
        }
        _handleUp() {
          this._setState("FEC");
        }
        _handleDown() {
          this._setState("Modulation");
        }
        _handleEnter() {
          if (!this.selectedDVBS2) {
            this.selectedDVBS2 = true;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedDVBS2 = false;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class Modulation extends this {
        $enter() {
          this.tag("Modulation")._focus();
        }
        $exit() {
          this.tag("Modulation")._unfocus();
        }
        _handleUp() {
          this._setState("DVBS2");
        }
        _handleDown() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleEnter() {
          this._setState("Modulation.SelectModulation");
        }
        static _states() {
          return [class SelectModulation extends Modulation {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectModulation").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Modulation"));
            }
            $exit() {
              this.tag("SelectModulation").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("Modulation.Title").text.text = Language$1.translate("Modulation") + ": " + (this.selectedModulation !== "" ? this.selectedModulation.toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("Modulation"));
            }
            _getFocused() {
              return this.tag("SelectModulation");
            }
            _handleBack() {
              this._setState("Modulation");
            }
          }];
        }
      }, class SearchType extends this {
        $enter() {
          this.tag("SearchType")._focus();
        }
        $exit() {
          this.tag("SearchType")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = 2;
          this._setState("Modulation");
        }
        _handleDown() {
          this.tag("Scroller").y = -178;
          this._setState("Retune");
        }
        _handleEnter() {
          this._setState("SearchType.SelectSearchType");
        }
        static _states() {
          return [class SelectSearchType extends SearchType {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSearchType").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Search Mode"));
            }
            $exit() {
              this.tag("SelectSearchType").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"));
              this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode") + ": " + (this.selectedSearchType !== "" ? this.selectedSearchType.charAt(0).toUpperCase() + this.selectedSearchType.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Search Mode"));
            }
            _getFocused() {
              return this.tag("SelectSearchType");
            }
            _handleBack() {
              this._setState("SearchType");
            }
          }];
        }
      }, class Retune extends this {
        $enter() {
          this.tag("Retune")._focus();
        }
        $exit() {
          this.tag("Retune")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleDown() {
          this._setState("StartScan");
        }
        _handleEnter() {
          if (!this.selectedRetune) {
            this.selectedRetune = true;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedRetune = false;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class StartScan extends this {
        $enter() {
          this.tag("StartScan").color = CONFIG.theme.hex;
          this.tag("StartScan.Title").text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag("StartScan").color = 0xffffffff;
          this.tag("StartScan.Title").text.textColor = 0xff000000;
        }
        _handleUp() {
          this._setState("Retune");
        }
        _handleEnter() {
          let errorString = this.verifyInputs();
          if (errorString === "") {
            this.tag("ErrorNotification").visible = false;
            let serviceSearchParams = {
              tunertype: "dvbs",
              searchtype: this.selectedSearchType,
              retune: this.selectedRetune,
              usetuningparams: true,
              dvbstuningparams: {
                satellite: this.selectedSatellite.name,
                frequency: parseInt(this.selectedFrequency),
                polarity: this.selectedPolarity,
                symbolrate: parseInt(this.selectedSymbolRate),
                fec: this.selectedFEC,
                modulation: this.selectedModulation,
                dvbs2: this.selectedDVBS2
              }
            };
            console.log(JSON.stringify(serviceSearchParams));
            dtvApi$4.startServiceSearch(serviceSearchParams).then(res => {
              this.setScanInProgress();
              console.log(res);
              setTimeout(() => {
                this.setScanFinished(); //to give back controls after 30 sec in case searchstatus event fails
                dtvApi$4.noOfServices().then(res => {
                  this.tag("ErrorNotification.Content").text.text = Language$1.translate("Found ") + res + Language$1.translate(" services.");
                  this.tag("ErrorNotification").visible = true;
                });
              }, 30000);
            });
          } else {
            this.tag("ErrorNotification.Content").text.text = Language$1.translate("Please enter the values for the following ") + errorString;
            this.tag("ErrorNotification").visible = true;
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Live TV Scan screen.
   */
  class LiveTVScan$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Settings / Live TV / Scan'));
    }
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        LiveTVScanScreenContents: {
          x: 200,
          y: 275,
          TScan: {
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-T Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CScan: {
            alpha: 0.3,
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-C Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          SScan: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-S Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        }
      };
    }
    _init() {
      this._setState('SScan');
    }
    _focus() {
      this._setState('SScan');
    }
    _handleBack() {
      Router.navigate('settings/livetv');
    }
    static _states() {
      return [class TScan extends this {
        $enter() {
          this.tag('TScan')._focus();
        }
        $exit() {
          this.tag('TScan')._unfocus();
        }
        _handleDown() {
          this._setState('CScan');
        }
        _handleEnter() {
          //Router.navigate()
        }
      }, class CScan extends this {
        $enter() {
          this.tag('CScan')._focus();
        }
        $exit() {
          this.tag('CScan')._unfocus();
        }
        _handleUp() {
          this._setState('TScan');
        }
        _handleDown() {
          this._setState('SScan');
        }
        _handleEnter() {
          // Router.navigate()
        }
      }, class SScan extends this {
        $enter() {
          this.tag('SScan')._focus();
        }
        $exit() {
          this.tag('SScan')._unfocus();
        }
        _handleUp() {
          // this._setState('CScan')
        }
        _handleEnter() {
          Router.navigate('settings/livetv/scan/dvb-s-scan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let active$1 = true; //expecting dtv plugin is active by default

  /**
   * Class for Live TV settings screen.
   */
  class LiveTVSettings$1 extends t.Component {
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate("Settings / Live TV"));
    }
    pageTransition() {
      return "left";
    }
    static _template() {
      return {
        rect: true,
        color: 0xff000000,
        w: 1920,
        h: 1080,
        LiveTVSettingsScreenContents: {
          x: 200,
          y: 275,
          Activate: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Activate / Deactivate"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/ToggleOnOrange.png")
            }
          },
          Scan: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Scan"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/Arrow.png")
            }
          }
        }
      };
    }
    _init() {
      this._setState("Activate");
    }
    _firstActive() {
      this.dtvApi = new DTVApi();
    }
    _focus() {
      this._setState(this.state);
      if (active$1) {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
      } else {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      }
    }
    _handleBack() {
      Router.navigate("settings");
    }
    static _states() {
      return [class Activate extends this {
        $enter() {
          this.tag("Activate")._focus();
        }
        $exit() {
          this.tag("Activate")._unfocus();
        }
        _handleDown() {
          this._setState("Scan");
        }
        _handleEnter() {
          if (active$1) {
            this.dtvApi.deactivate().then(res => {
              console.log(res);
              active$1 = false;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
            });
          } else {
            this.dtvApi.activate().then(res => {
              console.log(res);
              active$1 = true;
              this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
            });
          }
        }
      }, class Scan extends this {
        $enter() {
          this.tag("Scan")._focus();
        }
        $exit() {
          this.tag("Scan")._unfocus();
        }
        _handleUp() {
          this._setState("Activate");
        }
        _handleEnter() {
          Router.navigate("settings/livetv/scan");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const liveTvRoutes = [{
    path: 'settings/livetv',
    component: LiveTVSettings$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/livetv/scan',
    component: LiveTVScan$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }, {
    path: 'settings/livetv/scan/dvb-s-scan',
    component: DvbSScan$1,
    widgets: ['Menu', 'Volume', "AppCarousel"]
  }];

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for ControlSettings thunder plugin apis.
   */

  class PictureSettingsApi {
    constructor() {
      const config = {
        host: "127.0.0.1",
        port: 9998,
        versions: {
          default: 2,
          Controller: 1,
          ControlSettings: 2
        }
      };
      this._thunder = thunderJS$1(config);
      this._events = new Map();
      this.callsign = "org.rdk.tv.ControlSettings";
      this.settingsOptions = [{
        id: "_pictureMode",
        name: "Picture Mode",
        value: ["standard", "vivid", "energysaving", "custom", "theater", "game", "sports"]
        // value: ["DemoValue(Api Fail)"] //#forTesting
      }, {
        id: "_colorTemp",
        name: "Color Temperature",
        value: ["Standard", "Warm", "Cold", "User Defined"]
        // value: ["DemoValue(Api Fail)"] //#forTesting
      }, {
        id: "_backlight",
        name: "Backlight",
        value: "0"
      }, {
        id: "_brightness",
        name: "Brightness",
        value: "0"
      }, {
        id: "_contrast",
        name: "Contrast",
        value: "0"
      }, {
        id: "_sharpness",
        name: "Sharpness",
        value: "0"
      }, {
        id: "_saturation",
        name: "Saturation",
        value: "0"
      }];
      this.methodNames = {
        _pictureMode: {
          get: this.getPictureMode.bind(this),
          set: this.setPictureMode.bind(this)
        },
        _colorTemp: {
          get: this.getColorTemperature.bind(this),
          set: this.setColorTemperature.bind(this)
        },
        _backlight: {
          get: this.getBacklight.bind(this),
          set: this.setBacklight.bind(this)
        },
        _brightness: {
          get: this.getBrightness.bind(this),
          set: this.setBrightness.bind(this)
        },
        _contrast: {
          get: this.getContrast.bind(this),
          set: this.setContrast.bind(this)
        },
        _sharpness: {
          get: this.getSharpness.bind(this),
          set: this.setSharpness.bind(this)
        },
        _saturation: {
          get: this.getSaturation.bind(this),
          set: this.setSaturation.bind(this)
        }
      };
    }
    activate() {
      return new Promise((resolve, reject) => {
        this._thunder.call("Controller", "activate", {
          callsign: this.callsign
        }).then(result => {
          console.log("Activated tv.ControlSettings plugin: ", JSON.stringify(result));
          resolve(result);
        }).catch(err => {
          console.log("Failed to activate tv.ControlSettings plugin: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    getSettingsValue(settingsName) {
      console.log("getSettingsValue called for : ", settingsName);
      return new Promise((resolve, reject) => {
        this.methodNames[settingsName].get().then(result => {
          console.log("Result from getSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(result)));
          resolve(result);
        }).catch(err => {
          console.log("Error from getSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(err)));
          reject(err);
        });
      });
    }
    setSettingsValue(settingsName, value) {
      console.log("setSettingsValue called for : ", settingsName, " and for value: ", value);
      return new Promise((resolve, reject) => {
        this.methodNames[settingsName].set(value).then(result => {
          console.log("Result from setSettingsValue API for ".concat(settingsName, " : ").concat(JSON.stringify(result)));
          resolve(result);
        }).catch(err => {
          console.log("Error from setSettingsValue API for ".concat(settingsName, " and value : ").concat(value, " | Error: ").concat(JSON.stringify(err)));
          reject(err);
        });
      });
    }
    getOptions() {
      console.log("getOptions called: ", JSON.stringify(this.settingsOptions));
      return this.settingsOptions;
    }
    getSupportedPictureModes() {
      console.log("getSupportedPictureModes got called");
      return new Promise((resolve, reject) => {
        // resolve(true) //#forTesting
        this._thunder.call(this.callsign, "getSupportedPictureModes").then(result => {
          console.log("getSupportedPictureModes Result: ", JSON.stringify(result));
          if (result.success) {
            this.settingsOptions[0].value = result.SupportedPicmodes;
            resolve(true);
          }
        }).catch(err => {
          // this.settingsOptions[0].value=["tempval1", "tempval2"]  //#forTesting
          console.log("getSupportedPictureModes Error: ", JSON.stringify(err));
          reject(err);
        });
      });
    }
    getSupportedColorTemps() {
      console.log("getSupportedColorTemps got called");
      return new Promise((resolve, reject) => {
        // resolve(true) //#forTesting
        this._thunder.call(this.callsign, "getColorTemperature").then(result => {
          console.log("Log from getSupportedColorTemps API: ", JSON.stringify(result));
          if (result.success) {
            this.settingsOptions[1].value = result.ColorTemperature.Options;
            resolve(true);
          }
        }).catch(err => {
          console.log("Error from getSupportedColorTemps API: ", JSON.stringify(err));
          // this.settingsOptions[1].value=["tempval1", "tempval2"]  //#forTesting
          reject(err);
        });
      });
    }
    getPictureMode() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_pictureMode")) //#forTesting
        this._thunder.call(this.callsign, "getPictureMode").then(result => {
          resolve(result.pictureMode);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setPictureMode(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_pictureMode",value)) //#forTesting 
        this._thunder.call(this.callsign, "setPictureMode", {
          "pictureMode": value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getColorTemperature() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_colorTemp")) //#forTesting 
        this._thunder.call(this.callsign, "getColorTemperature").then(result => {
          resolve(result.ColorTemperature.Selected);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setColorTemperature(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_colorTemp",value)) //#forTesting 
        this._thunder.call(this.callsign, "setColorTemperature", {
          "colorTemp": value
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getBrightness() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_brightness")) //#forTesting 
        this._thunder.call(this.callsign, "getBrightness").then(result => {
          resolve(result.Brightness.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setBrightness(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_brightness",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setBrightness", {
          "brightness": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getContrast() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_contrast")) //#forTesting 
        this._thunder.call(this.callsign, "getContrast").then(result => {
          resolve(result.Contrast.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setContrast(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_contrast",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setContrast", {
          "contrast": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getSharpness() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_sharpness")) //#forTesting 
        this._thunder.call(this.callsign, "getSharpness").then(result => {
          resolve(result.Sharpness.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setSharpness(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_sharpness",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setSharpness", {
          "sharpness": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getSaturation() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_saturation")) //#forTesting 
        this._thunder.call(this.callsign, "getSaturation").then(result => {
          resolve(result.Saturation.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setSaturation(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_saturation",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setSaturation", {
          "saturation": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
    getBacklight() {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.getItem("_backlight")) //#forTesting 
        this._thunder.call(this.callsign, "getBacklight").then(result => {
          resolve(result.Backlight.Setting);
        }).catch(err => {
          reject(err);
        });
      });
    }
    setBacklight(value) {
      return new Promise((resolve, reject) => {
        // resolve(localStorage.setItem("_backlight",`${value}`)) //#forTesting 
        this._thunder.call(this.callsign, "setBacklight", {
          "backlight": "".concat(value)
        }).then(result => {
          resolve(result);
        }).catch(err => {
          reject(err);
        });
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlaySettingsItem extends t.Component {
    _construct() {
      this.pictureApi = new PictureSettingsApi();
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 500,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 500,
          h: 90,
          Title: {
            y: 45,
            x: 250,
            mount: 0.5,
            text: {
              text: "Setting: Sample Value",
              fontFace: CONFIG.language.font,
              fontSize: 25,
              wordWrap: false,
              wordWrapWidth: 400,
              fontStyle: "normal",
              textOverflow: "ellipsis"
            }
          },
          LeftArrow: {
            h: 45,
            w: 45,
            x: 0,
            scaleX: -1,
            y: 45,
            mountY: 0.5,
            src: Utils.asset("images/settings/Arrow.png"),
            color: 0xffffffff
          },
          RightArrow: {
            h: 45,
            w: 45,
            y: 45,
            x: 500,
            mountY: 0.5,
            mountX: 1,
            src: Utils.asset("images/settings/Arrow.png"),
            color: 0xffffffff
          }
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 500,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    _init() {}
    set item(item) {
      this._item = item;
      this.fetchAndUpdateValues();
    }
    fetchAndUpdateValues() {
      console.log("fetchAndUpdateValues got called!!!");
      if (Array.isArray(this._item.value)) {
        this.valueIdx = 0;
        this.valueLength = this._item.value.length;
        this.pictureApi.getSettingsValue(this._item.id).then(res => {
          console.log("getSettingsValue Result from fetchAndUpdateValues(array): ", JSON.stringify(res));
          let tIdx = this._item.value.indexOf(res);
          if (tIdx >= 0) {
            this.valueIdx = tIdx;
          }
          this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
        }).catch(err => {
          console.log("error from getSettingsValue(value is array) in set(item) in settings Item: ", JSON.stringify(err));
        });
      } else {
        this.pictureApi.getSettingsValue(this._item.id).then(res => {
          console.log("getSettingsValue Result from fetchAndUpdateValues(number): ", JSON.stringify(res));
          this._item.value = +res;
          this.currentVal = +res; //to change to int
          this.updateValue(this._item.value);
        }).catch(err => {
          console.log("error from getSettingsValue(value is number) in set(item) in settings Item: ", JSON.stringify(err));
        });
      }
    }
    updateValue(value) {
      this.tag("Title").text.text = "".concat(Language$1.translate(this._item.name), ": ").concat(value);
    }
    formatItemName(name) {
      return name.charAt(0).toUpperCase() + name.slice(1);
    }
    changeValueBy(val) {
      try {
        clearTimeout(this.changeValueTimer);
      } catch {
        console.log("CLEANUP ERROR");
      }
      if (this.currentVal + val <= 100 && this.currentVal + val >= 0) {
        this.currentVal += val;
        this.updateValue(this.currentVal);
      }
      this.changeValueTimer = setTimeout(() => {
        console.log("SENDING VALUE:".concat(this.currentVal, " TO API: ").concat(this._item.id));
        ///////////////// call set method and update the value in _item
        this.pictureApi.setSettingsValue(this._item.id, this.currentVal).then(res => {
          console.log(JSON.stringify(res));
          this._item.value = this.currentVal;
          this.updateValue(this.currentVal);
        }).catch(err => {
          console.log(JSON.stringify(err));
          console.log("this._item: ", JSON.stringify(this._item));
        });
      }, 600);
    }
    changePresetValueBy(direction) {
      this.fireAncestors("$moveDownLock", true); //user switching values prevent moving down
      try {
        clearTimeout(this.changePresetTimer);
      } catch {
        console.log("CLEANUP ERROR");
      }
      if (direction === "left") {
        this.valueIdx -= 1;
        if (this.valueIdx < 0) {
          this.valueIdx = this.valueLength - 1;
        }
      } else if (direction === "right") {
        this.valueIdx += 1;
        if (this.valueIdx >= this.valueLength) {
          this.valueIdx = 0;
        }
      }
      this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
      this.changePresetTimer = setTimeout(() => {
        console.log("SENDING VALUE:".concat(this._item.value[this.valueIdx], " TO API: ").concat(this._item.id));
        ///////// call set method and update the value in _item
        this.pictureApi.setSettingsValue(this._item.id, this._item.value[this.valueIdx]).then(res => {
          console.log(JSON.stringify(res));
          console.log(this._item.value[this.valueIdx]);
          this.updateValue(this.formatItemName(this._item.value[this.valueIdx]));
          this.fireAncestors("$moveDownLock", false); //api call success  user can move down
        }).catch(err => {
          console.log(JSON.stringify(err));
        });
      }, 600);
    }
    _handleLeft() {
      this.fireAncestors('$resetTimeout');
      if (this.valueLength > 0) {
        //value is an array
        this.changePresetValueBy("left");
      } else {
        if (this._item.id !== "_pictureMode" || this._item.id !== "_colorTemp") {
          this.changeValueBy(-1);
        }
      }
    }
    _handleRight() {
      this.fireAncestors('$resetTimeout');
      if (this.valueLength > 0) {
        //value is an array
        this.changePresetValueBy("right");
      } else {
        if (this._item.id !== "_pictureMode" || this._item.id !== "_colorTemp") {
          //except for preset, this condition check can be omitted by considering the value is not an array in this case
          this.changeValueBy(1);
        }
      }
    }
    _handleEnter() {
      this.fireAncestors('$resetTimeout');
    }
    _focus() {
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
      this.fetchAndUpdateValues(); //fetches the value from the api and updates on ui
    }

    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlaySettingsScreen extends t.Component {
    static _template() {
      return {
        Contents: {
          h: 1080,
          w: 500,
          Background: {
            h: 1080,
            w: 500,
            rect: true,
            colorLeft: 0xff000000,
            colorRight: 0x99000000
          },
          Settings: {
            w: 500,
            h: 910,
            clipping: true,
            y: 80,
            List: {
              type: t.components.ListComponent,
              w: 500,
              h: 910,
              y: 5,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -9
            }
          }
        }
      };
    }
    _firstEnable() {
      this.customLock = false; //by default its unlocked | will get locked when user switches any preset value 
      this.pictureApi = new PictureSettingsApi();
      this.options = this.pictureApi.getOptions(); //#byDefault //not required //fetches the defaults dummy values //following api calls fetches the actual values from api here after
      this.pictureApi.getSupportedPictureModes().then(res => {
        if (res) {
          this.options = this.pictureApi.getOptions();
          this.refreshList();
        }
      }).catch(err => {
        console.log("ERROR from settings overlay screen firstEnable: getSupportedPictureModes: ", JSON.stringify(err));
      });
      //the getSupportedColorTemps api call has some issue when working on chrome browser
      this.pictureApi.getSupportedColorTemps().then(res => {
        if (res) {
          this.options = this.pictureApi.getOptions();
          this.refreshList();
        }
      }).catch(err => {
        console.log("ERROR from settings overlay screen firstEnable: getSupportedColorTemps: ", JSON.stringify(err));
      });
    }
    refreshList() {
      console.log("this.refreshList got called");
      this.tag("List").items = this.options.map((item, index) => {
        return {
          w: 500,
          h: 90,
          type: TvOverlaySettingsItem,
          item: item
        };
      });
    }
    _focus() {
      this.fireAncestors('$focusOverlay');
      console.log("index: ", this.tag("List").index);
      // this.tag("List").setIndex(0);//not necessary
    }

    _unfocus() {
      this.fireAncestors('$unfocusOverlay');
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.fireAncestors('$resetTimeout');
      if (this.tag("List").index < this.tag("List").length - 1) {
        //to prevent circular scrolling
        if (this.tag("List").index === 1) {
          //to check if user should be moving to third item
          if (!this.customLock) {
            //customLock value is true means api call is happening wait before moving down
            this.moveDownOnCustom();
          } else {
            console.log("changing the preset value cant moveDown now!!");
          }
        } else {
          this.tag("List").setNext();
        }
      }
    }
    _handleUp() {
      this.fireAncestors('$resetTimeout');
      if (this.tag("List").index > 0) {
        //to prevent circular scrolling
        this.tag("List").setPrevious();
      }
    }
    _handleLeft() {
      // do nothing
    }
    _handleRight() {
      // do nothing
    }
    async moveDownOnCustom() {
      try {
        const pictureMode = await this.pictureApi.getPictureMode();
        const colorTemp = await this.pictureApi.getColorTemperature();
        console.log("picture mode: ", pictureMode, " color temperature: ", colorTemp);
        if (pictureMode === "custom" && colorTemp === "User Defined") {
          this.tag("List").setNext();
        } else {
          this.tag("List").setIndex(1);
        }
      } catch {
        console.log("error occoured in api call");
      }
    }
    $moveDownLock(lock) {
      this.customLock = lock; //prevents user from moving down when a preset value change api call is happening
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlayInputItem extends t.Component {
    _construct() {
      this.Tick = Utils.asset("/images/settings/Tick.png");
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1720,
          h: 3,
          rect: true,
          color: 0xffffffff
        },
        Item: {
          w: 1720,
          h: 90,
          Loader: {
            zIndex: 10,
            h: 45,
            w: 45,
            x: 1720,
            y: 45,
            mountY: 0.5,
            mountX: 1,
            src: Utils.asset("images/settings/Loading.png"),
            color: 0xffffffff,
            visible: false
          },
          InputError: {
            x: 1500,
            y: 45,
            mountY: 0.5,
            text: {
              text: Language$1.translate("Input not available"),
              fontSize: 25,
              textColor: 0xffffffff,
              fontFace: CONFIG.language.font
            },
            visible: false
          }
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1720,
          h: 3,
          rect: true,
          color: 0xffffffff
        }
      };
    }
    set isTicked(isTicked) {
      this.tag("Item").patch({
        Tick: {
          x: 10,
          y: 45,
          mountY: 0.5,
          h: 32.5,
          w: 32.5,
          src: this.Tick,
          color: 0xffffffff,
          visible: isTicked
        }
      });
      this.tag("Item.InputError").visible = false; //to remove the error text, when the list is refreshed.
    }

    _init() {
      console.log("_init from inputItem: list is getting rendered");
      this.hdmiApi = new HDMIApi();
      this.loadingAnimation = this.tag("Item.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag("Item").patch({
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: this.itemName,
            fontSize: 25,
            textColor: 0xffffffff,
            fontFace: CONFIG.language.font
          }
        }
      });
      this.tag("Item.Tick").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Tick.png";
        this.tag("Item.Tick").src = url;
      });
      this.tag("Item.Loader").on("txError", () => {
        const url = "http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png";
        this.tag("Item.Loader").src = url;
      });
    }
    _handleEnter() {
      this.fireAncestors('$resetTimeout');
      if (!this.tag("Item.Tick").visible) {
        //to start the loader
        this.loadingAnimation.start();
        this.tag("Item.Loader").visible = true;
        this.tag("Item.InputError").visible = false;
        const minLoaderDuration = 1000; //1 sec min duration to show the loader before the tick mark appears in the ui
        /////////////////
        this.hdmiApi.getHDMIDevices() //api does not throw error, just consider error condition when result is empty
        .then(res => {
          console.log("getHDMIDevices from input Item: ", JSON.stringify(res));
          if (res.length > 0) {
            res.map((item, index) => {
              if (item.id === this.uniqID.id) {
                if (item.connected === "true") {
                  //to check if the current item is connected
                  this.hdmiApi.setHDMIInput(item).then(res => {
                    console.log("input set to: ", JSON.stringify(item));
                    //to stop the loader and show tickmark
                    setTimeout(() => {
                      this.loadingAnimation.stop();
                      this.tag("Item.Loader").visible = false;
                      Storage$1.set("_currentInputMode", {
                        id: item.id,
                        locator: item.locator
                      });
                      this.fireAncestors("$getInputs"); //getInputs will fetch the inputs from api,
                    }, minLoaderDuration);
                  }).catch(err => {
                    console.log("Failed to setHDMIInput", JSON.stringify(err));
                    //to stop the loader
                    setTimeout(() => {
                      this.loadingAnimation.stop();
                      this.tag("Item.Loader").visible = false;
                    }, minLoaderDuration);
                    ///////////////////////
                    //display the error in the notification
                  });
                } else {
                  console.log("device not connected! item: ", JSON.stringify(item));
                  setTimeout(() => {
                    this.loadingAnimation.stop();
                    this.tag("Item.Loader").visible = false;
                    this.tag("Item.InputError").visible = true;
                  }, minLoaderDuration);
                }
              } else {
                console.log("ID not match! uniqID: ", JSON.stringify(this.uniqID), " item: ", JSON.stringify(item));
              }
            });
          } else {
            console.log("getHDMIDevices returned empty array"); //in case of error, getHDMIDevices api return empty array
            setTimeout(() => {
              this.loadingAnimation.stop();
              this.tag("Item.Loader").visible = false;
            }, minLoaderDuration);
          }
        }).catch(err => {
          console.log("Failed to getHDMIDevices", JSON.stringify(err));
          //to stop the loader
          setTimeout(() => {
            this.loadingAnimation.stop();
            this.tag("Item.Loader").visible = false;
          }, minLoaderDuration);
        });
      } else {
        console.log(Storage$1.get("_currentInputMode"));
      }
    }
    _focus() {
      //  this.tag("Item").color = COLORS.hightlightColor;
      this.refresh = false; //to check if the list needs a refresh // if connection status is false and user presses enter twice, hdmi input list gets refreshed
      this.tag("TopLine").color = CONFIG.theme.hex;
      this.tag("BottomLine").color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag("TopLine").h = 6;
      this.tag("BottomLine").h = 6;
    }
    _unfocus() {
      this.tag("TopLine").color = 0xffffffff;
      this.tag("BottomLine").color = 0xffffffff;
      this.patch({
        zIndex: 1
      });
      this.tag("TopLine").h = 3;
      this.tag("BottomLine").h = 3;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class TvOverlayInputScreen extends t.Component {
    static _template() {
      return {
        Contents: {
          h: 630,
          w: 1920,
          x: 960,
          mountX: 0.5,
          Background: {
            h: 630,
            w: 1920,
            rect: true,
            colorTop: 0xff000000,
            colorBottom: 0x99000000
          },
          Title: {
            y: 70,
            x: 100,
            text: {
              text: Language$1.translate("Video Input"),
              fontFace: CONFIG.language.font,
              textColor: CONFIG.theme.hex,
              fontSize: 40,
              wordWrap: false,
              wordWrapWidth: 370,
              fontStyle: "bold",
              textOverflow: "ellipsis"
            }
          },
          Inputs: {
            w: 1720,
            h: 370,
            clipping: true,
            y: 166,
            x: 960,
            mountX: 0.5,
            // rect: true, //
            // color: 0xffff0000, //
            List: {
              type: t.components.ListComponent,
              w: 1720,
              h: 370,
              y: 5,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -3
            }
          },
          BorderLine: {
            y: 630,
            mountY: 1,
            w: 1920,
            h: 3,
            rect: true,
            color: 0xffffffff
          }
        }
      };
    }
    refreshItems(selected) {
      console.log("refreshItems called: rendering the items");
      this.tag("List").items = this.inputItems.map((item, index) => {
        return {
          ref: "Inputs" + index,
          w: 1720,
          h: 90,
          type: TvOverlayInputItem,
          isTicked: selected.id === item.id && selected.locator === item.locator,
          itemName: this.options[index],
          //item.toUpperCase(), //pass the formated item name if required
          uniqID: item,
          //pass a uniq id that is to be returned when handle enter is pressed
          onHandleEnter: this.refreshItems.bind(this) //pass this function to refresh the tickmarks
        };
      });
    }

    _firstEnable() {
      this.options = ["HDMI1", "HDMI2", "HDMI3", "HDMI4"];
      this.inputItems = [{
        id: 0,
        locator: "hdmiin://localhost/deviceid/0",
        connected: true
      }, {
        id: 1,
        locator: "hdmiin://localhost/deviceid/1",
        connected: false
      }, {
        id: 2,
        locator: "hdmiin://localhost/deviceid/2",
        connected: true
      }];
      this.hdmiApi = new HDMIApi();
      this.$getInputs();
    }
    $getInputs() {
      console.log("fetching hdmi input options"); //call get inputs and refresh items after an event

      this.hdmiApi.getHDMIDevices().then(res => {
        this.inputItems = res;
        this.refreshItems(Storage$1.get("_currentInputMode"));
      }).catch(err => {
        console.log("inputScreen: getHDMIDevices Error: ", JSON.stringify(err));
      });
    }
    _focus() {
      this.fireAncestors('$focusOverlay');
      this.$getInputs(); //fetch the input modes and refresh the list, in case input status changes
    }

    _unfocus() {
      this.fireAncestors('$unfocusOverlay');
    }
    _getFocused() {
      return this.tag("List").element;
    }
    _handleDown() {
      this.fireAncestors('$resetTimeout');
      this.tag("List").setNext();
    }
    _handleUp() {
      this.fireAncestors('$resetTimeout');
      this.tag("List").setPrevious();
    }
    _handleLeft() {
      this.fireAncestors('$resetTimeout');
      // do nothing
    }

    _handleRight() {
      this.fireAncestors('$resetTimeout');
      // do nothing
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$9 = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  var thunder$a = thunderJS$1(config$9);
  class TvOverlayScreen extends t.Component {
    set params(args) {
      this._type = args.type;
      console.log("setting to idlestate");
      setTimeout(() => {
        if (this._type === "inputs") {
          this._setState("OverlayInputScreen");
        } else if (this._type === "settings") {
          this._setState("OverlaySettingsScreen");
        }
      }, 300);
    }

    // _onChanged() {
    //   this._setState("IdleState");
    // }

    static _template() {
      return {
        w: 1920,
        h: 1080,
        OverlaySettingsScreen: {
          x: -500,
          //set the x value to -500+ and add animation from left
          y: 0,
          type: TvOverlaySettingsScreen
        },
        OverlayInputScreen: {
          x: 0,
          y: -630,
          type: TvOverlayInputScreen
        }
      };
    }

    //   _getFocused() {
    //     console.log("getFocused Called")
    //     if (this._type === "inputs") {
    //       this._setState("OverlayInputScreen");
    //     } else if (this._type === "settings") {
    //       this._setState("OverlaySettingsScreen");
    //     }
    //   }

    _firstEnable() {
      this.appApi = new AppApi();
      this.overlayTimeout = null;
      this.timeoutDuration = 30000;
      this._sidePanelAnimation = this.tag("OverlaySettingsScreen").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "x",
          v: {
            0: -500,
            1: 0
          }
        }]
      });
      this._topPanelAnimation = this.tag("OverlayInputScreen").animation({
        delay: 0.3,
        duration: 0.3,
        stopMethod: "reverse",
        //so that .stop will play the transition towards left
        actions: [{
          p: "y",
          v: {
            0: -630,
            1: 0
          }
        }]
      });
    }
    _focus() {}
    $focusOverlay() {
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $unfocusOverlay() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
    }
    $resetTimeout() {
      this.overlayTimeout && Registry.clearTimeout(this.overlayTimeout);
      this.overlayTimeout = Registry.setTimeout(() => {
        this._handleBack();
      }, this.timeoutDuration);
    }
    $closeOverlay() {
      this._handleBack();
    }
    _handleBack() {
      let currentApp = Storage$1.get("applicationType");
      this._setState("IdleState");
      console.log("currentApp: ", currentApp);
      setTimeout(() => {
        if (currentApp !== "") {
          this.appApi.setVisibility("ResidentApp", false);
          thunder$a.call("org.rdk.RDKShell", "moveToFront", {
            client: currentApp
          }).then(result => {
            console.log(currentApp, " moveToFront Success");
            thunder$a.call("org.rdk.RDKShell", "setFocus", {
              client: currentApp
            }).then(result => {
              console.log(currentApp, " setFocus Success");
            }).catch(err => {
              console.log("Error", err);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            //don't navigate to menu if route is dtvplayer
            Router.focusPage();
          } else {
            console.log("else block navigating to menu");
            Router.navigate("menu"); //if user is currently on resident app, might not be needed as user should not be able to get on this screen while on resident app
          }
        }
      }, 500);
    }
    static _states() {
      return [class IdleState extends this {
        $enter() {
          console.log("entering overlay IdleState");
        }
        $exit() {
          console.log("exiting overlay IdleState");
        }
      }, class OverlaySettingsScreen extends this {
        $enter() {
          this._topPanelAnimation.finish();
          this._sidePanelAnimation.start();
          console.log("$enter from OverlaySettingsScreen");
        }
        $exit() {
          this._sidePanelAnimation.stop();
        }
        _getFocused() {
          return this.tag("OverlaySettingsScreen");
        }
      }, class OverlayInputScreen extends this {
        $enter() {
          this._sidePanelAnimation.finish();
          this._topPanelAnimation.start();
          console.log("$enter from OverlayInputScreen");
        }
        $exit() {
          this._topPanelAnimation.stop();
        }
        _getFocused() {
          return this.tag("OverlayInputScreen");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class ChannelItem extends t.Component {
    static _template() {
      return {
        w: 236,
        Title: {
          x: 10,
          y: 45,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: 'xxxxxx',
            fontFace: CONFIG.language.font,
            fontStyle: 'normal',
            fontSize: 21,
            textColor: 0xffffffff,
            maxLines: 1,
            maxLinexSuffix: '...',
            wordWrapWidth: 232
          }
        },
        Item: {
          w: 236 - 3,
          h: 78,
          color: 0xff272727,
          rect: true
          // texture: Lightning.Tools.getRoundRect(236, 81, 0, 1, 0xff000000, true, 0xff1d1c1c),
        }
      };
    }

    setBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "bold";
    }
    unsetBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "normal";
    }
    set fontStyle(v) {
      this.tag('Title').text.fontStyle = v;
    }
    set title(val) {
      this.tag('Title').text = val;
    }
    get title() {
      return this.tag("Title").text;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Shows extends t.Component {
    static _template() {
      return {
        y: 200
      }; /* this is just an empty component. used like a parent container for Cell containers */
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class Cell extends t.Component {
    static _template() {
      return {
        zIndex: 2
      };
    }
    set txt(ins) {
      /* the text on the Cell */
      this.patch({
        AiringOverlay: {
          zIndex: 4,
          Title: {
            x: 10,
            y: 45,
            mountY: 0.5,
            text: {
              text: ins ? ins : Language$1.translate("No Shows are being aired at the moment"),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...'
            }
          }
        }
      });
      this.insText = ins ? ins : Language$1.translate("No Shows are being aired at the moment");
    }
    get txt() {
      return this.insText;
    }
    set color(val) {
      let title = this.tag("Title");
      if (title) title.text.textColor = val;
    }
    setBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "bold";
    }
    unsetBoldText() {
      let title = this.tag("Title");
      if (title) title.text.fontStyle = "normal";
    }
    set width(w) {
      /* the horizontal width of the Cell */
      this.patch({
        Item: {
          // clipping: true,
          w: w - 3,
          h: 78,
          color: 0xff272727,
          rect: true
          // texture: Lightning.Tools.getRoundRect(w, 81, 0, 1, 0xff000000, true, 0xff272727),
        }
      });

      this.tag('Title').text.wordWrapWidth = w - 20;
    }
    getwidth() {
      return this.width;
    }
    _init() {
      this.tag('AiringOverlay').w = this.tag('Item').w;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class CellCursor extends t.Component {
    static _template() {
      return {
        zIndex: 5,
        UpperLine: {
          x: 0,
          y: 0,
          rect: true,
          w: 236,
          h: 2,
          color: CONFIG.theme.hex
        },
        LowerLine: {
          x: 0,
          y: 79,
          rect: true,
          w: 236,
          h: 2,
          color: CONFIG.theme.hex
        }
        // texture:Lightning.Tools.getRoundRect(236 ,81,0,1,0xffFFFFFF,true,0x0000ffff) // if you change this then you may wanna change the part where it patches itself too.
      };
    }

    patchCursor(x, y, w) {
      this.tag("UpperLine").patch({
        smooth: {
          x: x,
          y: y,
          w: w - 3
        }
      });
      this.tag("LowerLine").patch({
        smooth: {
          x: x,
          y: y + 79,
          w: w - 3
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let k = 5;
  const homeApi = new HomeApi();
  const dtvApi$3 = new DTVApi();
  class Epg extends t.Component {
    static _template() {
      return {
        Background: {
          color: 0xff000000,
          w: 1920,
          h: 1080,
          rect: true
        },
        Loader: {
          x: 960,
          y: 540,
          mount: 0.5,
          w: 100,
          h: 100,
          src: Utils.asset("images/settings/Loading.png"),
          visible: true
        },
        Wrapper: {
          x: 200,
          y: 150,
          w: 1920,
          h: 1080,
          visible: false,
          DayLabel: {
            x: 0,
            y: 281,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('Today'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ShowName: {
            x: 0,
            y: 195,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('SHOW'),
              fontFace: CONFIG.language.font,
              fontStyle: 'bold',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ShowTimings: {
            x: 236 * 5 + 59,
            y: 195,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('SHOW-TIMINGS'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 1,
              maxLinexSuffix: '...',
              wordWrapWidth: 236
            }
          },
          ChannelName: {
            x: 236 * 5 + 59,
            y: 225,
            w: 236,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('CHANNEL-NAME'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 2,
              maxLinexSuffix: '...',
              wordWrapWidth: 236 * 5
            }
          },
          ShowDetails: {
            x: 0,
            y: 225,
            w: 236 * 5,
            h: 81,
            mountY: 0.5,
            text: {
              text: Language$1.translate('SHOW-DETAILS'),
              fontFace: CONFIG.language.font,
              fontStyle: 'normal',
              fontSize: 21,
              textColor: 0xffffffff,
              maxLines: 2,
              maxLinexSuffix: '...',
              wordWrapWidth: 236 * 5
            }
          },
          Channels: {
            x: 0,
            y: 81 + 200,
            w: 236
          },
          TopBar: {
            y: 200,
            x: 236,
            TimeNotifiers: {
              x: -4,
              w: 236 * 6 + 2,
              h: 81,
              clipping: true,
              TimeBar: {
                // this is the gray bar
                x: k,
                y: 81 - 12,
                // this should be the ShowLists "y" value - 9, extra -3 to accomodate margin
                rect: true,
                h: 9,
                w: 0,
                color: 0xff404040
              },
              DownTriangle: {
                // this is the little triangle over the white bar.
                x: 4,
                y: 81 - 12,
                // this should be the same as TimeBar's "y" Value, extra -3 to accomodate margin
                mountX: 0.5,
                mountY: 0.5,
                color: 0xffffffff,
                text: {
                  text: "".concat(String.fromCodePoint(9662)),
                  fontSize: 25,
                  textColor: 0xffffffff
                }
              }
            },
            TimeLabels: {
              clipping: true,
              zIndex: 2,
              w: 236 * 6,
              h: 81,
              x: k,
              y: 0
            },
            Wrapper: {
              w: 236 * 6,
              h: 81 * 9,
              clipping: true,
              Shows: {
                y: 81,
                // x: 236,
                type: Shows
              },
              CellCursor: {
                y: 81,
                type: CellCursor
              }
            }
          }
        }
      };
    }
    setChannels(channels) {
      let c = channels.map((c, i) => {
        return {
          y: 81 * i,
          w: 236,
          type: ChannelItem,
          title: c.shortname
        };
      });
      this.tag('Channels').children = c;
      this.channelGridInstance = this.tag('Channels').children;
    }
    _firstEnable() {
      this.appApi = new AppApi();
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate("menu");
      }
    }
    getEventURI(events) {
      let showName = this.gridInstance[this.currentCellIndex].txt;
      let eventUri = null;
      for (let i = 0; i < events.length; i++) {
        if (events[i].name === showName) {
          eventUri = events[i].iptvuri;
        }
      }
      return eventUri;
    }
    async _handleEnter() {
      let channel = this.getCurrentChannel();
      let events = await dtvApi$3.getEvents(channel.dvburi);
      let eventUri = null;
      if (events != undefined) {
        eventUri = this.getEventURI(events);
      }
      if (channel.dvburi === "OTT") {
        let params = {
          launchLocation: "epgScreen",
          url: channel.url
        };
        const appIdentifiers = {
          "YouTube": "n:5",
          "YouTube": "n:4",
          "YouTube": "n:3",
          "Netflix": "n:1",
          "Amazon": "n:2"
        }; //callsign to identifier mapping
        const appIdentifier = appIdentifiers[channel.callsign];
        if (appIdentifier) {
          params.appIdentifier = appIdentifier;
        }
        this.appApi.launchApp(channel.callsign, params);
      } else if (channel.dvburi.startsWith("C_") && eventUri != null) {
        if (!Router.isNavigating()) {
          let playerParams = {
            url: eventUri,
            //video url for playing
            isChannel: true,
            channelName: channel.channelName,
            showName: this.gridInstance[this.currentCellIndex].insText,
            showDescription: this.gridInstance[this.currentCellIndex].description,
            channelIndex: this.D - 8 + this.currentlyFocusedRow
          };
          Router.navigate("player", playerParams);
        }
      } else {
        if (!Router.isNavigating()) {
          this.DTV.launchChannel(channel.dvburi).then(res => {
            console.log("launchChannel method successful: ", JSON.stringify(res));
            this.widgets.channeloverlay.$focusChannel(this.D - 8 + this.currentlyFocusedRow);
            Router.navigate("dtvplayer");
          }).catch(err => {
            console.log("launchChannel method failed: ", JSON.stringify(err));
          });
        } else {
          console.error("Router is still navigating.");
        }
      }
    }
    getCurrentChannel() {
      let currentChannel = this.activeChannels[this.currentlyFocusedRow];
      return currentChannel;
    }
    setShows4Channels(channels) {
      let headStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.strtindexesofrows = [];
      let ltp = this.ltp;
      let rtp = new Date(this.ltp.getTime() + 3 * 60 * 60 * 1000);
      let cells = [];
      let self = this;
      function filterShowsBasedOnTimeWindow(shows, index) {
        let inc = headStart < 0 ? -1 : 1;
        let i = Math.abs(headStart);
        while (i >= 0) {
          // binary search can optimize this loop.

          shows[i].endtime = shows[i].duration + shows[i].starttime;
          if (i >= shows.length) {
            console.warn("Reached the end of data , can't traverse shows any further!");
            break;
          } else if (new Date(shows[i].starttime) <= ltp && new Date(shows[i].endtime) > ltp) {
            break;
          } else if (new Date(shows[i].starttime) > ltp) {
            console.warn("there's chance that an empty space appear in one of the rows");
            break;
          } else if (i === shows.length - 1) {
            console.warn('traversed all of the shows and none of them are airing at this time for this channel');
            return;
          }
          i += inc;
        }
        let x = 0;
        self.strtindexesofrows.push(cells.length);
        for (; i < shows.length; i++) {
          if (new Date(shows[i].starttime) >= rtp) {
            break;
          }
          let width = shows[i].duration / (1000 * 60) / 30 * 236;
          shows[i].endtime = shows[i].duration + shows[i].starttime;
          // the below code trim the left most and right most cells
          if (new Date(shows[i].starttime) < ltp) {
            width -= (ltp - new Date(shows[i].starttime)) / (1000 * 60) / 30 * 236;
          }
          if (new Date(shows[i].endtime) > rtp) {
            width -= (new Date(shows[i].endtime) - rtp) / (1000 * 60) / 30 * 236;
          }
          //------------ Trimming ends here-----------------
          if (shows[i].shortdescription === "") {
            cells.push({
              x: x,
              y: index * 81,
              w: width,
              type: Cell,
              txt: shows[i].name,
              description: shows[i].shortdescription,
              width: width,
              starttime: shows[i].starttime,
              showIndex: i,
              duration: shows[i].duration,
              endtime: shows[i].endtime
            });
          } else {
            cells.push({
              x: x,
              y: index * 81,
              w: width,
              type: Cell,
              txt: shows[i].name,
              description: shows[i].description,
              width: width,
              starttime: shows[i].starttime,
              showIndex: i,
              duration: shows[i].duration,
              endtime: shows[i].endtime
            });
          }
          shows[i].duration + shows[i].starttime;
          x += width;
        }
        // the below code actually sets the shows
        if (index === channels.length - 1) {
          let shows = self.tag('Shows');
          shows.children = cells;
          self.strtindexesofrows.push(cells.length); // this is added just for calculation.
          self.gridInstance = shows.children;
          // self.updateCursor()
          self._setState('CellSelector');
        }
      }
      channels.map((channel, i) => {
        filterShowsBasedOnTimeWindow(channel.shows, i);
      });
    }
    setTimeLabelsBetween() {
      let startTime = this.ltp;
      let endTime = new Date(this.ltp.getTime() + 3 * 60 * 60 * 1000);
      let arr = [];
      let p = this.tag('TimeLabels');
      for (let t = startTime, i = 0; t <= endTime; t = new Date(t.getTime() + 30 * 60 * 1000), i++) {
        // the increment can probably be improvised
        let H = t.getHours();
        let M = t.getMinutes();
        M = M.toString().length < 2 ? '0' + M : M;
        arr.push({
          x: i * 236,
          y: 35,
          mountY: 0,
          text: {
            text: H >= 12 ? H === 12 ? "".concat(H, ":").concat(M, "PM") : "".concat(H - 12, ":").concat(M, "PM") : "".concat(H, ":").concat(M, "AM"),
            fontFace: CONFIG.language.font,
            fontStyle: 'normal',
            fontSize: 21,
            textColor: 0xffffffff,
            maxLines: 1,
            maxLinexSuffix: '...'
          }
        });
        p.children = arr;
      }
    }
    initialize() {
      this.ltp = new Date();
      let currentDateTime = this.ltp;
      let temp = currentDateTime.getMinutes();
      let closest30MinRoundOff;
      //the below round off system only works if the duration of the show is a multiple of 30.
      currentDateTime.setMilliseconds(0);
      currentDateTime.setSeconds(0);
      if (temp >= 30) {
        currentDateTime.setMinutes(30);
        closest30MinRoundOff = currentDateTime;
      } else {
        currentDateTime.setMinutes(0);
        closest30MinRoundOff = currentDateTime;
      }
      this.ltp = closest30MinRoundOff;
      this.closest30MinRoundOff = closest30MinRoundOff.getTime();
      this.setTimeLabelsBetween();
      let tBar = this.tag('TimeBar');
      let dTriangle = this.tag('DownTriangle');
      let self = this;
      this.interval = setInterval(() => {
        let now = new Date();
        if (now.getHours() === 0) ;
        let t = (now - self.ltp >= 0 ? now - self.ltp : 0) / (1000 * 60 * 30) * 236;
        tBar.w = t;
        dTriangle.x = t + k;
      }, 0);
    }
    setBoldText() {
      let l = this.strtindexesofrows[this.currentlyFocusedRow];
      let r = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
      this.channelGridInstance[this.currentlyFocusedRow].setBoldText();
      for (let i = l; i <= r; i++) {
        this.gridInstance[i].setBoldText();
      }
    }
    unsetBoldText() {
      let l = this.strtindexesofrows[this.currentlyFocusedRow];
      let r = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
      this.channelGridInstance[this.currentlyFocusedRow].unsetBoldText();
      for (let i = l; i <= r; i++) {
        this.gridInstance[i].unsetBoldText();
      }
    }
    scrollVertically(n) {
      if (n < 0) {
        this.D--;
      } else {
        this.D++;
      }
      console.log("setting vertical scroll from ".concat(this.D - 8, " to ").concat(this.D, " based the value ").concat(n));
      this.activeChannels = this.channels.slice(this.D - 8, this.D);
      this.setChannels(this.activeChannels);
      this.setShows4Channels(this.activeChannels);
    }
    onDataProvidedX() {
      console.log("on Data Provided");
      this.initialize();
      this.scrollVertically();
      this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
      this.setBoldText();
      this.paintCell();
      this.updateCursor();
      this.verticallyNonScrollableWindow = Math.min(this.channels.length - 1, 7);
    }
    paintCell() {
      this.gridInstance[this.currentCellIndex].color = CONFIG.theme.hex;
    }
    unpaintCell() {
      this.gridInstance[this.currentCellIndex].color = 0xffffffff;
    }
    _focus() {
      this.D = 7;
      this.DTV = this.DTV ? this.DTV : new DTVApi();
      let wrapper = this.tag("Wrapper");
      let loader = this.tag("Loader");
      wrapper.visible = false;
      loader.visible = true;
      this.loadingAnimation.start();
      let self = this;
      function f(page) {
        let d = new Date();
        d.setHours(0);
        d.setMinutes(0);
        d.setSeconds(0);
        d.setMilliseconds(0);
        d = d.getTime();
        let e = d + 7 * 24 * 60 * 60 * 1000;
        function filler(shows) {
          let diff = 0;
          let currentShowETime = d;
          diff = shows[0].starttime - d;
          if (diff > 0) {
            shows.unshift({
              name: '',
              starttime: d,
              duration: diff,
              eventid: 0,
              shortdescription: ''
            });
          }
          let memLeakAlert = shows.length - 1;
          for (let i = 0; i < shows.length - 1; i++) {
            currentShowETime = shows[i].starttime + shows[i].duration;
            diff = shows[i + 1].starttime - currentShowETime;
            if (diff > 0) {
              if (memLeakAlert < 0) {
                console.warn('Memory leak alert; aborting black cell insert');
              }
              shows.splice(i + 1, 0, {
                name: '',
                starttime: currentShowETime,
                duration: diff,
                eventid: 0,
                shortdescription: ''
              });
              memLeakAlert--;
            }
          }
          currentShowETime = shows[shows.length - 1].starttime + shows[shows.length - 1].duration;
          diff = e - currentShowETime;
          if (e > 0) {
            shows.push({
              name: '',
              starttime: currentShowETime,
              duration: diff,
              eventid: 0,
              shortdescription: ''
            });
          }
        }
        return new Promise((resolve, reject) => {
          self.DTV.serviceList().then(async channels => {
            await homeApi.checkChannelComapatability(channels).then(res => {
              channels = res;
            });
            let traversedChannels = 0;
            channels.map((channel, i) => {
              if (channel.dvburi === "OTT") {
                traversedChannels++;
                channels[i].shows = [{
                  name: Language$1.translate("click to launch") + " ".concat(channel.shortname),
                  starttime: 0,
                  duration: e,
                  eventid: 0,
                  shortdescription: ''
                }];
                if (channels.length - 1 === traversedChannels) {
                  console.log("premium apps exclusive resolve");
                  page.channels = channels;
                  resolve(true);
                }
                return 0;
              }
              self.DTV.scheduleEvents(channel.dvburi).then(shows => {
                traversedChannels++;
                // for premium apps and empty cell
                if (!shows || shows.length === 0) {
                  channels[i].shows = [{
                    name: '',
                    starttime: d,
                    duration: e,
                    eventid: 0,
                    shortdescription: ''
                  }];
                } else {
                  channels[i].shows = shows;
                  filler(channels[i].shows);
                }
                if (channels.length === traversedChannels) {
                  page.channels = channels;
                  resolve(true);
                }
              }).catch(err => {
                // console.error(err)
                // return "Home"
                console.error('error', err);
                reject(err);
              });
            });
          }).catch(err => {
            reject(err);
          });
        });
      }
      f(this).then(res => {
        self.loadingAnimation.stop();
        self.onDataProvidedX();
        loader.visible = false;
        wrapper.visible = true;
      }).catch(err => {
        console.log("error while fetching data from dtv", err);
        Router.navigate('menu');
      });
    }
    _init() {
      this.D = 7;
      this.currentCellIndex = 0;
      this.currentlyFocusedRow = 0;
      this.strtindexesofrows = [];
      this.cursorInstance = this.tag('CellCursor');
      this.loadingAnimation = this.tag("Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      //resetting all variables
      this.D = 7;
      this.currentCellIndex = 0;
      this.currentlyFocusedRow = 0;
      this.strtindexesofrows = [];
    }
    scrollHorizontally(n) {
      if (n < 0) {
        let prevShow = this.channels[this.D - (8 - this.currentlyFocusedRow)].shows[this.gridInstance[this.currentCellIndex].showIndex - 1];
        // this.ltp = new Date(Math.max(prevShow.starttime, this.closest30MinRoundOff))
        this.ltp = new Date(Math.max(prevShow.starttime));
        this.setShows4Channels(this.activeChannels);
        this.currentCellIndex = this.strtindexesofrows[this.currentlyFocusedRow];
        this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
        this.updateCursor();
      } else {
        let nextShow = this.channels[this.D - (8 - this.currentlyFocusedRow)].shows[this.gridInstance[this.currentCellIndex].showIndex + 1];
        if (nextShow.duration > 3 * 60 * 60 * 1000) {
          this.ltp = new Date(nextShow.starttime);
        } else {
          let l = nextShow.starttime + nextShow.duration - 3 * 60 * 60 * 1000;
          this.ltp = new Date(l);
        }
        this.setShows4Channels(this.activeChannels);
        this.currentCellIndex = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
        this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
        this.updateCursor();
      }
      this.setTimeLabelsBetween();
      this.setBoldText();
    }
    _onChanged() {
      this.widgets.menu.updateTopPanelText(Language$1.translate('Guide'));
    }
    pageTransition() {
      return 'up';
    }
    _handleLeft() {
      Router.focusWidget('Menu');
    }
    _handleUp() {
      this.widgets.menu.notify('TopPanel');
    }
    static _states() {
      return [class CellSelector extends this {
        $enter() {}
        _handleLeft() {
          this.unpaintCell();
          if (this.currentCellIndex > this.strtindexesofrows[this.currentlyFocusedRow]) {
            this.currentCellIndex--;
            this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
            this.updateCursor();
          } else if (this.gridInstance[this.currentCellIndex].showIndex > 0) {
            this.scrollHorizontally(-1);
          } else {
            console.log("can't traverse any left");
            Router.focusWidget('Menu');
          }
          this.paintCell();
        }
        _handleRight() {
          this.unpaintCell();
          this.channels[this.D - (8 - this.currentlyFocusedRow)].shortname;
          if (this.currentCellIndex < this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1) {
            this.currentCellIndex++;
            this.cellTimeTracker = this.gridInstance[this.currentCellIndex].starttime;
            this.updateCursor();
          } else if (this.gridInstance[this.currentCellIndex].showIndex < this.channels[this.D - (8 - this.currentlyFocusedRow)].shows.length - 1) {
            //current Cell index has to be updated at last
            this.scrollHorizontally(1);
          } else console.log("can't go further right");
          this.paintCell();
        }
        binarySearch(t, left, right) {
          const lim = left;
          t = new Date(t);
          let mid;
          while (left <= right) {
            mid = left + Math.floor((right - left) / 2);
            const sTime = new Date(this.gridInstance[mid].starttime);
            const eTime = new Date(this.gridInstance[mid].endtime);
            if (t >= sTime && t < eTime) return mid;else if (sTime > t) right = mid - 1;else left = mid + 1;
          }
          mid = Math.max(lim, left - 1);
          return mid;
        }
        _handleDown() {
          this.unpaintCell();
          this.unsetBoldText();
          if (this.currentlyFocusedRow < this.verticallyNonScrollableWindow) {
            let t = this.cellTimeTracker;
            this.currentlyFocusedRow++;
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            this.currentCellIndex = idx;
            this.updateCursor();
          } else if (this.D < this.channels.length) {
            let t = this.cellTimeTracker;
            this.scrollVertically(1);
            //---------------------------------
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            //---------------------------------
            this.currentCellIndex = idx;
            this.updateCursor();
          } else console.log("can't go any further ,it's the last row");
          this.setBoldText();
          this.paintCell();
        }
        _handleUp() {
          this.unpaintCell();
          this.unsetBoldText();
          if (this.currentlyFocusedRow > 0) {
            let t = this.cellTimeTracker;
            this.currentlyFocusedRow--;
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            this.currentCellIndex = idx;
            this.updateCursor();
          } else if (this.D > 8) {
            let t = this.cellTimeTracker;
            this.scrollVertically(-1);
            //---------------------------------
            let left = this.strtindexesofrows[this.currentlyFocusedRow];
            let right = this.strtindexesofrows[this.currentlyFocusedRow + 1] - 1;
            let idx = this.binarySearch(t, left, right);
            //---------------------------------
            this.currentCellIndex = idx;
            this.updateCursor();
          } else console.log("can't go any further , it's the first row");
          this.setBoldText();
          this.paintCell();
        }
        async updateDayLabel(starttime) {
          let daylabel = this.tag('DayLabel');
          let dTriangle = this.tag('DownTriangle');
          let channel = this.getCurrentChannel();
          let eventUri = null;
          if (channel.dvburi.startsWith("C_")) {
            let events = await dtvApi$3.getEvents(channel.dvburi);
            eventUri = this.getEventURI(events);
          }
          setTimeout(function () {
            let today = new Date();
            today.setHours(0);
            today.setMinutes(0);
            today.setSeconds(0);
            today.setMilliseconds(0);
            let t = today.getTime();
            let day = 24 * 60 * 60 * 1000;
            if (starttime == 0) {
              daylabel.text.text = Language$1.translate('TODAY');
            } else if (starttime > t) {
              t = starttime - t;
              if (t < day) {
                daylabel.text.text = Language$1.translate('TODAY');
              } else {
                let cellStartTime = new Date(starttime);
                daylabel.text.text = cellStartTime.getDate() + '-' + (cellStartTime.getMonth() + 1) + '-' + cellStartTime.getFullYear();
              }
            } else {
              t = t - starttime;
              if (t < day) {
                daylabel.text.text = Language$1.translate('TODAY');
              } else {
                if (dTriangle.__active && eventUri === null) {
                  daylabel.text.text = Language$1.translate('TODAY');
                } else {
                  let cellStartTime = new Date(starttime);
                  daylabel.text.text = cellStartTime.getDate() + '-' + (cellStartTime.getMonth() + 1) + '-' + cellStartTime.getFullYear();
                }
              }
            }
          }, 0);
        }
        updateInfoLabels() {
          let currentCell = this.gridInstance[this.currentCellIndex];
          this.tag('ChannelName').text.text = this.channelGridInstance[this.currentlyFocusedRow].title.text;
          this.tag('ShowName').text.text = currentCell.txt;
          this.tag('ShowDetails').text.text = currentCell.description;
          let s = new Date(currentCell.starttime);
          let e = new Date(currentCell.endtime);
          let ehours = e.getHours();
          let eminutes = e.getMinutes();
          if (eminutes.toString().length < 2) eminutes = '0' + eminutes;
          if (ehours >= 12) {
            eminutes = eminutes + 'p';
            if (ehours > 12) {
              ehours -= 12;
            }
          }
          let shours = s.getHours();
          let sminutes = s.getMinutes();
          if (sminutes.toString().length < 2) {
            sminutes = '0' + sminutes;
          }
          if (shours > 12) {
            shours -= 12;
          }
          this.tag('ShowTimings').text.text = "".concat(shours, ":").concat(sminutes, " - ").concat(ehours, ":").concat(eminutes);
          this.updateDayLabel(currentCell.starttime);
        }
        updateCursor() {
          let x = this.gridInstance[this.currentCellIndex].x;
          let y = this.gridInstance[this.currentCellIndex].y;
          let w = this.gridInstance[this.currentCellIndex].w;
          let self = this;
          setTimeout(function () {
            self.updateInfoLabels();
          }, 0);
          this.cursorInstance.patchCursor(x, y, w);
        }
        $exit() {
          console.log('exiting from state - CellSelector');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class DTVPlayer extends t.Component {
    static _template() {
      return {
        Player: {
          w: 1920,
          h: 1080
        }
      };
    }
    _firstEnable() {
      this.dtvApi = new DTVApi();
      this.appApi = new AppApi();
    }
    _handleBack() {
      this.dtvApi.exitChannel().then(res => {
        console.log("exit channel: ", JSON.stringify(res));
      }).catch(err => {
        console.log("failed to exit channel: ", JSON.stringify(err));
      });
      Router.back();
    }
    _handleLeft() {
      Router.focusWidget("ChannelOverlay");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  //applauncher screen "will" be responsible for handling all overlays as widget and splash screens for apps(if required) | currently only handles settings overlay widget
  class AppLauncherScreen extends t.Component {
    static _template() {
      return {
        Overlay: {
          w: 1920,
          h: 1080
        },
        SplashImage: {
          w: 1920,
          h: 1080,
          x: 960,
          y: 540,
          mount: 0.5,
          src: "",
          visible: false
        }
      };
    }
    showSplashImage(callsign) {
      if (this.splashImages[callsign]) {
        //splash image won't be shown if the callsign and image location is mapped in this.splashImages

        //first frame event
        this.firstFrameListener = this._thunder.on("org.rdk.RDKShell", "onApplicationFirstFrame", notification => {
          console.log("onApplicationFirstFrame notification from applauncherscreen: ", notification);
          if (notification.client === callsign.toLowerCase()) {
            console.log("firstframe event triggered hiding splash image");
            this.tag("SplashImage").src = "";
            this.tag("SplashImage").visible = false;
            this.moveApptoFront(callsign);
            this.firstFrameListener.dispose(); //dispose listener after event is triggered for first time
          }
        });

        //to show the splash image
        this.splashTimeout && Registry.clearTimeout(this.splashTimeout);
        this.tag("SplashImage").src = Utils.asset(this.splashImages[callsign]);
        this.tag("SplashImage").visible = true;

        //to hide the splash image after 30 sec in case firstframe event failed
        this.splashTimeout = Registry.setTimeout(() => {
          console.log("timeout triggered hiding splash image");
          this.tag("SplashImage").src = "";
          this.tag("SplashImage").visible = false;
          this.moveApptoFront(callsign);
          this.firstFrameListener.dispose(); //dispose the event listener incase event did not trigger till 30s
        }, 30000);
      }
    }
    moveApptoFront(callsign) {
      //moving the launched app to front.
      console.log("moveToFront: ", callsign, "from applauncher");
      this._thunder.call("org.rdk.RDKShell", "moveToFront", {
        "client": callsign,
        "callsign": callsign
      }).catch(err => {
        console.error("failed to moveToFront : ", callsign, " ERROR: ", JSON.stringify(err), " | fail reason can be since app is already in front");
      });
    }
    _firstEnable() {
      console.log("AppLauncherScreen is enabled for firstTime");
      this.splashImages = {
        "Netflix": 'images/apps/App_Netflix_Splash.png'
      }; //mapping between callsigns and splash images
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
      this.appApi = new AppApi();
    }
    _focus() {
      console.log("AppLauncherScreen is focused");
    }
    _handleKey() {
      console.log("AppLauncherScreen is in focus, returning focus to corresponding app");
      if (Storage$1.get("applicationType") === "") {
        //if appLauncher screen is in focus while on residentApp
        this.appApi.zorder("ResidentApp");
        this.appApi.setFocus("ResidentApp");
        this.appApi.visible("ResidentApp", true);
        Router.navigate(Storage$1.get("lastVisitedRoute"));
      } else {
        //when appLauncher screen is in focus while on other apps
        let currentApp = Storage$1.get("applicationType");
        this.appApi.zorder(currentApp);
        this.appApi.setFocus(currentApp);
        this.appApi.visible(currentApp, true);
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$8 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var thunder$9 = thunderJS$1(config$8);
  class CodeScreen extends t.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          BackButton: {
            x: 180,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate("Back"),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true
          },
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: "",
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            },
            Description2: {
              x: -100,
              y: 500,
              mount: 0.5,
              text: {
                text: Language$1.translate("Loading Code") + "...",
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFF00CAFF,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {
      this._setState('Description');
    }
    _focus() {
      if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
        thunder$9.Controller.activate({
          callsign: "org.rdk.VoiceControl"
        }).then(res => {
          //AlexaApi.get().resetAVSCredentials();
          thunder$9.on("org.rdk.VoiceControl", 'onServerMessage', notification => {
            console.log("VoiceControl.onServerMessage Notification: ", notification);
            this.VoiceControlData = notification;
            if (notification.xr_speech_avs.url != undefined) {
              this.tag('Description').text.text = Language$1.translate('Enter the code at') + " ".concat(notification.xr_speech_avs.url);
            } else {
              this.tag('Description').text.text = Language$1.translate('Fetching authorization code');
            }
            this.tag("Description2").visible = true;
            if (notification.xr_speech_avs.code != undefined) {
              this.tag("Description2").text.text = "".concat(notification.xr_speech_avs.code);
            } else {
              this.tag("Description2").text.text = Language$1.translate('Please wait');
            }
            if (notification.xr_speech_avs.state === "refreshed") {
              // DAB Demo Work Around - show Alexa Error screens only after Auth is succeeded.
              AlexaApi.get().setAlexaAuthStatus("AlexaHandleError");
              AlexaApi.get().enableSmartScreen();
              Router.navigate("SuccessScreen");
            } else if (notification.xr_speech_avs.state === "uninitialized" || notification.xr_speech_avs.state === "authorizing") {
              console.log("notification state is uninitialised");
              AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
            } else if (notification.xr_speech_avs.state === "unrecoverable error") {
              console.log("notification state is unrecoverable error");
              // Could be AUTH token Timeout; refresh it.
              Router.navigate("FailureScreen");
            }
          });
        }).catch(err => {
          console.log("VoiceControl Plugin Activation ERROR!: ", err);
        });
        this._setState('Description');
      }
    }
    _active() {
      this._setState('Description');
    }
    static _states() {
      return [class Description extends this {
        $enter() {
          this._setState("Description");
        }
        _handleUp() {
          this._setState("BackButton");
        }
        $exit() {
          this.tag('Description');
        }
      }, class BackButton extends this {
        $enter() {
          this.tag("BackButton");
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('AlexaConfirmationScreen');
          }
        }
        _focus() {
          this.tag('BackButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BackButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AlexaLoginScreen extends t.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          BackButton: {
            x: 180,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate('Back'),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true
          },
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: Language$1.translate('Alexa welcome message'),
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            },
            SignInButton: {
              x: -100,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 350,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 180,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate('Sign in with') + " Amazon",
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF000000,
                  fontStyle: 'normal'
                }
              },
              visible: true
            }
          }
        }
      };
    }
    _init() {}
    _focus() {
      this._setState('SignInButton');
    }
    _active() {
      this._setState('SignInButton');
    }
    static _states() {
      return [class SignInButton extends this {
        $enter() {
          this.tag("SignInButton").visible = true;
          this.tag('SignInButton.Title').text.textColor = 0xFFFFFFFF;
          this._focus();
        }
        _focus() {
          this.tag('SignInButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('SignInButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('SignInButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('SignInButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        async _handleEnter() {
          if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
            console.log("Code coming from AlexaLoginScreen");
            Router.navigate("CodeScreen");
          }
        }
        _handleUp() {
          this._setState("BackButton");
        }
        $exit() {
          this._unfocus();
        }
      }, class BackButton extends this {
        $enter() {
          this.tag("BackButton");
          this.tag('BackButton.Title').text.textColor = 0xFFFFFFFF;
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.navigate('AlexaConfirmationScreen');
          }
        }
        _focus() {
          this.tag('BackButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BackButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BackButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        _handleDown() {
          this._setState("SignInButton");
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  new AppApi();
  class SuccessScreen extends t.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: Language$1.translate("You are ready to use alexa. Here are some things to try"),
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            },
            Box1: {
              x: -600,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 420,
              rect: true,
              color: 0xFF00CAFF,
              Title: {
                x: 200,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Play some jazz music"),
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF232F3E,
                  fontStyle: 'italic',
                  borderRadius: 100
                }
              },
              visible: true
            },
            Box2: {
              x: -100,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 420,
              rect: true,
              color: 0xFF00CAFF,
              Title: {
                x: 200,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Play my Flash Briefing"),
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF232F3E,
                  fontStyle: 'italic',
                  borderRadius: 100
                }
              },
              visible: true
            },
            Box3: {
              x: 440,
              y: 500,
              mountX: 0.5,
              h: 60,
              w: 500,
              rect: true,
              color: 0xFF00CAFF,
              Title: {
                x: 250,
                y: 30,
                mount: 0.5,
                text: {
                  text: Language$1.translate("What's your favourite movie?"),
                  fontFace: CONFIG.language.font,
                  fontSize: 28,
                  textColor: 0xFF232F3E,
                  fontStyle: 'italic',
                  borderRadius: 100
                }
              },
              visible: true
            }
          },
          DoneButton: {
            x: 1700,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate("Finished"),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true,
            alpha: 1
          }
        }
      };
    }
    _init() {
      this._setState('DoneButton');
    }
    _focus() {
      Registry.clear();
      this._setState('DoneButton');
    }
    _active() {
      this._setState('DoneButton');
    }
    static _states() {
      return [class DoneButton extends this {
        $enter() {
          this.tag("DoneButton");
        }
        _handleEnter() {
          AlexaApi.get().enableSmartScreen();
          Router.navigate('menu');
        }
        _focus() {
          this.tag('DoneButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('DoneButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('DoneButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('DoneButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          //this.show()
          this.tag('DoneButton');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$7 = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  var thunder$8 = thunderJS$1(config$7);
  class FailureScreen extends t.Component {
    static _template() {
      return {
        Wrapper: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xff000000,
          Alexa: {
            x: 1050,
            y: 250,
            Logo: {
              h: 220,
              w: 442,
              x: 135,
              mountX: 1,
              y: 200,
              mountY: 0.5,
              src: Utils.asset('/images/apps/AlexaBadge.png')
            },
            Description: {
              x: -70,
              y: 380,
              mount: 0.5,
              text: {
                text: Language$1.translate('Alexa something went wrong message'),
                fontFace: CONFIG.language.font,
                fontSize: 32,
                textColor: 0xFFF9F9F9,
                fontStyle: 'normal',
                wordWrap: true,
                wordWrapWidth: 800
              }
            }
          },
          RetryButton: {
            x: 1700,
            y: 60,
            w: 150,
            mountX: 0.5,
            h: 60,
            rect: true,
            color: 0xFFFFFFFF,
            Title: {
              x: 75,
              y: 30,
              mount: 0.5,
              text: {
                text: Language$1.translate('Retry'),
                fontFace: CONFIG.language.font,
                fontSize: 22,
                textColor: 0xFF000000,
                fontStyle: 'bold'
              }
            },
            visible: true,
            alpha: 1
          }
        }
      };
    }
    _init() {}
    _focus() {
      this.appApi = new AppApi();
      this.currentApp = Storage$1.get("applicationType");
      if (this.currentApp !== "") {
        this.tag('RetryButton.Title').patch({
          text: {
            text: Language$1.translate("Dismiss")
          }
        });
      }
      this._setState('RetryButton');
    }
    _active() {
      this._setState('RetryButton');
    }
    static _states() {
      return [class RetryButton extends this {
        $enter() {
          console.log("setState DoneButton CodeScreen");
          this.tag("RetryButton");
          this._focus();
          this.tag('RetryButton.Title').text.textColor = CONFIG.theme.hex;
        }
        _handleEnter() {
          if (this.currentApp !== "") {
            AlexaApi.get().resetAVSCredentials().then(() => {
              console.log("avs credentials reseted");
            });
            console.log("Current app: " + this.currentApp + ", moving the app to front");
            this.appApi.setVisibility("ResidentApp", false);
            thunder$8.call("org.rdk.RDKShell", "moveToFront", {
              client: this.currentApp
            }).then(result => {
              console.log(this.currentApp, " moveToFront Success");
              thunder$8.call("org.rdk.RDKShell", "setFocus", {
                client: this.currentApp
              }).then(result => {
                console.log(this.currentApp, " setFocus Success");
              }).catch(err => {
                console.log("Error", err);
              });
            });
          } else {
            AlexaApi.get().resetAVSCredentials().then(() => {
              Router.navigate('AlexaLoginScreen');
            });
          }
        }
        _focus() {
          this.tag('RetryButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('RetryButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('RetryButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('RetryButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Reboot Confirmation Screen.
   */
  class AlexaConfirmationScreen extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Exit Alexa"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Alexa will be disabled, are you sure to exit?"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            YesButton: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Yes"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            NoButton: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("No"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _focus() {
      this._setState('NoButton');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.back();
      }
    }
    static _states() {
      return [class YesButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          AlexaApi.get().setAlexaAuthStatus("AlexaUserDenied");
          Router.navigate("menu");
        }
        _handleRight() {
          this._setState('NoButton');
        }
        _focus() {
          this.tag('YesButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('YesButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('YesButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class NoButton extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('YesButton');
        }
        _focus() {
          this.tag('NoButton').patch({
            color: CONFIG.theme.hex
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('NoButton').patch({
            color: 0xFFFFFFFF
          });
          this.tag('NoButton.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class CameraStreamingScreen extends t.Component {
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          shader: {
            x: 260,
            y: 390,
            w: 910,
            h: 520,
            type: t.shaders.Hole
          },
          visible: true
        },
        Riot: {
          x: 300,
          y: 300,
          mount: 0.5,
          text: {
            text: "RIoT",
            fontFace: CONFIG.language.font,
            fontSize: 32,
            textColor: 0xFFF9F9F9,
            fontStyle: 'normal',
            zIndex: 10
          }
        },
        BorderTop: {
          x: 1470,
          y: 400,
          w: 550,
          h: 6,
          rect: true,
          mountX: 0.5
        },
        Switch1: {
          Text: {
            x: 1260,
            y: 450,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 1"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 450,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom: {
            x: 1470,
            y: 500,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        },
        Switch2: {
          Text: {
            x: 1260,
            y: 550,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 2"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 550,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom2: {
            x: 1470,
            y: 600,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        },
        Switch3: {
          Text: {
            x: 1260,
            y: 650,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 3"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 650,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom3: {
            x: 1470,
            y: 700,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        },
        Switch4: {
          Text: {
            x: 1260,
            y: 750,
            mount: 0.5,
            text: {
              text: Language$1.translate("Switch 4"),
              fontFace: CONFIG.language.font,
              fontSize: 32,
              textColor: 0xFFF9F9F9,
              fontStyle: 'normal',
              wordWrap: true,
              wordWrapWidth: 800
            }
          },
          Button: {
            h: 45,
            w: 67,
            x: 1750,
            mountX: 1,
            y: 750,
            mountY: 0.5,
            src: Utils.asset('images/settings/ToggleOffWhite.png')
          },
          BorderBottom4: {
            x: 1470,
            y: 800,
            w: 550,
            h: 6,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _init() {
      this._setState('Switch1');
    }
    set params(args) {
      VideoPlayer.position(350, 270);
      VideoPlayer.size(890, 600);
      VideoPlayer.open(args.cameraUrl);
      VideoPlayer.consumer(this);
    }
    $videoPlayerEvent(eventName) {
      if (eventName === "Error" || eventName === "Abort") {
        VideoPlayer.reload();
      } else if (eventName === "Ended") {
        if (!Router.isNavigating()) {
          VideoPlayer.close();
          Router.navigate('camera/player/ExitScreen');
        }
      }
    }
    _handleBack() {
      VideoPlayer.close();
      Router.navigate('menu');
    }
    static _states() {
      return [class Switch1 extends this {
        $enter() {
          this.tag('BorderTop').color = CONFIG.theme.hex;
          this.tag('BorderBottom').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderTop').color = 0xFFF9F9F9;
          this.tag('BorderBottom').color = 0xFFF9F9F9;
        }
        _handleDown() {
          this._setState('Switch2');
        }
        _handleEnter() {
          if (this.tag("Switch1.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch1.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch1 Turned Off");
          } else {
            this.tag("Switch1.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch1 Turned On");
          }
        }
      }, class Switch2 extends this {
        $enter() {
          this.tag('BorderBottom').color = CONFIG.theme.hex;
          this.tag('BorderBottom2').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderBottom').color = 0xFFF9F9F9;
          this.tag('BorderBottom2').color = 0xFFF9F9F9;
        }
        _handleDown() {
          this._setState('Switch3');
        }
        _handleUp() {
          this._setState('Switch1');
        }
        _handleEnter() {
          if (this.tag("Switch2.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch2.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch2 Turned Off");
          } else {
            this.tag("Switch2.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch2 Turned On");
          }
        }
      }, class Switch3 extends this {
        $enter() {
          this.tag('BorderBottom2').color = CONFIG.theme.hex;
          this.tag('BorderBottom3').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderBottom2').color = 0xFFF9F9F9;
          this.tag('BorderBottom3').color = 0xFFF9F9F9;
        }
        _handleDown() {
          this._setState('Switch4');
        }
        _handleUp() {
          this._setState('Switch2');
        }
        _handleEnter() {
          if (this.tag("Switch3.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch3.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch3 Turned Off");
          } else {
            this.tag("Switch3.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch3 Turned On");
          }
        }
      }, class Switch4 extends this {
        $enter() {
          this.tag('BorderBottom3').color = CONFIG.theme.hex;
          this.tag('BorderBottom4').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('BorderBottom3').color = 0xFFF9F9F9;
          this.tag('BorderBottom4').color = 0xFFF9F9F9;
        }
        _handleUp() {
          this._setState('Switch3');
        }
        _handleEnter() {
          if (this.tag("Switch4.Button").src == "static/images/settings/ToggleOnOrange.png") {
            this.tag("Switch4.Button").src = "static/images/settings/ToggleOffWhite.png";
            console.log("Switch4 Turned Off");
          } else {
            this.tag("Switch4.Button").src = "static/images/settings/ToggleOnOrange.png";
            console.log("Switch4 Turned On");
          }
        }
      }];
    }
  }

  class CameraStreamingScreenExitConfirmationScreen extends t.Component {
    pageTransition() {
      return 'left';
    }
    static _template() {
      return {
        w: 1920,
        h: 2000,
        rect: true,
        color: 0xCC000000,
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Streaming has Ended Please go to Home"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to go to Home!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    _focus() {
      this._setState('Confirm');
    }
    _handleBack() {
      if (!Router.isNavigating()) {
        Router.navigate('camera/player');
      }
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          Router.navigate('menu');
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _focus() {
          this.tag('Confirm').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Confirm').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Confirm.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          if (!Router.isNavigating()) {
            Router.back();
          }
        }
        _handleLeft() {
          this._setState('Confirm');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let api = null;
  var routes = {
    boot: queryParam => {
      let homeApi = new HomeApi();
      homeApi.setPartnerAppsInfo(queryParam.data);
      homeApi.getAPIKey().then(data => {
        if (data.data.length > 1) {
          api = data;
        }
      });
      return Promise.resolve();
    },
    // root: 'splash',
    routes: [...splashScreenRoutes.splashScreenRoutes, ...route$1.network, ...otherSettingsRoutes.otherSettingsRoutes, ...audioScreenRoutes.audioScreenRoutes, ...detailsScreenRoutes.detailsScreenRoutes, ...liveTvRoutes, {
      path: 'settings',
      component: SettingsScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'failscreen',
      component: Failscreen
    }, {
      path: 'videoplayer',
      component: LightningPlayerControls,
      widgets: ['Volume', "AppCarousel", "VideoInfoChange"]
    }, {
      path: 'usb',
      component: UsbAppsScreen,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'epg',
      component: Epg,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'apps',
      component: AppStore,
      widgets: ['Menu', 'Volume', "AppCarousel"]
    }, {
      path: 'usb/player',
      component: AAMPVideoPlayer,
      widgets: ['Volume', "SettingsOverlay", "AppCarousel"]
    }, {
      path: 'usb/image',
      component: ImageViewer,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'image',
      component: ImageViewer,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'ui',
      component: UIList,
      widgets: ['Volume', "AppCarousel"]
    }, {
      path: 'menu',
      component: MainView,
      before: page => {
        const homeApi = new HomeApi();
        page.tvShowItems = homeApi.getTVShowsInfo();
        // page.usbApps = homeApi.getTVShowsInfo()
        if (api) {
          page.setGracenoteData(api);
        }
        return Promise.resolve();
      },
      widgets: ['Menu', 'Fail', 'Volume', "AppCarousel", "VideoInfoChange"]
    }, {
      path: 'tv-overlay/:type',
      component: TvOverlayScreen,
      options: {
        preventStorage: true
      }
    }, {
      path: 'applauncher',
      component: AppLauncherScreen,
      widgets: ['Volume', 'SettingsOverlay', "AppCarousel"] //other overlays needs to be added to improve ovelay functionality.
    }, {
      path: 'player',
      component: AAMPVideoPlayer,
      widgets: ['Volume', "SettingsOverlay", "AppCarousel"]
    }, {
      path: 'camera/player',
      component: CameraStreamingScreen,
      widgets: ['Menu']
    }, {
      path: 'camera/player/ExitScreen',
      component: CameraStreamingScreenExitConfirmationScreen
    }, {
      path: 'dtvplayer',
      component: DTVPlayer,
      widgets: ['Volume', 'TvOverlays', 'ChannelOverlay', "SettingsOverlay", "AppCarousel"]
    }, {
      path: '!',
      component: Error$1
    }, {
      path: '*',
      component: LogoScreen
    }, {
      path: "FailureScreen",
      component: FailureScreen
    }, {
      path: "SuccessScreen",
      component: SuccessScreen
    }, {
      path: "AlexaLoginScreen",
      component: AlexaLoginScreen
    }, {
      path: "CodeScreen",
      component: CodeScreen
    }, {
      path: "AlexaConfirmationScreen",
      component: AlexaConfirmationScreen
    }],
    afterEachRoute: request => {
      if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
        AlexaApi.get().reportApplicationState(request.hash, true);
      }
      if (request.hash === "menu") {
        /* To prevent the onboarding screen appearing next time. */
        Storage$1.set("setup", true);
      }
    }
  };

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class to render items in side panel.
   */
  class SidePanelItem extends t.Component {
    /**
     * Function to render various elements in the side panel item.
     */
    static _template() {
      return {
        Item: {
          rect: true,
          Image: {
            w: 70,
            H: 70
          },
          Title: {
            text: {
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: 0xffffffff
            }
          }
        }
      };
    }
    _init() {
      this.tag('Image').patch({
        src: Utils.asset(this.data.url),
        w: this.w,
        h: this.h,
        scale: this.unfocus
      });
    }

    /**
     * Function to change properties of item during focus.
     */
    _focus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.focus,
        color: CONFIG.theme.hex
      });
    }

    /**
     * Function to change properties of item during unfocus.
     */
    _unfocus() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        color: 0xffffffff
      });
    }
    setColor() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.focus,
        color: CONFIG.theme.hex
      });
    }
    clearColor() {
      this.tag('Image').patch({
        w: this.w,
        h: this.h,
        scale: this.unfocus,
        color: 0xffffffff
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for side panel in home UI */
  class SidePanel extends t.Component {
    static _template() {
      return {
        color: 0xff000000,
        rect: true,
        y: 270,
        w: 200,
        h: 810,
        SidePanel: {
          x: 0,
          y: 127,
          w: 240,
          h: 750,
          type: t.components.ListComponent,
          roll: true,
          horizontal: false,
          invertDirection: true
        }
      };
    }
    _init() {
      this.homeApi = new HomeApi();
      this.tag('SidePanel').sidePanelItems = this.homeApi.getSidePanelInfo();
      this.sidePanelData = this.homeApi.getSidePanelInfo();
      this._setState('SidePanel');
      this.indexVal = 0;
      this.prevIndex = 0;
    }

    /**
     * Function to set items in side panel.
     */
    set sidePanelItems(items) {
      this.tag('SidePanel').patch({
        x: 105
      });
      this.tag('SidePanel').items = items.map((info, index) => {
        this.data = info;
        return {
          w: 50,
          h: 50,
          y: index == 0 ? 20 : (index + 1) * 20,
          type: SidePanelItem,
          data: info,
          focus: 1.1,
          unfocus: 1,
          x_text: 100,
          y_text: 160,
          text_focus: 1.1,
          text_unfocus: 0.9
        };
      });
      this.tag('SidePanel').start();
    }

    /**
     * Function to reset items in side panel.
     */
    set resetSidePanelItems(items) {
      this.tag('SidePanel').patch({
        x: 0
      });
      this.tag('SidePanel').items = items.map((info, index) => {
        return {
          w: 204,
          h: 184,
          y: index == 0 ? 25 : index == 1 ? 105 : index == 2 ? 260 : 470,
          type: SidePanelItem,
          data: info,
          focus: 0.7,
          unfocus: 0.4,
          x_text: 100,
          y_text: 160,
          text_focus: 1.1,
          text_unfocus: 0.9
        };
      });
      this.tag('SidePanel').start();
    }
    /**
     * Function to set scaling to side panel.
     */
    set scale(scale) {
      this.tag('SidePanel').patch({
        scale: scale
      });
    }

    /**
     * Function to set x coordinate of side panel.
     */
    set x(x) {
      this.tag('SidePanel').patch({
        x: x
      });
    }

    /**
     * Function to set index value of side panel.
     */
    set index(index) {
      this.tag('SidePanel').items[this.prevIndex].clearColor();
      this.indexVal = index;
    }
    set deFocus(val) {
      if (val) {
        this.tag('SidePanel').items[this.prevIndex].clearColor();
      } else {
        this.tag('SidePanel').items[this.prevIndex].setColor();
      }
    }
    set scrollableLastRow(bool) {
      this.isLastRowScrollable = bool;
    }
    static _states() {
      return [class SidePanel extends this {
        _getFocused() {
          if (this.tag('SidePanel').length) {
            return this.tag('SidePanel').items[this.indexVal];
          }
        }
        _handleKey(key) {
          if (key.keyCode == keyMap.ArrowRight || key.keyCode == keyMap.Enter) {
            if (this.prevIndex != this.indexVal) {
              this.tag('SidePanel').items[this.prevIndex].clearColor();
            }
            this.prevIndex = this.indexVal;
            this.fireAncestors('$goToMainView', this.tag('SidePanel').items[this.indexVal], this.indexVal);
          } else if (key.keyCode == keyMap.ArrowDown) {
            if (this.tag('SidePanel').length - 1 != this.indexVal) {
              this.indexVal = this.indexVal + 1;
            }
            return this.tag('SidePanel').items[this.indexVal];
          } else if (key.keyCode == keyMap.ArrowUp) {
            if (0 === this.indexVal) {
              this.fireAncestors('$goToTopPanel', 0);
            } else {
              this.indexVal = this.indexVal - 1;
              return this.tag('SidePanel').items[this.indexVal];
            }
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /** Class for top panel in home UI */
  class TopPanel extends t.Component {
    static _template() {
      return {
        TopPanel: {
          color: 0xff000000,
          rect: true,
          w: 1920,
          h: 270,
          Mic: {
            x: 105,
            // zIndex: 2,
            y: 87,
            src: Utils.asset('/images/topPanel/microphone.png'),
            w: 50,
            h: 50
          },
          Logo: {
            x: 200,
            y: 90,
            src: Utils.asset('/images/' + CONFIG.theme.logo),
            w: 227,
            h: 43
          },
          Page: {
            x: 200,
            y: 184,
            // mountY: 0.5,
            text: {
              fontSize: 40,
              text: Language$1.translate('home'),
              textColor: CONFIG.theme.hex,
              fontStyle: 'bolder',
              fontFace: CONFIG.language.font,
              wordWrapWidth: 1720,
              maxLines: 1
            }
          },
          Settings: {
            x: 1825 - 105 - 160 - 37 + 30,
            y: 111,
            mountY: 0.5,
            src: Utils.asset('/images/topPanel/setting.png'),
            w: 37,
            h: 37
          },
          Time: {
            x: 1920 - 105 - 160,
            y: 111,
            mountY: 0.5,
            text: {
              text: '',
              fontSize: 35,
              fontFace: CONFIG.language.font
            },
            w: 160,
            h: 60
          }
        }
      };
    }
    changeTimeZone(time) {
      this.zone = time;
    }
    updateZone(res) {
      this.zone = res;
    }
    _construct() {
      this.indexVal = 1;
      this.audiointerval = null;
      this.zone = null; // declaring this variable to keep track of zone changes
      this.appApi = new AppApi();
      this.appApi.getZone().then(res => {
        this.updateZone(res);
      });
      this.zone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    set index(index) {
      this.indexVal = index;
    }
    _focus() {
      this._setState('Setting');
      this.tag('Settings').color = CONFIG.theme.hex;
    }
    set changeText(text) {
      this.tag('Page').text.text = text;
      if (text === 'Home') {
        this.tag('Settings').color = 0xffffffff;
      }
    }

    /**
    *
    * @param {boolean} toggle
    * Function to change the mic icon.
    */
    set changeMic(toggle) {
      if (toggle) {
        this.tag('Mic').src = Utils.asset('/images/topPanel/microphone_mute.png');
      } else {
        this.tag('Mic').src = Utils.asset('/images/topPanel/microphone.png');
      }
    }
    _build() {
      Registry.setInterval(() => {
        let _date = this._updateTime(this.zone);
        if (this.zone) {
          this.tag('Time').patch({
            text: {
              text: _date.strTime
            }
          });
        }
      }, 1000);
    }
    updateIcon(tagname, url) {
      this.tag(tagname).patch({
        src: Utils.asset(url)
      });
    }

    /**
     * Function to update time in home UI.
     */
    _updateTime(zone) {
      if (zone != null) {
        let date = new Date();
        date = new Date(date.toLocaleString('en-US', {
          timeZone: zone
        }));
        // get day
        let days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        let strDay = days[date.getDay()];

        // get month
        let month = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let strMonth = month[date.getMonth()];
        let strDate = date.toLocaleDateString('en-US', {
          day: '2-digit'
        }) + ' ' + strMonth + ' ' + date.getFullYear();
        let hours = date.getHours();
        let minutes = date.getMinutes();
        let ampm = hours >= 12 ? 'pm' : 'am';
        hours = hours % 12;
        hours = hours ? hours : 12;
        minutes = minutes < 10 ? '0' + minutes : minutes;
        let strTime = hours + ':' + minutes + ' ' + ampm;
        return {
          strTime,
          strDay,
          strDate
        };
      } else {
        return "";
      }
    }
    static _states() {
      return [class Mic extends this {
        $enter() {
          this.tag('Mic').color = CONFIG.theme.hex;
        }
        _getFocused() {
          this.tag('Mic').color = CONFIG.theme.hex;
        }
        $exit() {
          this.tag('Mic').color = 0xffffffff;
        }
        _handleKey(key) {
          if (key.keyCode == keyMap.ArrowRight) {
            this._setState('Setting');
          } else if (key.keyCode == keyMap.ArrowDown) {
            this.tag('Mic').color = 0xffffffff;
            this.fireAncestors('$goToSidePanel', 0);
          }
        }
      }, class Setting extends this {
        $enter() {
          this.tag('Settings').color = CONFIG.theme.hex;
        }
        _handleKey(key) {
          if (key.keyCode === keyMap.ArrowDown) {
            Router.focusPage();
            this.tag('Settings').color = 0xffffffff;
          } else if (key.keyCode === keyMap.ArrowLeft) ; else if (key.keyCode === keyMap.Enter) {
            //this.tag('Page').text.text = Language.translate('settings')
            Router.navigate('settings');
            Router.focusPage();
            this.tag('Settings').color = 0xffffffff;
          }
        }
        $exit() {
          this.tag('Settings').color = 0xffffffff;
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  var route = {
    1: () => {
      Router.navigate('epg');
      Router.focusPage();
    },
    3: () => {
      Router.navigate('apps');
      Router.focusPage();
    },
    'default': () => {
      Router.navigate('menu');
      Router.focusPage();
    }
  };
  class Menu extends t.Component {
    static _template() {
      return {
        TopPanel: {
          type: TopPanel
        },
        SidePanel: {
          type: SidePanel
        }
      };
    }
    pageTransition() {
      return 'down';
    }
    _init() {
      this.homeApi = new HomeApi();
      this.tag('SidePanel').sidePanelItems = this.homeApi.getSidePanelInfo();
    }
    _focus() {
      if (!this.mainView) {
        this.mainView = Router.activePage();
      }
      this._setState('SidePanel');
    }
    _handleRight() {
      Router.focusPage();
    }
    $goToTopPanel() {
      this._setState('TopPanel');
      Router.focusWidget('Menu');
    }
    $goToSidePanel() {
      this._setState('SidePanel');
    }
    $goToMainView(sidePanelInstance, index) {
      if (route[index]) {
        route[index]();
      } else {
        route['default']();
      }
      sidePanelInstance.setColor();
      return;
    }
    refreshMainView() {
      if (this.mainView) {
        this.mainView.refreshFirstRow();
      }
    }
    setIndex(index) {
      this.tag('SidePanel').index = index;
    }
    notify(val) {
      if (val === 'TopPanel') {
        Router.focusWidget('Menu');
        this._setState('TopPanel');
      }
    }
    $scroll(val) {
      if (this.mainView) {
        this.mainView.scroll(val);
      }
    }
    updateTimeZone(timezone) {
      this.tag('TopPanel').changeTimeZone(timezone);
    }
    updateTopPanelText(text) {
      this.tag('TopPanel').changeText = text;
    }
    static _states() {
      return [class SidePanel extends this {
        _getFocused() {
          return this.tag('SidePanel');
        }
      }, class TopPanel extends this {
        _getFocused() {
          return this.tag('TopPanel');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$6 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  const thunder$7 = thunderJS$1(config$6);
  function keyIntercept() {
    let clientName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ResidentApp";
    thunder$7.Controller.activate({
      callsign: 'org.rdk.RDKShell'
    }).then(result => {
      console.log('Successfully activated RDK Shell');
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'setFocus', {
        client: clientName
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.AudioVolumeMute,
        modifiers: []
      }).then(result => {
        console.log('addKeyIntercept success');
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.on('org.rdk.RDKShell', 'onSuspended', notification => {
        if (notification) {
          console.log('onSuspended notification from KeyIntercept: ' + notification.client);
        }
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.F1,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Inputs_Shortcut,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Picture_Setting_Shortcut,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Power,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Settings_Shortcut,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.AppCarousel,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Youtube,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Amazon,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Netflix,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.F7,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.AudioVolumeUp,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.AudioVolumeDown,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.MediaFastForward,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: 142,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.MediaRewind,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: clientName,
        keyCode: keyMap.Pause,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: 'YouTube',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: 'YouTubeTV',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: 'YouTubeKids',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: 'Amazon',
        keyCode: keyMap.Home,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: 'YouTube',
        keyCode: keyMap.Backspace,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    }).then(result => {
      thunder$7.call('org.rdk.RDKShell', 'addKeyIntercept', {
        client: 'Amazon',
        keyCode: keyMap.Backspace,
        modifiers: []
      }).catch(err => {
        console.log('Error', err);
      });
    }).catch(err => {
      console.log('Error', err);
    });
  }

  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  const config$5 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  thunderJS$1(config$5);
  class Volume extends t.Component {
    constructor() {
      super(...arguments);
      _defineProperty(this, "setVolume", async val => {
        let audioport = await this.getAudioPorts();
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            await this.appApi.setVolumeLevel(audioport[i], val);
          }
        }
        return true;
      });
      _defineProperty(this, "setMute", async val => {
        let audioport = await this.getAudioPorts();
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            this.appApi.audio_mute(audioport[i], val);
          }
        }
        return true;
      });
      _defineProperty(this, "getMuteStatus", async val => {
        let audioport = await this.getAudioPorts();
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            this.appApi.getMuted(audioport[i]).then(result => {
              if (result.success) {
                this.mute = result.muted;
              }
            });
          }
        }
        return true;
      });
    }
    static _template() {
      return {
        rect: true,
        w: 1920,
        h: 320,
        color: 0xFF000000,
        y: -320,
        alpha: 0.9,
        transitions: {
          y: {
            duration: .3,
            timingFunction: 'cubic-bezier(0.17, 0.9, 0.32, 1.3)'
          },
          h: {
            duration: .3,
            timingFunction: 'cubic-bezier(0.17, 0.9, 0.32, 1.3)'
          }
        },
        Overlay: {
          Line: {
            y: 317,
            h: 3,
            w: 1920,
            rect: true,
            color: 0xffffffff
          }
        },
        VolumeInfo: {
          alpha: 1,
          zIndex: 2,
          y: 160,
          x: 960,
          mountX: 0.5,
          mountY: 0.5,
          h: 100,
          w: 100,
          src: Utils.asset('/images/volume/Volume.png'),
          Text: {
            x: 100,
            y: 0,
            text: {
              text: 0,
              fontSize: 80,
              fontFace: CONFIG.language.font
            }
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.volTimeout = null;
      this.volume = 0;
      this.getMuteStatus();
      console.log("_firstEnable this.mute-", this.mute);
    }
    async onVolumeKeyDown() {
      this.volume = await this.getVolume();
      this.focus();
      console.log("onVolumeKeyDown this.mute-", this.mute);
      this._updateIcon(this.mute);
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      if (this.volume > 0) {
        this.volume -= 5;
        if (this.setVolume(this.volume)) {
          this._updateIcon(this.mute = false);
          this._updateText(this.volume);
        }
      }
    }
    async onVolumeKeyUp() {
      this.volume = await this.getVolume();
      this.focus();
      this._updateIcon(this.mute);
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      if (this.volume < 100) {
        this.volume += 5;
        if (this.setVolume(this.volume)) {
          this._updateIcon(this.mute = false);
          this._updateText(this.volume);
        }
      }
    }
    async onVolumeMute() {
      let requestedState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      this.volume = await this.getVolume();
      await this.getMuteStatus(); // to update this.mute
      this.focus();
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      if (this.setMute(requestedState != undefined ? requestedState : !this.mute)) {
        this._updateIcon(requestedState != undefined ? requestedState : !this.mute);
      }
    }
    async onVolumeChanged() {
      this.volume = await this.getVolume();
      this.focus();
      this._updateIcon(this.mute);
      this._updateText(this.volume);
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.volTimeout = Registry.setTimeout(() => {
        this.unfocus();
      }, 2000);
      this._updateText(this.volume);
    }
    _updateText(val) {
      this.tag('Text').text.text = val;
    }
    _updateIcon(check) {
      if (check) {
        this.tag('VolumeInfo').src = Utils.asset('images/volume/Volume_Mute.png');
      } else {
        this.tag('VolumeInfo').src = Utils.asset('/images/volume/Volume.png');
      }
    }
    focus() {
      //the volume widget would never be actually focused
      this.patch({
        smooth: {
          y: -30
        }
      });
    }
    unfocus() {
      //the volume widget would never be actually focused
      this.volTimeout && Registry.clearTimeout(this.volTimeout);
      this.patch({
        smooth: {
          y: -320
        }
      });
    }
    getAudioPorts() {
      return new Promise((resolve, reject) => {
        this.appApi.getConnectedAudioPorts().then(res => {
          resolve(res.connectedAudioPorts);
        });
      }).catch(err => {
        console.error('Volume getConnectedAudioPorts error:', JSON.stringify(err, 3, null));
        reject(false);
      });
    }
    updateIcon(audioport) {
      return new Promise((resolve, reject) => {
        this.appApi.getMuted(audioport).then(result => {
          this.mute = result.muted;
          this._updateIcon(this.mute);
          resolve(true);
        });
      });
    }
    getVolume() {
      return new Promise(async (resolve, reject) => {
        let audioport = await this.getAudioPorts();
        /* Returns an array. */
        for (let i = 0; i < audioport.length; i++) {
          if (Storage$1.get("deviceType") == "tv" && audioport[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport[i].startsWith("HDMI")) {
            this.appApi.getVolumeLevel(audioport[i]).then(async res1 => {
              await this.updateIcon(audioport[i]);
              if (res1) {
                resolve(parseInt(res1.volumeLevel));
              }
            }).catch(err => {
              console.error('Volume getVolumeLevel error:', JSON.stringify(err, 3, null));
              reject(false);
            });
          }
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for HDMI Output Screen.
   */
  var appApi$4 = new AppApi();
  class HdmiOutputScreen extends t.Component {
    static _template() {
      return {
        HdmiOutputScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _init() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      appApi$4.getSoundMode().then(result => {
        appApi$4.getSupportedAudioModes().then(res => {
          options = [...res.supportedAudioModes];
          this.tag('HdmiOutputScreenContents').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').h = options.length * 90;
          this.tag('HdmiOutputScreenContents.List').items = options.map((item, index) => {
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: result.soundMode === item ? true : false,
              item: item,
              videoElement: false
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this._setState("Options");
        }).catch(err => {
          console.log('error', err);
        });
      }).catch(err => {
        console.log('error', JSON.stringify(err));
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          console.log('focusedHDMI');
          return this.tag('HdmiOutputScreenContents.List').element;
        }
        _handleDown() {
          this.tag('HdmiOutputScreenContents.List').setNext();
        }
        _handleUp() {
          this.tag('HdmiOutputScreenContents.List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**s
   * Class for Audio screen.
   */

  class AudioScreen extends t.Component {
    static _template() {
      return {
        AudioScreenOverlay: {
          x: 200,
          y: 275,
          AudioOutput: {
            alpha: 0.3,
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Output: ') + " HDMI",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputMode: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Mode: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          DynamicRange: {
            alpha: 0.3,
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Full Dynamic Range'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AudioLanguage: {
            y: 270,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Language: ') + "Auto",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NavigationFeedback: {
            y: 360,
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Navigation Feedback'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 66,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOnWhite.png')
            }
          },
          Bluetooth: {
            alpha: 0.3,
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth: ') + "None",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        HdmiOutputScreen: {
          type: HdmiOutputScreen,
          visible: false
        }
      };
    }
    _init() {
      this.appApi = new AppApi();
      this._setState('OutputMode');
    }
    _focus() {
      this._setState('OutputMode');
      this.appApi.getSoundMode().then(result => {
        this.tag('OutputMode.Title').text.text = Language$1.translate('Output Mode: ') + result.soundMode;
      });
    }
    hide() {
      this.tag('AudioScreenOverlay').visible = false;
    }
    show() {
      this.tag('AudioScreenOverlay').visible = true;
    }
    static _states() {
      return [class AudioOutput extends this {
        $enter() {
          this.tag('AudioOutput')._focus();
        }
        $exit() {
          this.tag('AudioOutput')._unfocus();
        }
        _handleDown() {
          this._setState('OutputMode');
        }
        _handleEnter() {
          this._setState('HdmiOutputScreen');
        }
      }, class OutputMode extends this {
        $enter() {
          this.tag('OutputMode')._focus();
        }
        $exit() {
          this.tag('OutputMode')._unfocus();
        }
        _handleUp() {
          // this._setState('AudioOutput')
        }
        _handleDown() {
          // this._setState('DynamicRange');
        }
        _handleEnter() {
          console.log("hdmioutputscreen");
          this._setState('HdmiOutputScreen');
        }
      }, class DynamicRange extends this {
        $enter() {
          this.tag('DynamicRange')._focus();
        }
        $exit() {
          this.tag('DynamicRange')._unfocus();
        }
        _handleUp() {
          this._setState('OutputMode');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          /**
           * This handle Enter has api calls -
           * 1 - get DRC Mode which doesnot return a drc mode and the success value is mostly false
           * 2- set Volume - able to set the value to 100
           * 3- get Volume - able to get the volume successfully as well
           * 4-
           *
           */
          //console.log(`Enter input was given to dynamic range ... `);
          // gets the drc mode
          this.appApi.getDRCMode().then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.setVolumeLevel(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0", 100).then(res => {
            this.appApi.getVolumeLevel().catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
          this.appApi.getConnectedAudioPorts().then(res => {}).catch(err => {
            console.log(err);
          });
          // gets the enabled Audio Port
          this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {}).catch(err => {
            console.log(err);
          });
          this.appApi.getSupportedAudioPorts().catch(err => {
            console.log("Error while getting the supported Audio ports ie. ".concat(err));
          });

          // set enable Audio POrt
          this.appApi.setEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {
            this.appApi.getEnableAudioPort(Storage$1.get("deviceType") == "tv" ? "SPEAKER0" : "HDMI0").then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });

          // set zoom setting ,possible values : FULL, NONE, Letterbox 16x9, Letterbox 14x9, CCO, PanScan, Letterbox 2.21 on 4x3, Letterbox 2.21 on 16x9, Platform, Zoom 16x9, Pillarbox 4x3, Widescreen 4x3
          this.appApi.setZoomSetting("FULL").then(res => {
            this.appApi.getZoomSetting().then(res => {}).catch(err => {
              console.log(err);
            });
          }).catch(err => {
            console.log(err);
          });
        }
      }, class NavigationFeedback extends this {
        $enter() {
          this.tag('NavigationFeedback')._focus();
        }
        $exit() {
          this.tag('NavigationFeedback')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
        _handleDown() {
          this._setState('Bluetooth');
        }
        _handleEnter() {
          //
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag('Bluetooth')._focus();
        }
        $exit() {
          this.tag('Bluetooth')._unfocus();
        }
        _handleUp() {
          this._setState('DynamicRange');
        }
      }, class HdmiOutputScreen extends this {
        $enter() {
          this.hide();
          console.log("hdmioutputscreenEnter");
          this.tag('HdmiOutputScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Audio  Output Mode');
        }
        $exit() {
          this.tag("HdmiOutputScreen").visible = false;
          this.show();
          this.fireAncestors('$updatePageTitle', 'Settings  Audio');
        }
        _getFocused() {
          console.log("hdmioutputscreenfocused");
          return this.tag('HdmiOutputScreen');
        }
        _handleBack() {
          console.log("hdmioutputscreenbackHDMI");
          this._setState("OutputMode");
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const thunder$6 = thunderJS$1({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });

  /**
   * Class for Resolution Screen.
   */

  class ResolutionScreen extends t.Component {
    static _template() {
      return {
        ResolutionScreenContents: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        }
      };
    }
    _firstEnable() {
      this.appApi = new AppApi();
      this.appApi.activateDisplaySettings();
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      thunder$6.on('org.rdk.DisplaySettings', 'resolutionPreChange', notification => {
        console.log(new Date().toISOString() + " ResolutionOverlay got resolutionPreChange");
        Storage$1.set("ResolutionChangeInProgress", true);
      });
      thunder$6.on('org.rdk.DisplaySettings', 'resolutionChanged', notification => {
        console.log(new Date().toISOString() + " ResolutionOverlay got resolutionChanged");
        const items = this.tag('List').items;
        items.forEach(element => {
          element.tag('Item.Tick').visible = false;
          if (element._item === notification.resolution) {
            element.tag('Item.Tick').visible = true;
          }
        });
        Storage$1.set("ResolutionChangeInProgress", false);
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      let options = [];
      let sIndex = 0;
      this.appApi.getResolution().then(resolution => {
        this.appApi.getSupportedResolutions().then(res => {
          options = [...res];
          this.tag('ResolutionScreenContents').h = options.length * 90;
          this.tag('ResolutionScreenContents.List').h = options.length * 90;
          this.tag('List').items = options.map((item, index) => {
            let bool = false;
            if (resolution === item) {
              bool = true;
              sIndex = index;
            }
            return {
              ref: 'Option' + index,
              w: 1920 - 300,
              h: 90,
              type: VideoAndAudioItem,
              isTicked: bool,
              item: item,
              videoElement: true
            };
          });
          this.loadingAnimation.stop();
          this.tag('Loader').visible = false;
          this.tag('List').setIndex(sIndex);
          this._setState("Options");
        }).catch(err => {
          console.log("error while fetching the supported resolution ".concat(err));
        });
      });
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Video screen.
   */

  class VideoScreen extends t.Component {
    static _template() {
      return {
        VideoScreenContents: {
          x: 200,
          y: 275,
          Resolution: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Resolution: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDR: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('High Dynamic Range: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MatchContent: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Match Content: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          OutputFormat: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Output Format:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Chroma: {
            alpha: 0.3,
            // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Chroma:'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          HDCP: {
            y: 450,
            h: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('HDCP Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        },
        ResolutionOverlay: {
          type: ResolutionScreen,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('Resolution');
    }
    _focus() {
      this._appApi.getResolution().then(resolution => {
        this.tag("Resolution.Title").text.text = Language$1.translate('Resolution: ') + resolution;
      }).catch(err => {
        console.log("Error fetching the Resolution");
      });
      this._appApi.getHDCPStatus().then(result => {
        if (result.isHDCPCompliant && result.isHDCPEnabled) {
          this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Enabled, Version: ").concat(result.currentHDCPVersion);
        } else {
          this.tag("HDCP.Title").text.text = "".concat(Language$1.translate('HDCP Status: '), "Not Supported ");
        }
      });
      this._appApi.getHDRSetting().then(result => {
        const availableHDROptions = {
          "HdrOff": "Off",
          "Hdr10": "HDR 10",
          "Hdr10Plus": "HDR 10+",
          "HdrHlg": "HLG",
          "HdrDolbyvision": "Dolby Vision",
          "HdrTechnicolor": "Technicolor HDR"
        };
        this.tag("HDR.Title").text.text = Language$1.translate('High Dynamic Range: ') + availableHDROptions[result];
      });
      this._setState('Resolution');
    }
    hide() {
      this.tag('VideoScreenContents').visible = false;
    }
    show() {
      this.tag('VideoScreenContents').visible = true;
    }
    static _states() {
      return [class Resolution extends this {
        $enter() {
          this.tag('Resolution')._focus();
        }
        $exit() {
          this.tag('Resolution')._unfocus();
        }
        _handleDown() {
          this._setState('HDR');
        }
        _handleEnter() {
          this._setState("ResolutionOverlay");
        }
      }, class HDR extends this {
        $enter() {
          this.tag('HDR')._focus();
        }
        $exit() {
          this.tag('HDR')._unfocus();
        }
        _handleUp() {
          this._setState('Resolution');
        }
        _handleDown() {
          this._setState('HDCP');
        }
        _handleEnter() {
          //
        }
      }, class MatchContent extends this {
        $enter() {
          this.tag('MatchContent')._focus();
        }
        $exit() {
          this.tag('MatchContent')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleDown() {
          this._setState('OutputFormat');
        }
        _handleEnter() {
          //
        }
      }, class OutputFormat extends this {
        $enter() {
          this.tag('OutputFormat')._focus();
        }
        $exit() {
          this.tag('OutputFormat')._unfocus();
        }
        _handleUp() {
          this._setState('MatchContent');
        }
        _handleDown() {
          this._setState('Chroma');
        }
        _handleEnter() {
          //
        }
      }, class Chroma extends this {
        $enter() {
          this.tag('Chroma')._focus();
        }
        $exit() {
          this.tag('Chroma')._unfocus();
        }
        _handleUp() {
          this._setState('OutputFormat');
        }
        _handleDown() {
          // this._setState('HDCP')
        }
        _handleEnter() {
          //
        }
      }, class HDCP extends this {
        // class not required
        $enter() {
          this.tag('HDCP')._focus();
        }
        $exit() {
          this.tag('HDCP')._unfocus();
        }
        _handleUp() {
          this._setState('HDR');
        }
        _handleEnter() {
          //
        }
      }, class ResolutionOverlay extends this {
        $enter() {
          this.hide();
          this.tag('ResolutionOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', "Settings  Video  Resolution");
        }
        $exit() {
          this.tag('ResolutionOverlay').visible = false;
          this.show();
          this.fireAncestors('$updatePageTitle', "Settings  Video");
        }
        _getFocused() {
          return this.tag('ResolutionOverlay');
        }
        _handleBack() {
          this._setState('Resolution');
        }
        // $updateResolution(value) {
        //   this.tag('Resolution.Title').text.text = 'Resolution: ' + value;
        // }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Settings Screen.
    */

  var appApi$3 = new AppApi();
  var defaultInterface = "";
  var currentInterface = [];
  class NetworkInfo extends t.Component {
    static _template() {
      return {
        NetworkInfoScreenContents: {
          x: 200,
          y: 275,
          Status: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Status: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          ConnectionType: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Connection Type: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          IPAddress: {
            //alpha: 0.3, // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('IP Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Gateway: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Gateway: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          MACAddress: {
            //alpha: 0.3, // disabled
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('MAC Address: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          InternetProtocol: {
            //alpha: 0.3, // disabled
            y: 450,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Internet Protocol: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SSID: {
            //alpha: 0.3, // disabled
            y: 540,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('SSID: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          SignalStrength: {
            //alpha: 0.3, // disabled
            y: 630,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Signal Strength: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Value: {
              x: 500,
              y: 45,
              mountY: 0.5,
              text: {
                text: '',
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          }
        }
      };
    }
    getIPSetting(interfaceName) {
      appApi$3.getIPSetting(interfaceName).then(result => {
        this.tag('InternetProtocol.Value').text.text = result.ipversion;
      }).catch(err => console.log(err));
    }
    _focus() {
      //Getting the default interface
      appApi$3.getDefaultInterface().then(result => {
        defaultInterface = result.interface;
        this.getIPSetting(defaultInterface);
        if (defaultInterface === "WIFI") {
          this.tag("ConnectionType.Value").text.text = Language$1.translate('Wireless');
          this.tag("SSID").alpha = 1;
          this.tag("SignalStrength").alpha = 1;
        } else if (defaultInterface === "ETHERNET") {
          this.tag("ConnectionType.Value").text.text = "Ethernet";
          this.tag("SSID").alpha = 0;
          this.tag("SignalStrength").alpha = 0;
        } else {
          this.tag("ConnectionType.Value").text.text = "NA";
          this.tag("Status.Value").text.text = Language$1.translate('Disconnected');
          this.tag("IPAddress.Value").text.text = "NA";
          this.tag("Gateway.Value").text.text = "NA";
          this.tag("MACAddress.Value").text.text = "NA";
        }

        //Filtering the current interface
        appApi$3.getInterfaces().then(result => {
          currentInterface = result.interfaces.filter(data => data.interface === defaultInterface);
          //console.log(currentInterface);
          if (currentInterface[0].connected) {
            this.tag("Status.Value").text.text = Language$1.translate('Connected');
            appApi$3.getConnectedSSID().then(result => {
              if (parseInt(result.signalStrength) >= -50) {
                this.tag("SignalStrength.Value").text.text = "Excellent";
              } else if (parseInt(result.signalStrength) >= -60) {
                this.tag("SignalStrength.Value").text.text = "Good";
              } else if (parseInt(result.signalStrength) >= -67) {
                this.tag("SignalStrength.Value").text.text = "Fair";
              } else {
                this.tag("SignalStrength.Value").text.text = "Poor";
              }
              this.tag("SSID.Value").text.text = "".concat(result.ssid);
            }).catch(error => console.log(error));
            appApi$3.getIPSetting(defaultInterface).then(result => {
              this.tag('IPAddress.Value').text.text = "".concat(result.ipaddr);
              this.tag("Gateway.Value").text.text = "".concat(result.gateway);
            }).catch(error => console.log(error));
          } else {
            this.tag('Status.Value').text.text = Language$1.translate('Disconnected');
          }
          this.tag('MACAddress.Value').text.text = "".concat(currentInterface[0].macAddress);
        }).catch(error => console.log(error));
      }).catch(error => console.log(error));
    }
    _unfocus() {
      this.tag('SSID.Value').text.text = 'NA';
      this.tag('SignalStrength.Value').text.text = 'NA';
      this.tag('MACAddress.Value').text.text = 'NA';
      this.tag('Gateway.Value').text.text = 'NA';
      this.tag('IPAddress.Value').text.text = 'NA';
      this.tag('ConnectionType.Value').text.text = 'NA';
      this.tag('InternetProtocol.Value').text.text = 'NA';
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi$1 = new Wifi();
  class JoinAnotherNetworkComponent extends t.Component {
    _active() {
      this.hidePasswd = true;
      this.star = "";
      this.tag("Keyboard").visible = false;
    }
    handleDone() {
      this.tag("Keyboard").visible = false;
      let securityCode = this.securityCodes[this.securityCodeIndex].value;
      if (!this.textCollection['EnterSSID']) {
        this._setState("EnterSSID");
      } else if (securityCode < 0 || securityCode > 14 || securityCode === 0 && !this.scode) {
        this.scode = true;
        this._setState("EnterSecurity");
      } else if (securityCode !== 0 && !this.textCollection['EnterPassword']) {
        this._setState("EnterPassword");
      } else {
        if (this.textCollection['EnterSecurity'] === "0") {
          this.textCollection['EnterPassword'] = "";
          this.tag("Pwd").text.text = "";
        }
        let self = this;
        this.startConnectForAnotherNetwork({
          ssid: self.textCollection['EnterSSID'],
          security: securityCode
        }, self.textCollection['EnterPassword']);
      }
    }
    startConnectForAnotherNetwork(device, passphrase) {
      wifi$1.connect({
        ssid: device.ssid,
        security: device.security
      }, passphrase).then(() => {
        wifi$1.saveSSID(device.ssid, passphrase, device.security).then(response => {
          if (response.result === 0 && response.success === true) {
            wifi$1.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // Router.back()
          } else if (response.result !== 0) {
            wifi$1.clearSSID();
          }
        });
      });
      this.fireAncestors("$navigateBack");
    }
    static _template() {
      return {
        Background: {
          w: 1920,
          h: 1080,
          rect: true,
          color: 0xCC000000
        },
        Text: {
          x: 758,
          y: 70,
          text: {
            text: Language$1.translate("Find and join a WiFi network"),
            fontFace: CONFIG.language.font,
            fontSize: 35,
            textColor: CONFIG.theme.hex
          }
        },
        BorderTop: {
          x: 190,
          y: 130,
          w: 1488,
          h: 2,
          rect: true
        },
        Network: {
          x: 190,
          y: 176,
          text: {
            text: Language$1.translate("Network Name") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        NetworkBox: {
          x: 400,
          y: 160,
          texture: t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        NetworkText: {
          x: 420,
          y: 170,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        NetworkType: {
          x: 190,
          y: 246,
          text: {
            text: Language$1.translate("Security") + ": ",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        TypeBox: {
          x: 400,
          y: 230,
          texture: t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false),
          ArrowForward: {
            h: 30,
            w: 45,
            y: 15,
            x: 1220,
            src: Utils.asset('images/settings/Arrow.png')
          },
          ArrowBackward: {
            h: 30,
            w: 45,
            x: 10,
            scaleX: -1,
            y: 15,
            src: Utils.asset('images/settings/Arrow.png')
          }
        },
        TypeText: {
          x: 470,
          y: 263,
          mountY: 0.5,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        Password: {
          x: 190,
          y: 316,
          text: {
            text: Language$1.translate("Password") + ":",
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        },
        PasswordBox: {
          x: 400,
          y: 300,
          texture: t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false)
        },
        Pwd: {
          x: 420,
          y: 310,
          zIndex: 2,
          text: {
            text: '',
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            wordWrapWidth: 1300,
            wordWrap: false,
            textOverflow: 'ellipsis'
          }
        },
        BorderBottom: {
          x: 190,
          y: 396,
          w: 1488,
          h: 2,
          rect: true
        },
        Keyboard: {
          y: 437,
          x: 400,
          type: Keyboard$1,
          visible: false,
          zIndex: 2,
          formats: KEYBOARD_FORMATS.qwerty
        },
        PasswrdSwitch: {
          h: 45,
          w: 66.9,
          x: 1642,
          y: 330,
          zIndex: 2,
          type: PasswordSwitch,
          mount: 0.5,
          visible: true
        },
        ShowPassword: {
          x: 1405,
          y: 312,
          w: 300,
          h: 75,
          zIndex: 2,
          text: {
            text: Language$1.translate('Show Password'),
            fontSize: 25,
            fontFace: CONFIG.language.font,
            textColor: 0xffffffff,
            textAlign: 'left'
          },
          visible: true
        }
      };
    }
    _focus() {
      this.scode = false;
      this._setState('EnterSSID');
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': ''
      };
      this.tag('Pwd').text.text = Language$1.translate("Press OK to enter Password");
      this.tag("NetworkText").text.text = Language$1.translate("Press OK to enter SSID");
      this.tag('NetworkText').text.textColor = 0xff808080;
      this.tag('Pwd').text.textColor = 0xff808080;
      this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
      if (this.securityCodes[this.securityCodeIndex].value === 0) {
        this.pwdUnReachable = true;
        this.tag("PasswordBox").alpha = 0.5;
        this.tag("Password").alpha = 0.5;
      } else {
        this.pwdUnReachable = false;
        this.tag("PasswordBox").alpha = 1;
        this.tag("Password").alpha = 1;
      }
    }
    encrypt() {
      if (this.prevState === "EnterPassword" && this.hidePasswd) return true;else return false;
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    static _states() {
      return [class EnterSSID extends this {
        $enter() {
          this.tag('NetworkBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("EnterSecurity");
        }
        _handleEnter() {
          this._setState('Keyboard');
          this.tag('NetworkText').text.text = this.textCollection['EnterSSID'];
          this.tag('NetworkText').text.textColor = 0xffffffff;
          this.tag("Keyboard").visible = true;
        }
        $exit() {
          this.tag('NetworkBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterSecurity extends this {
        $enter() {
          this.tag("TypeBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSSID");
        }
        isPasswordUnReachable(secCode) {
          if (secCode === 0) {
            this.tag("PasswordBox").alpha = 0.5;
            this.tag("Password").alpha = 0.5;
            return true;
          } else {
            this.tag("PasswordBox").alpha = 1;
            this.tag("Password").alpha = 1;
            return false;
          }
        }
        _handleLeft() {
          this.securityCodeIndex = (15 + --this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleEnter() {
          this.handleDone();
        }
        _handleRight() {
          this.securityCodeIndex = (15 + ++this.securityCodeIndex) % 15;
          this.pwdUnReachable = this.isPasswordUnReachable(this.securityCodeIndex);
          this.tag("TypeText").text.text = this.securityCodes[this.securityCodeIndex].name;
        }
        _handleDown() {
          if (!this.pwdUnReachable) {
            this._setState("EnterPassword");
          }
        }
        $exit() {
          this.tag("TypeBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class EnterPassword extends this {
        $enter() {
          if (this.pwdUnReachable) {
            this._setState("EnterSecurity");
          }
          this.tag('PasswordBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleDown() {
          this._setState("EnterSSID");
        }
        _handleRight() {
          this._setState("PasswordSwitchState");
        }
        _handleEnter() {
          this.tag("Keyboard").visible = true;
          this._setState('Keyboard');
          this.tag('Pwd').text.text = this.hidePasswd ? this.star : this.textCollection['EnterPassword'];
          this.tag('Pwd').text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag('PasswordBox').texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, CONFIG.theme.hex, false);
          this.tag('ShowPassword').text.textColor = CONFIG.theme.hex;
        }
        _handleDown() {
          this._setState("Keyboard");
        }
        _handleUp() {
          this._setState("EnterSecurity");
        }
        _handleLeft() {
          this._setState("EnterPassword");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.textCollection['EnterPassword']);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1273, 58, 0, 3, 0xffffffff, false);
          this.tag('ShowPassword').text.textColor = 0xffffffff;
        }
      }, class Keyboard extends this {
        $enter(state) {
          this.prevState = state.prevState;
          if (this.prevState === 'EnterSSID') {
            this.element = 'NetworkText';
          }
          if (this.prevState === 'EnterPassword') {
            this.element = 'Pwd';
          }
          if (this.prevState === 'EnterSecurity') {
            this.element = 'TypeText';
          }
        }
        _getFocused() {
          return this.tag('Keyboard');
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (this.prevState === 'PasswordSwitchState') {
            this.prevState = "EnterPassword";
          }
          console.log("Prev state:", this.prevState);
          if (key === 'Done') {
            this.handleDone();
          } else if (key === 'Clear') {
            this.textCollection[this.prevState] = this.textCollection[this.prevState].substring(0, this.textCollection[this.prevState].length - 1);
            this.star = this.prevState === "EnterPassword" ? this.star.substring(0, this.star.length - 1) : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.textCollection[this.prevState] += ' ';
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else if (key === 'Delete') {
            this.textCollection[this.prevState] = '';
            this.star = this.prevState === "EnterPassword" ? '' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          } else {
            this.textCollection[this.prevState] += key;
            this.star += this.prevState === "EnterPassword" ? '\u25CF' : this.star;
            this.tag(this.element).text.text = this.encrypt() ? this.star : this.textCollection[this.prevState];
          }
        }
        _handleUp() {
          this._setState(this.prevState);
        }
        _handleBack() {
          this._setState(this.prevState);
        }
      }];
    }
    _init() {
      this.securityCodeIndex = 0;
      this.pwdUnReachable = true;
      this.star = '';
      this.textCollection = {
        'EnterSSID': '',
        'EnterPassword': '',
        'EnterSecurity': '0'
      };
      this.securityCodes = [{
        name: "Open/None (Unsecure)",
        value: 0
      }, {
        name: "WEP - Deprecated, not needed",
        value: 1
      }, {
        name: "WEP",
        value: 2
      }, {
        name: "WPA Personal TKIP",
        value: 3
      }, {
        name: "WPA Personal AES",
        value: 4
      }, {
        name: "WPA2 Personal TKIP",
        value: 5
      }, {
        name: "WPA2 Personal AES",
        value: 6
      }, {
        name: "WPA Enterprise TKIP",
        value: 7
      }, {
        name: "WPA Enterprise AES",
        value: 8
      }, {
        name: "WPA2 Enterprise TKIP",
        value: 9
      }, {
        name: "WPA2 Enterprise AES",
        value: 10
      }, {
        name: "Mixed Personal",
        value: 11
      }, {
        name: "Mixed Enterprise",
        value: 12
      }, {
        name: "WPA3 Personal AES",
        value: 13
      }, {
        name: "WPA3 Personal SAE",
        value: 14
      }];
      this.tag("Pwd").text.text = this.textCollection['EnterPassword'];
      this.tag("NetworkText").text.text = this.textCollection['EnterSSID'];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class WifiPairingScreen extends t.Component {
    static _template() {
      return {
        PairingScreen: {
          Title: {
            x: 960,
            y: 95,
            mountX: 0.5,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          RectangleWithColor: {
            x: 180,
            y: 164,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          PasswordLabel: {
            x: 180,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate("Password") + ": ",
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          Pwd: {
            x: 437,
            y: 240,
            zIndex: 2,
            text: {
              text: '',
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              wordWrapWidth: 1000,
              wordWrap: false,
              textOverflow: 'ellipsis'
            }
          },
          PasswordBox: {
            x: 417,
            y: 208,
            zIndex: 2,
            texture: t.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false)
          },
          PasswrdSwitch: {
            h: 45,
            w: 66.9,
            x: 1656,
            y: 255,
            zIndex: 2,
            type: PasswordSwitch,
            mount: 0.5
          },
          ShowPassword: {
            x: 1390,
            y: 240,
            w: 300,
            h: 75,
            zIndex: 2,
            text: {
              text: Language$1.translate('Show Password'),
              fontSize: 25,
              fontFace: CONFIG.language.font,
              textColor: 0xffffffff,
              textAlign: 'left'
            }
          },
          List: {
            x: 417,
            y: 331,
            type: t.components.ListComponent,
            w: 1080,
            h: 400,
            itemSize: 28,
            horizontal: true,
            invertDirection: false,
            roll: true,
            zIndex: 2
          },
          RectangleWithColor2: {
            x: 180,
            y: 451,
            w: 1515,
            h: 2,
            rect: true,
            color: 0xFFFFFFFF,
            zIndex: 2
          },
          KeyBoard: {
            y: 501,
            x: 420,
            type: Keyboard$1,
            visible: true,
            zIndex: 2,
            formats: KEYBOARD_FORMATS.qwerty
          }
        }
      };
    }
    _updateText(txt) {
      this.tag("Pwd").text.text = txt;
    }
    item(item) {
      this.star = "";
      this.passwd = "";
      this.tag("Pwd").text.text = "";
      this.tag('Title').text = item.ssid;
      let options = [];
      this._item = item;
      if (item.connected) {
        options = ['Disconnect', 'Cancel'];
      } else {
        options = ['Connect', 'Cancel'];
      }
      this.tag('List').items = options.map((item, index) => {
        return {
          ref: item,
          x: index === 0 ? 0 : 325 * index,
          w: 325,
          h: 85,
          type: ConfirmAndCancel,
          item: item
        };
      });
      this._setState('Pair');
    }
    _focus() {
      this.hidePasswd = true;
      this._setState('Pair');
      this.item(this.fireAncestors("$PairingnetworkParams"));
    }
    _unfocus() {}
    _init() {
      this.star = "";
      this.passwd = "";
      this.isOn = false;
      this._wifi = new Wifi();
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this.fireAncestors("$navigateBack");
      } else if (option === 'Connect') {
        if (this._item) {
          console.log('trying to connect wifi');
          this._wifi.connect(this._item, '').then(() => {}).catch(err => {
            console.log('Not able to connect to wifi', JSON.stringify(err));
          });
        }
        this.fireAncestors("$navigateBack");
      } else if (option === 'Disconnect') {
        this._wifi.disconnect().then(() => {
          this.fireAncestors("$navigateBack");
        });
      }
    }
    startConnect(password) {
      this._wifi.connect(this._item, password).then(() => {
        this._wifi.saveSSID(this._item.ssid, password, this._item.security).then(response => {
          if (response.result === 0 && response.success === true) {
            this._wifi.SaveSSIDKey(this._item.ssid).then(persistenceResponse => {
              console.log(persistenceResponse);
            });
            // Router.back()
          } else if (response.result !== 0) {
            this._wifi.clearSSID().then(response => {
              // console.log(response)
              // Router.back()
            });
          }
        });
        this.fireAncestors("$navigateBack");
      });
    }
    static _states() {
      return [class Password extends this {
        $enter() {
          this.shifter = false;
          this.capsLock = false;
        }
        _getFocused() {
          return this.tag("KeyBoard");
        }
        $onSoftKey(_ref) {
          let {
            key
          } = _ref;
          if (key === 'Done') {
            this.startConnect(this.passwd);
          } else if (key === 'Clear') {
            this.passwd = this.passwd.substring(0, this.passwd.length - 1);
            this.star = this.star.substring(0, this.star.length - 1);
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === '#@!' || key === 'abc' || key === '' || key === 'shift') {
            console.log('no saving');
          } else if (key === 'Space') {
            this.star += '\u25CF';
            this.passwd += ' ';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else if (key === 'Delete') {
            this.star = '';
            this.passwd = '';
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          } else {
            this.star += '\u25CF';
            this.passwd += key;
            this._updateText(this.hidePasswd ? this.star : this.passwd);
          }
        }
        _handleUp() {
          this._setState("Pair");
        }
      }, class Pair extends this {
        $enter() {}
        _getFocused() {
          return this.tag('List').element;
        }
        _handleRight() {
          this.tag('List').setNext();
        }
        _handleLeft() {
          this.tag('List').setPrevious();
        }
        _handleUp() {
          this._setState("PasswordSwitchState");
        }
        _handleDown() {
          this._setState("Password");
        }
        _handleEnter() {
          if (this.tag('List').element.ref == 'Connect' && this._item.security != 0) {
            if (this.star === '') {
              this._setState('Password');
            } else {
              this.startConnect(this.passwd);
            }
          } else {
            this.pressEnter(this.tag('List').element.ref);
          }
        }
      }, class PasswordSwitchState extends this {
        $enter() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1279, 88, 0, 3, CONFIG.theme.hex, false);
        }
        _handleDown() {
          this._setState("Pair");
        }
        _getFocused() {
          return this.tag('PasswrdSwitch');
        }
        $handleEnter(bool) {
          if (bool) {
            this._updateText(this.passwd);
            this.hidePasswd = false;
          } else {
            this._updateText(this.star);
            this.hidePasswd = true;
          }
          this.isOn = bool;
        }
        $exit() {
          this.tag("PasswordBox").texture = t.Tools.getRoundRect(1279, 88, 0, 3, 0xffffffff, false);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const errorTitle = 'Error Title';
  const errorMsg = 'Error Message';
  class FailComponent extends t.Component {
    notify(args) {
      console.log(args);
      if (args.title && args.msg) {
        this.tag('FailComponent.Title').text.text = args.title;
        this.tag('FailComponent.Message').text.text = Language$1.translate(args.msg);
      }
    }
    _unfocus() {
      this.tag('FailComponent.Title').text.text = errorTitle;
      this.tag('FailComponent.Message').text.text = errorMsg;
    }
    static _template() {
      return {
        FailComponent: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: errorTitle,
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Message: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: errorMsg,
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          RectangleDefault: {
            x: 0,
            y: 200,
            w: 200,
            mountX: 0.5,
            h: 50,
            rect: true,
            color: CONFIG.theme.hex,
            Ok: {
              x: 100,
              y: 25,
              mount: 0.5,
              text: {
                text: Language$1.translate("OK"),
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for WiFi screen.
  */
  class WiFiScreen extends t.Component {
    static _template() {
      return {
        WifiContents: {
          x: 200,
          y: 275,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              visible: false,
              h: 45,
              w: 45,
              x: 1500,
              // x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Networks: {
            y: 180,
            flex: {
              direction: 'column'
            },
            PairedNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                type: t.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            AvailableNetworks: {
              flexItem: {
                margin: 0
              },
              List: {
                w: 1920 - 300,
                type: t.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -4
              }
            },
            visible: false
          },
          JoinAnotherNetwork: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Join Another Network'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        },
        JoinAnotherNetworkOverlay: {
          type: JoinAnotherNetworkComponent,
          visible: false
        },
        WifiPairingScreen: {
          type: WifiPairingScreen,
          visible: false
        },
        FailScreen: {
          type: FailComponent,
          visible: false
        }
      };
    }
    _active() {
      this._setState('Switch');
    }
    _focus() {
      this._setState('Switch');
      this._enable();
    }
    changeStateBack(state) {
      this._setState(state);
    }
    _firstEnable() {
      this.wifiLoading = this.tag('Switch.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: Math.PI * 2
          }
        }]
      });
      this.onError = {
        0: 'SSID_CHANGED - The SSID of the network changed',
        1: 'CONNECTION_LOST - The connection to the network was lost',
        2: 'CONNECTION_FAILED - The connection failed for an unknown reason',
        3: 'CONNECTION_INTERRUPTED - The connection was interrupted',
        4: 'INVALID_CREDENTIALS - The connection failed due to invalid credentials',
        5: 'NO_SSID - The SSID does not exist',
        6: 'UNKNOWN - Any other error'
      };
      this._wifi = new Wifi();
      this._network = new Network();
      this.wifiStatus = false;
      this._wifiIcon = true;
      this._activateWiFi();
      this._setState('Switch');
      if (this.wiFiStatus) {
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
      }
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this._network.activate().then(result => {
        if (result) {
          this.wifiStatus = true;
          this._network.registerEvent('onIPAddressStatusChanged', notification => {
            console.log(JSON.stringify(notification));
            if (notification.status == 'LOST') {
              if (notification.interface === 'WIFI') {
                this._wifi.setInterface('ETHERNET', true).then(res => {
                  if (res.success) {
                    this._wifi.setDefaultInterface('ETHERNET', true);
                  }
                });
              }
            }
          });
          this._network.registerEvent('onDefaultInterfaceChanged', notification => {
            if (notification.newInterfaceName === 'ETHERNET') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
            if (notification.newInterfaceName == 'ETHERNET' || notification.oldInterfaceName == 'WIFI') {
              this._wifi.disconnect();
              this.wifiStatus = false;
              this.tag('Networks').visible = false;
              this.tag('JoinAnotherNetwork').visible = false;
              this.tag('Switch.Loader').visible = false;
              this.wifiLoading.stop();
              this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this._setState('Switch');
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
            if (notification.newInterfaceName == '' && notification.oldInterfaceName == 'WIFI') {
              this._wifi.setInterface('ETHERNET', true).then(result => {
                if (result.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true).then(result1 => {
                    if (result1.success) {
                      console.log('set default success', result1);
                    }
                  });
                }
              });
            }
          });
          this._network.registerEvent('onConnectionStatusChanged', notification => {
            if (notification.interface === 'ETHERNET' && notification.status === 'CONNECTED') {
              this._wifi.setInterface('ETHERNET', true).then(res => {
                if (res.success) {
                  this._wifi.setDefaultInterface('ETHERNET', true);
                }
              });
            }
          });
        }
      });
    }

    /**
     * Function to be executed when the Wi-Fi screen is enabled.
     */
    _enable() {
      if (this.wifiStatus) {
        this._wifi.discoverSSIDs();
      }
    }

    /**
     * Function to be executed when the Wi-Fi screen is disabled.
     */
    _disable() {
      this._wifi.stopScan();
    }
    pairedDevices() {
      this._pairedNetworks.tag('List').items = [];
      this._availableNetworks.tag('List').items = [];
    }

    /**
     * Function to render list of Wi-Fi networks.
     */
    renderDeviceList(ssids) {
      this._pairedList = [];
      this._pairedNetworks.h = 0;
      this._availableNetworks.tag('List').rollMax = ssids.length * 90;
      this._pairedNetworks.tag('List').items = [];
      this._pairedNetworks.tag('List').h = 0;
      this._wifi.getConnectedSSID().then(result => {
        if (result.ssid != '') {
          this._pairedList = [result];
          this._pairedNetworks.h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
          this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
            item.connected = true;
            return {
              ref: 'Paired' + index,
              w: 1920 - 300,
              h: 90,
              type: WiFiItem,
              item: item
            };
          });
        }
        this._otherList = ssids.filter(device => {
          console.log("SSID filter", device);
          result = this._pairedList.map(a => a.ssid);
          if (result.includes(device.ssid)) {
            return false;
          } else return device;
        });
        console.log("otherlist", this._otherList);
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        //  this._availableNetworks.tag('List').y = this._pairedNetworks.tag('List').h
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          item.connected = false;
          return {
            ref: 'Other' + index,
            w: 1620,
            h: 90,
            type: WiFiItem,
            item: item
          };
        });
      });
    }
    hide() {
      this.tag('WifiContents').visible = false;
    }
    show() {
      this.tag('WifiContents').visible = true;
    }
    $PairingnetworkParams() {
      return this.ListItem;
    }
    $navigateBack() {
      this._setState('Switch');
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.tag('Switch.Button').scaleX = 1;
          }
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          if (this.wifiStatus === true) {
            this._setState('JoinAnotherNetwork');
          }
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          this.ListItem = this._pairedNetworks.tag('List').element._item;
          this._setState("WifiPairingScreen");
        }
      }, class AvailableDevices extends this {
        $enter() {
          if (this.wifiStatus === true) {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            this.tag('Switch.Button').scaleX = -1;
          }
        }
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          console.log("SSID check", this._availableNetworks.tag('List').element._item);
          this.ListItem = this._availableNetworks.tag('List').element._item;
          console.log("enter connect method");
          this._wifi.getSSIDKey().then(response => {
            console.log("ssid check");
            if (response === this.ListItem.ssid) {
              this._wifi.connect().then(response => {
                console.log(response);
              }).catch(err => {
                this._setState("WifiPairingScreen");
                this._wifi.SaveSSIDKey("").then(() => {});
              });
            } else {
              this._setState("WifiPairingScreen");
            }
          });
        }
      }, class JoinAnotherNetwork extends this {
        $enter() {
          this.tag('JoinAnotherNetwork')._focus();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleEnter() {
          this._setState("JoinAnotherNetworkOverlay");
        }
        _handleDown() {
          if (this.wifiStatus) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('JoinAnotherNetwork')._unfocus();
        }
      }, class JoinAnotherNetworkOverlay extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('JoinAnotherNetworkOverlay').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('JoinAnotherNetworkOverlay').visible = false;
        }
        _getFocused() {
          return this.tag('JoinAnotherNetworkOverlay');
        }
        _handleBack() {
          this._setState('Switch');
        }
      },
      //WifiPairingScreen
      class WifiPairingScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('WifiPairingScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('WifiPairingScreen').visible = false;
        }
        _getFocused() {
          return this.tag('WifiPairingScreen');
        }
        _handleBack() {
          this._setState('Switch');
        }
      }, class FailScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('FailScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('FailScreen').visible = false;
        }
        _getFocused() {
          return this.tag('FailScreen');
        }
        _handleBack() {
          this._setState('Switch');
        }
        _handleEnter() {
          this._setState('Switch');
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */

    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          this._wifi.discoverSSIDs();
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) {
            this._setState('AvailableDevices');
          }
        }
      } else if (dir === 'up') {
        if (list.length === 0) {
          this._setState('JoinAnotherNetwork');
          return;
        }
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) {
            this._setState('PairedDevices');
          } else {
            this._setState('JoinAnotherNetwork');
          }
        }
      }
    }
    /**
     * Function to turn on and off Wi-Fi.
     */
    switch() {
      if (this.wifiStatus) {
        this._wifi.disconnect();
        console.log('turning off wifi');
        this._wifi.setInterface('ETHERNET', true).then(result => {
          if (result.success) {
            this._wifi.setDefaultInterface('ETHERNET', true).then(result => {
              if (result.success) {
                this._wifi.disconnect();
                this.wifiStatus = false;
                this.tag('Networks').visible = false;
                this.tag('JoinAnotherNetwork').visible = false;
                this.tag('Switch.Loader').visible = false;
                this.wifiLoading.stop();
                this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              }
            });
          }
        });
      } else {
        console.log('turning on wifi');
        this.wifiStatus = true;
        this.tag('Networks').visible = true;
        this.tag('JoinAnotherNetwork').visible = true;
        this.wifiLoading.play();
        this.tag('Switch.Loader').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this._wifi.discoverSSIDs();
        this.pairedDevices();
      }
    }

    /**
     * Function to activate Wi-Fi plugin.
     */
    _activateWiFi() {
      this._wifi.activate().then(() => {
        this.switch();
      });
      this._wifi.registerEvent('onWIFIStateChanged', notification => {
        console.log(JSON.stringify(notification));
        if (notification.state === 2 || notification.state === 5) {
          this._wifi.discoverSSIDs();
        }
        if (notification.state === 5) {
          this._wifi.getConnectedSSID().then(result => {
            this._wifi.SaveSSIDKey(result.ssid).then(response => {
              console.log(response);
            });
          });
        }
      });
      this._wifi.registerEvent('onError', notification => {
        if (notification.code === 4) {
          this._wifi.clearSSID();
        }
        console.log('on errro');
        this._wifi.discoverSSIDs();
        this._wifi.setInterface('ETHERNET', true).then(res => {
          if (res.success) {
            this._wifi.setDefaultInterface('ETHERNET', true);
          }
        });
        this.tag("FailScreen").notify({
          title: 'WiFi Error',
          msg: Language$1.translate(this.onError[notification.code])
        });
        this._setState('FailScreen');
      });
      this._wifi.registerEvent('onAvailableSSIDs', notification => {
        console.log("notification", notification);
        this.renderDeviceList(notification.ssids);
        if (!notification.moreData) {
          setTimeout(() => {
            this.tag('Switch.Loader').visible = false;
            this.wifiLoading.stop();
          }, 1000);
        }
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const wifi = new Wifi();
  class NetworkInterfaceScreen extends t.Component {
    _construct() {
      this.LoadingIcon = Utils.asset('images/settings/Loading.png');
    }
    static _template() {
      return {
        NetworkInterfaceScreenContents: {
          x: 200,
          y: 275,
          WiFi: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('WiFi'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Ethernet: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Ethernet'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 175,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          }
        },
        WifiScreen: {
          type: WiFiScreen,
          visible: false
        }
      };
    }
    _focus() {
      this._setState('WiFi');
    }
    _init() {
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      this._thunder = thunderJS$1(config);
      const systemcCallsign = 'org.rdk.Network';
      const eventName = 'onDefaultInterfaceChanged';
      this._thunder.on(systemcCallsign, eventName, notification => {
        console.log('onDefaultInterfaceChanged notification from networkInterfaceScreen: ', notification);
        if (notification.newInterfaceName === "ETHERNET") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate('Connected');
        } else if (notification.newInterfaceName === "" && notification.oldInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet: ' + Language$1.translate('Error') + "," + Language$1.translate('Retry') + '!';
        } else if (notification.newInterfaceName === "WIFI") {
          this.loadingAnimation.stop();
          this.tag('Ethernet.Loader').visible = false;
          this.tag('Ethernet.Title').text.text = 'Ethernet';
        }
      });
      this.loadingAnimation = this.tag('Ethernet.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.tag('Ethernet.Loader').src = this.LoadingIcon;
    }
    _firstActive() {
      this.tag('Ethernet.Loader').on('txError', () => {
        const url = 'http://127.0.0.1:50050/lxresui/static/images/settings/Loading.png';
        this.tag('Ethernet.Loader').src = url;
      });
    }
    hide() {
      this.tag('NetworkInterfaceScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkInterfaceScreenContents').visible = true;
    }
    setEthernetInterface() {
      wifi.getInterfaces().then(res => {
        res.interfaces.forEach(element => {
          if (element.interface === "ETHERNET" && element.connected) {
            wifi.setInterface('ETHERNET', true).then(result => {
              if (result.success) {
                wifi.setDefaultInterface('ETHERNET', true);
                this.tag('Ethernet.Title').text.text = 'Ethernet';
                this.tag('Ethernet.Loader').visible = true;
                this.loadingAnimation.start();
              }
            });
          }
        });
      });
    }
    static _states() {
      return [class WiFi extends this {
        $enter() {
          this.tag('WiFi')._focus();
        }
        $exit() {
          this.tag('WiFi')._unfocus();
        }
        _handleDown() {
          this._setState('Ethernet');
        }
        _getFocused() {
          return this.tag('WiFi');
        }
        _handleEnter() {
          this._setState("WifiScreen");
        }
      }, class Ethernet extends this {
        $enter() {
          this.tag('Ethernet')._focus();
        }
        $exit() {
          this.tag('Ethernet')._unfocus();
        }
        _handleEnter() {
          wifi.getDefaultInterface().then(res => {
            if (res.success) {
              if (res.interface !== "ETHERNET") {
                this.setEthernetInterface();
              }
            }
          });
        }
        _handleDown() {
          //  this._setState('WiFi')
        }
        _handleUp() {
          this._setState('WiFi');
        }
      }, class WifiScreen extends this {
        $enter() {
          console.log("wifiscreen");
          this.hide();
          this.tag('WifiScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface  WiFi');
        }
        $exit() {
          this.show();
          this.tag('WifiScreen').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface');
        }
        _getFocused() {
          return this.tag('WifiScreen');
        }
        _handleBack() {
          this._setState('WiFi');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
    * Class for Other Network Config Screen.
    */

  class NetworkConfigurationScreen extends t.Component {
    static _template() {
      return {
        rect: true,
        color: 0x00000000,
        w: 1920,
        h: 1080,
        NetworkConfigurationScreenContents: {
          x: 200,
          y: 275,
          NetworkInfo: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          NetworkInterface: {
            //alpha: 0.3, // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Network Interface: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TestInternetAccess: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Test Internet Access: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 420,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png'),
              visible: false
            }
          },
          StaticMode: {
            alpha: 0,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Static Mode'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        NetworkInfoScreen: {
          type: NetworkInfo,
          visible: false
        },
        NetworkInterfaceOverlay: {
          type: NetworkInterfaceScreen,
          visible: false
        }
      };
    }
    _firstEnable() {
      console.log("first trigger");
      this._setState('NetworkInfo');
      let _currentIPSettings = {};
      let _newIPSettings = {};
      this._network = new Network();
      this._network.getDefaultInterface().then(interfaceName => {
      });
      _newIPSettings = _currentIPSettings;
      _newIPSettings.ipversion = "IPV6"; // this fails, need to verify how to set proper ip settings

      // loader animation for testing internet
      this.loadingAnimation = this.tag('TestInternetAccess.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('NetworkInfo');
      new Network().getDefaultInterface().then(interfaceName => {
        this.$NetworkInterfaceText(interfaceName);
      });
    }
    _unfocus() {
      this.tag('TestInternetAccess.Title').text.text = Language$1.translate('Test Internet Access: ');
    }
    $NetworkInterfaceText(text) {
      this.tag('NetworkInterface.Title').text.text = Language$1.translate('Network Interface: ') + text;
    }
    hide() {
      this.tag('NetworkConfigurationScreenContents').visible = false;
    }
    show() {
      this.tag('NetworkConfigurationScreenContents').visible = true;
    }
    static _states() {
      return [class NetworkInfo extends this {
        $enter() {
          this.tag('NetworkInfo')._focus();
        }
        $exit() {
          this.tag('NetworkInfo')._unfocus();
        }
        _handleDown() {
          this._setState('NetworkInterface');
        }
        _handleEnter() {
          this._setState("NetworkInfoScreen");
        }
      }, class NetworkInterface extends this {
        $enter() {
          this.tag('NetworkInterface')._focus();
        }
        $exit() {
          this.tag('NetworkInterface')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInfo');
        }
        _handleDown() {
          this._setState('TestInternetAccess');
        }
        _handleEnter() {
          this._setState("NetworkInterfaceOverlay");
          //  if (!Router.isNavigating()) {

          //  }
        }
      }, class TestInternetAccess extends this {
        $enter() {
          this.tag('TestInternetAccess')._focus();
        }
        $exit() {
          this.tag('TestInternetAccess')._unfocus();
        }
        _handleUp() {
          this._setState('NetworkInterface');
        }
        _handleDown() {
          //  this._setState('NetworkInfo')
        }
        _handleEnter() {
          this.loadingAnimation.start();
          this.tag('TestInternetAccess.Loader').visible = true;
          this._network.isConnectedToInternet().then(result => {
            let connectionStatus = Language$1.translate("Internet Access: ");
            if (result) {
              connectionStatus += Language$1.translate("Connected");
            } else {
              connectionStatus += Language$1.translate("Not Connected");
            }
            setTimeout(() => {
              this.tag('TestInternetAccess.Loader').visible = false;
              this.tag('TestInternetAccess.Title').text.text = connectionStatus;
              this.loadingAnimation.stop();
            }, 2000);
          });
        }
      }, class StaticMode extends this {
        $enter() {
          this.tag('StaticMode')._focus();
        }
        $exit() {
          this.tag('StaticMode')._unfocus();
        }
        _handleUp() {
          this._setState('TestInternetAccess');
        }
        _handleDown() {
          this._setState('NetworkInfo');
        }
        _handleEnter() {}
      }, class NetworkInfoScreen extends this {
        $enter() {
          this.hide();
          this.tag('NetworkInfoScreen').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Info');
        }
        $exit() {
          this.show();
          this.tag('NetworkInfoScreen').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings / Network Configuration');
        }
        _getFocused() {
          return this.tag('NetworkInfoScreen');
        }
        _handleBack() {
          this._setState('NetworkInfo');
        }
      }, class NetworkInterfaceOverlay extends this {
        $enter() {
          this.hide();
          this.tag('NetworkInterfaceOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration  Network Interface');
        }
        $exit() {
          this.show();
          this.tag('NetworkInterfaceOverlay').visible = false;
          this.fireAncestors('$updatePageTitle', 'Settings  Network Configuration');
        }
        _getFocused() {
          return this.tag('NetworkInterfaceOverlay');
        }
        _handleBack() {
          this._setState('NetworkInterface');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let _item;
  /**
   * Class for pairing screen for the Bluetooth.
   */
  class BluetoothPairingScreen extends t.Component {
    static _template() {
      return {
        BluetoothPair: {
          x: 960,
          y: 300,
          Title: {
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Pairing: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: "",
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 0,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            ConnectDisconnect: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: "",
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Unpair: {
              x: 0 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFFFFFFFF,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Unpair"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            },
            Cancel: {
              x: 0 + 220 + 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xFF7D7D7D,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xFF000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          }
        }
      };
    }
    getData(item) {
      console.log("setting pairing screen item: ", item);
      _item = item;
      this._setState('ConnectDisconnect');
      this.tag('Title').text = item.name;
      if (item.connected) {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Disconnect');
      } else {
        this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').text = Language$1.translate('Connect');
      }
    }
    _init() {
      this._setState('ConnectDisconnect');
    }
    _focus() {
      this._setState('ConnectDisconnect');
      this.item(this.fireAncestors("$BluetoothParams"));
    }
    static _states() {
      return [class ConnectDisconnect extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          // this.tag('Pairing').text = "Someting is wrong " + _item.name
          if (_item.connected) {
            this.fireAncestors('$triggerBluetoothAction', 'Disconnect');
          } else {
            this.fireAncestors('$triggerBluetoothAction', 'Connect');
          }
        }
        _handleRight() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: CONFIG.theme.hex
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('BluetoothPair.Buttons.ConnectDisconnect').patch({
            color: 0xFFFFFFFF
          });
          this.tag('BluetoothPair.Buttons.ConnectDisconnect.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Unpair extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.fireAncestors('$triggerBluetoothAction', 'Unpair');
        }
        _handleRight() {
          this._setState('Cancel');
        }
        _handleLeft() {
          this._setState('ConnectDisconnect');
        }
        _focus() {
          this.tag('Unpair').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Unpair').patch({
            color: 0xFFFFFFFF
          });
          this.tag('Unpair.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          this.fireAncestors('$triggerBluetoothAction', 'Cancel');
        }
        _handleLeft() {
          this._setState('Unpair');
        }
        _focus() {
          this.tag('Cancel').patch({
            color: CONFIG.theme.hex
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFFFFFFFF
            }
          });
        }
        _unfocus() {
          this.tag('Cancel').patch({
            color: 0xFF7D7D7D
          });
          this.tag('Cancel.Title').patch({
            text: {
              textColor: 0xFF000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Bluetooth screen.
   */
  class BluetoothScreen extends t.Component {
    static _template() {
      return {
        Bluetooth: {
          y: 275,
          x: 200,
          Switch: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bluetooth On/Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Searching: {
            visible: false,
            h: 90,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Searching for Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Loader: {
              h: 45,
              w: 45,
              // x: 1600,
              x: 320,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Loading.png')
            }
          },
          Networks: {
            PairedNetworks: {
              y: 180,
              List: {
                type: t.components.ListComponent,
                w: 1920 - 300,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            AvailableNetworks: {
              y: 90,
              visible: false,
              List: {
                w: 1920 - 300,
                type: t.components.ListComponent,
                itemSize: 90,
                horizontal: false,
                invertDirection: true,
                roll: true,
                rollMax: 900,
                itemScrollOffset: -6
              }
            },
            visible: false
          },
          AddADevice: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Add A Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            visible: false
          }
        },
        BluetoothPairingScreen: {
          type: BluetoothPairingScreen,
          visible: false
        },
        FailScreen: {
          type: FailComponent,
          visible: false
        }
      };
    }

    //  $navigateBack() {
    //   this._setState('AddADevice')
    // }

    $triggerBluetoothAction(option) {
      this.pressEnter(option);
      this._setState('AddADevice');
    }
    hide() {
      this.tag('Bluetooth').visible = false;
    }
    show() {
      this.tag('Bluetooth').visible = true;
    }
    _unfocus() {
      this._disable();
    }
    _firstEnable() {
      this._bt = new BluetoothApi();
      this._bluetooth = false;
      this._activateBluetooth();
      this._setState('Switch');
      this.switch(); //so that switch will be enabled by default
      //this._bluetooth = false
      this._pairedNetworks = this.tag('Networks.PairedNetworks');
      this._availableNetworks = this.tag('Networks.AvailableNetworks');
      this.renderDeviceList();
      this.loadingAnimation = this.tag('Searching.Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _focus() {
      this._setState('AddADevice');
      this._enable();
      if (this._bluetooth) {
        this.tag('Networks').visible = true;
        this.tag('AddADevice').visible = true;
        this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.renderDeviceList();
        //this._bt.startScan()
      }
    }

    /**
     * Function to be excuted when the Bluetooth screen is enabled.
     */
    _enable() {
      if (this._bluetooth) {
        this._bt.startScan();
      }
      this.scanTimer = Registry.setInterval(() => {
        if (this._bluetooth) {
          this._bt.startScan();
        }
      }, 5000);
    }

    /**
     * Function to be executed when the Bluetooth screen is disabled from the screen.
     */
    _disable() {
      Registry.clearInterval(this.scanTimer);
      this._bt.stopScan();
    }

    /**
     * Function to be executed when add a device is pressed
     */

    showAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 0
      });
      this.tag('PairedNetworks').patch({
        alpha: 0
      });
      this.tag('AddADevice').patch({
        alpha: 0
      });
      this.tag('Searching').patch({
        visible: true
      });
      this.tag('AvailableNetworks').patch({
        visible: true
      });
      //  this.loadingAnimation.stop()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    hideAvailableDevices() {
      this.tag('Switch').patch({
        alpha: 1
      });
      this.tag('PairedNetworks').patch({
        alpha: 1
      });
      this.tag('AddADevice').patch({
        alpha: 1
      });
      this.tag('Searching').patch({
        visible: false
      });
      this.tag('AvailableNetworks').patch({
        visible: false
      });
      //  this.loadingAnimation.start()
      // this.tag('TopPanel').patch({ alpha: 0 });
      // this.tag('SidePanel').patch({ alpha: 0 });
    }

    /**
     * Function to render list of Bluetooth devices
     */
    renderDeviceList() {
      this._bt.getPairedDevices().then(result => {
        this._pairedList = result;
        this._pairedNetworks.h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').h = this._pairedList.length * 90;
        this._pairedNetworks.tag('List').items = this._pairedList.map((item, index) => {
          item.paired = true;
          return {
            ref: 'Paired' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
      this._bt.getDiscoveredDevices().then(result => {
        this._discoveredList = result;
        this._otherList = this._discoveredList.filter(device => {
          if (!device.paired) {
            result = this._pairedList.map(a => a.deviceID);
            if (result.includes(device.deviceID)) {
              return false;
            } else return device;
          }
        });
        this._availableNetworks.tag('List').rollMax = this._otherList.length * 90;
        this._availableNetworks.h = this._otherList.length * 90;
        this._availableNetworks.tag('List').h = this._otherList.length * 90;
        this._availableNetworks.tag('List').items = this._otherList.map((item, index) => {
          return {
            ref: 'Other' + index,
            w: 1920 - 300,
            h: 90,
            type: BluetoothItem,
            item: item
          };
        });
      });
    }
    pressEnter(option) {
      if (option === 'Cancel') {
        this._setState('AddADevice');
      } else if (option === 'Pair') {
        this._bt.pair(this._availableNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._availableNetworks.tag('List').element._item.name;
          if (result.success) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Pairing Successful')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Pairing Failed')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Connect') {
        this._bt.connect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Failed')
            });
            this._setState('FailScreen');
          } else {
            this._bt.setAudioStream(this._pairedNetworks.tag('List').element._item.deviceID);
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Successful')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Disconnect') {
        this._bt.disconnect(this._pairedNetworks.tag('List').element._item.deviceID, this._pairedNetworks.tag('List').element._item.deviceType).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (!result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Failed to Disconnect')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Disconnected')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      } else if (option === 'Unpair') {
        this._bt.unpair(this._pairedNetworks.tag('List').element._item.deviceID).then(result => {
          let btName = this._pairedNetworks.tag('List').element._item.name;
          if (result) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Unpaired')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Unpairing Failed')
            });
            this._setState('FailScreen');
          }
        }).finally(() => {
          this._setState('AddADevice');
        });
      }
    }
    $BluetoothParams() {
      return this._pairedNetworks.tag('List').element._item;
    }
    static _states() {
      return [class Switch extends this {
        $enter() {
          this.hideAvailableDevices();
          this.tag('Switch')._focus();
        }
        $exit() {
          this.tag('Switch')._unfocus();
        }
        _handleDown() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this.switch();
        }
      }, class PairedDevices extends this {
        $enter() {
          this.hideAvailableDevices();
        }
        _getFocused() {
          return this._pairedNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('MyDevices', 'down');
        }
        _handleUp() {
          this._navigate('MyDevices', 'up');
        }
        _handleEnter() {
          this.tag('BluetoothPairingScreen').getData(this._pairedNetworks.tag('List').element._item);
          this._setState('BluetoothPairingScreen');
        }
      }, class AvailableDevices extends this {
        _getFocused() {
          return this._availableNetworks.tag('List').element;
        }
        _handleDown() {
          this._navigate('AvailableDevices', 'down');
        }
        _handleUp() {
          this._navigate('AvailableDevices', 'up');
        }
        _handleEnter() {
          this.pressEnter('Pair');
        }
        _handleBack() {
          this.hideAvailableDevices();
          this._setState('AddADevice');
        }
      }, class AddADevice extends this {
        $enter() {
          this.tag('AddADevice')._focus();
          this.hideAvailableDevices();
        }
        _handleUp() {
          this._setState('Switch');
        }
        _handleDown() {
          if (this._bluetooth) {
            if (this._pairedNetworks.tag('List').length > 0) {
              this._setState('PairedDevices');
            } else if (this._availableNetworks.tag('List').length > 0) {
              this._setState('AvailableDevices');
            }
          }
        }
        $exit() {
          this.tag('AddADevice')._unfocus();
        }
        _handleEnter() {
          if (this._bluetooth) {
            this.showAvailableDevices();
            this._setState('AvailableDevices');
          }
        }
      }, class BluetoothPairingScreen extends this {
        $enter() {
          this._disable();
          this._bt.stopScan();
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('BluetoothPairingScreen').visible = true;
        }
        _getFocused() {
          return this.tag('BluetoothPairingScreen');
        }
        $exit() {
          this._enable();
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('BluetoothPairingScreen').visible = false;
        }
        _handleBack() {
          this._setState('AddADevice');
        }
      }, class FailScreen extends this {
        $enter() {
          this.hide();
          this.fireAncestors('$hideBreadCrum');
          this.tag('FailScreen').visible = true;
        }
        $exit() {
          this.show();
          this.fireAncestors('$showBreadCrum');
          this.tag('FailScreen').visible = false;
        }
        _getFocused() {
          return this.tag('FailScreen');
        }
        _handleBack() {
          this._setState('AddADevice');
        }
        _handleEnter() {
          this._setState('AddADevice');
        }
      }];
    }

    /**
     * Function to navigate through the lists in the screen.
     * @param {string} listname
     * @param {string} dir
     */
    _navigate(listname, dir) {
      let list;
      if (listname === 'MyDevices') list = this._pairedNetworks.tag('List');else if (listname === 'AvailableDevices') list = this._availableNetworks.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();else if (list.index == list.length - 1) {
          if (listname === 'MyDevices' && this._availableNetworks.tag('List').length > 0) ;
        }
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();else if (list.index == 0) {
          if (listname === 'AvailableDevices' && this._pairedNetworks.tag('List').length > 0) ; else if (listname === 'MyDevices') {
            this._setState('AddADevice');
          }
        }
      }
    }

    /**
     * Function to turn on and off Bluetooth.
     */
    switch() {
      if (this._bluetooth) {
        this._bt.disable().then(result => {
          if (result.success) {
            this._bluetooth = false;
            this.tag('Networks').visible = false;
            this.tag('AddADevice').visible = false;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          }
        }).catch(() => {
          console.log('Cannot turn off Bluetooth');
        });
      } else {
        this._bt.enable().then(result => {
          if (result.success) {
            this._bluetooth = true;
            this.tag('Networks').visible = true;
            this.tag('AddADevice').visible = true;
            this.tag('Switch.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            this.renderDeviceList();
            this._bt.startScan();
          }
        }).catch(() => {
          console.log('Cannot turn on Bluetooth');
        });
      }
    }

    /**
     * Function to activate Bluetooth plugin.
     */
    _activateBluetooth() {
      this._bt.activate().then(res => {
        console.log(res);
        this._bluetooth = true;
        this._bt.registerEvent('onDiscoveredDevice', () => {
          this.renderDeviceList();
        });
        this._bt.registerEvent('onPairingRequest', notification => {
          this.respondToPairingRequest(notification.deviceID, 'ACCEPTED');
        });
        this._bt.registerEvent('onConnectionChange', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          let btName = notification.name;
          if (notification.connected) {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Successful')
            });
            this._setState('FailScreen');
          } else {
            this.tag("FailScreen").notify({
              title: btName,
              msg: Language$1.translate('Connection Failed')
            });
            this._setState('FailScreen');
          }
        });
        this._bt.registerEvent('onDiscoveryCompleted', () => {
          this.tag('Searching.Loader').visible = false;
          this.loadingAnimation.stop();
          this.renderDeviceList();
        });
        this._bt.registerEvent('onDiscoveryStarted', () => {
          this.loadingAnimation.start();
          this.tag('Searching.Loader').visible = true;
        });
        this._bt.registerEvent('onRequestFailed', notification => {
          this._bt.startScan();
          this.renderDeviceList();
          this.tag("FailScreen").notify({
            title: notification.name,
            msg: notification.newStatus
          });
          this._setState('FailScreen');
        });
      }).catch(err => {
        console.log(err);
      });
    }

    /**
     * Function to respond to Bluetooth client.
     * @param {number} deviceID
     * @param {string} responseValue
     */
    respondToPairingRequest(deviceID, responseValue) {
      this._bt.respondToEvent(deviceID, 'onPairingRequest', responseValue);
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const dtvApi$2 = new DTVApi();
  const config$4 = {
    host: "127.0.0.1",
    port: 9998,
    default: 1
  };
  const thunder$5 = thunderJS$1(config$4);

  /**
   * Class for DVB Scan screen.
   */
  class DvbSScan extends t.Component {
    static _template() {
      return {
        DvbSScanScreenContents: {
          x: 200,
          y: 275,
          Wrapper: {
            y: -3,
            h: 635,
            w: 1700,
            clipping: true,
            Scroller: {
              y: 2,
              Satellite: {
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Satellite"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Frequency: {
                y: 90,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Frequency"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Polarity: {
                y: 180,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Polarity"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SymbolRate: {
                y: 270,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Symbol Rate"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              FEC: {
                y: 360,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("FEC"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              DVBS2: {
                y: 450,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("DVB-S2"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              },
              Modulation: {
                y: 540,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Modulation"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              SearchType: {
                y: 630,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Search Mode"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 45,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/Arrow.png")
                }
              },
              Retune: {
                y: 720,
                type: SettingsMainItem,
                Title: {
                  x: 10,
                  y: 45,
                  mountY: 0.5,
                  text: {
                    text: Language$1.translate("Clear existing service list"),
                    textColor: COLORS.titleColor,
                    fontFace: CONFIG.language.font,
                    fontSize: 25
                  }
                },
                Button: {
                  h: 45,
                  w: 67,
                  x: 1600,
                  mountX: 1,
                  y: 45,
                  mountY: 0.5,
                  src: Utils.asset("images/settings/ToggleOffWhite.png")
                }
              }
            }
          },
          StartScan: {
            zIndex: 3,
            x: 10,
            y: 670,
            h: 50,
            w: 200,
            rect: true,
            color: 0xffffffff,
            Title: {
              x: 100,
              y: 27,
              mount: 0.5,
              text: {
                text: Language$1.translate("Start Scan"),
                textColor: 0xff000000,
                fontFace: CONFIG.language.font,
                fontSize: 24
              }
            }
          },
          ErrorNotification: {
            x: 250,
            y: 670,
            h: 50,
            visible: false,
            Content: {
              x: 10,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Error!"),
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            }
          },
          ScanProgress: {
            x: 270,
            y: 670,
            h: 50,
            visible: false,
            Title: {
              visible: false,
              x: 40,
              y: 25,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Please wait scan in progress") + "...",
                textColor: CONFIG.theme.hex,
                fontFace: CONFIG.language.font,
                fontSize: 21
              }
            },
            Loader: {
              h: 45,
              w: 45,
              x: 10,
              mountX: 1,
              y: 25,
              mountY: 0.5,
              src: Utils.asset("images/settings/Loading.png")
            }
          }
        },
        SelectSatellite: {
          type: Satellite,
          visible: false
        },
        SelectFrequency: {
          type: IntegerInput,
          visible: false
        },
        SelectPolarity: {
          type: Polarity,
          visible: false
        },
        SelectSymbolRate: {
          type: IntegerInput,
          visible: false
        },
        SelectFEC: {
          type: FEC,
          visible: false
        },
        SelectModulation: {
          type: Modulation,
          visible: false
        },
        SelectSearchType: {
          type: SearchType,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Satellite");
      this.preventExit = false;
      this.selectedSatellite = {};
      this.selectedFrequency = "";
      this.selectedPolarity = "";
      this.selectedSymbolRate = "";
      this.selectedFEC = "";
      this.selectedDVBS2 = false; //default value is false
      this.selectedModulation = "";
      this.selectedSearchType = "";
      this.selectedRetune = false; //default value is set to false

      this.loadingAnimation = this.tag("ScanProgress.Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.inProgressAnimation = this.tag("ScanProgress.Title").animation({
        duration: 0.6,
        repeat: 0,
        stopMethod: "immediate",
        actions: [{
          p: "text.text",
          v: {
            0: Language$1.translate("Please wait scan in progress"),
            0.3: Language$1.translate("Please wait scan in progress") + ".",
            0.6: Language$1.translate("Please wait scan in progress") + "..",
            0.9: Language$1.translate("Please wait scan in progress") + "..."
          }
        }]
      });
    }
    setScanInProgress() {
      this.preventExit = true;
      this.loadingAnimation.start();
      this.inProgressAnimation.start();
      this.tag("ScanProgress").visible = true;
    }
    setScanFinished() {
      this.preventExit = false;
      this.loadingAnimation.stop();
      this.inProgressAnimation.stop();
      this.tag("ScanProgress").visible = false;
      this.tag("ScanProgress.Title").visible = false;
    }
    _captureKey() {
      if (this.preventExit) {
        this.tag("ScanProgress.Title").visible = true;
        this.inProgressAnimation.start();
      } else {
        return false;
      }
    }
    consoleLog() {
      //log it everywhere
      console.log("selectedSatellite: ", JSON.stringify(this.selectedSatellite), " selectedFrequency: ", this.selectedFrequency, " selectedPolarity: ", this.selectedPolarity, " selectedSymbolRate: ", this.selectedSymbolRate, " selectedFEC: ", this.selectedFEC, " selectedDVBS2: ", this.selectedDVBS2, " selectedModulation: ", this.selectedModulation, " selectedSearchType: ", this.selectedSearchType, " selectedRetune: ", this.selectedRetune);
    }
    _focus() {
      // console.log("dvbscan screen in focus");
      this.resetForm();
      this._setState("Satellite");
      this.consoleLog();
      // console.log(this.satelliteList);
      // console.log(this.polarityList);
      // console.log(this.fecList);
      // console.log(this.modulationList);
      // console.log(this.searchtypeList);
    }

    _firstActive() {
      thunder$5.on("DTV", "searchstatus", notification => {
        console.log("SearchStatus Notification: ", JSON.stringify(notification));
        if (notification.finished) {
          console.log("notification.finished: ", notification.finished);
          this.setScanFinished();
        }
      });

      ///////////////satellite

      this.satelliteList = [];
      dtvApi$2.satelliteList().then(res => {
        this.satelliteList = res;
      });

      ///////////////////polarity

      this.polarityList = [];
      dtvApi$2.polarityList().then(res => {
        this.polarityList = res;
      });

      ///////////////////symbolRate
      //symbol rate has some predefined values additional to custom imput
      this.symbolRateList = [];
      dtvApi$2.symbolRateList().then(res => {
        this.symbolRateList = res;
      });

      ////////////////////FEC

      this.fecList = [];
      dtvApi$2.fecList().then(res => {
        this.fecList = res;
      });

      ///////////////////modulation

      this.modulationList = [];
      dtvApi$2.modulationList().then(res => {
        this.modulationList = res;
      });

      ///////////////////searchtype

      this.searchtypeList = [];
      dtvApi$2.searchtypeList().then(res => {
        this.searchtypeList = res;
      });
    }
    _handleBack() {
      this.resetForm();
      return false; //so that handleBack of parent is also executed.
    }

    $getSatelliteList() {
      return this.satelliteList;
    }
    $setSatellite(satellite) {
      this.selectedSatellite = satellite;
      //this.consoleLog();
    }

    $getSelectedSatellite() {
      return this.selectedSatellite;
    }
    $getPolarityList() {
      return this.polarityList;
    }
    $setPolarity(polarity) {
      this.selectedPolarity = polarity;
      //this.consoleLog();
    }

    $getSelectedPolarity() {
      return this.selectedPolarity;
    }
    $getFECList() {
      return this.fecList;
    }
    $setFEC(fec) {
      this.selectedFEC = fec;
      //this.consoleLog();
    }

    $getSelectedFEC() {
      return this.selectedFEC;
    }
    $getModulationList() {
      return this.modulationList;
    }
    $setModulation(modulation) {
      this.selectedModulation = modulation;
      //this.consoleLog();
    }

    $getSelectedModulation() {
      return this.selectedModulation;
    }
    $getSearchTypeList() {
      return this.searchtypeList;
    }
    $setSearchType(searchtype) {
      this.selectedSearchType = searchtype;
      //this.consoleLog();
    }

    $getSelectedSearchType() {
      return this.selectedSearchType;
    }
    setFrequency(frequency) {
      this._setState("Frequency");
      this.selectedFrequency = frequency;
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency") + ": " + (this.selectedFrequency !== "" ? this.selectedFrequency : Language$1.translate("Select a") + " " + Language$1.translate("Frequency"));
    }
    setSymbolRate(symbolrate) {
      this._setState("SymbolRate");
      this.selectedSymbolRate = symbolrate;
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate") + ": " + (this.selectedSymbolRate !== "" ? this.selectedSymbolRate : Language$1.translate("Select a") + " " + Language$1.translate("Symbol Rate"));
    }
    resetForm() {
      this.setScanFinished();
      //reset the form variables to initial state on exit from this form
      this.selectedSatellite = {};
      this.tag("Satellite.Title").text.text = Language$1.translate("Satellite");
      this.selectedFrequency = "";
      this.tag("Frequency.Title").text.text = Language$1.translate("Frequency");
      this.selectedPolarity = "";
      this.tag("Polarity.Title").text.text = Language$1.translate("Polarity");
      this.selectedSymbolRate = "";
      this.tag("SymbolRate.Title").text.text = Language$1.translate("Symbol Rate");
      this.selectedFEC = "";
      this.tag("FEC.Title").text.text = Language$1.translate("FEC");
      this.selectedDVBS2 = false;
      this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.selectedModulation = "";
      this.tag("Modulation.Title").text.text = Language$1.translate("Modulation");
      this.selectedSearchType = "";
      this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode");
      this.selectedRetune = false;
      this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      this.tag("ErrorNotification").visible = false;
    }
    verifyInputs() {
      let errorString = "";
      if (Object.keys(this.selectedSatellite).length === 0) {
        errorString += "| " + Language$1.translate("Satellite") + " ";
      }
      if (this.selectedFrequency === "") {
        errorString += "| " + Language$1.translate("Frequency") + " ";
      }
      if (this.selectedPolarity === "") {
        errorString += "| " + Language$1.translate("Polarity") + " ";
      }
      if (this.selectedSymbolRate === "") {
        errorString += "| " + Language$1.translate("Symbol Rate") + " ";
      }
      if (this.selectedFEC === "") {
        errorString += "| " + Language$1.translate("FEC") + " ";
      }
      if (this.selectedModulation === "") {
        errorString += "| " + Language$1.translate("Modulation") + " ";
      }
      if (this.selectedSearchType === "") {
        errorString += "| " + Language$1.translate("Search Mode") + " ";
      }
      return errorString;
    }
    static _states() {
      return [class Satellite extends this {
        $enter() {
          this.tag("Satellite")._focus();
          this.tag("Scroller").y = 2; //to reset the scroll to show the first item.
        }

        $exit() {
          this.tag("Satellite")._unfocus();
        }
        _handleDown() {
          this._setState("Frequency");
        }
        _handleEnter() {
          if (this.satelliteList.length > 0) {
            this._setState("Satellite.SelectSatellite");
          } else {
            dtvApi$2.satelliteList().then(res => {
              this.satelliteList = res;
            });
          }
        }
        static _states() {
          return [class SelectSatellite extends Satellite {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSatellite").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Satellite"), true);
            }
            $exit() {
              this.tag("SelectSatellite").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Satellite.Title").text.text = Language$1.translate("Satellite") + ": " + (Object.keys(this.selectedSatellite).length !== 0 ? this.selectedSatellite.name : Language$1.translate("Select a") + " " + Language$1.translate("Satellite"));
            }
            _getFocused() {
              return this.tag("SelectSatellite");
            }
            _handleBack() {
              this._setState("Satellite");
            }
          }];
        }
      }, class Frequency extends this {
        $enter() {
          this.tag("Frequency")._focus();
        }
        $exit() {
          this.tag("Frequency")._unfocus();
        }
        _handleUp() {
          this._setState("Satellite");
        }
        _handleDown() {
          this._setState("Polarity");
        }
        _handleEnter() {
          this.tag("SelectFrequency").patch({
            prevVal: this.selectedFrequency,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setFrequency.bind(this) //pass a function that will be executed when done is clicked on the keyboard
          });

          this._setState("Frequency.SelectFrequency");
        }
        static _states() {
          return [class SelectFrequency extends Frequency {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFrequency").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Frequency"), true);
            }
            $exit() {
              this.tag("SelectFrequency").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
            }
            _getFocused() {
              return this.tag("SelectFrequency");
            }
            _handleBack() {
              this.setFrequency(this.selectedFrequency);
            }
          }];
        }
      }, class Polarity extends this {
        $enter() {
          this.tag("Polarity")._focus();
        }
        $exit() {
          this.tag("Polarity")._unfocus();
        }
        _handleUp() {
          this._setState("Frequency");
        }
        _handleDown() {
          this._setState("SymbolRate");
        }
        _handleEnter() {
          this._setState("Polarity.SelectPolarity");
        }
        static _states() {
          return [class SelectPolarity extends Polarity {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectPolarity").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Polarity"), true);
            }
            $exit() {
              this.tag("SelectPolarity").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Polarity.Title").text.text = Language$1.translate("Polarity") + ": " + (this.selectedPolarity !== "" ? this.selectedPolarity.charAt(0).toUpperCase() + this.selectedPolarity.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Polarity"));
            }
            _getFocused() {
              return this.tag("SelectPolarity");
            }
            _handleBack() {
              this._setState("Polarity");
            }
          }];
        }
      }, class SymbolRate extends this {
        $enter() {
          this.tag("SymbolRate")._focus();
        }
        $exit() {
          this.tag("SymbolRate")._unfocus();
        }
        _handleUp() {
          this._setState("Polarity");
        }
        _handleDown() {
          this._setState("FEC");
        }
        _handleEnter() {
          this.tag("SelectSymbolRate").patch({
            prevVal: this.selectedSymbolRate,
            //previous value is passed to retain the previously entered value
            onHandleDone: this.setSymbolRate.bind(this),
            //pass a function that will be executed when done is clicked on the keyboard
            presetValues: this.symbolRateList //can handle a list of predefined values that can be selected using arrow keys
          });

          this._setState("SymbolRate.SelectSymbolRate");
        }
        static _states() {
          return [class SelectSymbolRate extends SymbolRate {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSymbolRate").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Symbol Rate"), true);
            }
            $exit() {
              this.tag("SelectSymbolRate").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
            }
            _getFocused() {
              return this.tag("SelectSymbolRate");
            }
            _handleBack() {
              this.setSymbolRate(this.selectedSymbolRate);
            }
          }];
        }
      }, class FEC extends this {
        $enter() {
          this.tag("FEC")._focus();
        }
        $exit() {
          this.tag("FEC")._unfocus();
        }
        _handleUp() {
          this._setState("SymbolRate");
        }
        _handleDown() {
          this._setState("DVBS2");
        }
        _handleEnter() {
          this._setState("FEC.SelectFEC");
        }
        static _states() {
          return [class SelectFEC extends FEC {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectFEC").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("FEC"), true);
            }
            $exit() {
              this.tag("SelectFEC").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("FEC.Title").text.text = Language$1.translate("FEC") + ": " + (this.selectedFEC !== "" ? this.selectedFEC.replace("fec", "").replace("_", "/").toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("FEC"));
            }
            _getFocused() {
              return this.tag("SelectFEC");
            }
            _handleBack() {
              this._setState("FEC");
            }
          }];
        }
      }, class DVBS2 extends this {
        $enter() {
          this.tag("DVBS2")._focus();
        }
        $exit() {
          this.tag("DVBS2")._unfocus();
        }
        _handleUp() {
          this._setState("FEC");
        }
        _handleDown() {
          this._setState("Modulation");
        }
        _handleEnter() {
          if (!this.selectedDVBS2) {
            this.selectedDVBS2 = true;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedDVBS2 = false;
            this.tag("DVBS2.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class Modulation extends this {
        $enter() {
          this.tag("Modulation")._focus();
        }
        $exit() {
          this.tag("Modulation")._unfocus();
        }
        _handleUp() {
          this._setState("DVBS2");
        }
        _handleDown() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleEnter() {
          this._setState("Modulation.SelectModulation");
        }
        static _states() {
          return [class SelectModulation extends Modulation {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectModulation").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Modulation"), true);
            }
            $exit() {
              this.tag("SelectModulation").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("Modulation.Title").text.text = Language$1.translate("Modulation") + ": " + (this.selectedModulation !== "" ? this.selectedModulation.toUpperCase() : Language$1.translate("Select a") + " " + Language$1.translate("Modulation"));
            }
            _getFocused() {
              return this.tag("SelectModulation");
            }
            _handleBack() {
              this._setState("Modulation");
            }
          }];
        }
      }, class SearchType extends this {
        $enter() {
          this.tag("SearchType")._focus();
        }
        $exit() {
          this.tag("SearchType")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = 2;
          this._setState("Modulation");
        }
        _handleDown() {
          this.tag("Scroller").y = -178;
          this._setState("Retune");
        }
        _handleEnter() {
          this._setState("SearchType.SelectSearchType");
        }
        static _states() {
          return [class SelectSearchType extends SearchType {
            $enter() {
              this.tag("DvbSScanScreenContents").visible = false;
              this.tag("SelectSearchType").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan") + " / " + Language$1.translate("Search Mode"), true);
            }
            $exit() {
              this.tag("SelectSearchType").visible = false;
              this.tag("DvbSScanScreenContents").visible = true;
              this.fireAncestors('$updatePageTitle', Language$1.translate("Settings / Live TV / Scan / DVB-S Scan"), true);
              this.tag("SearchType.Title").text.text = Language$1.translate("Search Mode") + ": " + (this.selectedSearchType !== "" ? this.selectedSearchType.charAt(0).toUpperCase() + this.selectedSearchType.slice(1) : Language$1.translate("Select a") + " " + Language$1.translate("Search Mode"));
            }
            _getFocused() {
              return this.tag("SelectSearchType");
            }
            _handleBack() {
              this._setState("SearchType");
            }
          }];
        }
      }, class Retune extends this {
        $enter() {
          this.tag("Retune")._focus();
        }
        $exit() {
          this.tag("Retune")._unfocus();
        }
        _handleUp() {
          this.tag("Scroller").y = -88;
          this._setState("SearchType");
        }
        _handleDown() {
          this._setState("StartScan");
        }
        _handleEnter() {
          if (!this.selectedRetune) {
            this.selectedRetune = true;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
          } else {
            this.selectedRetune = false;
            this.tag("Retune.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
          }
        }
      }, class StartScan extends this {
        $enter() {
          this.tag("StartScan").color = CONFIG.theme.hex;
          this.tag("StartScan.Title").text.textColor = 0xffffffff;
        }
        $exit() {
          this.tag("StartScan").color = 0xffffffff;
          this.tag("StartScan.Title").text.textColor = 0xff000000;
        }
        _handleUp() {
          this._setState("Retune");
        }
        _handleEnter() {
          let errorString = this.verifyInputs();
          if (errorString === "") {
            this.tag("ErrorNotification").visible = false;
            let serviceSearchParams = {
              tunertype: "dvbs",
              searchtype: this.selectedSearchType,
              retune: this.selectedRetune,
              usetuningparams: true,
              dvbstuningparams: {
                satellite: this.selectedSatellite.name,
                frequency: parseInt(this.selectedFrequency),
                polarity: this.selectedPolarity,
                symbolrate: parseInt(this.selectedSymbolRate),
                fec: this.selectedFEC,
                modulation: this.selectedModulation,
                dvbs2: this.selectedDVBS2
              }
            };
            console.log(JSON.stringify(serviceSearchParams));
            dtvApi$2.startServiceSearch(serviceSearchParams).then(res => {
              this.setScanInProgress();
              console.log(res);
              setTimeout(() => {
                this.setScanFinished(); //to give back controls after 30 sec in case searchstatus event fails
              }, 30000);
            });
          } else {
            this.tag("ErrorNotification.Content").text.text = Language$1.translate("Please enter the values for the following ") + errorString;
            this.tag("ErrorNotification").visible = true;
          }
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
   * Class for Live TV Scan screen.
   */
  class LiveTVScan extends t.Component {
    static _template() {
      return {
        LiveTVScanScreenContents: {
          x: 200,
          y: 275,
          TScan: {
            alpha: 0.3,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-T Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CScan: {
            alpha: 0.3,
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-C Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          SScan: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('DVB-S Scan'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DvbSScan: {
          type: DvbSScan,
          visible: false
        }
      };
    }
    _init() {
      this._setState('SScan');
    }
    _focus() {
      this._setState('SScan');
    }
    hide() {
      this.tag("LiveTVScanScreenContents").visible = false;
    }
    show() {
      this.tag("LiveTVScanScreenContents").visible = true;
    }
    static _states() {
      return [class TScan extends this {
        $enter() {
          this.tag('TScan')._focus();
        }
        $exit() {
          this.tag('TScan')._unfocus();
        }
        _handleDown() {
          this._setState('CScan');
        }
      }, class CScan extends this {
        $enter() {
          this.tag('CScan')._focus();
        }
        $exit() {
          this.tag('CScan')._unfocus();
        }
        _handleUp() {
          this._setState('TScan');
        }
        _handleDown() {
          this._setState('SScan');
        }
      }, class SScan extends this {
        $enter() {
          this.tag('SScan')._focus();
        }
        $exit() {
          this.tag('SScan')._unfocus();
        }
        _handleUp() {
          // this._setState('CScan')
        }
        _handleEnter() {
          this._setState("DvbSScan");
        }
      }, class DvbSScan extends this {
        $enter() {
          this.hide();
          this.tag('DvbSScan').visible = true;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV / Scan / DVB-S Scan'));
        }
        $exit() {
          this.show();
          this.tag('DvbSScan').visible = false;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV / Scan'));
        }
        _getFocused() {
          return this.tag('DvbSScan');
        }
        _handleBack() {
          this._setState('SScan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  let active = true; //expecting dtv plugin is active by default

  /**
   * Class for Live TV settings screen.
   */
  class LiveTVSettings extends t.Component {
    static _template() {
      return {
        LiveTVSettingsScreenContents: {
          x: 200,
          y: 275,
          Activate: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Activate / Deactivate"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/ToggleOnOrange.png")
            }
          },
          Scan: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Scan"),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset("images/settings/Arrow.png")
            }
          }
        },
        LiveTvScanOverlay: {
          type: LiveTVScan,
          visible: false
        }
      };
    }
    _init() {
      this._setState("Activate");
    }
    _firstActive() {
      this.dtvApi = new DTVApi();
    }
    _focus() {
      this._setState("Activate");
      if (active) {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
      } else {
        this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
      }
    }
    hide() {
      this.tag("LiveTVSettingsScreenContents").visible = false;
    }
    show() {
      this.tag("LiveTVSettingsScreenContents").visible = true;
    }
    static _states() {
      return [class Activate extends this {
        $enter() {
          this.tag("Activate")._focus();
        }
        $exit() {
          this.tag("Activate")._unfocus();
        }
        _handleDown() {
          this._setState("Scan");
        }
        _handleEnter() {
          if (Storage.get("deviceType") != "IpStb") {
            if (active) {
              this.dtvApi.deactivate().then(res => {
                console.log(res);
                active = false;
                this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOffWhite.png");
              });
            } else {
              this.dtvApi.activate().then(res => {
                console.log(res);
                active = true;
                this.tag("Activate.Button").src = Utils.asset("images/settings/ToggleOnOrange.png");
              });
            }
          }
        }
      }, class Scan extends this {
        $enter() {
          this.tag("Scan")._focus();
        }
        $exit() {
          this.tag("Scan")._unfocus();
        }
        _handleUp() {
          this._setState("Activate");
        }
        _handleEnter() {
          this._setState("LiveTvScanOverlay");
        }
      }, class LiveTvScanOverlay extends this {
        $enter() {
          this.hide();
          this.tag('LiveTvScanOverlay').visible = true;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV / Scan'));
        }
        $exit() {
          this.show();
          this.tag('LiveTvScanOverlay').visible = false;
          this.fireAncestors('$updatePageTitle', Language$1.translate('Settings / Live TV'));
        }
        _getFocused() {
          return this.tag('LiveTvScanOverlay');
        }
        _handleBack() {
          this._setState('Scan');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class SleepTimerScreen extends t.Component {
    static _template() {
      return {
        SleepTimer: {
          y: 275,
          x: 200,
          List: {
            w: 1920 - 300,
            type: t.components.ListComponent,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -5
          }
        }
      };
    }
    _firstEnable() {
      this.lastElement = false;
      this.options = [{
        value: 'Off',
        tick: true
      }, {
        value: '15 Minutes',
        tick: false
      }, {
        value: '1 Hour',
        tick: false
      }, {
        value: '1.5 Hours',
        tick: false
      }, {
        value: '2 Hours',
        tick: false
      }, {
        value: '3 Hours',
        tick: false
      }];
      this.tag('List').h = this.options.length * 90;
      let timeoutInterval = Storage$1.get('TimeoutInterval');
      if (!timeoutInterval) {
        timeoutInterval = 'Off';
      }
      let index = 0;
      this.tag('List').items = this.options.map((item, id) => {
        if (timeoutInterval === item.value) {
          index = id;
        }
        return {
          w: 1920 - 300,
          h: 90,
          type: SettingsItem,
          item: item.value
        };
      });
      this.tag('List').getElement(index).tag('Tick').visible = true;
      this.fireAncestors('$registerInactivityMonitoringEvents').then(res => {
        this.fireAncestors('$resetSleepTimer', timeoutInterval);
      }).catch(err => {
        console.error("error while registering the inactivity monitoring event");
      });
      this._setState('Options');
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          this.options.forEach((element, idx) => {
            //if (element.tick) {
            this.tag('List').getElement(idx).tag('Tick').visible = false;
            //this.options[idx].tick = false
            //}
          });

          this.tag('List').element.tag('Tick').visible = true;
          //this.options[this.tag('List').index].tick = true
          this.fireAncestors('$sleepTimerText', this.options[this.tag('List').index].value);
          this.fireAncestors('$resetSleepTimer', this.options[this.tag('List').index].value);
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class EnergySavingsScreen extends t.Component {
    static _template() {
      return {
        EnerygySavingContents: {
          x: 200,
          y: 275,
          List: {
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png"),
            visible: true
          }
        }
      };
    }
    $resetPrevTickObject(prevTicObject) {
      if (!this.prevTicOb) {
        this.prevTicOb = prevTicObject;
      } else {
        this.prevTicOb.tag("Item.Tick").visible = false;
        this.prevTicOb = prevTicObject;
      }
    }
    static _states() {
      return [class Options extends this {
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
        _handleEnter() {
          // this.tag("List").element.patch({ "Item.Tick.visible": true });
          this.tag("List").element.tag("Tick").visible = true;
          // enable the tick mark in VideoAudioItem.js
          //to update the resolution value on Video Screen
        }
      }];
    }

    _firstEnable() {
      this._appApi = new AppApi();
      this.options = [Language$1.translate("Deep Sleep"), Language$1.translate("Light Sleep")];
      this.tag('EnerygySavingContents').h = this.options.length * 90;
      this.tag('EnerygySavingContents.List').h = this.options.length * 90;
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
      }
    }
    _focus() {
      this.loadingAnimation.start();
      let standbyMode = "";
      this._appApi.getPreferredStandbyMode().then(result => {
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          standbyMode = Language$1.translate("Light Sleep");
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          standbyMode = Language$1.translate("Deep Sleep");
        }
        this.tag('List').items = this.options.map((item, index) => {
          return {
            ref: 'Option' + index,
            w: 1920 - 300,
            h: 90,
            type: EnergySavingsItem,
            isTicked: standbyMode === item ? true : false,
            item: item,
            energyItem: true
          };
        });
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
        this._setState("Options");
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$2 = new AppApi();
  const thunder$4 = thunderJS$1({
    host: '127.0.0.1',
    port: 9998,
    default: 1
  });
  const loader = 'Loader';
  class LanguageScreen extends t.Component {
    static _template() {
      return {
        LanguageScreenContents: {
          x: 200,
          y: 275,
          Languages: {
            flexItem: {
              margin: 0
            },
            List: {
              type: t.components.ListComponent,
              w: 1920 - 300,
              itemSize: 90,
              horizontal: false,
              invertDirection: true,
              roll: true,
              rollMax: 900,
              itemScrollOffset: -4
            }
          }
        }
      };
    }
    _init() {
      this._Languages = this.tag('LanguageScreenContents.Languages');
      this._Languages.h = availableLanguages.length * 90;
      this._Languages.tag('List').h = availableLanguages.length * 90;
      this._Languages.tag('List').items = availableLanguages.map((item, index) => {
        return {
          ref: 'Lng' + index,
          w: 1620,
          h: 90,
          type: LanguageItem,
          item: item
        };
      });
      appApi$2.deactivateResidentApp(loader);
      appApi$2.setVisibility(Storage$1.get("selfClientName"), true);
      thunder$4.call('org.rdk.RDKShell', 'moveToFront', {
        client: Storage$1.get("selfClientName")
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      });
      thunder$4.call('org.rdk.RDKShell', 'setFocus', {
        client: Storage$1.get("selfClientName")
      }).then(result => {
        console.log('ResidentApp moveToFront Success');
      }).catch(err => {
        console.log('Error', err);
      });
    }
    _focus() {
      this._setState('Languages');
    }
    static _states() {
      return [class Languages extends this {
        $enter() {}
        _getFocused() {
          return this._Languages.tag('List').element;
        }
        _handleDown() {
          this._navigate('down');
        }
        _handleUp() {
          this._navigate('up');
        }
        _handleEnter() {
          if (localStorage.getItem('Language') !== availableLanguages[this._Languages.tag('List').index]) {
            localStorage.setItem('Language', availableLanguages[this._Languages.tag('List').index]);
            let path = location.pathname.split('index.html')[0];
            let url = path.slice(-1) === '/' ? "static/loaderApp/index.html" : "/static/loaderApp/index.html";
            let notification_url = location.origin + path + url;
            console.log(notification_url);
            appApi$2.launchResident(notification_url, loader).catch(err => {});
            appApi$2.setVisibility(Storage$1.get("selfClientName"), false);
            location.reload();
          }
        }
      }];
    }
    _navigate(dir) {
      let list = this._Languages.tag('List');
      if (dir === 'down') {
        if (list.index < list.length - 1) list.setNext();
      } else if (dir === 'up') {
        if (list.index > 0) list.setPrevious();
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const _privacyPolicy = "Privacy\n  Welcome to RDKCentral.com, a website owned and operated by RDK Management, LLC (\u201CRDK Management,\u201D \u201Cwe,\u201D or \u201Cus\u201D). This privacy policy discloses the privacy practices for this website only, including an explanation of:\n\n  the categories of personally identifiable information about you that may be collected and how that information is used;\n  how we collect and use non-personally identifiable information about your use of the website;\n  the categories of persons or entities with whom the information may be shared;\n  the choices that are available to you regarding collection, use, and distribution of the information;\n  how you can opt out of RDK-related promotional e-mail;\n  the kind of security procedures that are in place to protect the loss, misuse or alteration of information;\n  how you can review and request changes to the information; and\n  how we notify users of this website of changes to this privacy policy.\n  Questions regarding this policy should be directed to \u201CRDK Management \u2013 Privacy Feedback\u201D and can be submitted via e-mail to info@rdkcentral.com.\n\n\n  What categories of information do we collect?\n  The information collected by RDK Management falls into two categories: (1) information voluntarily supplied by users of the website and (2) tracking information recorded as users navigate through the website. Some of this information is personally identifiable information (i.e., information that identifies a particular person, such as e-mail address), but much of it is not.\n\n  To make use of some features on our website, like the RDK Wiki, users need to register and provide certain information as part of the registration process. We may ask, for example, for your name, e-mail address, street address, and zip code. We might also request information about your employer and the type of work that you do, in order to determine whether your employer is a member of the RDK program, to help us ensure that you are given access to the correct portions of the website, and to tailor our website content and e-mail (if you\u2019ve registered to receive e-mail) to your interests to make it more useful to you. If you are a registered user, our systems will remember some of this information the next time you log in and use our website, but you can always review and change your information by logging in and editing your profile here.\n\n  The more you tell us about yourself, the more value we can offer you. Supplying this information is entirely voluntary. But if you choose not to supply the information, we may be unable to provide you with access to all of the features of this website. There are certain features of this website, including the Wiki and requesting to receive RDK-related promotional e-mail, that you will not be able to use unless you provide certain personally identifiable information about yourself. When you submit any personally identifiable information over this website, RDK Management (i) will use the information for the purposes described at the time you submit it and (ii) may use the information to contact you, subject to the contact preferences in your profile. If you want to remain completely anonymous, you\u2019re still free to take advantage of the publicly available content on our website without registration.\n\n  Does RDK Management analyze my interaction with this website?\n  Some of the third-party service providers that RDK Management uses to deliver services, like analytics providers, may collect information on this website as disclosed in this privacy policy. This information may include personally identifiable information or may be used to contact you online.\n\n  We and our service providers may use cookies to provide these services. The World Wide Web Consortium (W3C) has started a process to develop a \u201CDo Not Track\u201D Standard. Since the definitions and rules for such a standard have not yet been defined, RDK Management does not yet respond to \u201CDo Not Track\u201D signals sent from browsers.\n\n  You may opt out of receiving cookies from the companies that provide services on this website by going to www.networkadvertising.org/consumer/opt_out.asp or http://www.aboutads.info/choices.\n\n  What categories of persons or entities do we share personally identifiable information with?\n  We consider the personally identifiable information contained in our business records to be confidential. We may sometimes disclose personally identifiable information about you to our affiliates or to others who work for us. We may also disclose personally identifiable information about you to service providers and vendors, and to others who provide products and services to us. For example, when you use certain functions on this website you may notice that the website actually collecting or processing the information may be other than an RDK Management website. We may be required by law or legal process to disclose certain personally identifiable information about you to lawyers and parties in connection with litigation and to law enforcement personnel. For example, we may be required by law to disclose personally identifiable information about you without your consent and without notice in order to comply with a valid legal process such as a subpoena, court order, or search warrant.\n\n  What do we do to personalize your use of this website?\n  We, or our service providers, may customize this website based on non-personal information including: (i) the IP address associated with your computer for purposes of determining your approximate geographic location; (ii) the type of web page that is being displayed; or (iii) the content on the page that is shown. Because this activity automatically applies to all users and it is purely contextual, this type of content delivery cannot be customized or controlled by individual users. We may also personalize this website based on the information that you provided us during registration. You may modify this information as further described in this Privacy Policy.\n\n  To help make our website more responsive to the needs of our users, we use a standard feature of browser software called a \u201Ccookie.\u201D We use cookies to help us tailor our website to your needs, to deliver a better, more personalized service, and to remember certain choices you\u2019ve made so you don\u2019t have to re-enter them.\n\n  RDK Management uses cookies, among other things, to remember your username and password, if you choose to store them, as well as to remember some of your personalization preferences and website features. RDK Management does not store your name or other personal information in cookies. You may read about enabling, disabling, and deleting cookies here. Of course, if you set your browser not to accept cookies or you delete them, you may not be able to take advantage of the personalized features enjoyed by other users of our website.\n\n  The cookies we use don\u2019t directly identify users of our website as particular persons. Rather, they contain information sufficient to simplify and improve a user\u2019s experience on our website. For example, we may use session-based cookies to track the pages on our website visited by our users. We can build a better website if we know which pages our users are visiting and how often. Or, we may use persistent cookies to simplify access to a user\u2019s account information over our website, for example.\n\n  In connection with the standard operation of RDK Management\u2019s systems, certain non-personally identifiable information about users of this website is recorded. This information is used primarily to tailor and enhance users\u2019 experience using the website. We may use this information in an aggregate, non-personally identifiable form to, among other things, measure the use of our website and determine which pages are the most popular with website users.\n\n  We may also use one or more audience segmenting technology providers to help present content on this website. These providers uses cookies, web beacons, or similar technologies on your computer or mobile or other device to serve you advertisements or content tailored to interests you have shown by browsing on this and other websites you have visited. It also helps determine whether you have seen a particular piece of content before and in order to avoid sending you duplicates. In doing so, these providers collect non-personally identifiable information such as your browser type, your operating system, web pages visited, time of visits, content viewed, ads viewed, and other click stream data. When you visit this website, these providers may use cookies or web beacons to note which product and service descriptions your browser visited. The use of cookies, web beacons, or similar technologies by these providers is subject to their own privacy policies, not RDK Management\u2019s privacy policy for this website. If you do not want the benefits of the cookies used by these providers, you may opt-out of them by visiting http://www.networkadvertising.org/consumer/opt_out.asp or by visiting their opt-out pages.\n\n  Your Access to and Control over your information?\n  You may opt out of any future contacts from us at any time. You can do the following at any time via email to support@rdkcentral.com or info@rdkcentral.com or unsubscribe to emails.\n\n  Request to see all the information stored in the system\n  Accuracy of your data can be checked or corrected.\n  Personal data will be archived, in case user does not access our system for 90 days. However, user can request for deletion by writing to us at support@rdkcentral.com\n  Express any concern you have about our use of your data\n  Opt out from receiving emails by clicking unsubscribe.\n  How do users opt out of RDK-related promotional e-mail?\n  You can opt out of receiving RDK-related promotional e-mail from RDK Management using the opt-out link found in the footer of any of these e-mails. You can also e-mail the request to the attention of \u201CRDK Management \u2013 E-mail Opt Out\u201D via e-mail to info@rdkcentral.com.\n\n  Other Websites\n\n  To make our website more valuable to our users, we may offer some features in conjunction with other providers. Our website may also include links to other websites whose privacy policies and practices we don\u2019t control. Once you leave our website by linking to another one (you can tell where you are by checking the address \u2013 known as a URL \u2013 in the location bar on your browser), use of any information you provide is governed by the privacy policy of the operator of the website you\u2019re visiting. That policy may differ from ours. If you can\u2019t find the privacy policy of any of these websites via a link from the site\u2019s homepage, you should contact the website directly for more information.\n\n  Security\n\n  All information gathered on our website is stored within a database accessible only to RDK Management, its affiliates, and their specifically-authorized contractors and vendors. However, as effective as any security measure implemented by RDK Management may be, no security system is impenetrable. We cannot guarantee the complete security of our database, nor can we guarantee that information you supply won\u2019t be intercepted while being transmitted to us over the Internet. If you don\u2019t want us to know any particular information about you, don\u2019t include it in anything that you submit or post to this website or send to us in e-mail. We will retain and use your information to the extent necessary to comply with our legal obligations, resolve disputes, and enforce our policies.\n\n  Changes to this Privacy Policy\n\n  We may change this privacy policy from time to time. If we change this privacy policy at some point in the future, we\u2019ll post the changes on our website and by continuing to use the website after we post any changes, you accept and agree to this privacy statement, as modified.\n\n  A Special Note About Children\n\n  This website is not directed to children under the age of 13, and RDK Management does not knowingly collect personally identifiable information from anyone under the age of 18 on this website.\n\n  Contacting us:\n\n  If you have any questions about RDK Management, LLC privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\n\n  Data Protection Officer:  Herman-Jan Smith\n\n  Email us at: hj.smith@rdkcentral.com\n\n  Contacting the appropriate authority:\n\n  Should you wish to report a complaint or if you feel that Our Company has not addressed your concern in a satisfactory manner, you may contact the Information Commissioner\u2019s Office.\n\n  Email: compliance_team@rdkcentral.com\n\n  Address:  1701 JFK Boulevard, Philadelphia, PA 19103 U.S.A";
  class PrivacyPolicyScreen extends t.Component {
    static _template() {
      return {
        PrivacyPolicyScreenContents: {
          h: 810,
          w: 1720,
          x: 200,
          y: 270,
          clipping: true,
          PrivacyPolicy: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy Policy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontStyle: "bold",
                fontSize: 40
              }
            },
            Content: {
              x: 10,
              y: 100,
              text: {
                text: _privacyPolicy,
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 20,
                wordWrapWidth: 1500,
                wordWrap: true
              }
            }
          }
        }
      };
    }
    _handleDown() {
      if (this.tag("PrivacyPolicy").y > -2400) {
        this.tag("PrivacyPolicy").y -= 35;
      }
    }
    _handleUp() {
      if (this.tag("PrivacyPolicy").y <= 3) {
        this.tag("PrivacyPolicy").y += 35;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Privacy Screen.
   */

  const xcastApi$1 = new XcastApi();
  class PrivacyScreen extends t.Component {
    static _template() {
      return {
        PrivacyScreenContents: {
          x: 200,
          y: 275,
          LocalDeviceDiscovery: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Local Device Discovery'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          UsbMediaDevices: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('USB Media Devices'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          AudioInput: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Audio Input'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          ClearCookies: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Clear Cookies and App Data'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          PrivacyPolicy: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy Policy and License'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        PrivacyPolicyScreen: {
          type: PrivacyPolicyScreen,
          visible: false
        }
      };
    }
    _firstEnable() {
      this._setState('LocalDeviceDiscovery');
      this.checkLocalDeviceStatus();
      this.USBApi = new UsbApi();
      this.AppApi = new AppApi();
    }
    _focus() {
      this._setState(this.state);
      this.checkLocalDeviceStatus();
      this.checkUSBDeviceStatus();
    }
    checkUSBDeviceStatus() {
      if (!Storage$1.get('UsbMedia')) {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        Storage$1.set('UsbMedia', 'ON');
      } else if (Storage$1.get('UsbMedia') === 'ON') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
      } else if (Storage$1.get('UsbMedia') === 'OFF') {
        this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      }
    }
    checkLocalDeviceStatus() {
      xcastApi$1.getEnabled().then(res => {
        if (res.enabled) {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        } else {
          this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
        }
      }).catch(err => {
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    toggleLocalDeviceDiscovery() {
      xcastApi$1.getEnabled().then(res => {
        if (!res.enabled) {
          xcastApi$1.activate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
            }
          });
        } else {
          xcastApi$1.deactivate().then(res => {
            if (res) {
              this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
            }
          });
        }
      }).catch(err => {
        console.log('Service not active');
        this.tag('LocalDeviceDiscovery.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
      });
    }
    hide() {
      this.tag('PrivacyScreenContents').visible = false;
    }
    show() {
      this.tag('PrivacyScreenContents').visible = true;
    }
    static _states() {
      return [class LocalDeviceDiscovery extends this {
        $enter() {
          this.tag('LocalDeviceDiscovery')._focus();
        }
        $exit() {
          this.tag('LocalDeviceDiscovery')._unfocus();
        }
        _handleUp() {
          //  this._setState('PrivacyPolicy')
        }
        _handleDown() {
          this._setState('UsbMediaDevices');
        }
        _handleEnter() {
          this.toggleLocalDeviceDiscovery();
        }
      }, class UsbMediaDevices extends this {
        $enter() {
          this.tag('UsbMediaDevices')._focus();
        }
        $exit() {
          this.tag('UsbMediaDevices')._unfocus();
        }
        _handleUp() {
          this._setState('LocalDeviceDiscovery');
        }
        _handleDown() {
          this._setState('AudioInput');
        }
        _handleEnter() {
          let _UsbMedia = Storage$1.get('UsbMedia');
          if (_UsbMedia === 'ON') {
            this.fireAncestors('$deRegisterUsbMount');
            this.USBApi.deactivate().then(res => {
              Storage$1.set('UsbMedia', 'OFF');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
              this.widgets.menu.refreshMainView();
            }).catch(err => {
              console.error("error while disabling the usb plugin = ".concat(err));
              this.fireAncestors('$registerUsbMount');
            });
          } else if (_UsbMedia === 'OFF') {
            this.USBApi.activate().then(res => {
              Storage$1.set('UsbMedia', 'ON');
              this.tag('UsbMediaDevices.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
              this.fireAncestors('$registerUsbMount');
              this.widgets.menu.refreshMainView();
            });
          }
        }
      }, class AudioInput extends this {
        $enter() {
          this.tag('AudioInput')._focus();
        }
        $exit() {
          this.tag('AudioInput')._unfocus();
        }
        _handleUp() {
          this._setState('UsbMediaDevices');
        }
        _handleDown() {
          this._setState('ClearCookies');
        }
        _handleEnter() {
          //
        }
      }, class ClearCookies extends this {
        $enter() {
          this.tag('ClearCookies')._focus();
        }
        $exit() {
          this.tag('ClearCookies')._unfocus();
        }
        _handleUp() {
          this._setState('AudioInput');
        }
        _handleDown() {
          this._setState('PrivacyPolicy');
        }
        _handleEnter() {
          this.AppApi.clearCache().then(() => {
            //location.reload(true)
          });
        }
      }, class PrivacyPolicy extends this {
        $enter() {
          this.tag('PrivacyPolicy')._focus();
        }
        $exit() {
          this.tag('PrivacyPolicy')._unfocus();
        }
        _handleUp() {
          this._setState('ClearCookies');
        }
        _handleDown() {
          //  this._setState('LocalDeviceDiscovery')
        }
        _handleEnter() {
          this._setState("PrivacyPolicyScreen");
        }
      }, class PrivacyPolicyScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('PrivacyPolicyScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Privacy  Policy');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('PrivacyPolicyScreen');
        }
        $exit() {
          this.show();
          this.tag('PrivacyPolicyScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings ');
        }
        _handleBack() {
          this._setState('PrivacyPolicy');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Video and Audio screen.
   */

  class DeviceInformationScreen extends t.Component {
    static _template() {
      return {
        DeviceInfoWrapper: {
          w: 1720,
          h: 810,
          x: 200,
          y: 275,
          clipping: true,
          DeviceInfoContents: {
            y: 3,
            Line1: {
              y: 0,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            ChipSet: {
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Chipset"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 45,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line2: {
              y: 90,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            SerialNumber: {
              Title: {
                x: 10,
                y: 135,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Serial Number"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 135,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line3: {
              y: 180,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            Location: {
              Title: {
                x: 10,
                y: 225,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Location"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 225,
                mountY: 0.5,
                text: {
                  text: "CountryCode:",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line4: {
              y: 270,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            SupportedDRM: {
              Title: {
                x: 10,
                y: 360,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Supported DRM & Key-System"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  wordWrapWidth: 1600,
                  wordWrap: true,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 360,
                mountY: 0.5,
                text: {
                  text: "N/A",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  wordWrapWidth: 1200,
                  wordWrap: true,
                  fontSize: 25
                }
              }
            },
            Line5: {
              y: 450,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            FirmwareVersions: {
              Title: {
                x: 10,
                y: 540,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Firmware version"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 540,
                mountY: 0.5,
                text: {
                  text: "UI Version: ".concat(Settings$2.get('platform', 'version'), ", Build Version: , Firebolt API Version: "),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line6: {
              y: 630,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            },
            AppVersions: {
              Title: {
                x: 10,
                y: 720,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("App Info"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Value: {
                x: 400,
                y: 720,
                mountY: 0.5,
                text: {
                  text: "YouTube:\nAmazon Prime:\nNetflix ESN:",
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              }
            },
            Line7: {
              y: 810,
              mountY: 0.5,
              w: 1600,
              h: 3,
              rect: true,
              color: 0xFFFFFFFF
            }
          }
        }
      };
    }
    _init() {
      this._network = new Network();
      this.appApi = new AppApi();
    }
    _focus() {
      this._setState('DeviceInformationScreen');
      this.appApi.getSerialNumber().then(result => {
        this.tag("SerialNumber.Value").text.text = "".concat(result.serialNumber);
      });
      if ("ResidentApp" === Storage$1.get("selfClientName")) {
        this.appApi.getSystemVersions().then(res => {
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.stbVersion, " \nTime Stamp - ").concat(res.stbTimestamp, " ");
        }).catch(err => {
          console.error("error while getting the system versions");
        });
        this._network.isConnectedToInternet().then(result => {
          if (result.connectedToInternet === true) {
            this.appApi.getLocation().then(result => {
              console.log("getLocation from device info " + JSON.stringify(result));
              let locationInfo = "";
              if (result.city.length !== 0) {
                locationInfo = "City: " + result.city;
              } else {
                locationInfo = "City: N/A ";
              }
              if (result.country.length !== 0) {
                locationInfo += ", Country: " + result.country;
              } else {
                locationInfo += ", Country: N/A ";
              }
              this.tag('Location.Value').text.text = "".concat(locationInfo);
            });
          } else {
            this.tag('Location.Value').text.text = "City: N/A, Country: N/A";
          }
        });
      } else {
        FireBoltApi.get().deviceinfo.getversion().then(res => {
          console.log("build verion".concat(res.firmware.readable, " Firebolt API Version - ").concat(res.api.readable));
          this.tag('FirmwareVersions.Value').text.text = "UI Version - ".concat(Settings$2.get('platform', 'version'), " \nBuild Version - ").concat(res.firmware.readable, " \nFirebolt API Version - ").concat(res.api.readable, " ");
        }).catch(err => {
          console.error("error while getting the system versions from Firebolt.getversion API");
        });
        FireBoltApi.get().localization.countryCode().then(res => {
          this.tag('Location.Value').text.text = "CountryCode: ".concat(res);
        });
      }
      this.appApi.getDRMS().then(result => {
        console.log('from device info supported drms ' + JSON.stringify(result));
        let drms = "";
        result.forEach(element => {
          drms += "".concat(element.name, " :");
          if (element.keysystems) {
            drms += "\t";
            element.keysystems.forEach(keySystem => {
              drms += "".concat(keySystem, ", ");
            });
            drms += "\n";
          } else {
            drms += "\n";
          }
        });
        this.tag('SupportedDRM.Value').text.text = "".concat(drms.substring(0, drms.length - 1));
      });
      this.appApi.getDeviceIdentification().then(result => {
        console.log('from device Information screen getDeviceIdentification: ' + JSON.stringify(result));
        this.tag('ChipSet.Value').text.text = "".concat(result.chipset);
        // this.tag('FirmwareVersions.Value').text.text = `${result.firmwareversion}`
      });

      let self = this;
      if (Storage$1.get('Netflix_ESN')) {
        self.tag('AppVersions.Value').text.text = "Youtube: NA\nAmazon Prime: NA\nNetflix ESN: ".concat(Storage$1.get('Netflix_ESN'));
      } else {
        self.appApi.getPluginStatus('Netflix').then(result => {
          let sel = self;
          console.log("Netflix : plugin status : ", JSON.stringify(result));
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            sel.appApi.launchPremiumAppInSuspendMode("Netflix").then(res => {
              console.log("Netflix : netflix launch for esn value in suspend mode returns : ", JSON.stringify(res));
              let se = sel;
              se.appApi.getNetflixESN().then(res => {
                Storage$1.set('Netflix_ESN', res);
                console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
                se.netflixESN = "YouTube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
              }).catch(err => {
                console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
              });
            }).catch(err => {
              console.error("Netflix : error while launching netflix in suspendMode : ", JSON.stringify(err));
            });
          } else {
            self.appApi.getNetflixESN().then(res => {
              Storage$1.set('Netflix_ESN', res);
              console.log("Netflix : netflix esn call returns : ", JSON.stringify(res));
              self.netflixESN = "YouTube: NA \nAmazon Prime: NA \nNetflix ESN: ".concat(res);
            }).catch(err => {
              console.error("Netflix : error while getting netflix esn : ", JSON.stringify(err));
            });
          }
        }).catch(err => {
          console.error("Netflix : error while getting netflix plugin status ie. ", JSON.stringify(err));
        });
      }
      this.appApi.registerChangeLocation();
    }
    set netflixESN(v) {
      console.log("setting netflix ESN value to ".concat(v));
      this.tag('AppVersions.Value').text.text = v;
    }
    _handleDown() {
      if (this.tag("DeviceInfoContents").y > -200) {
        this.tag("DeviceInfoContents").y -= 20;
      }
    }
    _handleUp() {
      if (this.tag("DeviceInfoContents").y < 3) {
        this.tag("DeviceInfoContents").y += 20;
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeOverlayItems extends t.Component {
    static _template() {
      return {
        TimeItemsContents: {
          y: 3,
          List: {
            type: t.components.ListComponent,
            h: 810,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          }
        }
      };
    }

    /**
     * Function refresh the list.
     */
    refreshList(item) {
      console.log("item from refreshList", item);
      this._item = item;
      this.tag('List').items = Object.keys(item.time_region).map((ele, idx) => {
        return {
          ref: 'Time' + idx,
          w: 1620,
          h: 90,
          type: TimeItem,
          item: [ele, ele === item.isActive]
        };
      });
    }
    _firstEnable() {
      this.appApi = new AppApi();
    }
    _handleDown() {
      this.tag('List').setNext();
    }
    _handleUp() {
      this.tag('List').setPrevious();
    }
    _handleEnter() {
      console.log("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      this.fireAncestors("$updateTimeZone", "".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      //  this.widgets.menu.updateTimeZone(`${this._item.zone}/${this.tag('List').element._item[0]}`)
      this.appApi.setZone("".concat(this._item.zone, "/").concat(this.tag('List').element._item[0]));
      //  Router.navigate('settings/advanced/device/timezone', { refresh: true })
      return false; //to execute handle enter in parent component
    }

    _getFocused() {
      return this.tag('List').element;
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for rendering items in Settings screen.
   */
  class TimeZoneOverlayItem extends t.Component {
    _construct() {
      this.Arrow = Utils.asset('/images/settings/Arrow.png');
      this.Tick = Utils.asset('/images/settings/Tick.png');
    }
    static _template() {
      return {
        zIndex: 1,
        TopLine: {
          y: 0,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        },
        Item: {
          w: 1600,
          h: 90
        },
        BottomLine: {
          y: 90,
          mountY: 0.5,
          w: 1600,
          h: 3,
          rect: true,
          color: 0xFFFFFFFF
        }
      };
    }

    /**
     * Function to set contents for an item in settings screen.
     */
    set item(item) {
      this._item = item;
      this.tag('Item').patch({
        Right: {
          y: 45,
          x: 1600,
          mountX: 1,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Arrow, 45, 45),
          color: 0xffffffff
        },
        Tick: {
          y: 45,
          mountY: 0.5,
          texture: t.Tools.getSvgTexture(this.Tick, 32.5, 32.5),
          color: 0xffffffff,
          visible: item[2]
        },
        Left: {
          x: 40,
          y: 45,
          mountY: 0.5,
          text: {
            text: item[0],
            fontSize: 25,
            textColor: COLORS.textColor,
            fontFace: CONFIG.language.font
          }
        }
      });
    }
    _handleEnter() {
      console.log('enter', this._item[1]);
      this.fireAncestors("$navigateAndRefreshItems", {
        time_region: this._item[1],
        zone: this._item[0],
        isActive: this.zone
      });
      // Router.navigate('settings/advanced/device/timezone/item', { time_region: this._item[1], zone: this._item[0], isActive: this.zone })
    }

    _focus() {
      this.tag('TopLine').color = CONFIG.theme.hex;
      this.tag('BottomLine').color = CONFIG.theme.hex;
      this.patch({
        zIndex: 2
      });
      this.tag('TopLine').h = 6;
      this.tag('BottomLine').h = 6;
    }
    _unfocus() {
      this.tag('TopLine').color = 0xFFFFFFFF;
      this.tag('BottomLine').color = 0xFFFFFFFF;
      this.patch({
        zIndex: 1
      });
      this.tag('TopLine').h = 3;
      this.tag('BottomLine').h = 3;
    }
  }

  class TimeZone extends t.Component {
    /**
     * @param {object} args
     */
    set params(args) {
      if (args.refresh) {
        this._firstEnable();
      }
    }
    static _template() {
      return {
        TimeZoneOverlayScreenContents: {
          x: 200,
          y: 275,
          w: 1720,
          h: 810,
          clipping: true,
          List: {
            y: 3,
            type: t.components.ListComponent,
            w: 1920 - 300,
            itemSize: 90,
            horizontal: false,
            invertDirection: true,
            roll: true,
            rollMax: 900,
            itemScrollOffset: -6
          },
          Error: {
            alpha: 0,
            x: 560,
            y: 340,
            mountX: 0.5,
            MSG: {
              text: {
                text: Language$1.translate('Not supported'),
                fontFace: CONFIG.language.font,
                fontSize: 40,
                textColor: 0xffffffff
              }
            }
          },
          Loader: {
            x: 740,
            y: 340,
            w: 90,
            h: 90,
            mount: 0.5,
            zIndex: 4,
            src: Utils.asset("images/settings/Loading.png")
          }
        },
        TimeOverlayItems: {
          x: 200,
          y: 275,
          w: 1720,
          h: 810,
          clipping: true,
          type: TimeOverlayItems,
          visible: false
        }
      };
    }
    async _firstEnable() {
      this.loadingAnimation = this.tag('Loader').animation({
        duration: 3,
        repeat: -1,
        stopMethod: 'immediate',
        stopDelay: 0.2,
        actions: [{
          p: 'rotation',
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
      this.loadingAnimation.start();
      this.tag('Loader').visible = true;
      this.appApi = new AppApi();
      this.resp = await this.appApi.fetchTimeZone();
      let data = [];
      this.zone = await this.appApi.getZone();
      try {
        console.log(this.resp, this.zone);
        delete this.resp.Etc;
        for (const i in this.resp) {
          if (typeof this.resp[i] === 'object') {
            data.push([i, this.resp[i], this.zone !== undefined ? this.zone.split('/')[0] === i : false]);
          }
        }
      } catch (error) {
        console.log('no api present', error);
      }
      console.log(data);
      if (data.length > 1) {
        this.tag('List').h = data.length * 90;
        this.tag('List').items = data.map((item, idx) => {
          return {
            ref: 'Time' + idx,
            w: 1620,
            h: 90,
            type: TimeZoneOverlayItem,
            item: item,
            zone: this.zone !== undefined ? this.zone.split('/')[1] : ''
          };
        });
      } else {
        this.tag('Error').alpha = 1;
      }
      this.loadingAnimation.stop();
      this.tag('Loader').visible = false;
      this._setState('List');
    }
    _unfocus() {
      if (this.loadingAnimation.isPlaying()) {
        this.loadingAnimation.stop();
        this.tag('Loader').visible = false;
      }
    }
    hide() {
      this.tag('TimeZoneOverlayScreenContents').visible = false;
    }
    show() {
      this.tag('TimeZoneOverlayScreenContents').visible = true;
    }
    $navigateAndRefreshItems(params) {
      this.tag("TimeOverlayItems").refreshList(params);
      this._setState('TimeOverlayItems');
    }
    static _states() {
      return [class TimeOverlayItems extends this {
        $enter() {
          this.hide();
          this.tag('TimeOverlayItems').visible = true;
        }
        $exit() {
          this.show();
          this.tag('TimeOverlayItems').visible = false;
          this._firstEnable(); // so that the list will be refreshed when exiting from child screen.
        }

        _getFocused() {
          return this.tag('TimeOverlayItems');
        }
        _handleEnter() {
          this._setState('List');
        }
        _handleBack() {
          this._setState('List');
        }
      }, class List extends this {
        $enter() {
          this.show();
        }
        _getFocused() {
          return this.tag('List').element;
        }
        _handleDown() {
          this.tag('List').setNext();
        }
        _handleUp() {
          this.tag('List').setPrevious();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Firmware screen.
   */

  class FirmwareScreen extends t.Component {
    static _template() {
      return {
        FirmwareContents: {
          x: 200,
          y: 270,
          State: {
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware State: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          Version: {
            Title: {
              x: 10,
              y: 90,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Firmware Versions: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedVersion: {
            Title: {
              x: 10,
              y: 135,
              mountY: 0.5,
              text: {
                text: Language$1.translate("Downloaded Firmware Version: "),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          DownloadedPercent: {
            Title: {
              x: 10,
              y: 180,
              mountY: 0.5,
              text: {
                text: "",
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 22
              }
            }
          },
          FirmwareUpdate: {
            RectangleDefault: {
              x: 110,
              y: 200,
              w: 300,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: CONFIG.theme.hex,
              Update: {
                x: 170,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Check for Update"),
                  fontFace: CONFIG.language.font,
                  fontSize: 24
                }
              }
            }
          }
        }
      };
    }
    _firstEnable() {
      let state = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      const config = {
        host: '127.0.0.1',
        port: 9998,
        default: 1
      };
      const thunder = thunderJS$1(config);
      thunder.Controller.activate({
        callsign: "org.rdk.System"
      }).then(res => {
        thunder.on(callsign, "onFirmwareUpdateStateChange", notification => {
          console.log("FirmwareOverlay: on Firmware update state changed notifcation = ".concat(JSON.stringify(notification)));
          if (state[notification.firmwareUpdateStateChange] == "Downloading") {
            this.downloadInterval = setInterval(() => {
              console.log("Downloading...");
              this.getDownloadPercent();
            }, 1000);
          } else if (state[notification.firmwareUpdateStateChange] != "Downloading" && this.downloadInterval) {
            clearInterval(this.downloadInterval);
            this.downloadInterval = null;
          }
        }, err => {
          console.error("FirmwareOverlay: error while fetching notification ie. ".concat(err));
        });
      }).catch(err => {
        console.error("FirmwareOverlay: error while activating the system plugin");
      });
    }
    _unfocus() {
      if (this.downloadInterval) {
        clearInterval(this.downloadInterval);
        this.downloadInterval = null;
      }
    }
    _focus() {
      this.downloadInterval = null;
      this._appApi = new AppApi();
      const downloadState = ['Uninitialized', 'Requesting', 'Downloading', 'Failed', 'DownLoad Complete', 'Validation Complete', 'Preparing to Reboot'];
      this._appApi.getFirmwareUpdateState().then(res => {
        console.log("FirmwareOverlay: getFirmwareUpdateState " + JSON.stringify(res));
        this.tag('State.Title').text.text = Language$1.translate("Firmware State: ") + downloadState[res.firmwareUpdateState];
      });
      this._appApi.getDownloadFirmwareInfo().then(res => {
        console.log("FirmwareOverlay: getDownloadFirmwareInfo " + JSON.stringify(res));
        this.tag('Version.Title').text.text = Language$1.translate("Firmware Versions: ") + res.currentFWVersion;
      });
      this._setState('FirmwareUpdate');
    }
    getDownloadPercent() {
      this._appApi.getFirmwareDownloadPercent().then(res => {
        console.log("FirmwareOverlay: getFirmwareDownloadPercent ".concat(JSON.stringify(res)));
        if (res.downloadPercent < 0) {
          this.tag('DownloadedPercent.Title').text.text = "";
        } else {
          this.tag('DownloadedPercent.Title').text.text = Language$1.translate("Download Progress: ") + res.downloadPercent + "%";
        }
      }).catch(err => {
        console.error(err);
      });
    }
    getDownloadFirmwareInfo() {
      this._appApi.updateFirmware().then(res => {
        this._appApi.getDownloadFirmwareInfo().then(result => {
          console.log("FirmwareOverlay: getDownloadFirmwareInfo : ".concat(JSON.stringify(result.downloadFWVersion)));
          this.tag('DownloadedVersion.Title').text.text = Language$1.translate('Downloaded Firmware Version: ') + "".concat(result.downloadFWVersion ? result.downloadFWVersion : 'NA');
        }).catch(err => {
          console.error(err);
        });
      }).catch(err => {
        console.error(err);
      });
    }
    static _states() {
      return [class FirmwareUpdate extends this {
        _handleEnter() {
          this.getDownloadFirmwareInfo();
          this.getDownloadPercent();
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const appApi$1 = new AppApi();
  /**
   * Class for Reboot Confirmation Component.
   */
  class RebootConfirmation extends t.Component {
    static _template() {
      return {
        RebootScreen: {
          x: 950,
          y: 270,
          Title: {
            x: 0,
            y: 0,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Reboot"),
              fontFace: CONFIG.language.font,
              fontSize: 40,
              textColor: CONFIG.theme.hex
            }
          },
          BorderTop: {
            x: 0,
            y: 75,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Info: {
            x: 0,
            y: 125,
            mountX: 0.5,
            text: {
              text: Language$1.translate("Click Confirm to reboot!"),
              fontFace: CONFIG.language.font,
              fontSize: 25
            }
          },
          Buttons: {
            x: 100,
            y: 200,
            w: 440,
            mountX: 0.5,
            h: 50,
            Confirm: {
              x: 0,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xffffffff,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Confirm"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xff000000
                }
              }
            },
            Cancel: {
              x: 220,
              w: 200,
              mountX: 0.5,
              h: 50,
              rect: true,
              color: 0xff7d7d7d,
              Title: {
                x: 100,
                y: 25,
                mount: 0.5,
                text: {
                  text: Language$1.translate("Cancel"),
                  fontFace: CONFIG.language.font,
                  fontSize: 22,
                  textColor: 0xff000000
                }
              }
            }
          },
          BorderBottom: {
            x: 0,
            y: 300,
            w: 1558,
            h: 3,
            rect: true,
            mountX: 0.5
          },
          Loader: {
            x: 0,
            y: 150,
            mountX: 0.5,
            w: 90,
            h: 90,
            zIndex: 2,
            src: Utils.asset("images/settings/Loading.png"),
            visible: false
          }
        }
      };
    }
    _focus() {
      this._setState("Confirm");
      this.loadingAnimation = this.tag("Loader").animation({
        duration: 3,
        repeat: -1,
        stopMethod: "immediate",
        stopDelay: 0.2,
        actions: [{
          p: "rotation",
          v: {
            sm: 0,
            0: 0,
            1: 2 * Math.PI
          }
        }]
      });
    }
    static _states() {
      return [class Confirm extends this {
        $enter() {
          this._focus();
        }
        _handleEnter() {
          appApi$1.reboot().then(result => {
            console.log("device rebooting" + JSON.stringify(result));
            this._setState("Rebooting");
          });
        }
        _handleRight() {
          this._setState("Cancel");
        }
        _focus() {
          this.tag("Confirm").patch({
            color: CONFIG.theme.hex
          });
          this.tag("Confirm.Title").patch({
            text: {
              textColor: 0xffffffff
            }
          });
        }
        _unfocus() {
          this.tag("Confirm").patch({
            color: 0xffffffff
          });
          this.tag("Confirm.Title").patch({
            text: {
              textColor: 0xff000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Cancel extends this {
        //handleEnter is not required, default behaviour from parent is to exit this screen
        $enter() {
          this._focus();
        }
        _handleLeft() {
          this._setState("Confirm");
        }
        _focus() {
          this.tag("Cancel").patch({
            color: CONFIG.theme.hex
          });
          this.tag("Cancel.Title").patch({
            text: {
              textColor: 0xffffffff
            }
          });
        }
        _unfocus() {
          this.tag("Cancel").patch({
            color: 0xff7d7d7d
          });
          this.tag("Cancel.Title").patch({
            text: {
              textColor: 0xff000000
            }
          });
        }
        $exit() {
          this._unfocus();
        }
      }, class Rebooting extends this {
        $enter() {
          this.loadingAnimation.start();
          this.tag("Loader").visible = true;
          this.tag("Title").text.text = Language$1.translate("Rebooting") + "...";
          this.tag("Buttons").visible = false;
          this.tag("Info").visible = false;
        }
        _handleEnter() {
          // do nothing
        }
        _handleLeft() {
          // do nothing
        }
        _handleRight() {
          // do nothing
        }
        _handleBack() {
          // do nothing
        }
        _handleUp() {
          // do nothing
        }
        _handleDown() {
          // do nothing
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Video and Audio screen.
   */

  class DeviceScreen extends t.Component {
    static _template() {
      return {
        DeviceScreenContents: {
          x: 200,
          y: 275,
          Info: {
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Info'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          TimeZone: {
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Time Zone'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Firmware: {
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Check for Firmware Update'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Reboot: {
            y: 270,
            //  alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Reboot'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            }
          },
          Reset: {
            y: 360,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Factory Reset'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DeviceInformationScreen: {
          type: DeviceInformationScreen,
          visible: false
        },
        TimeZoneOverlay: {
          type: TimeZone,
          visible: false
        },
        FirmwareScreen: {
          type: FirmwareScreen,
          visible: false
        },
        RebootConfirmationScreen: {
          type: RebootConfirmation,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._network = new Network();
      this._setState('Info');
    }
    _focus() {
      this._setState('Info');
    }
    hide() {
      this.tag('DeviceScreenContents').visible = false;
    }
    show() {
      this.tag('DeviceScreenContents').visible = true;
    }
    static _states() {
      return [class Info extends this {
        $enter() {
          this.tag('Info')._focus();
        }
        $exit() {
          this.tag('Info')._unfocus();
        }
        _handleUp() {
          //  this._setState('Reboot');
        }
        _handleDown() {
          this._setState('TimeZone');
        }
        _handleEnter() {
          this._setState("DeviceInformationScreen");
        }
      }, class TimeZone extends this {
        $enter() {
          this.tag('TimeZone')._focus();
        }
        $exit() {
          this.tag('TimeZone')._unfocus();
        }
        _handleUp() {
          this._setState('Info');
        }
        _handleDown() {
          this._setState('Firmware');
        }
        _handleEnter() {
          this._setState("TimeZoneOverlay");
        }
      }, class Firmware extends this {
        $enter() {
          this.tag('Firmware')._focus();
        }
        $exit() {
          this.tag('Firmware')._unfocus();
        }
        _handleUp() {
          this._setState('TimeZone');
        }
        _handleDown() {
          this._setState('Reboot');
        }
        _handleEnter() {
          this._setState("FirmwareScreen");
        }
      }, class Reboot extends this {
        $enter() {
          this.tag('Reboot')._focus();
        }
        $exit() {
          this.tag('Reboot')._unfocus();
        }
        _handleUp() {
          this._setState('Firmware');
        }
        _handleDown() {
          //  this._setState('Reset')
        }
        _handleEnter() {
          this._setState("RebootConfirmation");
        }
      }, class Reset extends this {
        $enter() {
          this.tag('Reset')._focus();
        }
        $exit() {
          this.tag('Reset')._unfocus();
        }
        _handleUp() {
          //this._setState('Reboot');
        }
        _handleDown() {
          //this._setState('Info')
        }
        _handleEnter() {}
      }, class DeviceInformationScreen extends this {
        $enter() {
          this.hide();
          this.tag('DeviceInformationScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Info');
        }
        _getFocused() {
          return this.tag('DeviceInformationScreen');
        }
        $exit() {
          this.show();
          this.tag('DeviceInformationScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Device ');
        }
        _handleBack() {
          this._setState('Info');
        }
      },
      //TimeZoneOverlay
      class TimeZoneOverlay extends this {
        $enter() {
          this.hide();
          this.tag('TimeZoneOverlay').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Time');
        }
        _getFocused() {
          return this.tag('TimeZoneOverlay');
        }
        $exit() {
          this.show();
          this.tag('TimeZoneOverlay').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device ');
        }
        _handleBack() {
          this._setState('TimeZone');
        }
      }, class FirmwareScreen extends this {
        $enter() {
          this.hide();
          this.tag('FirmwareScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device  Firmware Update');
        }
        _getFocused() {
          return this.tag('FirmwareScreen');
        }
        $exit() {
          this.show();
          this.tag('FirmwareScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device ');
        }
        _handleBack() {
          this._setState('Firmware');
        }
      }, class RebootConfirmation extends this {
        $enter() {
          this.hide();
          this.tag("RebootConfirmationScreen").visible = true;
          this.fireAncestors('$hideBreadCrum');
        }
        _getFocused() {
          return this.tag("RebootConfirmationScreen");
        }
        $exit() {
          this.show();
          this.tag("RebootConfirmationScreen").visible = false;
          this.fireAncestors('$showBreadCrum');
        }
        _handleBack() {
          this._setState('Reboot');
        }
        _handleEnter() {
          //default behaviour, confirm will override this
          this._setState('Reboot');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/

  /**
  * Class for AdvancedSettings screen.
  */

  class AdvanceSettingsScreen extends t.Component {
    static _template() {
      return {
        AdvanceScreenContents: {
          x: 200,
          y: 275,
          TTSOptions: {
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('TTS Options'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          CECControl: {
            y: 90,
            // alpha: 0.3, // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('CEC Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 67,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/ToggleOffWhite.png')
            }
          },
          Bug: {
            y: 180,
            alpha: 0.3,
            // disabled
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Bug Report'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Contact: {
            alpha: 0.3,
            // disabled
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Contact Support'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Device: {
            y: 360,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Device'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        DeviceScreen: {
          type: DeviceScreen,
          visible: false
        }
      };
    }
    _init() {
      this.cecApi = new CECApi();
      this.cecApi.activate().then(() => {
        this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
        this.performOTPAction();
      });
      this._setState('CECControl');
    }
    _focus() {
      this._setState('CECControl');
    }
    performOTPAction() {
      this.cecApi.setEnabled().then(res => {
        if (res.success) {
          this.cecApi.performOTP().then(otpRes => {
            if (otpRes.success) {
              console.log('Otp Action success full');
            }
          });
        }
      });
    }
    toggleCEC() {
      this.cecApi.getEnabled().then(res => {
        console.log(res);
        if (res.enabled) {
          this.cecApi.deactivate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOffWhite.png');
          });
        } else {
          this.cecApi.activate().then(() => {
            this.tag('CECControl.Button').src = Utils.asset('images/settings/ToggleOnOrange.png');
          });
        }
      });
    }
    hide() {
      this.tag('AdvanceScreenContents').visible = false;
    }
    show() {
      this.tag('AdvanceScreenContents').visible = true;
    }
    static _states() {
      return [class UIVoice extends this {
        $enter() {
          this.tag('UIVoice')._focus();
        }
        $exit() {
          this.tag('UIVoice')._unfocus();
        }
        _handleUp() {
          //this._setState('Reset');
        }
        _handleDown() {
          //this._setState('TTSOptions')
        }
        _handleEnter() {}
      }, class TTSOptions extends this {
        $enter() {
          this.tag('TTSOptions')._focus();
        }
        $exit() {
          this.tag('TTSOptions')._unfocus();
        }
        _handleUp() {
          //this._setState('UIVoice');
        }
        _handleDown() {
          //this._setState('CECControl')
        }
        _handleEnter() {}
      }, class CECControl extends this {
        $enter() {
          this.tag('CECControl')._focus();
        }
        $exit() {
          this.tag('CECControl')._unfocus();
        }
        _handleUp() {
          //this._setState('TTSOptions');
        }
        _handleDown() {
          this._setState('Device');
        }
        _handleEnter() {
          this.toggleCEC();
        }
      }, class Bug extends this {
        $enter() {
          this.tag('Bug')._focus();
        }
        $exit() {
          this.tag('Bug')._unfocus();
        }
        _handleUp() {
          //this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('Contact')
        }
        _handleEnter() {}
      }, class Contact extends this {
        $enter() {
          this.tag('Contact')._focus();
        }
        $exit() {
          this.tag('Contact')._unfocus();
        }
        _handleUp() {
          //this._setState('Bug');
        }
        _handleDown() {
          //this._setState('Device')
        }
        _handleEnter() {}
      }, class Device extends this {
        $enter() {
          this.tag('Device')._focus();
        }
        $exit() {
          this.tag('Device')._unfocus();
        }
        _handleUp() {
          this._setState('CECControl');
        }
        _handleDown() {
          //this._setState('UI Voice')
        }
        _handleEnter() {
          this._setState("DeviceScreen");
        }
      }, class DeviceScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('DeviceScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings  Device');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('DeviceScreen');
        }
        $exit() {
          this.show();
          this.tag('DeviceScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings ');
        }
        _handleBack() {
          this._setState('Device');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  /**
   * Class for Other Settings Screen.
   */

  class OtherSettingsScreen extends t.Component {
    static _template() {
      return {
        OtherSettingsScreenContents: {
          x: 200,
          y: 275,
          SleepTimer: {
            y: 0,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Sleep Timer: Off'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          RemoteControl: {
            alpha: 0.3,
            // disabled
            y: 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Remote Control'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          ScreenSaver: {
            alpha: 0.3,
            // disabled
            y: 180,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Screen-Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          EnergySaver: {
            y: 270,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Energy Saver: '),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Language: {
            alpha: 0.3,
            // disabled
            y: 450 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Language'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          Privacy: {
            //alpha: 0.3, // disabled
            y: 540 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Privacy'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          },
          AdvancedSettings: {
            y: 630 - 90,
            type: SettingsMainItem,
            Title: {
              x: 10,
              y: 45,
              mountY: 0.5,
              text: {
                text: Language$1.translate('Advanced Settings'),
                textColor: COLORS.titleColor,
                fontFace: CONFIG.language.font,
                fontSize: 25
              }
            },
            Button: {
              h: 45,
              w: 45,
              x: 1600,
              mountX: 1,
              y: 45,
              mountY: 0.5,
              src: Utils.asset('images/settings/Arrow.png')
            }
          }
        },
        SleepTimerScreen: {
          type: SleepTimerScreen,
          visible: false
        },
        EnergySavingsScreen: {
          type: EnergySavingsScreen,
          visible: false
        },
        LanguageScreen: {
          type: LanguageScreen,
          visible: false
        },
        PrivacyScreen: {
          type: PrivacyScreen,
          visible: false
        },
        AdvanceSettingsScreen: {
          type: AdvanceSettingsScreen,
          visible: false
        }
      };
    }
    _init() {
      this._appApi = new AppApi();
      this._setState('SleepTimer');
    }
    $updateStandbyMode(standbyMode) {
      this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + standbyMode;
    }
    $sleepTimerText(text) {
      this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + text;
    }
    _focus() {
      this._setState('SleepTimer');
      if (Storage$1.get('TimeoutInterval')) {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + Storage$1.get('TimeoutInterval');
      } else {
        this.tag('SleepTimer.Title').text.text = Language$1.translate('Sleep Timer: ') + 'Off';
      }
      this._appApi.getPreferredStandbyMode().then(result => {
        let currentStandbyMode = "";
        if (result.preferredStandbyMode == "LIGHT_SLEEP") {
          currentStandbyMode = "Light Sleep";
        } else if (result.preferredStandbyMode == "DEEP_SLEEP") {
          currentStandbyMode = "Deep Sleep";
        }
        this.tag("EnergySaver.Title").text.text = Language$1.translate("Energy Saver: ") + currentStandbyMode;
      });
      if (Storage$1.get('ScreenSaverTimeoutInterval')) {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + Storage$1.get('ScreenSaverTimeoutInterval') + ' min';
      } else {
        this.tag('ScreenSaver.Title').text.text = Language$1.translate('Screen-Saver: ') + 'Off';
      }
    }
    hide() {
      this.tag('OtherSettingsScreenContents').visible = false;
    }
    show() {
      this.tag('OtherSettingsScreenContents').visible = true;
    }
    static _states() {
      return [class SleepTimer extends this {
        $enter() {
          this.tag('SleepTimer')._focus();
        }
        $exit() {
          this.tag('SleepTimer')._unfocus();
        }
        _handleUp() {
          //  this._setState('AdvancedSettings')
        }
        _handleDown() {
          // this._setState('RemoteControl')
          this._setState('EnergySaver');
        }
        _handleEnter() {
          this._setState("SleepTimerScreen");
        }
      }, class RemoteControl extends this {
        $enter() {
          this.tag('RemoteControl')._focus();
        }
        $exit() {
          this.tag('RemoteControl')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('ScreenSaver');
        }
        _handleEnter() {}
      }, class ScreenSaver extends this {
        $enter() {
          this.tag('ScreenSaver')._focus();
        }
        $exit() {
          this.tag('ScreenSaver')._unfocus();
        }
        _handleUp() {
          this._setState('RemoteControl');
        }
        _handleDown() {
          this._setState('EnergySaver');
        }
        _handleEnter() {
          //
        }
      }, class EnergySaver extends this {
        $enter() {
          this.tag('EnergySaver')._focus();
        }
        $exit() {
          this.tag('EnergySaver')._unfocus();
        }
        _handleUp() {
          this._setState('SleepTimer');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          this._setState("EnergySavingsScreen");
        }
      }, class Language extends this {
        $enter() {
          this.tag('Language')._focus();
        }
        $exit() {
          this.tag('Language')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('Privacy');
        }
        _handleEnter() {
          // this._setState("LanguageScreen")
        }
      }, class Privacy extends this {
        $enter() {
          this.tag('Privacy')._focus();
        }
        $exit() {
          this.tag('Privacy')._unfocus();
        }
        _handleUp() {
          this._setState('EnergySaver');
        }
        _handleDown() {
          this._setState('AdvancedSettings');
        }
        _handleEnter() {
          this._setState("PrivacyScreen");
        }
      }, class AdvancedSettings extends this {
        $enter() {
          this.tag('AdvancedSettings')._focus();
        }
        $exit() {
          this.tag('AdvancedSettings')._unfocus();
        }
        _handleUp() {
          this._setState('Privacy');
        }
        _handleDown() {
          //  this._setState('SleepTimer')
        }
        _handleEnter() {
          this._setState("AdvanceSettingsScreen");
        }
      }, class SleepTimerScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('SleepTimerScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Sleep Timer');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('SleepTimerScreen');
        }
        $exit() {
          this.show();
          this.tag('SleepTimerScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('SleepTimer');
        }
      }, class EnergySavingsScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('EnergySavingsScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Energy Saver');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('EnergySavingsScreen');
        }
        $exit() {
          this.show();
          this.tag('EnergySavingsScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('EnergySaver');
        }
      },
      //LanguageScreen
      class LanguageScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('LanguageScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Language');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('LanguageScreen');
        }
        $exit() {
          this.show();
          this.tag('LanguageScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('Language');
        }
      },
      //PrivacyScreen
      class PrivacyScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('PrivacyScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Privacy');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('PrivacyScreen');
        }
        $exit() {
          this.show();
          this.tag('PrivacyScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('Privacy');
        }
      }, class AdvanceSettingsScreen extends this {
        $enter() {
          ////console.log("bpscreen")
          this.hide();
          this.tag('AdvanceSettingsScreen').visible = true;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings  Advanced Settings');
        }
        _getFocused() {
          //console.log("getfocusedbp")
          return this.tag('AdvanceSettingsScreen');
        }
        $exit() {
          this.show();
          this.tag('AdvanceSettingsScreen').visible = false;
          this.fireAncestors("$updatePageTitle", 'Settings  Other Settings');
        }
        _handleBack() {
          this._setState('AdvancedSettings');
        }
      }];
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$3 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var thunder$3 = thunderJS$1(config$3);
  /**
   * Class for settings screen.
   */
  class SettingsOverlay extends t.Component {
    static _template() {
      return {
        Wrapper: {
          rect: true,
          color: 0xcc000000,
          w: 1920,
          h: 1080,
          visible: false,
          BreadCrumbs: {
            x: 200,
            y: 184,
            text: {
              fontSize: 40,
              text: Language$1.translate("settings"),
              textColor: CONFIG.theme.hex,
              fontStyle: "bolder",
              fontFace: CONFIG.language.font,
              wordWrapWidth: 1720,
              maxLines: 1
            }
          },
          SettingsScreenContents: {
            x: 200,
            y: 275,
            NetworkConfiguration: {
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Network Configuration"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Bluetooth: {
              y: 90,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Pair Remote Control"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Video: {
              y: 180,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Video"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            Audio: {
              y: 270,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Audio"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            OtherSettings: {
              y: 360,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Other Settings"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            },
            NFRStatus: {
              y: 450,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate('Native Frame Rate'),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 67,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset('images/settings/ToggleOffWhite.png')
              }
            },
            DTVSettings: {
              alpha: 0.3,
              y: 540,
              type: SettingsMainItem,
              Title: {
                x: 10,
                y: 45,
                mountY: 0.5,
                text: {
                  text: Language$1.translate("Live TV"),
                  textColor: COLORS.titleColor,
                  fontFace: CONFIG.language.font,
                  fontSize: 25
                }
              },
              Button: {
                h: 45,
                w: 45,
                x: 1600,
                mountX: 1,
                y: 45,
                mountY: 0.5,
                src: Utils.asset("images/settings/Arrow.png")
              }
            }
          },
          AudioScreenOverlay: {
            type: AudioScreen,
            visible: false
          },
          NetworkConfigurationOverlay: {
            type: NetworkConfigurationScreen,
            visible: false
          },
          BluetoothScreenOverlay: {
            type: BluetoothScreen,
            visible: false
          },
          LiveTvSettings: {
            type: LiveTVSettings,
            visible: false
          },
          VideoScreenOverlay: {
            type: VideoScreen,
            visible: false
          },
          OtherSettingsScreen: {
            type: OtherSettingsScreen,
            visible: false
          }
        }
      };
    }
    _focus() {
      this.tag("Wrapper").visible = true;
      this._setState("NetworkConfiguration");
      this.$updatePageTitle("settings"); //use this method as fireancestor from child components to change the page title
    }

    _unfocus() {
      this.tag("Wrapper").visible = false;
    }
    _firstActive() {
      if (Storage$1.get("NFRStatus")) {
        console.log("Netflix : NFRStatus is found to be enabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
      } else {
        console.log("Netflix : NFRStatus is found to be disabled");
        this.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
      }
      this.appApi = new AppApi();
      this.dtvApi = new DTVApi();
      this.dtvPlugin = false; //plugin availability
      if (Storage$1.get("deviceType") != "IpStb") {
        this.dtvApi.activate().then(res => {
          this.dtvPlugin = true;
          this.tag("DTVSettings").alpha = 1;
        });
      }
    }
    _handleBack() {
      console.log("application Type = ", Storage$1.get("applicationType"));
      if (Storage$1.get("applicationType") === "") {
        if (Router.getActiveHash() === "player" || Router.getActiveHash() === "dtvplayer" || Router.getActiveHash() === "usb/player") {
          Router.focusPage();
        } else {
          Router.focusPage();
          Router.navigate("menu");
        }
      } else {
        Router.focusPage();
        this.appApi.visible("ResidentApp", false);
        this.appApi.setFocus(Storage$1.get("applicationType"));
      }
    }
    _handleLeft() {
      //do nothing
    }
    _handleRight() {
      //do nothing
    }
    _handleUp() {
      //do nothing
    }
    _handleDown() {
      //do nothing
    }
    $updatePageTitle(title, alreadyTranslated) {
      console.log("title", title);
      if (alreadyTranslated) {
        this.tag("BreadCrumbs").text.text = title;
      } else {
        this.tag("BreadCrumbs").text.text = Language$1.translate(title);
      }
    }
    hide() {
      this.tag('SettingsScreenContents').visible = false;
    }
    show() {
      this.tag('SettingsScreenContents').visible = true;
    }
    $hideBreadCrum() {
      this.tag("BreadCrumbs").visible = false;
    }
    $showBreadCrum() {
      this.tag("BreadCrumbs").visible = true;
    }
    static _states() {
      return [class NetworkConfiguration extends this {
        $enter() {
          this.tag("NetworkConfiguration")._focus();
        }
        $exit() {
          this.tag("NetworkConfiguration")._unfocus();
        }
        _handleDown() {
          this._setState("Bluetooth");
        }
        _handleEnter() {
          this._setState('NetworkConfigurationOverlay');
        }
      }, class Bluetooth extends this {
        $enter() {
          this.tag("Bluetooth")._focus();
        }
        $exit() {
          this.tag("Bluetooth")._unfocus();
        }
        _handleUp() {
          this._setState("NetworkConfiguration");
        }
        _handleDown() {
          this._setState("Video");
        }
        _handleLeft() {}
        _handleEnter() {
          this._setState("BluetoothScreenOverlay");
        }
      }, class Video extends this {
        $enter() {
          this.tag("Video")._focus();
        }
        $exit() {
          this.tag("Video")._unfocus();
        }
        _handleUp() {
          this._setState("Bluetooth");
        }
        _handleDown() {
          this._setState("Audio");
        }
        _handleEnter() {
          this._setState('VideoScreenOverlay');
        }
      }, class Audio extends this {
        $enter() {
          this.tag("Audio")._focus();
        }
        $exit() {
          this.tag("Audio")._unfocus();
        }
        _handleUp() {
          this._setState("Video");
        }
        _handleEnter() {
          this._setState('AudioScreenOverlay');
        }
        _handleDown() {
          this._setState("OtherSettings");
        }
      }, class OtherSettings extends this {
        $enter() {
          this.tag("OtherSettings")._focus();
        }
        $exit() {
          this.tag("OtherSettings")._unfocus();
        }
        _handleUp() {
          this._setState("Audio");
        }
        _handleEnter() {
          this._setState("OtherSettingsScreen");
        }
        _handleDown() {
          this._setState("NFRStatus");
        }
      }, class NFRStatus extends this {
        $enter() {
          this.tag('NFRStatus')._focus();
        }
        $exit() {
          this.tag('NFRStatus')._unfocus();
        }
        _handleUp() {
          this._setState('OtherSettings');
        }
        _handleDown() {
          if (this.dtvPlugin) {
            this._setState('DTVSettings');
          }
        }
        _handleEnter() {
          //handle Switch
          let self = this;
          if (Storage$1.get("NFRStatus")) {
            thunder$3.call("Netflix.1", "nfrstatus", {
              "params": "disable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOffWhite.png";
              Storage$1.set("NFRStatus", false);
              console.log("Netflix : nfr disable updation results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus");
              console.error(nerr);
            });
          } else {
            thunder$3.call("Netflix.1", "nfrstatus", {
              "params": "enable"
            }).then(nr => {
              self.tag("NFRStatus.Button").src = "static/images/settings/ToggleOnOrange.png";
              Storage$1.set("NFRStatus", true);
              console.log("Netflix : nfr enable results in ".concat(nr));
            }).catch(nerr => {
              console.error("Netflix : error while updating nfrstatus ");
              console.error(nerr);
            });
          }
        }
      }, class DTVSettings extends this {
        $enter() {
          this.tag("DTVSettings")._focus();
        }
        $exit() {
          this.tag("DTVSettings")._unfocus();
        }
        _handleUp() {
          this._setState('NFRStatus');
        }
        _handleEnter() {
          if (this.dtvPlugin) {
            this._setState("LiveTvSettings");
          }
          dtvApi.activate().then(res => {
            this.tag('DTVSettings.Title').text.text = 'DTV Settings: Activtion' + res;
          });
        }
      }, class AudioScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('AudioScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Audio');
        }
        _getFocused() {
          return this.tag('AudioScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('AudioScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState("Audio");
        }
      }, class VideoScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('VideoScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Video');
        }
        _getFocused() {
          return this.tag('VideoScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('VideoScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('Video');
        }
      }, class NetworkConfigurationOverlay extends this {
        $enter() {
          this.hide();
          this.tag('NetworkConfigurationOverlay').visible = true;
          this.$updatePageTitle("Settings  Network Configuration");
        }
        _getFocused() {
          return this.tag('NetworkConfigurationOverlay');
        }
        $exit() {
          this.show();
          this.tag('NetworkConfigurationOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState("NetworkConfiguration");
        }
      }, class BluetoothScreenOverlay extends this {
        $enter() {
          this.hide();
          this.tag('BluetoothScreenOverlay').visible = true;
          this.$updatePageTitle('Settings  Bluetooth On/Off');
        }
        _getFocused() {
          return this.tag('BluetoothScreenOverlay');
        }
        $exit() {
          this.show();
          this.tag('BluetoothScreenOverlay').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('Bluetooth');
        }
      }, class OtherSettingsScreen extends this {
        $enter() {
          this.hide();
          this.tag('OtherSettingsScreen').visible = true;
          this.$updatePageTitle('Settings  Other Settings');
        }
        _getFocused() {
          return this.tag('OtherSettingsScreen');
        }
        $exit() {
          this.show();
          this.tag('OtherSettingsScreen').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('OtherSettings');
        }
      }, class LiveTvSettings extends this {
        $enter() {
          this.hide();
          this.tag('LiveTvSettings').visible = true;
          this.$updatePageTitle("Settings / Live TV");
        }
        _getFocused() {
          return this.tag('LiveTvSettings');
        }
        $exit() {
          this.show();
          this.tag('LiveTvSettings').visible = false;
          this.$updatePageTitle('Settings');
        }
        _handleBack() {
          this._setState('DTVSettings');
        }
      }];
    }
  }

  class AppCarousel extends t.Component {
    static _template() {
      return {
        rect: true,
        y: -340,
        w: 1920,
        h: 340,
        clipping: true,
        colorTop: 0xAA000000,
        colorBottom: 0xDD000000,
        AppList: {
          y: 24,
          x: 0,
          type: List,
          h: 400,
          scroll: {
            after: 2
          },
          spacing: 20
        }
      };
    }
    set appItems(items) {
      // items.shift();
      this.currentItems = items;
      this.tag('AppList').clear();
      this.tag('AppList').add(items.map((info, idx) => {
        return {
          w: 454,
          h: 220,
          type: ListItem,
          data: info,
          focus: 1.11,
          unfocus: 1,
          idx: idx,
          bar: 12
        };
      }));
    }
    _init() {
      this.homeApi = new HomeApi();
      this.appApi = new AppApi();
      this.metroApps = [];
      this.premiumApps = [];
      this.showcaseApps = [];
    }
    _focus() {
      let self = this;
      console.log("self.homeApi.getAppListInfo()", self.homeApi.getAppListInfo());
      self.appApi.isConnectedToInternet().then(result => {
        if (result) {
          self.metroApps = self.homeApi.getOnlineMetroApps();
          self.premiumApps = self.homeApi.getAppListInfo();
          self.showcaseApps = self.homeApi.getShowCaseApps();
        } else {
          self.metroApps = self.homeApi.getOfflineMetroApps();
          self.premiumApps = self.homeApi.getAppListInfo();
          self.showcaseApps = self.homeApi.getShowCaseApps();
        }
      }).catch(err => {
        console.log(err);
        self.metroApps = self.homeApi.getOfflineMetroApps();
        self.premiumApps = self.homeApi.getAppListInfo();
        self.showcaseApps = self.homeApi.getShowCaseApps();
      }).then(async () => {
        let order = Storage$1.get("appCarouselOrder");
        console.log("order", order);
        let apps = [];
        if (order) {
          let storedApps = order.split(",");
          storedApps.map(appIdentifier => {
            let index;
            if (appIdentifier.startsWith("s")) {
              // showcase apps
              index = appIdentifier.split(":")[1];
              apps.push(self.showcaseApps[index]);
              self.showcaseApps[index] = -1;
            } else if (appIdentifier.startsWith("n")) {
              // native apps
              index = appIdentifier.split(":")[1];
              apps.push(self.premiumApps[index]);
              self.premiumApps[index] = -1;
            } else if (appIdentifier.startsWith("m")) {
              // metro apps
              index = appIdentifier.split(":")[1];
              apps.push(self.metroApps[index]);
              self.metroApps[index] = -1;
            }
          });
          console.log("APPS ARRAY: ", apps);
          self.premiumApps.map(papp => {
            if (papp !== -1 && papp.uri != "USB") {
              apps.push(papp);
            }
          });
          self.metroApps.map(mapp => {
            if (mapp !== -1) {
              apps.push(mapp);
            }
          });
          self.showcaseApps.map(sapp => {
            if (sapp !== -1) {
              apps.push(sapp);
            }
          });
        } else {
          self.premiumApps = self.premiumApps.filter(e => {
            if (e.uri == "USB") {
              return 0;
            } else {
              return e;
            }
          });
          apps = [...self.premiumApps, ...self.showcaseApps, ...self.metroApps];
        }
        await this.homeApi.checkAppCompatability(apps).then(res => {
          apps = res;
        });
        this.appItems = apps;
        self._setState("AppList.0");
        this.patch({
          smooth: {
            y: 0
          }
        });
      });
    }
    close() {
      this.patch({
        smooth: {
          y: -340
        }
      });
    }
    _unfocus() {
      console.log("unfocus");
      this.close();
    }
    _handleBack() {
      let self = this;
      if (Storage$1.get("applicationType") !== "") {
        // if a non-resident app is on focus    
        let currentApp = Storage$1.get("applicationType");
        self.appApi.zorder(currentApp);
        self.appApi.setFocus(currentApp);
        self.appApi.setVisibility(currentApp, true);
      }
      Router.focusPage();
    }
    static _states() {
      return [class AppList extends this {
        $enter() {
          this.indexVal = 0;
        }
        _getFocused() {
          if (this.tag('AppList').length) {
            return this.tag('AppList');
          }
        }
        _handleLeft() {
          console.log("H left");
        }
        async _handleEnter() {
          let applicationType = this.tag('AppList').items[this.tag('AppList').index].data.applicationType;
          let uri = this.tag('AppList').items[this.tag('AppList').index].data.uri;
          let appIdentifier = this.tag('AppList').items[this.tag('AppList').index].data.appIdentifier;
          let params = {
            url: uri,
            launchLocation: "mainView",
            appIdentifier: appIdentifier
          };
          this.appApi.launchApp(applicationType, params).then(res => {
            Router.focusPage();
          }).catch(err => {
            console.log("ApplaunchError: ", err);
          });
        }
      }];
    }
  }

  class Splash extends t.Component {
    static _template() {
      return {};
    }
    _active() {
      console.log("Activevideo");
      VideoPlayer.playPause();
      VideoPlayer.open(Utils.asset("images/Screensaver.mp4"));
      VideoPlayer.loop();
    }
    _inactive() {
      VideoPlayer.close();
    }
    _init() {
      VideoPlayer.playPause();
      VideoPlayer.consumer(this);
      VideoPlayer.size(1920, 1080);
      VideoPlayer.position(0, 0);
      //VideoPlayer.mute();
    }
  }

  class VideoInfoChange extends t.Component {
    static _template() {
      return {
        w: 1920,
        h: 340,
        y: -340,
        Background: {
          rect: true,
          y: 0,
          //-340,
          w: 1920,
          h: 340,
          clipping: true,
          colorTop: 0xAA000000,
          colorBottom: 0xDD000000
        },
        Title: {
          zIndex: 1,
          x: w => w / 2,
          y: h => h / 2,
          mountY: 0.5,
          mountX: 0.5,
          text: {
            text: "ZZZZ",
            //Language.translate('New Video Format : '),
            textColor: COLORS.titleColor,
            fontFace: CONFIG.language.font,
            fontSize: 25
          }
        }
      };
    }
    clear() {
      this.patch({
        smooth: {
          y: -340
        }
      });
      this.tag("Title").text.text = "YYYY";
      Router.focusPage();
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
    update(data) {
      let append = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (append) {
        let txt = this.tag("Title").text.text;
        txt += "\n" + data;
        this.tag("Title").text.text = txt;
        console.log("write request recieved with data ", data);
        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          Router.focusPage();
          self.clear();
        }, 3000);
      } else {
        console.log("update request recieved with the data ", data);
        this.tag("Title").text.text = data;
      }
    }
    _focus() {
      this.patch({
        smooth: {
          y: 0
        }
      });
      let self = this;
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        Router.focusPage();
        self.clear();
      }, 3000);
    }
    _handleKey() {
      clearTimeout(this.timer);
      this.timer = null;
      this.clear();
      console.log("Widget handle kEy Trigger");
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$2 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  let thunder$2 = thunderJS$1(config$2);
  class PinChallengeProvider {
    challenge(challenge, session) {
      if (!challenge) return;
      console.log('Got challenge ' + JSON.stringify(challenge), "challenge");
      return new Promise((resolve, reject) => {
        this.showChallengeUi(challenge, resolve);
        session.focus();
      });
    }
    showChallengeUi(challenge, responder) {
      console.log("Displaying showChallengeUi with: " + Storage$1.get("selfClientName"));
      new Promise(async (resolve, reject) => {
        let message = challenge.requestor.name + ' is requesting that you enter your ' + challenge.pinSpace + ' pin.';
        let params = {
          message: message,
          challenge: challenge,
          responder
        };
        thunder$2.call('org.rdk.RDKShell', 'setVisibility', {
          client: Storage$1.get("selfClientName"),
          visible: true
        }).then(() => {
          Router.navigate('settings/other/SecurityPinScreen', params);
        });
        resolve(true);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  class AckChallengeProvider {
    challenge(challenge, session) {
      if (!challenge) return;
      console.log("Got challenge req:" + JSON.stringify(challenge) + "challenge");
      return new Promise((resolve, reject) => {
        this.showChallengeUi(challenge, resolve);
        session.focus();
      });
    }
    showChallengeUi(challenge, responder) {
      new Promise(async (resolve, reject) => {
        let message = 'Do you give access to ' + challenge.requestor.name + ' to ' + challenge.capability + '?';
        let params = {
          message: message,
          responder
        };
        Router.navigate('settings/other/AcknowledgeScreen', params);
        resolve(true);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config$1 = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  let thunder$1 = thunderJS$1(config$1);
  class KeyboardUIProvider {
    constructor(app) {
      this._app = app;
      this.INFO = function () {};
      this.LOG = console.log;
      this.ERR = console.error;
    }
    standard(keyboardSession, providerSession) {
      this.LOG("Inside standard call");
      if (!keyboardSession) return;
      return new Promise((resolve, reject) => {
        this.showKeyboardUi(keyboardSession, false, resolve);
        providerSession.focus();
      });
    }
    email(keyboardSession, providerSession) {
      this.LOG("Inside email call");
      if (!keyboardSession) return;
      return new Promise((resolve, reject) => {
        this.showKeyboardUi(keyboardSession, false, resolve);
        providerSession.focus();
      });
    }
    password(keyboardSession, providerSession) {
      this.LOG("Inside password call");
      if (!keyboardSession) return;
      return new Promise((resolve, reject) => {
        this.showKeyboardUi(keyboardSession, true, resolve);
        providerSession.focus();
      });
    }
    async showKeyboardUi(session, mask, responder) {
      if (!session) return;
      this.LOG('Got session ' + JSON.stringify(session), "showKeyboardUi");
      this.LOG("Displaying Keyboard overlay with: " + Storage$1.get("selfClientName"));
      let params = {
        message: session.message,
        type: session.type,
        responder
      };
      thunder$1.call('org.rdk.RDKShell', 'setVisibility', {
        client: Storage$1.get("selfClientName"),
        visible: true
      }).then(() => {
        Router.navigate("settings/other/KeyboardScreen", params);
      });
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  const config = {
    host: '127.0.0.1',
    port: 9998,
    default: 1
  };
  var powerState = 'ON';
  var AlexaAudioplayerActive = false;
  var thunder = thunderJS$1(config);
  var appApi = new AppApi();
  var dtvApi$1 = new DTVApi();
  new HDMIApi();
  var cecApi = new CECApi();
  var xcastApi = new XcastApi();
  var voiceApi = new VoiceApi();
  class App extends Router.App {
    static getFonts() {
      return [{
        family: CONFIG.language.font,
        url: Utils.asset('fonts/' + CONFIG.language.fontSrc)
      }];
    }
    _setup() {
      Storage$1.set("selfClientName", "ResidentApp");
      console.log("accelerator-home-ui version: " + Settings$2.get("platform", "version"));
      if (window.__firebolt.endpoint !== undefined) {
        console.log("window.__firebolt.endpoint ", JSON.stringify(window.__firebolt.endpoint));
        Storage$1.set("selfClientName", "FireboltMainApp-refui");
      }
      console.log("selfClientName:", Storage$1.get("selfClientName"));
      Router.startRouter(routes, this);
      Storage$1.set("ResolutionChangeInProgress", false);
      document.onkeydown = e => {
        if (e.keyCode == keyMap.Backspace) {
          e.preventDefault();
        }
      };
      function updateAddress() {
        if (window.navigator.onLine) {
          console.log("is online");
        } else {
          Storage$1.set("ipAddress", null);
          console.log("is offline");
        }
      }
      window.addEventListener("offline", updateAddress);
    }
    static _template() {
      return {
        Pages: {
          // this hosts all the pages
          forceZIndexContext: true
        },
        Widgets: {
          VideoInfoChange: {
            type: VideoInfoChange
          },
          Menu: {
            type: Menu
          },
          Fail: {
            type: Failscreen
          },
          Volume: {
            type: Volume
          },
          TvOverlays: {
            type: TvOverlayScreen
          },
          ChannelOverlay: {
            type: ChannelOverlay
          },
          SettingsOverlay: {
            type: SettingsOverlay
          },
          AppCarousel: {
            type: AppCarousel
          }
        },
        VideoScreen: {
          alpha: 0,
          w: 2000,
          h: 1500,
          zIndex: 999,
          type: Splash
        },
        Failscreen1: {
          alpha: 0,
          type: Failscreen
        },
        AAMPVideoPlayer: {
          type: AAMPVideoPlayer
        },
        ScreenSaver: {
          alpha: 0,
          w: 2000,
          h: 1500,
          zIndex: 999,
          src: Utils.asset('images/tvShows/fantasy-island.jpg')
        }
      };
    }
    static language() {
      return {
        file: Utils.asset('language/language-file.json'),
        language: CONFIG.language.id
      };
    }
    $updateTimeZone(timezone) {
      this.tag('Menu').updateTimeZone(timezone);
    }
    _captureKey(key) {
      let self = this;
      console.log(key, key.keyCode);
      this.$hideImage(0);
      if (key.keyCode == keyMap.Home && !Router.isNavigating()) {
        if (Storage$1.get('applicationType').includes("dac.native")) {
          this.jumpToRoute("apps");
        } else {
          this.jumpToRoute("menu"); //method to exit the current app(if any) and route to home screen
        }

        return true;
      } else if (key.keyCode == keyMap.Inputs_Shortcut && !Router.isNavigating()) {
        //for inputs overlay
        if (Storage$1.get("applicationType") !== "") {
          if (Router.getActiveHash() === "tv-overlay/inputs") {
            Router.reload();
          } else {
            Router.navigate("tv-overlay/inputs", false);
          }
          // appApi.setVisibility('ResidentApp', true);
          thunder.call('org.rdk.RDKShell', 'moveToFront', {
            client: Storage$1.get("selfClientName")
          }).then(result => {
            appApi.setVisibility(Storage$1.get("selfClientName"), true); //#requiredChange
            console.log('ResidentApp moveToFront Success');
            thunder.call("org.rdk.RDKShell", "setFocus", {
              client: Storage$1.get("selfClientName")
            }).then(result => {
              console.log("residentApp setFocus Success");
            }).catch(err => {
              console.log("Error", err);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            Router.focusWidget('TvOverlays');
            Router.getActiveWidget()._setState("OverlayInputScreen");
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Picture_Setting_Shortcut && !Router.isNavigating()) {
        //for video settings overlay
        if (Storage$1.get("applicationType") !== "") {
          if (Router.getActiveHash() === "tv-overlay/settings") {
            Router.reload();
          } else {
            Router.navigate("tv-overlay/settings", false);
          }
          // appApi.setVisibility('ResidentApp', true);
          thunder.call('org.rdk.RDKShell', 'moveToFront', {
            client: Storage$1.get("selfClientName")
          }).then(result => {
            appApi.setVisibility(Storage$1.get("selfClientName"), true); //#requiredChange
            console.log('ResidentApp moveToFront Success');
            thunder.call("org.rdk.RDKShell", "setFocus", {
              client: Storage$1.get("selfClientName")
            }).then(result => {
              console.log("Resident App setFocus Success");
            }).catch(err => {
              console.log("Error", err);
            });
          });
        } else {
          if (Router.getActiveHash() === "dtvplayer") {
            Router.focusWidget('TvOverlays');
            Router.getActiveWidget()._setState("OverlaySettingsScreen");
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Settings_Shortcut && !Router.isNavigating()) {
        console.log("settings shortcut");
        if (Storage$1.get("applicationType") === "") {
          //launch settings overlay/page depending on the current route.
          if (Router.getActiveHash() === "player" || Router.getActiveHash() === "dtvplayer" || Router.getActiveHash() === "usb/player") {
            //player supports settings overlay, so launch it as overlay
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "SettingsOverlay") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
            } else {
              //launch the settings overlay
              Router.focusWidget('SettingsOverlay');
            }
          } else {
            //navigate to settings page for all other routes
            Router.navigate("settings");
          }
        } else {
          //currently on some application
          if (Router.getActiveHash() === "applauncher") {
            //if route is applauncher just focus the overlay widget
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "SettingsOverlay") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
              let currentApp = Storage$1.get("applicationType");
              appApi.zorder(currentApp);
              appApi.setFocus(currentApp);
              appApi.setVisibility(currentApp, true);
            } else {
              //launch the settings overlay
              appApi.zorder("ResidentApp");
              appApi.setFocus("ResidentApp");
              appApi.setVisibility("ResidentApp", true);
              Router.focusWidget('SettingsOverlay');
            }
          } else {
            //if on some other route while on an application, route to applauncher before launching the settings overlay
            appApi.zorder("ResidentApp");
            appApi.setFocus("ResidentApp");
            appApi.setVisibility("ResidentApp", true);
            Router.navigate("applauncher");
            Router.focusWidget('SettingsOverlay');
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Guide_Shortcut && !Router.isNavigating()) {
        Router.navigate('epg');
        return true;
      } else if (key.keyCode == keyMap.Amazon && !Router.isNavigating()) {
        let params = {
          launchLocation: "dedicatedButton",
          appIdentifier: self.appIdentifiers["Amazon"]
        };
        appApi.launchApp("Amazon", params).catch(err => {
          console.error("Error in launching Amazon via dedicated key: " + JSON.stringify(err));
        });
        return true;
      } else if (key.keyCode == keyMap.Youtube && !Router.isNavigating()) {
        let params = {
          launchLocation: "dedicatedButton",
          appIdentifier: self.appIdentifiers["YouTube"]
        };
        appApi.launchApp("YouTube", params).catch(err => {
          console.error("Error in launching Youtube via dedicated key: " + JSON.stringify(err));
        });
        return true;
      } else if (key.keyCode == keyMap.Netflix && !Router.isNavigating()) {
        //launchLocation mapping is in launchApp method in AppApi.js
        let params = {
          launchLocation: "dedicatedButton",
          appIdentifier: self.appIdentifiers["Netflix"]
        };
        appApi.launchApp("Netflix", params).catch(err => {
          console.error("Error in launching Netflix via dedicated key: " + JSON.stringify(err));
        });
        return true;
      } else if (key.keyCode == keyMap.AppCarousel && !Router.isNavigating()) {
        if (Storage$1.get("applicationType") === "") {
          // if resident app is on focus
          if (Router.getActiveHash() === "menu") {
            return true;
          } else if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "AppCarousel") {
            //currently focused on appcarousel, so hide it
            Router.focusPage();
          } else {
            //launch the app carousel
            Router.focusWidget("AppCarousel");
          }
        } else {
          //currently on some application
          if (Router.getActiveHash() === "applauncher") {
            //if route is applauncher just focus the overlay widget
            if (Router.getActiveWidget() && Router.getActiveWidget().__ref === "AppCarousel") {
              //currently focused on settings overlay, so hide it
              Router.focusPage();
              let currentApp = Storage$1.get("applicationType");
              appApi.zorder(currentApp);
              appApi.setFocus(currentApp);
              appApi.setVisibility(currentApp, true);
            } else {
              //launch the settings overlay
              appApi.zorder("ResidentApp");
              appApi.setFocus("ResidentApp");
              appApi.setVisibility("ResidentApp", true);
              Router.focusWidget('AppCarousel');
            }
          } else {
            //if on some other route while on an application, route to applauncher before launching the settings overlay
            appApi.zorder("ResidentApp");
            appApi.setFocus("ResidentApp");
            appApi.setVisibility("ResidentApp", true);
            Router.navigate("applauncher");
            Router.focusWidget('AppCarousel');
          }
        }
        return true;
      } else if (key.keyCode == keyMap.Power) {
        // Remote power key and keyboard F1 key used for STANDBY and POWER_ON
        appApi.getPowerState().then(res => {
          console.log("getPowerState: ", res);
          if (res.success) {
            if (res.powerState === "ON") {
              console.log("current powerState is ON so setting power state to LIGHT_SLEEP/DEEP_SLEEP depending of preferred option");
              appApi.getPreferredStandbyMode().then(res => {
                console.log("getPreferredStandbyMode: ", res.preferredStandbyMode);
                appApi.setPowerState(res.preferredStandbyMode).then(result => {
                  if (result.success) {
                    console.log("successfully set powerstate to: " + res.preferredStandbyMode);
                  }
                });
              });
            } else {
              console.log("current powerState is " + res.powerState + " so setting power state to ON");
              appApi.setPowerState("ON").then(res => {
                if (res.success) {
                  console.log("successfully set powerstate to: ON");
                }
              });
            }
          }
        });
      } else if (key.keyCode == 228) {
        console.log("___________DEEP_SLEEP_______________________F12");
        appApi.setPowerState("DEEP_SLEEP").then(res => {
          powerState = 'DEEP_SLEEP';
        });
        return true;
      } else if (key.keyCode === keyMap.AudioVolumeMute && !Router.isNavigating()) {
        if (Storage$1.get('applicationType') === '') {
          this.tag("Volume").onVolumeMute();
        } else {
          console.log("muting on some app");
          if (Router.getActiveHash() === "applauncher") {
            console.log("muting on some app while route is app launcher");
            appApi.zorder("ResidentApp");
            appApi.visible("ResidentApp", true);
            this.tag("Volume").onVolumeMute();
          } else {
            console.log("muting on some app while route is NOT app launcher");
            appApi.zorder("ResidentApp");
            appApi.visible("ResidentApp", true);
            Router.navigate("applauncher");
            this.tag("Volume").onVolumeMute();
          }
        }
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeUp && !Router.isNavigating()) {
        if (Storage$1.get('applicationType') === '') {
          this.tag("Volume").onVolumeKeyUp();
        } else {
          console.log("muting on some app");
          if (Router.getActiveHash() === "applauncher") {
            console.log("muting on some app while route is app launcher");
            appApi.zorder("ResidentApp");
            appApi.visible("ResidentApp", true);
            this.tag("Volume").onVolumeKeyUp();
          } else {
            console.log("muting on some app while route is NOT app launcher");
            appApi.zorder("ResidentApp");
            appApi.visible("ResidentApp", true);
            Router.navigate("applauncher");
            this.tag("Volume").onVolumeKeyUp();
          }
        }
        return true;
      } else if (key.keyCode == keyMap.AudioVolumeDown && !Router.isNavigating()) {
        if (Storage$1.get('applicationType') === '') {
          this.tag("Volume").onVolumeKeyDown();
        } else {
          console.log("muting on some app");
          if (Router.getActiveHash() === "applauncher") {
            console.log("muting on some app while route is app launcher");
            appApi.zorder("ResidentApp");
            appApi.visible("ResidentApp", true);
            this.tag("Volume").onVolumeKeyDown();
          } else {
            console.log("muting on some app while route is NOT app launcher");
            appApi.zorder("ResidentApp");
            appApi.visible("ResidentApp", true);
            Router.navigate("applauncher");
            this.tag("Volume").onVolumeKeyDown();
          }
        }
        return true;
      }
      return false;
    }
    _moveToFront() {
      appApi.setVisibility(Storage$1.get("selfClientName"), true);
      appApi.zorder(Storage$1.get("selfClientName"));
    }
    AvDecodernotificationcall() {
      thunder.on('org.rdk.DeviceDiagnostics', 'onAVDecoderStatusChanged', notification => {
        console.log(new Date().toISOString() + "AvDecoderStatusNotification: ", JSON.stringify(notification));
      });
    }
    async userInactivity() {
      let persisteneTimerValue = await appApi.getTimerValue();
      console.log("persistenceTimer", persisteneTimerValue);
      if (persisteneTimerValue === "undefined" || persisteneTimerValue === undefined || persisteneTimerValue === "Off") {
        appApi.enabledisableinactivityReporting(false).then(resp => {
          this.userInactivity.dispose();
        });
      } else {
        console.log("came else block");
        this.setTimerValuethroughPersistence(parseInt(persisteneTimerValue));
      }
    }
    setTimerValuethroughPersistence(persisteneTimerValue) {
      appApi.enabledisableinactivityReporting(true).then(resp => {
        console.log("enable", resp);
        appApi.setInactivityInterval(persisteneTimerValue).then(resp => {
          this.userInactivity = thunder.on('org.rdk.RDKShell', 'onUserInactivity', notification => {
            console.log("UserInactivityStatusNotification: ", JSON.stringify(notification));
            appApi.getAvCodeStatus().then(result => {
              console.log("Avdecoder", result.avDecoderStatus);
              if ((result.avDecoderStatus === "IDLE" || result.avDecoderStatus === "PAUSE") && Storage$1.get("applicationType") === "") {
                this.$hideImage(1);
              }
            });
          });
        });
      });
    }
    $hideImage(alpha) {
      if (alpha === 1) {
        this.tag("Widgets").visible = false;
        this.tag("Pages").visible = false;
      } else {
        this.tag("Widgets").visible = true;
        this.tag("Pages").visible = true;
      }
      this.tag("VideoScreen").alpha = alpha;
      // this.tag("ScreenSaver").alpha = alpha;
    }

    _init() {
      let self = this;
      self.appIdentifiers = {
        "YouTubeKids": "n:5",
        "YouTubeTV": "n:4",
        "YouTube": "n:3",
        "Netflix": "n:1",
        "Amazon Prime": "n:2",
        "Amazon": "n:2",
        "Prime": "n:2"
      };
      if (!availableLanguages.includes(localStorage.getItem('Language'))) {
        localStorage.setItem('Language', 'English');
      }
      this.userInactivity();
      FireBoltApi.get().deviceinfo.gettype();
      FireBoltApi.get().lifecycle.ready();
      FireBoltApi.get().lifecycle.registerEvent('foreground', value => {
        console.log("FireBoltApi[foreground] value:" + JSON.stringify(value) + ", launchResidentApp with:" + JSON.stringify(Storage$1.get("selfClientName")));
        // Ripple launches refui with this rdkshell client name.
        appApi.launchResidentApp(Storage$1.get("selfClientName"));
      });
      FireBoltApi.get().lifecycle.state().then(res => {
        console.log("Lifecycle.state result:" + res);
      });
      Keyboard.provide('xrn:firebolt:capability:input:keyboard', new KeyboardUIProvider(this));
      console.log("Keyboard provider registered");
      PinChallenge.provide('xrn:firebolt:capability:usergrant:pinchallenge', new PinChallengeProvider(this));
      console.log("PinChallenge provider registered");
      AcknowledgeChallenge.provide('xrn:firebolt:capability:usergrant:acknowledgechallenge', new AckChallengeProvider(this));
      console.log("Acknowledge challenge provider registered");
      appApi.deviceType().then(result => {
        console.log("App detected deviceType as:", result.devicetype != null ? result.devicetype : "tv");
        Storage$1.set("deviceType", result.devicetype != null ? result.devicetype : "tv");
      });
      thunder.Controller.activate({
        callsign: 'org.rdk.UserPreferences'
      }).then(result => {
        console.log("App UserPreferences plugin activation result: " + result);
      }).catch(err => {
        reject(err);
      });
      thunder.Controller.activate({
        callsign: 'org.rdk.System'
      }).then(result => {
        console.log("App System plugin activation result: " + result);
        let rfc = "Device.DeviceInfo.X_RDKCENTRAL-COM_RFC.Feature.XDial.WolWakeEnable";
        let rfcList = {
          rfcList: [rfc]
        };
        appApi.getRFCConfig(rfcList).then(rfcStatus => {
          if (rfcStatus.hasOwnProperty("success") && rfcStatus.success) {
            if (rfcStatus.RFCConfig.hasOwnProperty(rfc) && rfcStatus.RFCConfig[rfc] === "true") {
              appApi.setNetworkStandbyMode().then(result => {
                if (!result.success) {
                  console.warn("App RFC setNetworkStandbyMode returned false; trying updated API.");
                  let param = {
                    wakeupSources: [{
                      "WAKEUPSRC_WIFI": true,
                      "WAKEUPSRC_IR": true,
                      "WAKEUPSRC_POWER_KEY": true,
                      "WAKEUPSRC_CEC": true,
                      "WAKEUPSRC_LAN": true
                    }]
                  };
                  appApi.setWakeupSrcConfiguration(param);
                }
              });
            } else {
              console.error("App RFC WolWakeEnable response:", JSON.stringify(rfcStatus));
              console.error("App RFC check of WolWakeEnable failed.");
            }
          }
        });
      }).catch(err => {
        reject(err);
      });
      appApi.getPluginStatus("org.rdk.DeviceDiagnostics").then(res => {
        console.log("App DeviceDiagnostics state:", res[0].state);
        if (res[0].state === "deactivated") {
          thunder.Controller.activate({
            callsign: 'org.rdk.DeviceDiagnostics'
          }).then(result => {
            this.AvDecodernotificationcall();
          }).catch(err => {
            reject(err);
          });
        } else {
          this.AvDecodernotificationcall();
        }
      });
      appApi.getHDCPStatus().then(result => {
        Storage$1.set("UICacheonDisplayConnectionChanged", result.isConnected);
      });
      if (Storage$1.get("applicationType") !== "HDMI") {
        //to default to hdmi, if previous input was hdmi
        Storage$1.set('applicationType', ''); //to set the application type to none
      }

      Storage$1.set("lastVisitedRoute", "menu"); //setting to menu so that it will be always defaulted to #menu
      appApi.enableDisplaySettings().then(res => {
        console.log("results : ".concat(JSON.stringify(res)));
      }).catch(err => {
        console.error("error while enabling displaysettings");
      });
      appApi.cobaltStateChangeEvent();
      this.xcastApi = new XcastApi();
      this.xcastApi.activate().then(result => {
        let serialNumber;
        try {
          appApi.getSerialNumber().then(res => {
            serialNumber = res;
            console.log("App getSerialNumber result:", serialNumber);
            appApi.getModelName().then(modelName => {
              let friendlyName = modelName + "_" + serialNumber;
              this.xcastApi.setFriendlyName(friendlyName).then(result => {
                console.log("App XCAST setFriendlyName result:", result);
              }).catch(error => {
                console.error("App Error setting friendlyName:", error);
              });
            }).catch(error => {
              console.error("App Error retrieving modelName:", error);
            });
          }).catch(error => {
            console.error("App Error getSerialNumber:", error);
          });
        } catch (error) {
          console.log(error);
        }
        if (result) {
          this.registerXcastListeners();
        }
      });
      keyIntercept(Storage$1.get("selfClientName"));
      thunder.on('Controller.1', 'all', noti => {
        console.log("App controller notification:", noti);
        if (noti.data.url && noti.data.url.slice(-5) === "#boot" || noti.data.httpstatus && noti.data.httpstatus != 200 && noti.data.httpstatus != -1) {
          // to exit metro apps by pressing back key & to auto exit webapp if httpstatus is not 200
          appApi.exitApp(Storage$1.get('applicationType'));
        }
        // TODO: make the check based on XcastApi.supportedApps() list
        if (noti.hasOwnProperty("callsign") && (noti.callsign.startsWith("YouYube") || noti.callsign.startsWith("Amazon") || noti.callsign.startsWith("Netflix"))) {
          let params = {
            applicationName: noti.callsign,
            state: 'stopped'
          };
          switch (noti.data.state) {
            case "activated":
            case "resumed":
              params.state = 'running';
              break;
            case "Activation":
            case "deactivated":
            case "Deactivation":
              params.state = 'stopped';
              break;
            case "suspended":
              params.state = 'suspended';
          }
          if (noti.callsign.startsWith("Amazon")) {
            params.applicationName = "AmazonInstantVideo";
          }
          console.log("App Controller state change to xcast: ", JSON.stringify(params));
          this.xcastApi.onApplicationStateChanged(params);
          params = null;
        }
      });
      appApi.getPluginStatus("Cobalt").then(res => {
        /* Loop through YouTube variants and set respective urls. */
        JSON.parse(JSON.stringify(appListInfo)).forEach(appInfo => {
          if (appInfo.hasOwnProperty("applicationType") && appInfo.applicationType.startsWith("YouTube") && appInfo.hasOwnProperty("uri") && appInfo.uri.length) {
            thunder.Controller.clone({
              callsign: "Cobalt",
              newcallsign: appInfo.applicationType
            }).then(result => {
              console.log("App Controller.clone Cobalt as " + appInfo.applicationType + " done.", result);
            }).catch(err => {
              console.error("App Controller clone Cobalt for " + appInfo.applicationType + " failed: ", err);
              // TODO: hide YouTube Icon and listing from Menu, AppCarousel, Channel overlay and EPG page.
            });

            appApi.getPluginStatus(appInfo.applicationType).then(res => {
              if (res[0].state !== "deactivated") {
                thunder.Controller.deactivate({
                  callsign: appInfo.applicationType
                }).catch(err => {
                  console.error("App Controller.deactivate " + appInfo.applicationType + " failed. It may not work.", err);
                  resolve(false);
                });
              }
              /* Do not change YouTube's configuration as Page-visibility test runs on that. */
              if (res[0].callsign !== "YouTube") {
                thunder.call('Controller', "configuration@".concat(appInfo.applicationType)).then(result => {
                  /* Ensure appending '?' so that later params can be directly appended. */
                  result.url = appInfo.uri + "?"; // Make sure that appListInfo.js has only base url.
                  thunder.call('Controller', "configuration@".concat(appInfo.applicationType), result).then(result => {
                    Storage$1.set(appInfo.applicationType + "DefaultURL", appInfo.uri + "?"); // Make sure that appListInfo.js has only base url.
                  }).catch(err => {
                    console.error("App Controller.configuration@" + appInfo.applicationType + " set failed. It may not work.", err);
                    resolve(false);
                  });
                }).catch(err => {
                  console.error("App Controller.configuration@" + appInfo.applicationType + " get failed. It may not work.", err);
                  resolve(false);
                });
              } else {
                /* Just store the plugin configured url as default url and ensure '?' is appended. */
                Storage$1.set(appInfo.applicationType + "DefaultURL", res[0].configuration.url.includes('?') ? res[0].configuration.url : res[0].configuration.url + "?");
              }
            }).catch(err => {
              console.error("App getPluginStatus " + appInfo.applicationType + " Error: " + err);
              resolve(false);
            });
          }
        });
      }).catch(err => {
        console.error("App getPluginStatus Cobalt error: ", err);
      });
      thunder.on('org.rdk.RDKShell', 'onApplicationDisconnected', notification => {
        console.log("onApplicationDisconnectedNotification: ", JSON.stringify(notification));
        // DO NOT HANDLE THIS, see RDKUI-474 for details.
        // if (notification.hasOwnProperty("client") && (Storage.get("applicationType").includes(notification.client))) {
        //   appApi.exitApp(Storage.get("applicationType"));
        // }
      });

      //video info change events begin here---------------------

      thunder.on('org.rdk.tv.ControlSettings.1', 'videoFormatChanged', notification => {
        console.log("videoFormatChangedNotification: ", JSON.stringify(notification));
        if (Router.getActiveWidget() == this.widgets.videoinfochange) {
          this.widgets.videoinfochange.update(" New videoFormat :  " + notification.currentVideoFormat, true);
        } else {
          Router.focusWidget("VideoInfoChange");
          this.widgets.videoinfochange.update(" New videoFormat :  " + notification.currentVideoFormat);
        }
      });
      thunder.on('org.rdk.tv.ControlSettings.1', 'videoFrameRateChanged', notification => {
        console.log("videoFrameRateChangedNotification: ", JSON.stringify(notification));
        if (Router.getActiveWidget() == this.widgets.videoinfochange) {
          this.widgets.videoinfochange.update(" New videoFrameRate :  " + notification.currentVideoFrameRate, true);
        } else {
          Router.focusWidget("VideoInfoChange");
          this.widgets.videoinfochange.update(" New videoFrameRate :  " + notification.currentVideoFrameRate);
        }
      });
      thunder.on('org.rdk.tv.ControlSettings.1', 'videoResolutionChanged', notification => {
        console.log("videoResolutionChangedNotification: ", JSON.stringify(notification));
        if (Router.getActiveWidget() == this.widgets.videoinfochange) {
          this.widgets.videoinfochange.update(" New video resolution :  " + notification.currentVideoFormat, true);
        } else {
          Router.focusWidget("VideoInfoChange");
          this.widgets.videoinfochange.update(" New video resolution :  " + notification.currentVideoFormat);
        }
      });
      thunder.on('Controller', 'statechange', notification => {
        // get plugin status
        console.log("Controller statechange Notification : " + JSON.stringify(notification));
        if (notification && (notification.callsign.startsWith("YouTube") || notification.callsign === 'Amazon' || notification.callsign === 'LightningApp' || notification.callsign === 'HtmlApp' || notification.callsign === 'Netflix') && (notification.state == 'Deactivation' || notification.state == 'Deactivated')) {
          console.log("".concat(notification.callsign, " status = ").concat(notification.state));
          console.log(">>notification.callsign: ", notification.callsign, " applicationType: ", Storage$1.get("applicationType"));
          if (Router.getActiveHash().startsWith("tv-overlay") || Router.getActiveHash().startsWith("overlay") || Router.getActiveHash().startsWith("applauncher")) {
            //navigate to last visited route when exiting from any app
            console.log("navigating to lastVisitedRoute");
            Router.navigate(Storage$1.get("lastVisitedRoute"));
          }
          if (notification.callsign === Storage$1.get("applicationType")) {
            //only launch residentApp iff notification is from currentApp
            console.log(notification.callsign + " is in: " + notification.state + " state, and application type in Storage is still: " + Storage$1.get("applicationType") + " calling launchResidentApp");
            appApi.launchResidentApp(Storage$1.get("selfClientName"));
          }
        }
        if (notification && notification.callsign === 'org.rdk.HdmiCec_2' && notification.state === 'Activated') {
          this.advanceScreen = Router.activePage();
          if (typeof this.advanceScreen.performOTPAction === 'function') {
            console.log('otp action');
            this.advanceScreen.performOTPAction();
          }
        }
        if (notification && (notification.callsign.startsWith("YouTube") || notification.callsign === 'Amazon' || notification.callsign === 'LightningApp' || notification.callsign === 'HtmlApp' || notification.callsign === 'Netflix') && notification.state == 'Activated') {
          Storage$1.set('applicationType', notification.callsign); //required in case app launch happens using curl command.
          if (notification.callsign === 'Netflix') {
            appApi.getNetflixESN().then(res => {
              Storage$1.set('Netflix_ESN', res);
            });
            thunder.on('Netflix', 'notifyeventchange', notification => {
              console.log("NETFLIX : notifyEventChange notification = ", JSON.stringify(notification));
              if (notification.EventName === "rendered") {
                Router.navigate('menu');
                if (Storage$1.get("NFRStatus")) {
                  thunder.call("Netflix.1", "nfrstatus", {
                    "params": "enable"
                  }).then(nr => {
                    console.log("Netflix : nfr enable results in ".concat(nr));
                  }).catch(nerr => {
                    console.error("Netflix : error while updating nfrstatus ".concat(nerr));
                  });
                } else {
                  thunder.call("Netflix.1", "nfrstatus", {
                    "params": "disable"
                  }).then(nr => {
                    console.log("Netflix : nfr disable results in ".concat(nr));
                  }).catch(nerr => {
                    console.error("Netflix : error while updating nfrstatus ".concat(nerr));
                  });
                }
                appApi.visible(Storage$1.get("selfClientName"), false);
              }
              if (notification.EventName === "requestsuspend") {
                this.deactivateChildApp('Netflix');
              }
              if (notification.EventName === "updated") {
                console.log("Netflix : xxxxxxxxxxxxxxxxxx Updated Event Trigger xxxxxxxxxxxxxxxxxxxx");
                appApi.getNetflixESN().then(res => {
                  Storage$1.set('Netflix_ESN', res);
                });
              }
            });
          } else {
            appApi.setFocus(notification.callsign); //required in case app launch happens using curl command.
          }
        }
      });

      /********************   RDKUI-341 CHANGES - DEEP SLEEP/LIGHT SLEEP **************************/

      let cachedPowerState = Storage$1.get('SLEEPING');
      console.log('cached power state', cachedPowerState);
      console.log(typeof cachedPowerState);
      if (cachedPowerState) {
        appApi.getWakeupReason().then(result => {
          if (result.result.wakeupReason !== 'WAKEUP_REASON_UNKNOWN') {
            cachedPowerState = 'ON';
          }
        });
        appApi.setPowerState(cachedPowerState).then(result => {
          if (result.success) {
            console.log("successfully set powerstate to: " + cachedPowerState);
          }
        });
      }

      /********************   RDKUI-303 - PAGE VISIBILITY API **************************/

      //ACTIVATING HDMI CEC PLUGIN
      cecApi.activate().then(res => {
        let getfriendlyname, getosdname;
        setTimeout(() => {
          xcastApi.getFriendlyName().then(res => {
            getfriendlyname = res.friendlyname;
            console.log("XcastApi getFriendlyName :" + getfriendlyname);
          }).catch(err => {
            console.error('XcastApi getFriendlyName Error: ', err);
          });
          cecApi.getOSDName().then(result => {
            getosdname = result.name;
            console.log("CECApi getOSDName :" + getosdname);
            if (getfriendlyname !== getosdname) {
              cecApi.setOSDName(getfriendlyname);
            }
          }).catch(err => {
            console.error('CECApi getOSDName Error :', err);
          });
        }, 5000);
        cecApi.getActiveSourceStatus().then(res => {
          Storage$1.set("UICacheCECActiveSourceStatus", res);
          console.log("App getActiveSourceStatus: " + res + " UICacheCECActiveSourceStatus:" + Storage$1.get("UICacheCECActiveSourceStatus"));
        });
      }).catch(err => console.log(err));

      //UNPLUG/PLUG HDMI

      thunder.on("org.rdk.HdcpProfile", "onDisplayConnectionChanged", notification => {
        console.log(new Date().toISOString() + " onDisplayConnectionChanged ", notification.HDCPStatus);
        let temp = notification.HDCPStatus;
        if (!Storage$1.get("ResolutionChangeInProgress") && temp.isConnected != Storage$1.get("UICacheonDisplayConnectionChanged")) {
          if (temp.isConnected) {
            let currentApp = Storage$1.get('applicationType');
            let launchLocation = Storage$1.get(currentApp + "LaunchLocation");
            console.log("App HdcpProfile onDisplayConnectionChanged current app is:", currentApp);
            let params = {
              launchLocation: launchLocation,
              appIdentifier: self.appIdentifiers[currentApp]
            };
            if (currentApp.startsWith("YouTube")) {
              params["url"] = Storage$1.get(currentApp + "DefaultURL");
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state === (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.launchApp(currentApp, params).catch(err => {
                    console.error("Error in launching ".concat(currentApp, " : ") + JSON.stringify(err));
                  });
                } else {
                  console.log("App HdcpProfile onDisplayConnectionChanged skipping; " + currentApp + " is already: ", JSON.stringify(result[0].state));
                }
              });
            }
          } else {
            let currentApp = Storage$1.get('applicationType');
            if (currentApp.startsWith("YouTube")) {
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state !== (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.exitApp(currentApp, true);
                } else {
                  console.log("App HdcpProfile onDisplayConnectionChanged skipping; " + currentApp + " is already: ", JSON.stringify(result[0].state));
                }
              });
            }
          }
          Storage$1.set("UICacheonDisplayConnectionChanged", temp.isConnected);
        } else {
          console.warn("App HdcpProfile onDisplayConnectionChanged discarding.");
          console.log("App HdcpProfile ResolutionChangeInProgress: " + Storage$1.get("ResolutionChangeInProgress") + " UICacheonDisplayConnectionChanged: " + Storage$1.get("UICacheonDisplayConnectionChanged"));
        }
      });

      //CHANGING HDMI INPUT PORT

      thunder.on("org.rdk.HdmiCec_2", "onActiveSourceStatusUpdated", notification => {
        console.log(new Date().toISOString() + " onActiveSourceStatusUpdated ", notification);
        if (notification.status != Storage$1.get("UICacheCECActiveSourceStatus")) {
          if (notification.status) {
            let currentApp = Storage$1.get('applicationType');
            let launchLocation = Storage$1.get(currentApp + "LaunchLocation");
            console.log("current app is ", currentApp);
            let params = {
              launchLocation: launchLocation,
              appIdentifier: self.appIdentifiers[currentApp]
            };
            if (currentApp.startsWith("YouTube")) {
              params["url"] = Storage$1.get(currentApp + "DefaultURL");
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state === (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.launchApp(currentApp, params).catch(err => {
                    console.error("Error in launching ".concat(currentApp, " : ") + JSON.stringify(err));
                  });
                } else {
                  console.log("App HdmiCec_2 onActiveSourceStatusUpdated skipping; " + currentApp + " is already:", JSON.stringify(result[0].state));
                }
              });
            }
          } else {
            let currentApp = Storage$1.get('applicationType');
            if (currentApp.startsWith("YouTube")) {
              appApi.getPluginStatus(currentApp).then(result => {
                if (result[0].state !== (Settings$2.get("platform", "enableAppSuspended") ? "suspended" : "deactivated")) {
                  appApi.exitApp(currentApp, true);
                } else {
                  console.log("App HdmiCec_2 onActiveSourceStatusUpdated skipping; " + currentApp + " is already:", JSON.stringify(result[0].state));
                }
              });
            }
          }
          Storage$1.set("UICacheCECActiveSourceStatus", notification.status);
          console.log("App HdmiCec_2 onActiveSourceStatusUpdated UICacheCECActiveSourceStatus:", Storage$1.get("UICacheCECActiveSourceStatus"));
        } else {
          console.warn("App HdmiCec_2 onActiveSourceStatusUpdated discarding.");
        }
      });
      let currentLanguage = availableLanguageCodes[localStorage.getItem('Language')];
      if (currentLanguage.length) {
        appApi.setUILanguage(currentLanguage);
      }
    }
    _firstEnable() {
      thunder.on("org.rdk.System", "onSystemPowerStateChanged", notification => {
        console.log(new Date().toISOString() + " onSystemPowerStateChanged Notification: ", notification);
        if (notification.powerState !== "ON" && notification.currentPowerState === "ON") {
          console.log("onSystemPowerStateChanged Notification: power state was changed from ON to " + notification.powerState);

          //TURNING OFF THE DEVICE
          Storage$1.set('SLEEPING', notification.powerState);
          let currentApp = Storage$1.get('applicationType');
          if (currentApp !== "") {
            appApi.exitApp(currentApp); //will suspend/destroy the app depending on the setting.
          }

          Router.navigate('menu');
        } else if (notification.powerState === "ON" && notification.currentPowerState !== "ON") {
          //TURNING ON THE DEVICE
          Storage$1.remove('SLEEPING');
        }
      });
      console.log("App Calling listenToVoiceControl method to activate VoiceControl Plugin");
      this.listenToVoiceControl();
      let updatedLanguage = availableLanguageCodes[localStorage.getItem('Language')];
      if (updatedLanguage.length) {
        appApi.setUILanguage(updatedLanguage);
      }
      /* Subscribe to Volume status events to report to Alexa. */
      thunder.on('org.rdk.DisplaySettings', 'connectedAudioPortUpdated', notification => {
        console.log("App got connectedAudioPortUpdated: ", notification);
        // TODO: future -> can be used for volume adjustments ?
      });

      thunder.on('org.rdk.DisplaySettings', 'muteStatusChanged', notification => {
        if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
          AlexaApi.get().reportVolumeState(undefined, notification.muted);
        }
      });
      thunder.on('org.rdk.DisplaySettings', 'volumeLevelChanged', notification => {
        if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
          AlexaApi.get().reportVolumeState(notification.volumeLevel, undefined);
        }
      });
      thunder.on('org.rdk.System', 'onTimeZoneDSTChanged', notification => {
        if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
          AlexaApi.get().updateDeviceTimeZoneInAlexa(notification.newTimeZone);
        }
      });
    }
    async listenToVoiceControl() {
      let self = this;
      console.log("App listenToVoiceControl method got called, configuring VoiceControl Plugin");
      await voiceApi.activate().then(() => {
        voiceApi.voiceStatus().then(voiceStatusResp => {
          if (voiceStatusResp.ptt.status != "ready" || !voiceStatusResp.urlPtt.includes("avs://")) {
            console.error("App voiceStatus says PTT/AVS not ready, enabling it.");
            // TODO: Future -> add option for user to select which Voice service provider.
            // Then configure VoiceControl plugin for that end point.
            // TODO: voiceApi.configureVoice()
            if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
              AlexaApi.get().setAlexaAuthStatus("");
              voiceApi.configureVoice({
                "enable": true
              }).then(() => {
                AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
              });
            }
          }
        });
        if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaAuthPending") ; else if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError") {
          console.log("App checkAlexaAuthStatus is AlexaHandleError; enableSmartScreen.");
          AlexaApi.get().enableSmartScreen();
          AlexaApi.get().getAlexaDeviceSettings();
          /* Alexa device volume state report. */
          appApi.getConnectedAudioPorts().then(audioport => {
            for (let i = 0; i < audioport.connectedAudioPorts.length && !audioport.connectedAudioPorts[i].startsWith("SPDIF"); i++) {
              if (Storage$1.get("deviceType") == "tv" && audioport.connectedAudioPorts[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport.connectedAudioPorts[i].startsWith("HDMI")) {
                appApi.getMuted(audioport.connectedAudioPorts[i]).then(muteRes => {
                  appApi.getVolumeLevel(audioport.connectedAudioPorts[i]).then(volres => {
                    AlexaApi.get().reportVolumeState(volres.success ? Number.isInteger(volres.volumeLevel) ? volres.volumeLevel : parseInt(volres.volumeLevel) : undefined, muteRes.success ? muteRes.muted : undefined);
                  });
                });
              }
            }
          });

          /* Report device language */
          if (availableLanguageCodes[localStorage.getItem('Language')].length) {
            AlexaApi.get().updateDeviceLanguageInAlexa(availableLanguageCodes[localStorage.getItem('Language')]);
          }
          /* Report device timeZone */
          appApi.getZone().then(updatedTimeZone => {
            if (updatedTimeZone.length) {
              console.log("App updateDeviceTimeZoneInAlexa with zone:", updatedTimeZone);
              AlexaApi.get().updateDeviceTimeZoneInAlexa(updatedTimeZone);
            } else {
              console.error("App getTimezoneDST returned:", updatedTimeZone);
            }
          });
        }
        console.log("App VoiceControl check if user has denied ALEXA:", AlexaApi.get().checkAlexaAuthStatus());

        /* Handle VoiceControl Notifications */
        voiceApi.registerEvent('onServerMessage', notification => {
          console.log('App onServerMessage: ' + JSON.stringify(notification));
          if (Storage$1.get("appSwitchingInProgress")) {
            console.warn("App is appSwitchingInProgress? " + Storage$1.get("appSwitchingInProgress") + ", dropping processing the server notification.");
            return;
          }
          if (AlexaApi.get().checkAlexaAuthStatus() !== "AlexaUserDenied") {
            if (notification.xr_speech_avs.state_reporter === "authorization_req" || notification.xr_speech_avs.code) {
              console.log("Alexa Auth URL is ", notification.xr_speech_avs.url);
              if (!Router.isNavigating() && !AlexaApi.get().isSmartScreenActiavated() && Router.getActiveHash() === "menu") {
                console.log("App enableSmartScreen");
                AlexaApi.get().enableSmartScreen();
              }
              if (Router.getActiveHash() === "menu" && Storage$1.get("applicationType") === "") {
                if (Router.getActiveHash() != "AlexaLoginScreen" && Router.getActiveHash() != "CodeScreen" && !Router.isNavigating()) {
                  console.log("Routing to Alexa login page");
                  Router.navigate("AlexaLoginScreen");
                }
              }
              console.log("Alexa Auth OTP is ", notification.xr_speech_avs.code);
            } else if (notification.xr_speech_avs.state_reporter === "authendication") {
              console.log("Alexa Auth State is now at ", notification.xr_speech_avs.state);
              if (notification.xr_speech_avs.state === "refreshed") {
                AlexaApi.get().setAlexaAuthStatus("AlexaHandleError");
                Router.navigate("SuccessScreen");
              } else if (notification.xr_speech_avs.state === "uninitialized" || notification.xr_speech_avs.state === "authorizing") {
                AlexaApi.get().setAlexaAuthStatus("AlexaAuthPending");
              } else if (notification.xr_speech_avs.state === "unrecoverable error" && Storage$1.get("applicationType") === "") {
                // Could be AUTH token Timeout; refresh it.
                Router.navigate("FailureScreen");
              }
            } else if (notification.xr_speech_avs.state_reporter === "login" && notification.xr_speech_avs.state === "User request to disable Alexa") {
              // https://jira.rdkcentral.com/jira/browse/RDKDEV-746: SDK abstraction layer sends on SKIP button event.
              AlexaApi.get().setAlexaAuthStatus("AlexaUserDenied");
            }
          }
          if (AlexaApi.get().checkAlexaAuthStatus() === "AlexaHandleError" && (notification.xr_speech_avs.state === "CONNECTING" || notification.xr_speech_avs.state === "DISCONNECTED")) {
            // || notification.xr_speech_avs.state === "CONNECTED"
            this.tag("Failscreen1").alpha = 1;
            this.tag("Widgets").visible = false;
            this.tag("Pages").visible = false;
            this.tag("Failscreen1").notify({
              title: 'Alexa State',
              msg: notification.xr_speech_avs.state
            });
            setTimeout(() => {
              this.tag("Failscreen1").alpha = 0;
              this.tag("Widgets").visible = true;
              this.tag("Pages").visible = true;
            }, 5000);
          }
          if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied" && notification.xr_speech_avs.state) {
            if (notification.xr_speech_avs.state.guiAPL === "ACTIVATED") {
              AlexaApi.get().displaySmartScreenOverlay();
              appApi.setFocus(Storage$1.get("applicationType") === "" ? "ResidentApp" : Storage$1.get("applicationType"));
            }
            if (notification.xr_speech_avs.state.dialogUX === "idle" && notification.xr_speech_avs.state.audio === "stopped") {
              console.log("App current AlexaAudioplayerActive state:" + AlexaAudioplayerActive);
              if (AlexaAudioplayerActive && notification.xr_speech_avs.state.guiManager === "DEACTIVATED" || !AlexaAudioplayerActive) {
                AlexaAudioplayerActive = false;
                appApi.setFocus(Storage$1.get("applicationType") === "" ? "ResidentApp" : Storage$1.get("applicationType"));
              }
            }
            if (notification.xr_speech_avs.state.dialogUX === "idle" && notification.xr_speech_avs.state.audio === "playing") {
              AlexaApi.get().displaySmartScreenOverlay(true);
            } else if (notification.xr_speech_avs.state.dialogUX === "listening") {
              AlexaApi.get().displaySmartScreenOverlay();
            } else if (notification.xr_speech_avs.state.dialogUX === "speaking") {
              AlexaApi.get().displaySmartScreenOverlay(true);
            }
            if (notification.xr_speech_avs.state_reporter === "dialog") {
              // Smartscreen playback state reports
              if (notification.xr_speech_avs.state.dialogUX === "idle" && notification.xr_speech_avs.state.audio) {
                AlexaApi.get().setAlexaSmartscreenAudioPlaybackState(notification.xr_speech_avs.state.audio);
              }
            }
          }
          if (notification.xr_speech_avs.directive && AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied") {
            const header = notification.xr_speech_avs.directive.header;
            const payload = notification.xr_speech_avs.directive.payload;
            /////////Alexa.Launcher START
            if (header.namespace === "Alexa.Launcher") {
              //Alexa.launcher will handle launching a particular app(exiting might also be there)
              if (header.name === "LaunchTarget") {
                //Alexa payload will be to "launch" an app
                if (AlexaLauncherKeyMap[payload.identifier]) {
                  let appCallsign = AlexaLauncherKeyMap[payload.identifier].callsign;
                  let appUrl = AlexaLauncherKeyMap[payload.identifier].url; //keymap url will be default, if alexa can give a url, it can be used istead
                  let targetRoute = AlexaLauncherKeyMap[payload.identifier].route;
                  let params = {
                    url: appUrl,
                    launchLocation: "alexa",
                    appIdentifier: self.appIdentifiers[appCallsign]
                  };
                  // Send AVS State report: STOP request if "playing" to end the Smartscreen App instance.
                  if (AlexaApi.get().checkAlexaSmartscreenAudioPlaybackState() == "playing") {
                    console.log("Sending playbackstatereport to Pause:", PlaybackStateReport);
                    AlexaApi.get().reportPlaybackState("PAUSED");
                  }
                  console.log("Alexa is trying to launch " + appCallsign + " using params: " + JSON.stringify(params));
                  if (appCallsign) {
                    //appCallsign is valid means target is an app and it needs to be launched
                    appApi.launchApp(appCallsign, params).catch(err => {
                      console.log("Alexa.Launcher LaunchTarget checkerrstatusAlexa", err);
                      if (err.includes("Netflix")) {
                        AlexaApi.get().reportErrorState(notification.xr_speech_avs.directive, "INVALID_VALUE", "Unsupported AppID");
                      } else {
                        AlexaApi.get().reportErrorState(notification.xr_speech_avs.directive);
                      }
                      console.error("Alexa.Launcher LaunchTarget Error in launching " + appCallsign + " via Alexa: " + JSON.stringify(err));
                    });
                  } else if (targetRoute) {
                    console.log("Alexa.Launcher is trying to route to ", JSON.stringify(targetRoute));
                    // exits the app if any and navigates to the specific route.
                    Storage$1.set("appSwitchingInProgress", true);
                    this.jumpToRoute(targetRoute);
                    Storage$1.set("applicationType", "");
                    Storage$1.set("appSwitchingInProgress", false);
                  }
                } else {
                  console.log("Alexa.Launcher is trying to launch an unsupported app : " + JSON.stringify(payload));
                  AlexaApi.get().reportErrorState(notification.xr_speech_avs.directive);
                }
              }
            } /////////Alexa.Launcher END
            else if (header.namespace === "Alexa.RemoteVideoPlayer") {
              //alexa remote video player will search on youtube for now
              console.log("Alexa.RemoteVideoPlayer: " + JSON.stringify(header));
              if (header.name === "SearchAndDisplayResults" || header.name === "SearchAndPlay") {
                console.log("Alexa.RemoteVideoPlayer: SearchAndDisplayResults || SearchAndPlay: " + JSON.stringify(header));
                /* Find if payload contains Destination App */
                if (payload.hasOwnProperty("entities")) {
                  let entityId = payload.entities.filter(obj => Object.keys(obj).some(key => obj[key].hasOwnProperty("ENTITY_ID")));
                  if (entityId.length && AlexaLauncherKeyMap[entityId[0].externalIds.ENTITY_ID]) {
                    /* ENTITY_ID or vsk key found; meaning Target App is there in response. */
                    let replacedText = payload.searchText.transcribed.replace(entityId[0].value.toLowerCase(), "").trim();
                    let appCallsign = AlexaLauncherKeyMap[entityId[0].externalIds.ENTITY_ID].callsign;
                    //let appUrl = AlexaLauncherKeyMap[entityId[0].externalIds.ENTITY_ID].url
                    let launchParams = {
                      url: "",
                      launchLocation: "alexa",
                      appIdentifier: self.appIdentifiers[appCallsign]
                    };
                    if ("Netflix" === appCallsign) {
                      launchParams.url = encodeURI(replacedText);
                    } else if (appCallsign.startsWith("YouTube")) {
                      launchParams.url = Storage$1.get(appCallsign + "DefaultURL") + "&va=" + (header.name === "SearchAndPlay" ? "play" : "search") + "&vq=" + encodeURI(replacedText);
                    }
                    console.log("Alexa.RemoteVideoPlayer: launchApp " + appCallsign + " with params " + launchParams);
                    appApi.launchApp(appCallsign, launchParams).then(res => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launched successfully using alexa search: " + JSON.stringify(res));
                    }).catch(err => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launch FAILED using alexa search: " + JSON.stringify(err));
                    });
                    replacedText = null;
                    appCallsign = null;
                    launchParams = null;
                  } else if (!entityId.length && Storage$1.get("applicationType") != "") {
                    /* give it to current focused app */
                    console.warn("Alexa.RemoteVideoPlayer: " + Storage$1.get("applicationType") + " is the focued app; need Voice search integration support to it.");
                  } else if (!entityId.length && Storage$1.get("applicationType") == "") {
                    /* Generic global search without a target app; redirect to Youtube as of now. */
                    let replacedText = payload.searchText.transcribed.trim();
                    let appCallsign = AlexaLauncherKeyMap["amzn1.alexa-ask-target.app.70045"].callsign;
                    let launchParams = {
                      url: "",
                      launchLocation: "alexa",
                      appIdentifier: self.appIdentifiers[appCallsign]
                    };
                    launchParams.url = Storage$1.get(appCallsign + "DefaultURL") + "&va=" + (header.name === "SearchAndPlay" ? "play" : "search") + "&vq=" + encodeURI(replacedText);
                    console.log("Alexa.RemoteVideoPlayer: global search launchApp " + appCallsign + " with params " + launchParams);
                    appApi.launchApp(appCallsign, launchParams).then(res => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launched successfully using alexa search: " + JSON.stringify(res));
                    }).catch(err => {
                      console.log("Alexa.RemoteVideoPlayer:" + appCallsign + " launch FAILED using alexa search: " + JSON.stringify(err));
                    });
                    replacedText = null;
                    appCallsign = null;
                    launchParams = null;
                  } else {
                    /* Possibly an unsupported App. */
                    console.warn("Alexa.RemoteVideoPlayer: got ENTITY_ID " + entityId[0].externalIds.ENTITY_ID + "but no match in AlexaLauncherKeyMap.");
                  }
                } else {
                  console.warn("Alexa.RemoteVideoPlayer: payload does not have entities; may not work.");
                }
              }
            } else if (header.namespace === "Alexa.PlaybackController") {
              appApi.deeplinkToApp(Storage$1.get("applicationType"), header.name, "alexa", header.namespace);
              AlexaApi.get().reportPlaybackState(header.name);
            } else if (header.namespace === "Alexa.SeekController") {
              if (Router.getActiveHash() === "player" || Router.getActiveHash() === "usb/player") {
                let time = notification.xr_speech_avs.directive.payload.deltaPositionMilliseconds / 1000;
                this.tag("AAMPVideoPlayer").voiceSeek(time);
              } else {
                appApi.deeplinkToApp(Storage$1.get("applicationType"), payload, "alexa", header.namespace);
              }
            } else if (header.namespace === "AudioPlayer") {
              if (header.name === "Play") {
                AlexaApi.get().displaySmartScreenOverlay(true);
                AlexaAudioplayerActive = true;
                console.log("App AudioPlayer: Suspending the current app:'" + Storage$1.get("applicationType") + "'");
                if (Storage$1.get("applicationType") != "") {
                  appApi.exitApp(Storage$1.get("applicationType"));
                }
              }
            } else if (header.namespace === "TemplateRuntime") {
              if (header.name === "RenderPlayerInfo") {
                AlexaApi.get().displaySmartScreenOverlay(true);
                AlexaAudioplayerActive = true;
              }
            } else if (header.namespace === "Speaker") {
              console.log("Speaker");
              if (header.name === "AdjustVolume") {
                VolumePayload.msgPayload.event.header.messageId = header.messageId;
                appApi.getConnectedAudioPorts().then(audioport => {
                  for (let i = 0; i < audioport.connectedAudioPorts.length && !audioport.connectedAudioPorts[i].startsWith("SPDIF"); i++) {
                    if (Storage$1.get("deviceType") == "tv" && audioport.connectedAudioPorts[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport.connectedAudioPorts[i].startsWith("HDMI")) {
                      appApi.getVolumeLevel(audioport.connectedAudioPorts[i]).then(volres => {
                        console.log("getVolumeLevel[" + audioport.connectedAudioPorts[i] + "] is:" + parseInt(volres.volumeLevel));
                        if (parseInt(volres.volumeLevel) >= 0 || parseInt(volres.volumeLevel) <= 100) {
                          VolumePayload.msgPayload.event.payload.volume = parseInt(volres.volumeLevel) + payload.volume;
                          console.log("volumepayload", VolumePayload.msgPayload.event.payload.volume);
                          if (VolumePayload.msgPayload.event.payload.volume < 0) {
                            VolumePayload.msgPayload.event.payload.volume = 0;
                          } else if (VolumePayload.msgPayload.event.payload.volume > 100) {
                            VolumePayload.msgPayload.event.payload.volume = 100;
                          }
                        }
                        VolumePayload.msgPayload.event.payload.muted = false;
                        appApi.setVolumeLevel(audioport.connectedAudioPorts[i], VolumePayload.msgPayload.event.payload.volume).then(res => {
                          this.tag("Volume").onVolumeChanged();
                        });
                      });
                    }
                  }
                });
              }
              if (header.name === "SetVolume") {
                VolumePayload.msgPayload.event.header.messageId = header.messageId;
                VolumePayload.msgPayload.event.payload.volume = payload.volume;
                VolumePayload.msgPayload.event.payload.muted = false;
                console.log("adjust volume", VolumePayload);
                console.log("checkvolume", VolumePayload.msgPayload.event.payload.volume);
                if (VolumePayload.msgPayload.event.payload.volume > 100) {
                  VolumePayload.msgPayload.event.payload.volume = 100;
                } else if (VolumePayload.msgPayload.event.payload.volume < 0) {
                  VolumePayload.msgPayload.event.payload.volume = 0;
                }
                appApi.getConnectedAudioPorts().then(audioport => {
                  for (let i = 0; i < audioport.connectedAudioPorts.length && !audioport.connectedAudioPorts[i].startsWith("SPDIF"); i++) {
                    if (Storage$1.get("deviceType") == "tv" && audioport.connectedAudioPorts[i].startsWith("SPEAKER") || Storage$1.get("deviceType") != "tv" && audioport.connectedAudioPorts[i].startsWith("HDMI")) {
                      appApi.setVolumeLevel(audioport.connectedAudioPorts[i], VolumePayload.msgPayload.event.payload.volume).then(() => {
                        this.tag("Volume").onVolumeChanged();
                      });
                    }
                  }
                });
              }
              if (header.name === "SetMute") {
                VolumePayload.msgPayload.event.header.messageId = header.messageId;
                VolumePayload.msgPayload.event.payload.volume = payload.volume;
                VolumePayload.msgPayload.event.payload.muted = payload.mute;
                this.tag("Volume").onVolumeMute(payload.mute);
              }
            } else if (header.namespace === "ExternalMediaPlayer") {
              appApi.deeplinkToApp(Storage$1.get("applicationType"), payload, "alexa", header.namespace);
            }
          }
          if (AlexaApi.get().checkAlexaAuthStatus() != "AlexaUserDenied" && notification.xr_speech_avs.deviceSettings) {
            let updatedLanguage = availableLanguageCodes[localStorage.getItem('Language')];
            if (notification.xr_speech_avs.deviceSettings.currentLocale.toString() != updatedLanguage) {
              /* Get Alexa matching Locale String */
              for (let i = 0; i < notification.xr_speech_avs.deviceSettings.supportedLocales.length; i++) {
                if (updatedLanguage === notification.xr_speech_avs.deviceSettings.supportedLocales[i].toString()) {
                  AlexaApi.get().updateDeviceLanguageInAlexa(updatedLanguage);
                }
              }
            }
          }
        });
        voiceApi.registerEvent('onSessionBegin', notification => {
          this.$hideImage(0);
        });
        voiceApi.registerEvent('onSessionEnd', notification => {
          if (notification.result === "success" && notification.success.transcription === "User request to disable Alexa") {
            console.warn("App VoiceControl.onSessionEnd got disable Alexa.");
            AlexaApi.get().resetAVSCredentials(); // To avoid Audio Feedback
            AlexaApi.get().setAlexaAuthStatus("AlexaUserDenied"); // Reset back to disabled as resetAVSCredentials() sets to ErrorHandling.
          }
        });
      }).catch(err => {
        console.error("App VoiceControl Plugin activation error:", err);
      });
    }
    deactivateChildApp(plugin) {
      //#needToBeRemoved
      switch (plugin) {
        case 'WebApp':
          appApi.deactivateWeb();
          break;
        case 'YouTube':
          appApi.suspendPremiumApp("YouTube").then(res => {
            console.log("YouTube : suspend YouTube request");
          }).catch(err => {
            console.error(err);
          });
          break;
        case 'YouTubeTV':
          appApi.suspendPremiumApp("YouTubeTV").then(res => {
            console.log("YouTubeTV : suspend YouTubeTV request");
          }).catch(err => {
            console.error(err);
          });
          break;
        case 'YouTubeKids':
          appApi.suspendPremiumApp("YouTubeKids").then(res => {
            console.log("YouTubeKids : suspend YouTubeKids request");
          }).catch(err => {
            console.error(err);
          });
          break;
        case 'Lightning':
          appApi.deactivateLightning();
          break;
        case 'Native':
          appApi.killNative();
          break;
        case 'Amazon':
          appApi.suspendPremiumApp('Amazon').then(res => {
            if (res) {
              let params = {
                applicationName: "AmazonInstantVideo",
                state: 'suspended'
              };
              this.xcastApi.onApplicationStateChanged(params);
            }
          });
          break;
        case "Netflix":
          appApi.suspendPremiumApp("Netflix").then(res => {
            Router.navigate(Storage$1.get("lastVisitedRoute"));
            thunder.call("org.rdk.RDKShell", "setFocus", {
              client: "ResidentApp"
            });
            thunder.call("org.rdk.RDKShell", "setVisibility", {
              client: "ResidentApp",
              visible: true
            });
            thunder.call("org.rdk.RDKShell", "moveToFront", {
              client: "ResidentApp",
              callsign: "ResidentApp"
            });
            if (res) {
              let params = {
                applicationName: "NetflixApp",
                state: "suspended"
              };
              this.xcastApi.onApplicationStateChanged(params);
            }
          });
          break;
        case 'HDMI':
          new HDMIApi().stopHDMIInput();
          Storage$1.set("_currentInputMode", {});
          break;
      }
    }
    $initLaunchPad(url) {
      return new Promise((resolve, reject) => {
        appApi.getPluginStatus('Netflix').then(result => {
          console.log("netflix plugin status is :", JSON.stringify(result));
          console.log("netflix plugin status is :", result);
          if (result[0].state === 'deactivated' || result[0].state === 'deactivation') {
            Router.navigate('image', {
              src: Utils.asset('images/apps/App_Netflix_Splash.png')
            });
            if (url) {
              appApi.configureApplication('Netflix', url).then(() => {
                appApi.launchPremiumApp("Netflix").then(res => {
                  appApi.setVisibility(Storage$1.get("selfClientName"), false);
                  resolve(true);
                }).catch(err => {
                  reject(false);
                }); // ie. org.rdk.RDKShell.launch
              }).catch(err => {
                console.error("Netflix : error while fetching configuration data : ", JSON.stringify(err));
                reject(err);
              }); // gets configuration object and sets configuration
            } else {
              appApi.launchPremiumApp("Netflix").then(res => {
                appApi.setVisibility(Storage$1.get("selfClientName"), false);
                resolve(true);
              }).catch(err => {
                reject(false);
              }); // ie. org.rdk.RDKShell.launch
            }
          } else {
            /* Not in deactivated; could be suspended */
            if (url) {
              appApi.launchPremiumApp("Netflix").then(res => {
                thunder.call("Netflix", "systemcommand", {
                  "command": url
                }).then(res => {}).catch(err => {
                  console.error("Netflix : error while sending systemcommand : ", JSON.stringify(err));
                  reject(false);
                });
                appApi.setVisibility(Storage$1.get("selfClientName"), false);
                resolve(true);
              }).catch(err => {
                reject(false);
              }); // ie. org.rdk.RDKShell.launch
            } else {
              appApi.launchPremiumApp("Netflix").then(res => {
                console.log("Netflix : launch premium app resulted in ", JSON.stringify(res));
                appApi.setVisibility(Storage$1.get("selfClientName"), false);
                resolve(true);
              });
            }
          }
        }).catch(err => {
          console.log('Netflix plugin error', err);
          Storage$1.set('applicationType', '');
          reject(false);
        });
      });
    }

    /**
     * Function to register event listeners for Xcast plugin.
     */
    registerXcastListeners() {
      let self = this;
      this.xcastApi.registerEvent('onApplicationLaunchRequest', notification => {
        console.log('App onApplicationLaunchRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          if (applicationName.startsWith("YouTube")) {
            let params = {
              url: notification.parameters.url,
              launchLocation: "dial",
              appIdentifier: self.appIdentifiers[applicationName]
            };
            appApi.launchApp(applicationName, params).then(res => {
              console.log("App onApplicationLaunchRequest: launched " + applicationName + " : ", res);
              Storage$1.set("applicationType", applicationName);
              // TODO: move to Controller.statuschange event
              let params = {
                applicationName: notification.applicationName,
                state: 'running'
              };
              this.xcastApi.onApplicationStateChanged(params);
            }).catch(err => {
              console.log("App onApplicationLaunchRequest: error ", err);
            });
          }
        }
      });
      this.xcastApi.registerEvent('onApplicationHideRequest', notification => {
        console.log('App onApplicationHideRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          console.log('App onApplicationHideRequest: ' + this.xcastApps(notification.applicationName));
          if (applicationName.startsWith("YouTube")) {
            //second argument true means resident app won't be launched the required app will be exited in the background.
            //only bring up the resident app when the notification is from the current app(ie app in focus)
            console.log("App onApplicationHideRequest: exitApp as " + applicationName + "!==" + Storage$1.get("applicationType"));
            appApi.exitApp(applicationName, applicationName !== Storage$1.get("applicationType"));
          }
        }
      });
      this.xcastApi.registerEvent('onApplicationResumeRequest', notification => {
        console.log('App onApplicationResumeRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let params = {
            url: notification.parameters.url,
            launchLocation: "dial",
            appIdentifier: self.appIdentifiers[applicationName]
          };
          console.log('App onApplicationResumeRequest: launchApp ', applicationName, " with params: ", params);
          appApi.launchApp(applicationName, params).then(res => {
            Storage$1.set("applicationType", applicationName);
            console.log("App onApplicationResumeRequest: launched ", applicationName, " result: ", res);
          }).catch(err => {
            console.log("Error in launching ", applicationName, " on casting resume request: ", err);
          });
        }
      });
      this.xcastApi.registerEvent('onApplicationStopRequest', notification => {
        console.log('App onApplicationStopRequest: ' + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          if (applicationName.startsWith("YouTube")) {
            appApi.deactivateCobalt(applicationName);
            if (Storage$1.get("applicationType") === applicationName) {
              appApi.exitApp(applicationName);
            }
          }
        }
      });
      this.xcastApi.registerEvent('onApplicationStateRequest', notification => {
        //console.log("App onApplicationStateRequest: " + JSON.stringify(notification));
        if (this.xcastApps(notification.applicationName)) {
          let applicationName = this.xcastApps(notification.applicationName);
          let appState = {
            "applicationName": notification.applicationName,
            "state": "stopped"
          };
          appApi.checkStatus(applicationName).then(result => {
            switch (result[0].state) {
              case "activated":
              case "resumed":
                appState.state = "running";
                break;
              case "Activation":
              case "deactivated":
              case "Deactivation":
              case "Precondition":
                appState.state = "stopped";
                break;
              case "suspended":
                appState.state = "suspended";
                break;
            }
            this.xcastApi.onApplicationStateChanged(appState);
          }).catch(error => {
            console.error("App onApplicationStateRequest: checkStatus error ", error);
          });
        }
      });
    }

    /**
     * Function to get the plugin name for the application name.
     * @param {string} app App instance.
     */
    xcastApps(app) {
      if (Object.keys(XcastApi.supportedApps()).includes(app)) {
        return XcastApi.supportedApps()[app];
      } else return false;
    }
    $mountEventConstructor(fun) {
      this.ListenerConstructor = fun;
      console.log("MountEventConstructor was initialized");
      // console.log(`listener constructor was set t0 = ${this.ListenerConstructor}`);
    }

    $registerUsbMount() {
      this.disposableListener = this.ListenerConstructor();
      console.log("Successfully registered the usb Mount");
    }
    $deRegisterUsbMount() {
      console.log("the current usbListener = ".concat(this.disposableListener));
      this.disposableListener.dispose();
      console.log("successfully deregistered usb listener");
    }
    standby(value) {
      console.log("standby call");
      if (value == 'Back') ; else {
        if (powerState == 'ON') {
          console.log("Power state was on trying to set it to standby");
          appApi.setPowerState(value).then(res => {
            if (res.success) {
              console.log("successfully set to standby");
              powerState = 'STANDBY';
              if (Storage$1.get('applicationType') !== "") {
                appApi.exitApp(Storage$1.get('applicationType'));
              } else {
                if (!Router.isNavigating()) {
                  Router.navigate('menu');
                }
              }
            }
          });
          return true;
        }
      }
    }
    $registerInactivityMonitoringEvents() {
      return new Promise((resolve, reject) => {
        console.log("registered inactivity listener");
        appApi.setPowerState('ON').then(res => {
          if (res.success) {
            powerState = 'ON';
          }
        });
        thunder.Controller.activate({
          callsign: 'org.rdk.RDKShell.1'
        }).then(res => {
          console.log("activated the rdk shell plugin trying to set the inactivity listener; res = ".concat(JSON.stringify(res)));
          thunder.on("org.rdk.RDKShell.1", "onUserInactivity", notification => {
            console.log("user was inactive");
            if (powerState === "ON" && Storage$1.get('applicationType') == '') {
              this.standby("STANDBY");
            }
          }, err => {
            console.error("error while inactivity monitoring , ".concat(err));
          });
          resolve(res);
        }).catch(err => {
          reject(err);
          console.error("error while activating the displaysettings plugin; err = ".concat(err));
        });
      });
    }
    $resetSleepTimer(t) {
      console.log("reset sleep timer call ".concat(t));
      var arr = t.split(" ");
      function setTimer() {
        console.log('Timer ', arr);
        var temp = arr[1].substring(0, 1);
        if (temp === 'H') {
          let temp1 = parseFloat(arr[0]) * 60;
          appApi.setInactivityInterval(temp1).then(res => {
            Storage$1.set('TimeoutInterval', t);
            console.log("successfully set the timer to ".concat(t, " hours"));
          }).catch(err => {
            console.error("error while setting the timer");
          });
        } else if (temp === 'M') {
          console.log("minutes");
          let temp1 = parseFloat(arr[0]);
          appApi.setInactivityInterval(temp1).then(res => {
            Storage$1.set('TimeoutInterval', t);
            console.log("successfully set the timer to ".concat(t, " minutes"));
          }).catch(err => {
            console.error("error while setting the timer");
          });
        }
      }
      if (arr.length < 2) {
        appApi.enabledisableinactivityReporting(false).then(res => {
          if (res.success === true) {
            Storage$1.set('TimeoutInterval', false);
            console.log("Disabled inactivity reporting");
            // this.timerIsOff = true;
          }
        }).catch(err => {
          console.error("error : unable to set the reset; error = ".concat(err));
        });
      } else {
        appApi.enabledisableinactivityReporting(true).then(res => {
          if (res.success === true) {
            console.log("Enabled inactivity reporting; trying to set the timer to ".concat(t));
            // this.timerIsOff = false;
            setTimer();
          }
        }).catch(err => {
          console.error("error while enabling inactivity reporting");
        });
      }
    }
    jumpToRoute(route) {
      if (Storage$1.get('applicationType') != '') {
        appApi.exitApp(Storage$1.get('applicationType')).catch(err => {
          console.log(err);
        });
        Storage$1.set("lastVisitedRoute", route); // incase any state change event tries to navigate, it need to be navigated to alexa requested route
        Router.navigate(route);
      } else {
        if (!Router.isNavigating()) {
          if (Router.getActiveHash() === "dtvplayer") {
            //exit scenario for dtv player
            dtvApi$1.exitChannel().then(res => {
              console.log("exit channel: ", JSON.stringify(res));
            }).catch(err => {
              console.log("failed to exit channel: ", JSON.stringify(err));
            });
            if (Router.getActiveWidget()) {
              Router.getActiveWidget()._setState("IdleState");
            }
          }
          Storage$1.set("lastVisitedRoute", route);
          Router.navigate(route);
        }
      }
    }
  }

  /**
   * If not stated otherwise in this file or this component's LICENSE
   * file the following copyright and licenses apply:
   *
   * Copyright 2020 RDK Management
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   **/
  function index () {
    console.time('PerformanceTest');
    console.log('Timer Start - ', new Date().toUTCString());
    return Launch(App, ...arguments);
  }

  return index;

})();
//# sourceMappingURL=appBundle.js.map
